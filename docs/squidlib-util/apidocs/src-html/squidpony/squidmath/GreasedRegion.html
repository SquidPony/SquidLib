<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (16) -->
<title>Source code</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="source: package: squidpony.squidmath, class: GreasedRegion">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body class="source-page">
<main role="main">
<div class="source-container">
<pre><span class="source-line-no">001</span><span id="line.1">package squidpony.squidmath;</span>
<span class="source-line-no">002</span><span id="line.2"></span>
<span class="source-line-no">003</span><span id="line.3">import squidpony.ArrayTools;</span>
<span class="source-line-no">004</span><span id="line.4">import squidpony.LZSEncoding;</span>
<span class="source-line-no">005</span><span id="line.5">import squidpony.StringKit;</span>
<span class="source-line-no">006</span><span id="line.6">import squidpony.squidgrid.zone.MutableZone;</span>
<span class="source-line-no">007</span><span id="line.7">import squidpony.squidgrid.zone.Zone;</span>
<span class="source-line-no">008</span><span id="line.8"></span>
<span class="source-line-no">009</span><span id="line.9">import java.io.Serializable;</span>
<span class="source-line-no">010</span><span id="line.10">import java.util.*;</span>
<span class="source-line-no">011</span><span id="line.11"></span>
<span class="source-line-no">012</span><span id="line.12">import static squidpony.squidmath.CrossHash.Water.*;</span>
<span class="source-line-no">013</span><span id="line.13"></span>
<span class="source-line-no">014</span><span id="line.14">/**</span>
<span class="source-line-no">015</span><span id="line.15"> * Region encoding of on/off information about areas using bitsets; uncompressed (fatty), but fast (greased lightning).</span>
<span class="source-line-no">016</span><span id="line.16"> * This can handle any size of 2D data, and is not strictly limited to 256x256 as CoordPacker is. It stores several long</span>
<span class="source-line-no">017</span><span id="line.17"> * arrays and uses each bit in one of those numbers to represent a single point, though sometimes this does waste bits</span>
<span class="source-line-no">018</span><span id="line.18"> * if the height of the area this encodes is not a multiple of 64 (if you store a 80x64 map, this uses 80 longs; if you</span>
<span class="source-line-no">019</span><span id="line.19"> * store an 80x65 map, this uses 160 longs, 80 for the first 64 rows and 80 more to store the next row). It's much</span>
<span class="source-line-no">020</span><span id="line.20"> * faster than CoordPacker at certain operations (anything that expands or retracts an area, including</span>
<span class="source-line-no">021</span><span id="line.21"> * {@link #expand()}), {@link #retract()}), {@link #fringe()}), {@link #surface()}, and {@link #flood(GreasedRegion)},</span>
<span class="source-line-no">022</span><span id="line.22"> * and slightly faster on others, like {@link #and(GreasedRegion)} (called intersectPacked() in CoordPacker) and</span>
<span class="source-line-no">023</span><span id="line.23"> * {@link #or(GreasedRegion)} (called unionPacked() in CoordPacker).</span>
<span class="source-line-no">024</span><span id="line.24"> * &lt;br&gt;</span>
<span class="source-line-no">025</span><span id="line.25"> * Each GreasedRegion is mutable, and instance methods typically modify that instance and return it for chaining. There</span>
<span class="source-line-no">026</span><span id="line.26"> * are exceptions, usually where multiple GreasedRegion values are returned and the instance is not modified.</span>
<span class="source-line-no">027</span><span id="line.27"> * &lt;br&gt;</span>
<span class="source-line-no">028</span><span id="line.28"> * Typical usage involves constructing a GreasedRegion from some input data, like a char[][] for a map or a double[][]</span>
<span class="source-line-no">029</span><span id="line.29"> * from DijkstraMap, and modifying it spatially with expand(), retract(), flood(), etc. It's common to mix in data from</span>
<span class="source-line-no">030</span><span id="line.30"> * other GreasedRegions with and() (which gets the intersection of two GreasedRegions and stores it in one), or() (which</span>
<span class="source-line-no">031</span><span id="line.31"> * is like and() but for the union), xor() (like and() but for exclusive or, finding only cells that are on in exactly</span>
<span class="source-line-no">032</span><span id="line.32"> * one of the two GreasedRegions), and andNot() (which can be considered the "subtract another region from me" method).</span>
<span class="source-line-no">033</span><span id="line.33"> * There are 8-way (Chebyshev distance) variants on all of the spatial methods, and methods without "8way" in the name</span>
<span class="source-line-no">034</span><span id="line.34"> * are either 4-way (Manhattan distance) or not affected by distance measurement. There's really quite a lot of methods</span>
<span class="source-line-no">035</span><span id="line.35"> * here that modify a GreasedRegion, so here's a partial list:</span>
<span class="source-line-no">036</span><span id="line.36"> * &lt;ul&gt;</span>
<span class="source-line-no">037</span><span id="line.37"> *     &lt;li&gt;{@link #expand()} changes any cells next to a currently "on" cell to also be "on." It's 4-way, and has an</span>
<span class="source-line-no">038</span><span id="line.38"> *     8-way variant {@link #expand8way()}. There's an overload that expands several times as if by a loop,</span>
<span class="source-line-no">039</span><span id="line.39"> *     {@link #expand(int)}, which also has an 8-way variant. You can use {@link #expandSeries(int)} to get multiple</span>
<span class="source-line-no">040</span><span id="line.40"> *     GreasedRegions produced as intermediate values of a series of expansions; this also has an 8-way variant.</span>
<span class="source-line-no">041</span><span id="line.41"> *     {@link #expandSeriesToLimit()} returns an ArrayList of as many GreasedRegions as it takes to expand until no more</span>
<span class="source-line-no">042</span><span id="line.42"> *     cells can change.&lt;/li&gt;</span>
<span class="source-line-no">043</span><span id="line.43"> *     &lt;li&gt;{@link #retract()} is just like {@link #expand()}, but changes any "on" cells that are next to an "off" cell</span>
<span class="source-line-no">044</span><span id="line.44"> *     to also be "off." It can be thought of as expanding the "off" cells, with the subtle difference that the edges</span>
<span class="source-line-no">045</span><span id="line.45"> *     are also considered "off" here. All of the above variants of {@link #expand()} listed above have equivalents for</span>
<span class="source-line-no">046</span><span id="line.46"> *     {@link #retract()}, like {@link #retractSeriesToLimit()}.&lt;/li&gt;</span>
<span class="source-line-no">047</span><span id="line.47"> *     &lt;li&gt;{@link #fringe()} is like {@link #expand()}, but doesn't keep the old contents of the GreasedRegion, only the</span>
<span class="source-line-no">048</span><span id="line.48"> *     cells that are added. This has some differences in how {@link #fringe(int)} works (it returns a</span>
<span class="source-line-no">049</span><span id="line.49"> *     multiple-cell-thick fringe section, still not containing any of the original), and how {@link #fringeSeries(int)}</span>
<span class="source-line-no">050</span><span id="line.50"> *     works (it returns many single-cell-thick fringe sections). There's a {@link #fringeSeriesToLimit()}, too.&lt;/li&gt;</span>
<span class="source-line-no">051</span><span id="line.51"> *     &lt;li&gt;{@link #surface()} is something like removing the result of {@link #retract()} from this GreasedRegion; it</span>
<span class="source-line-no">052</span><span id="line.52"> *     gets only those "on" cells that are next to an "off" cell. Like with {@link #fringe()}, the variants are a little</span>
<span class="source-line-no">053</span><span id="line.53"> *     different; {@link #surface(int)} gets a multiple-cell deep surface, and {@link #surfaceSeries(int)} gets a series</span>
<span class="source-line-no">054</span><span id="line.54"> *     of single-cell deep rings from further and further inside the original GreasedRegion. Yes, there's also a</span>
<span class="source-line-no">055</span><span id="line.55"> *     {@link #surfaceSeriesToLimit()}.&lt;/li&gt;</span>
<span class="source-line-no">056</span><span id="line.56"> *     &lt;li&gt;{@link #flood(GreasedRegion)} is useful; it acts like {@link #expand()}, but won't change any cells unless</span>
<span class="source-line-no">057</span><span id="line.57"> *     they are "on" in its {@code bounds} argument, another GreasedRegion. There's also</span>
<span class="source-line-no">058</span><span id="line.58"> *     {@link #flood(GreasedRegion, int)}, which may be most useful with a very large {@code amount} parameter to fill</span>
<span class="source-line-no">059</span><span id="line.59"> *     up the bounds completely with whatever the original GreasedRegion could reach. {@link #flood8way(GreasedRegion)},</span>
<span class="source-line-no">060</span><span id="line.60"> *     {@link #floodSeries(GreasedRegion, int)}, and {@link #floodSeriesToLimit(GreasedRegion)} are all here, too.&lt;/li&gt;</span>
<span class="source-line-no">061</span><span id="line.61"> *     &lt;li&gt;{@link #spill(GreasedRegion, int, IRNG)} is like calling {@link #flood(GreasedRegion)} many times, but only</span>
<span class="source-line-no">062</span><span id="line.62"> *     expanding one cell on the edge each time, randomly choosing it. As long as {@code volume} is not enough to fully</span>
<span class="source-line-no">063</span><span id="line.63"> *     fill the reachable part of {@code bounds}, the filled area will be random but always connected.&lt;/li&gt;</span>
<span class="source-line-no">064</span><span id="line.64"> *     &lt;li&gt;Various random modifications: {@link #randomRegion(IRNG, int)} simply chooses "on" points from this</span>
<span class="source-line-no">065</span><span id="line.65"> *     GreasedRegion until it reaches {@code size}, {@link #deteriorate(RandomnessSource, double)} randomly removes</span>
<span class="source-line-no">066</span><span id="line.66"> *     points but stops when the fraction of cells remaining is equal to {@code preservation}, {@link #fray(double)}</span>
<span class="source-line-no">067</span><span id="line.67"> *     acts like {@link #deteriorate(RandomnessSource, double)} but only affects the surface (what {@link #surface()}</span>
<span class="source-line-no">068</span><span id="line.68"> *     would return), and {@link #disperseRandom(RandomnessSource)} randomly removes one of each pair of "on" cells.</span>
<span class="source-line-no">069</span><span id="line.69"> *     &lt;/li&gt;</span>
<span class="source-line-no">070</span><span id="line.70"> *     &lt;li&gt;Various quasi-random modifications: Mostly you should use {@link #separatedRegionBlue(double)} if you want</span>
<span class="source-line-no">071</span><span id="line.71"> *     to get an approximate fraction of well-separated "on" cells from a GreasedRegion; there are other similar methods</span>
<span class="source-line-no">072</span><span id="line.72"> *     but the ones that use {@link BlueNoise} seem superior. {@link #fray(double)} also has a quasi-random version that</span>
<span class="source-line-no">073</span><span id="line.73"> *     doesn't use a RandomnessSource.&lt;/li&gt;</span>
<span class="source-line-no">074</span><span id="line.74"> * &lt;/ul&gt;</span>
<span class="source-line-no">075</span><span id="line.75"> * &lt;br&gt;</span>
<span class="source-line-no">076</span><span id="line.76"> * Once you have a GreasedRegion, you may want to:</span>
<span class="source-line-no">077</span><span id="line.77"> * &lt;ul&gt;</span>
<span class="source-line-no">078</span><span id="line.78"> *     &lt;li&gt;get a single random point from it (use {@link #singleRandom(IRNG)}),&lt;/li&gt;</span>
<span class="source-line-no">079</span><span id="line.79"> *     &lt;li&gt;get several random points from it with random sampling (use {@link #randomPortion(IRNG, int)}),&lt;/li&gt;</span>
<span class="source-line-no">080</span><span id="line.80"> *     &lt;li&gt;mutate the current GreasedRegion to keep random points from it with random sampling (use {@link #randomRegion(IRNG, int)}),&lt;/li&gt;</span>
<span class="source-line-no">081</span><span id="line.81"> *     &lt;li&gt;get random points that are likely to be separated (use {@link #mixedRandomSeparated(double, int, long)} with</span>
<span class="source-line-no">082</span><span id="line.82"> *     a random long for the last parameter, or {@link #separatedBlue(double)} if you don't want a random seed),&lt;/li&gt;</span>
<span class="source-line-no">083</span><span id="line.83"> *     &lt;li&gt;do what any of the above "separated" methods can do, but mutate the current GreasedRegion (use</span>
<span class="source-line-no">084</span><span id="line.84"> *     {@link #mixedRandomRegion(double, int, long)} or {@link #separatedRegionBlue(double)} ),&lt;/li&gt;</span>
<span class="source-line-no">085</span><span id="line.85"> *     &lt;li&gt;get all points from it (use {@link #asCoords()} to get a Coord array, or produce a 2D array of the contents</span>
<span class="source-line-no">086</span><span id="line.86"> *     with {@link #decode()} or {@link #toChars(char, char)}),&lt;/li&gt;</span>
<span class="source-line-no">087</span><span id="line.87"> *     &lt;li&gt;use it to modify other 2D data, such as with {@link #mask(char[][], char)},</span>
<span class="source-line-no">088</span><span id="line.88"> *     {@link #inverseMask(char[][], char)}, {@link #writeDoubles(double[][], double)}, or</span>
<span class="source-line-no">089</span><span id="line.89"> *     {@link #writeIntsInto(int[][], int)}, along with variations on those.&lt;/li&gt;</span>
<span class="source-line-no">090</span><span id="line.90"> * &lt;/ul&gt;</span>
<span class="source-line-no">091</span><span id="line.91"> * &lt;br&gt;</span>
<span class="source-line-no">092</span><span id="line.92"> * You may also want to produce some 2D data from one or more GreasedRegions, as with {@link #sum(GreasedRegion...)} or</span>
<span class="source-line-no">093</span><span id="line.93"> * {@link #toChars()}. The most effective techniques regarding GreasedRegion involve multiple methods, like getting a</span>
<span class="source-line-no">094</span><span id="line.94"> * few random points from an existing GreasedRegion representing floor tiles in a dungeon with</span>
<span class="source-line-no">095</span><span id="line.95"> * {@link #randomRegion(IRNG, int)}, then finding a random expansion of those initial points with</span>
<span class="source-line-no">096</span><span id="line.96"> * {@link #spill(GreasedRegion, int, IRNG)}, giving the original GreasedRegion of floor tiles as the first argument.</span>
<span class="source-line-no">097</span><span id="line.97"> * This could be used to position puddles of water or toxic waste in a dungeon level, while still keeping the starting</span>
<span class="source-line-no">098</span><span id="line.98"> * points and finished points within the boundaries of valid (floor) cells. If you wanted to place something like mold</span>
<span class="source-line-no">099</span><span id="line.99"> * that can be on floors or on cells immediately adjacent to floors (like walls), you could call {@link #expand()} on</span>
<span class="source-line-no">100</span><span id="line.100"> * the floor tiles before calling spill, allowing the spill to spread onto non-floor cells that are next to floors.</span>
<span class="source-line-no">101</span><span id="line.101"> * &lt;br&gt;</span>
<span class="source-line-no">102</span><span id="line.102"> * For efficiency, you can place one GreasedRegion into another (typically a temporary value that is no longer needed</span>
<span class="source-line-no">103</span><span id="line.103"> * and can be recycled) using {@link #remake(GreasedRegion)}, or give the information that would normally be used to</span>
<span class="source-line-no">104</span><span id="line.104"> * construct a fresh GreasedRegion to an existing one of the same dimensions with {@link #refill(boolean[][])} or any</span>
<span class="source-line-no">105</span><span id="line.105"> * of the overloads of refill(). These re-methods don't do as much work as a constructor does if the width and height</span>
<span class="source-line-no">106</span><span id="line.106"> * of their argument are identical to their current width and height, and don't create more garbage for the GC.</span>
<span class="source-line-no">107</span><span id="line.107"> * &lt;br&gt;</span>
<span class="source-line-no">108</span><span id="line.108"> * Created by Tommy Ettinger on 6/24/2016.</span>
<span class="source-line-no">109</span><span id="line.109"> */</span>
<span class="source-line-no">110</span><span id="line.110">public class GreasedRegion extends Zone.Skeleton implements Collection&lt;Coord&gt;, Serializable, MutableZone {</span>
<span class="source-line-no">111</span><span id="line.111">    private static final long serialVersionUID = 0;</span>
<span class="source-line-no">112</span><span id="line.112">    private static final SobolQRNG sobol = new SobolQRNG(2);</span>
<span class="source-line-no">113</span><span id="line.113"></span>
<span class="source-line-no">114</span><span id="line.114">    public long[] data;</span>
<span class="source-line-no">115</span><span id="line.115">    public int height;</span>
<span class="source-line-no">116</span><span id="line.116">    public int width;</span>
<span class="source-line-no">117</span><span id="line.117">    private int ySections;</span>
<span class="source-line-no">118</span><span id="line.118">    private long yEndMask;</span>
<span class="source-line-no">119</span><span id="line.119">    private boolean tallied;</span>
<span class="source-line-no">120</span><span id="line.120">    private int ct;</span>
<span class="source-line-no">121</span><span id="line.121">    private int[] counts;</span>
<span class="source-line-no">122</span><span id="line.122"></span>
<span class="source-line-no">123</span><span id="line.123">    private void tally()</span>
<span class="source-line-no">124</span><span id="line.124">    {</span>
<span class="source-line-no">125</span><span id="line.125">        ct = 0;</span>
<span class="source-line-no">126</span><span id="line.126">        for (int i = 0, tmp; i &lt; counts.length; i++) {</span>
<span class="source-line-no">127</span><span id="line.127">            tmp = Long.bitCount(data[i]);</span>
<span class="source-line-no">128</span><span id="line.128">            counts[i] = tmp == 0 ? 0 : (ct += tmp);</span>
<span class="source-line-no">129</span><span id="line.129">        }</span>
<span class="source-line-no">130</span><span id="line.130">        tallied = true;</span>
<span class="source-line-no">131</span><span id="line.131">    }</span>
<span class="source-line-no">132</span><span id="line.132"></span>
<span class="source-line-no">133</span><span id="line.133">    /**</span>
<span class="source-line-no">134</span><span id="line.134">     * Constructs an empty 64x64 GreasedRegion.</span>
<span class="source-line-no">135</span><span id="line.135">     * GreasedRegions are mutable, so you can add to this with insert() or insertSeveral(), among others.</span>
<span class="source-line-no">136</span><span id="line.136">     */</span>
<span class="source-line-no">137</span><span id="line.137">    public GreasedRegion()</span>
<span class="source-line-no">138</span><span id="line.138">    {</span>
<span class="source-line-no">139</span><span id="line.139">        width = 64;</span>
<span class="source-line-no">140</span><span id="line.140">        height = 64;</span>
<span class="source-line-no">141</span><span id="line.141">        ySections = 1;</span>
<span class="source-line-no">142</span><span id="line.142">        yEndMask = -1L;</span>
<span class="source-line-no">143</span><span id="line.143">        data = new long[64];</span>
<span class="source-line-no">144</span><span id="line.144">        counts = new int[64];</span>
<span class="source-line-no">145</span><span id="line.145">        ct = 0;</span>
<span class="source-line-no">146</span><span id="line.146">        tallied = true;</span>
<span class="source-line-no">147</span><span id="line.147">    }</span>
<span class="source-line-no">148</span><span id="line.148"></span>
<span class="source-line-no">149</span><span id="line.149">    /**</span>
<span class="source-line-no">150</span><span id="line.150">     * Constructs a GreasedRegion with the given rectangular boolean array, with width of bits.length and height of</span>
<span class="source-line-no">151</span><span id="line.151">     * bits[0].length, any value of true considered "on", and any value of false considered "off."</span>
<span class="source-line-no">152</span><span id="line.152">     * @param bits a rectangular 2D boolean array where true is on and false is off</span>
<span class="source-line-no">153</span><span id="line.153">     */</span>
<span class="source-line-no">154</span><span id="line.154">    public GreasedRegion(final boolean[][] bits)</span>
<span class="source-line-no">155</span><span id="line.155">    {</span>
<span class="source-line-no">156</span><span id="line.156">        width = bits.length;</span>
<span class="source-line-no">157</span><span id="line.157">        height = bits[0].length;</span>
<span class="source-line-no">158</span><span id="line.158">        ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">159</span><span id="line.159">        yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">160</span><span id="line.160">        data = new long[width * ySections];</span>
<span class="source-line-no">161</span><span id="line.161">        for (int x = 0, xs = 0; x &lt; width; x++, xs += ySections) {</span>
<span class="source-line-no">162</span><span id="line.162">            for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">163</span><span id="line.163">                if(bits[x][y]) data[xs + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">164</span><span id="line.164">            }</span>
<span class="source-line-no">165</span><span id="line.165">        }</span>
<span class="source-line-no">166</span><span id="line.166">        counts = new int[width * ySections];</span>
<span class="source-line-no">167</span><span id="line.167">        tallied = false;</span>
<span class="source-line-no">168</span><span id="line.168">    }</span>
<span class="source-line-no">169</span><span id="line.169">    /**</span>
<span class="source-line-no">170</span><span id="line.170">     * Reassigns this GreasedRegion with the given rectangular boolean array, reusing the current data storage (without</span>
<span class="source-line-no">171</span><span id="line.171">     * extra allocations) if this.width == map.length and this.height == map[0].length. The current values stored in</span>
<span class="source-line-no">172</span><span id="line.172">     * this are always cleared, then any value of true in map is considered "on", and any value of false in map is</span>
<span class="source-line-no">173</span><span id="line.173">     * considered "off."</span>
<span class="source-line-no">174</span><span id="line.174">     * @param map a rectangular 2D boolean array where true is on and false is off</span>
<span class="source-line-no">175</span><span id="line.175">     * @return this for chaining</span>
<span class="source-line-no">176</span><span id="line.176">     */</span>
<span class="source-line-no">177</span><span id="line.177">    public GreasedRegion refill(final boolean[][] map) {</span>
<span class="source-line-no">178</span><span id="line.178">        if (map != null &amp;&amp; map.length &gt; 0 &amp;&amp; width == map.length &amp;&amp; height == map[0].length) {</span>
<span class="source-line-no">179</span><span id="line.179">            Arrays.fill(data, 0L);</span>
<span class="source-line-no">180</span><span id="line.180">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">181</span><span id="line.181">                for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">182</span><span id="line.182">                    data[x * ySections + (y &gt;&gt; 6)] |= (map[x][y] ? 1L : 0L) &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">183</span><span id="line.183">                }</span>
<span class="source-line-no">184</span><span id="line.184">            }</span>
<span class="source-line-no">185</span><span id="line.185">            tallied = false;</span>
<span class="source-line-no">186</span><span id="line.186">            return this;</span>
<span class="source-line-no">187</span><span id="line.187">        } else {</span>
<span class="source-line-no">188</span><span id="line.188">            width = (map == null) ? 0 : map.length;</span>
<span class="source-line-no">189</span><span id="line.189">            height = (map == null || map.length &lt;= 0) ? 0 : map[0].length;</span>
<span class="source-line-no">190</span><span id="line.190">            ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">191</span><span id="line.191">            yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">192</span><span id="line.192">            data = new long[width * ySections];</span>
<span class="source-line-no">193</span><span id="line.193">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">194</span><span id="line.194">                for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">195</span><span id="line.195">                    if(map[x][y]) data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">196</span><span id="line.196">                }</span>
<span class="source-line-no">197</span><span id="line.197">            }</span>
<span class="source-line-no">198</span><span id="line.198">            counts = new int[width * ySections];</span>
<span class="source-line-no">199</span><span id="line.199">            tallied = false;</span>
<span class="source-line-no">200</span><span id="line.200">            return this;</span>
<span class="source-line-no">201</span><span id="line.201">        }</span>
<span class="source-line-no">202</span><span id="line.202">    }</span>
<span class="source-line-no">203</span><span id="line.203"></span>
<span class="source-line-no">204</span><span id="line.204">    /**</span>
<span class="source-line-no">205</span><span id="line.205">     * Constructs a GreasedRegion with the given rectangular char array, with width of map.length and height of</span>
<span class="source-line-no">206</span><span id="line.206">     * map[0].length, any value that equals yes is considered "on", and any other value considered "off."</span>
<span class="source-line-no">207</span><span id="line.207">     * @param map a rectangular 2D char array where yes is on and everything else is off</span>
<span class="source-line-no">208</span><span id="line.208">     * @param yes which char to encode as "on"</span>
<span class="source-line-no">209</span><span id="line.209">     */</span>
<span class="source-line-no">210</span><span id="line.210">    public GreasedRegion(final char[][] map, final char yes)</span>
<span class="source-line-no">211</span><span id="line.211">    {</span>
<span class="source-line-no">212</span><span id="line.212">        width = map.length;</span>
<span class="source-line-no">213</span><span id="line.213">        height = map[0].length;</span>
<span class="source-line-no">214</span><span id="line.214">        ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">215</span><span id="line.215">        yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">216</span><span id="line.216">        data = new long[width * ySections];</span>
<span class="source-line-no">217</span><span id="line.217">        for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">218</span><span id="line.218">            for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">219</span><span id="line.219">                if(map[x][y] == yes) data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">220</span><span id="line.220">            }</span>
<span class="source-line-no">221</span><span id="line.221">        }</span>
<span class="source-line-no">222</span><span id="line.222">        counts = new int[width * ySections];</span>
<span class="source-line-no">223</span><span id="line.223">        tallied = false;</span>
<span class="source-line-no">224</span><span id="line.224">    }</span>
<span class="source-line-no">225</span><span id="line.225">    /**</span>
<span class="source-line-no">226</span><span id="line.226">     * Reassigns this GreasedRegion with the given rectangular char array, reusing the current data storage (without</span>
<span class="source-line-no">227</span><span id="line.227">     * extra allocations) if this.width == map.length and this.height == map[0].length. The current values stored in</span>
<span class="source-line-no">228</span><span id="line.228">     * this are always cleared, then any value that equals yes is considered "on", and any other value considered "off."</span>
<span class="source-line-no">229</span><span id="line.229">     * @param map a rectangular 2D char array where yes is on and everything else is off</span>
<span class="source-line-no">230</span><span id="line.230">     * @param yes which char to encode as "on"</span>
<span class="source-line-no">231</span><span id="line.231">     * @return this for chaining</span>
<span class="source-line-no">232</span><span id="line.232">     */</span>
<span class="source-line-no">233</span><span id="line.233">    public GreasedRegion refill(final char[][] map, final char yes) {</span>
<span class="source-line-no">234</span><span id="line.234">        if (map != null &amp;&amp; map.length &gt; 0 &amp;&amp; width == map.length &amp;&amp; height == map[0].length) {</span>
<span class="source-line-no">235</span><span id="line.235">            Arrays.fill(data, 0L);</span>
<span class="source-line-no">236</span><span id="line.236">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">237</span><span id="line.237">                for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">238</span><span id="line.238">                    data[x * ySections + (y &gt;&gt; 6)] |= ((map[x][y] == yes) ? 1L : 0L) &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">239</span><span id="line.239">                }</span>
<span class="source-line-no">240</span><span id="line.240">            }</span>
<span class="source-line-no">241</span><span id="line.241">            tallied = false;</span>
<span class="source-line-no">242</span><span id="line.242">            return this;</span>
<span class="source-line-no">243</span><span id="line.243">        } else {</span>
<span class="source-line-no">244</span><span id="line.244">            width = (map == null) ? 0 : map.length;</span>
<span class="source-line-no">245</span><span id="line.245">            height = (map == null || map.length &lt;= 0) ? 0 : map[0].length;</span>
<span class="source-line-no">246</span><span id="line.246">            ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">247</span><span id="line.247">            yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">248</span><span id="line.248">            data = new long[width * ySections];</span>
<span class="source-line-no">249</span><span id="line.249">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">250</span><span id="line.250">                for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">251</span><span id="line.251">                    if(map[x][y] == yes) data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">252</span><span id="line.252">                }</span>
<span class="source-line-no">253</span><span id="line.253">            }</span>
<span class="source-line-no">254</span><span id="line.254">            counts = new int[width * ySections];</span>
<span class="source-line-no">255</span><span id="line.255">            tallied = false;</span>
<span class="source-line-no">256</span><span id="line.256">            return this;</span>
<span class="source-line-no">257</span><span id="line.257">        }</span>
<span class="source-line-no">258</span><span id="line.258">    }</span>
<span class="source-line-no">259</span><span id="line.259"></span>
<span class="source-line-no">260</span><span id="line.260">    /**</span>
<span class="source-line-no">261</span><span id="line.261">     * Constructs a GreasedRegion with the given rectangular char array, with width of map.length and height of</span>
<span class="source-line-no">262</span><span id="line.262">     * map[0].length, any value that equals yes is considered "on", and any other value considered "off."</span>
<span class="source-line-no">263</span><span id="line.263">     * @param map a rectangular 2D char array where yes is on and everything else is off</span>
<span class="source-line-no">264</span><span id="line.264">     * @param yes which char to encode as "on"</span>
<span class="source-line-no">265</span><span id="line.265">     */</span>
<span class="source-line-no">266</span><span id="line.266">    public GreasedRegion(final char[][] map, final char[] yes)</span>
<span class="source-line-no">267</span><span id="line.267">    {</span>
<span class="source-line-no">268</span><span id="line.268">        width = map.length;</span>
<span class="source-line-no">269</span><span id="line.269">        height = map[0].length;</span>
<span class="source-line-no">270</span><span id="line.270">        ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">271</span><span id="line.271">        yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">272</span><span id="line.272">        data = new long[width * ySections];</span>
<span class="source-line-no">273</span><span id="line.273">        for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">274</span><span id="line.274">            for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">275</span><span id="line.275">                for(char e : yes)</span>
<span class="source-line-no">276</span><span id="line.276">                {</span>
<span class="source-line-no">277</span><span id="line.277">                    if(map[x][y] == e) {</span>
<span class="source-line-no">278</span><span id="line.278">                        data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">279</span><span id="line.279">                        break;</span>
<span class="source-line-no">280</span><span id="line.280">                    }</span>
<span class="source-line-no">281</span><span id="line.281">                }</span>
<span class="source-line-no">282</span><span id="line.282">            }</span>
<span class="source-line-no">283</span><span id="line.283">        }</span>
<span class="source-line-no">284</span><span id="line.284">        counts = new int[width * ySections];</span>
<span class="source-line-no">285</span><span id="line.285">        tallied = false;</span>
<span class="source-line-no">286</span><span id="line.286">    }</span>
<span class="source-line-no">287</span><span id="line.287">    /**</span>
<span class="source-line-no">288</span><span id="line.288">     * Reassigns this GreasedRegion with the given rectangular char array, reusing the current data storage (without</span>
<span class="source-line-no">289</span><span id="line.289">     * extra allocations) if this.width == map.length and this.height == map[0].length. The current values stored in</span>
<span class="source-line-no">290</span><span id="line.290">     * this are always cleared, then any value that equals yes is considered "on", and any other value considered "off."</span>
<span class="source-line-no">291</span><span id="line.291">     * @param map a rectangular 2D char array where yes is on and everything else is off</span>
<span class="source-line-no">292</span><span id="line.292">     * @param yes which char to encode as "on"</span>
<span class="source-line-no">293</span><span id="line.293">     * @return this for chaining</span>
<span class="source-line-no">294</span><span id="line.294">     */</span>
<span class="source-line-no">295</span><span id="line.295">    public GreasedRegion refill(final char[][] map, final char[] yes) {</span>
<span class="source-line-no">296</span><span id="line.296">        if (map != null &amp;&amp; map.length &gt; 0 &amp;&amp; width == map.length &amp;&amp; height == map[0].length) {</span>
<span class="source-line-no">297</span><span id="line.297">            Arrays.fill(data, 0L);</span>
<span class="source-line-no">298</span><span id="line.298">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">299</span><span id="line.299">                for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">300</span><span id="line.300">                    for(char e : yes)</span>
<span class="source-line-no">301</span><span id="line.301">                    {</span>
<span class="source-line-no">302</span><span id="line.302">                        if(map[x][y] == e) {</span>
<span class="source-line-no">303</span><span id="line.303">                            data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">304</span><span id="line.304">                            break;</span>
<span class="source-line-no">305</span><span id="line.305">                        }</span>
<span class="source-line-no">306</span><span id="line.306">                    }</span>
<span class="source-line-no">307</span><span id="line.307">                }</span>
<span class="source-line-no">308</span><span id="line.308">            }</span>
<span class="source-line-no">309</span><span id="line.309">            tallied = false;</span>
<span class="source-line-no">310</span><span id="line.310">            return this;</span>
<span class="source-line-no">311</span><span id="line.311">        } else {</span>
<span class="source-line-no">312</span><span id="line.312">            width = (map == null) ? 0 : map.length;</span>
<span class="source-line-no">313</span><span id="line.313">            height = (map == null || map.length &lt;= 0) ? 0 : map[0].length;</span>
<span class="source-line-no">314</span><span id="line.314">            ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">315</span><span id="line.315">            yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">316</span><span id="line.316">            data = new long[width * ySections];</span>
<span class="source-line-no">317</span><span id="line.317">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">318</span><span id="line.318">                for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">319</span><span id="line.319">                    for(char e : yes)</span>
<span class="source-line-no">320</span><span id="line.320">                    {</span>
<span class="source-line-no">321</span><span id="line.321">                        if(map[x][y] == e) {</span>
<span class="source-line-no">322</span><span id="line.322">                            data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">323</span><span id="line.323">                            break;</span>
<span class="source-line-no">324</span><span id="line.324">                        }</span>
<span class="source-line-no">325</span><span id="line.325">                    }</span>
<span class="source-line-no">326</span><span id="line.326">                }</span>
<span class="source-line-no">327</span><span id="line.327">            }</span>
<span class="source-line-no">328</span><span id="line.328">            counts = new int[width * ySections];</span>
<span class="source-line-no">329</span><span id="line.329">            tallied = false;</span>
<span class="source-line-no">330</span><span id="line.330">            return this;</span>
<span class="source-line-no">331</span><span id="line.331">        }</span>
<span class="source-line-no">332</span><span id="line.332">    }</span>
<span class="source-line-no">333</span><span id="line.333"></span>
<span class="source-line-no">334</span><span id="line.334">    /**</span>
<span class="source-line-no">335</span><span id="line.335">     * Weird constructor that takes a String array, _as it would be printed_, so each String is a row and indexing would</span>
<span class="source-line-no">336</span><span id="line.336">     * be done with y, x instead of the normal x, y.</span>
<span class="source-line-no">337</span><span id="line.337">     * @param map String array (as printed, not the normal storage) where each String is a row</span>
<span class="source-line-no">338</span><span id="line.338">     * @param yes the char to consider "on" in the GreasedRegion</span>
<span class="source-line-no">339</span><span id="line.339">     */</span>
<span class="source-line-no">340</span><span id="line.340">    public GreasedRegion(final String[] map, final char yes)</span>
<span class="source-line-no">341</span><span id="line.341">    {</span>
<span class="source-line-no">342</span><span id="line.342">        height = map.length;</span>
<span class="source-line-no">343</span><span id="line.343">        width = map[0].length();</span>
<span class="source-line-no">344</span><span id="line.344">        ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">345</span><span id="line.345">        yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">346</span><span id="line.346">        data = new long[width * ySections];</span>
<span class="source-line-no">347</span><span id="line.347">        for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">348</span><span id="line.348">            for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">349</span><span id="line.349">                if(map[y].charAt(x) == yes) data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">350</span><span id="line.350">            }</span>
<span class="source-line-no">351</span><span id="line.351">        }</span>
<span class="source-line-no">352</span><span id="line.352">        counts = new int[width * ySections];</span>
<span class="source-line-no">353</span><span id="line.353">        tallied = false;</span>
<span class="source-line-no">354</span><span id="line.354">    }</span>
<span class="source-line-no">355</span><span id="line.355"></span>
<span class="source-line-no">356</span><span id="line.356">    /**</span>
<span class="source-line-no">357</span><span id="line.357">     * Weird refill method that takes a String array, _as it would be printed_, so each String is a row and indexing</span>
<span class="source-line-no">358</span><span id="line.358">     * would be done with y, x instead of the normal x, y.</span>
<span class="source-line-no">359</span><span id="line.359">     * @param map String array (as printed, not the normal storage) where each String is a row</span>
<span class="source-line-no">360</span><span id="line.360">     * @param yes the char to consider "on" in the GreasedRegion</span>
<span class="source-line-no">361</span><span id="line.361">     * @return this for chaining</span>
<span class="source-line-no">362</span><span id="line.362">     */</span>
<span class="source-line-no">363</span><span id="line.363">    public GreasedRegion refill(final String[] map, final char yes) {</span>
<span class="source-line-no">364</span><span id="line.364">        if (map != null &amp;&amp; map.length &gt; 0 &amp;&amp; height == map.length &amp;&amp; width == map[0].length()) {</span>
<span class="source-line-no">365</span><span id="line.365">            Arrays.fill(data, 0L);</span>
<span class="source-line-no">366</span><span id="line.366">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">367</span><span id="line.367">                for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">368</span><span id="line.368">                    data[x * ySections + (y &gt;&gt; 6)] |= ((map[y].charAt(x) == yes) ? 1L : 0L) &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">369</span><span id="line.369">                }</span>
<span class="source-line-no">370</span><span id="line.370">            }</span>
<span class="source-line-no">371</span><span id="line.371">            tallied = false;</span>
<span class="source-line-no">372</span><span id="line.372">            return this;</span>
<span class="source-line-no">373</span><span id="line.373">        } else {</span>
<span class="source-line-no">374</span><span id="line.374">            height = (map == null) ? 0 : map.length;</span>
<span class="source-line-no">375</span><span id="line.375">            width = (map == null || map.length &lt;= 0) ? 0 : map[0].length();</span>
<span class="source-line-no">376</span><span id="line.376">            ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">377</span><span id="line.377">            yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">378</span><span id="line.378">            data = new long[width * ySections];</span>
<span class="source-line-no">379</span><span id="line.379">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">380</span><span id="line.380">                for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">381</span><span id="line.381">                    if(map[y].charAt(y) == yes) data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">382</span><span id="line.382">                }</span>
<span class="source-line-no">383</span><span id="line.383">            }</span>
<span class="source-line-no">384</span><span id="line.384">            counts = new int[width * ySections];</span>
<span class="source-line-no">385</span><span id="line.385">            tallied = false;</span>
<span class="source-line-no">386</span><span id="line.386">            return this;</span>
<span class="source-line-no">387</span><span id="line.387">        }</span>
<span class="source-line-no">388</span><span id="line.388">    }</span>
<span class="source-line-no">389</span><span id="line.389">    /**</span>
<span class="source-line-no">390</span><span id="line.390">     * Constructs a GreasedRegion with the given rectangular int array, with width of map.length and height of</span>
<span class="source-line-no">391</span><span id="line.391">     * map[0].length, any value that equals yes is considered "on", and any other value considered "off."</span>
<span class="source-line-no">392</span><span id="line.392">     * @param map a rectangular 2D int array where an int == yes is on and everything else is off</span>
<span class="source-line-no">393</span><span id="line.393">     * @param yes which int to encode as "on"</span>
<span class="source-line-no">394</span><span id="line.394">     */</span>
<span class="source-line-no">395</span><span id="line.395">    public GreasedRegion(final int[][] map, final int yes)</span>
<span class="source-line-no">396</span><span id="line.396">    {</span>
<span class="source-line-no">397</span><span id="line.397">        width = map.length;</span>
<span class="source-line-no">398</span><span id="line.398">        height = map[0].length;</span>
<span class="source-line-no">399</span><span id="line.399">        ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">400</span><span id="line.400">        yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">401</span><span id="line.401">        data = new long[width * ySections];</span>
<span class="source-line-no">402</span><span id="line.402">        for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">403</span><span id="line.403">            for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">404</span><span id="line.404">                if(map[x][y] == yes) data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">405</span><span id="line.405">            }</span>
<span class="source-line-no">406</span><span id="line.406">        }</span>
<span class="source-line-no">407</span><span id="line.407">        counts = new int[width * ySections];</span>
<span class="source-line-no">408</span><span id="line.408">        tallied = false;</span>
<span class="source-line-no">409</span><span id="line.409">    }</span>
<span class="source-line-no">410</span><span id="line.410">    /**</span>
<span class="source-line-no">411</span><span id="line.411">     * Reassigns this GreasedRegion with the given rectangular int array, reusing the current data storage (without</span>
<span class="source-line-no">412</span><span id="line.412">     * extra allocations) if this.width == map.length and this.height == map[0].length. The current values stored in</span>
<span class="source-line-no">413</span><span id="line.413">     * this are always cleared, then any value that equals yes is considered "on", and any other value considered "off."</span>
<span class="source-line-no">414</span><span id="line.414">     * @param map a rectangular 2D int array where an int == yes is on and everything else is off</span>
<span class="source-line-no">415</span><span id="line.415">     * @param yes which int to encode as "on"</span>
<span class="source-line-no">416</span><span id="line.416">     * @return this for chaining</span>
<span class="source-line-no">417</span><span id="line.417">     */</span>
<span class="source-line-no">418</span><span id="line.418">    public GreasedRegion refill(final int[][] map, final int yes) {</span>
<span class="source-line-no">419</span><span id="line.419">        if (map != null &amp;&amp; map.length &gt; 0 &amp;&amp; width == map.length &amp;&amp; height == map[0].length) {</span>
<span class="source-line-no">420</span><span id="line.420">            Arrays.fill(data, 0L);</span>
<span class="source-line-no">421</span><span id="line.421">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">422</span><span id="line.422">                for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">423</span><span id="line.423">                    data[x * ySections + (y &gt;&gt; 6)] |= ((map[x][y] == yes) ? 1L : 0L) &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">424</span><span id="line.424">                }</span>
<span class="source-line-no">425</span><span id="line.425">            }</span>
<span class="source-line-no">426</span><span id="line.426">            tallied = false;</span>
<span class="source-line-no">427</span><span id="line.427">            return this;</span>
<span class="source-line-no">428</span><span id="line.428">        } else {</span>
<span class="source-line-no">429</span><span id="line.429">            width = (map == null) ? 0 : map.length;</span>
<span class="source-line-no">430</span><span id="line.430">            height = (map == null || map.length &lt;= 0) ? 0 : map[0].length;</span>
<span class="source-line-no">431</span><span id="line.431">            ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">432</span><span id="line.432">            yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">433</span><span id="line.433">            data = new long[width * ySections];</span>
<span class="source-line-no">434</span><span id="line.434">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">435</span><span id="line.435">                for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">436</span><span id="line.436">                    if(map[x][y] == yes) data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">437</span><span id="line.437">                }</span>
<span class="source-line-no">438</span><span id="line.438">            }</span>
<span class="source-line-no">439</span><span id="line.439">            counts = new int[width * ySections];</span>
<span class="source-line-no">440</span><span id="line.440">            tallied = false;</span>
<span class="source-line-no">441</span><span id="line.441">            return this;</span>
<span class="source-line-no">442</span><span id="line.442">        }</span>
<span class="source-line-no">443</span><span id="line.443">    }</span>
<span class="source-line-no">444</span><span id="line.444"></span>
<span class="source-line-no">445</span><span id="line.445">    /**</span>
<span class="source-line-no">446</span><span id="line.446">     * Constructs this GreasedRegion using an int[][], treating cells as on if they are greater than or equal to lower</span>
<span class="source-line-no">447</span><span id="line.447">     * and less than upper, or off otherwise.</span>
<span class="source-line-no">448</span><span id="line.448">     * @param map an int[][] that should have some ints between lower and upper</span>
<span class="source-line-no">449</span><span id="line.449">     * @param lower lower bound, inclusive; all on cells will have values in map that are at least equal to lower</span>
<span class="source-line-no">450</span><span id="line.450">     * @param upper upper bound, exclusive; all on cells will have values in map that are less than upper</span>
<span class="source-line-no">451</span><span id="line.451">     */</span>
<span class="source-line-no">452</span><span id="line.452">    public GreasedRegion(final int[][] map, final int lower, final int upper)</span>
<span class="source-line-no">453</span><span id="line.453">    {</span>
<span class="source-line-no">454</span><span id="line.454">        width = map.length;</span>
<span class="source-line-no">455</span><span id="line.455">        height = map[0].length;</span>
<span class="source-line-no">456</span><span id="line.456">        ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">457</span><span id="line.457">        yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">458</span><span id="line.458">        data = new long[width * ySections];</span>
<span class="source-line-no">459</span><span id="line.459">        int[] column;</span>
<span class="source-line-no">460</span><span id="line.460">        for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">461</span><span id="line.461">            column = map[x];</span>
<span class="source-line-no">462</span><span id="line.462">            for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">463</span><span id="line.463">                if(column[y] &gt;= lower &amp;&amp; column[y] &lt; upper) data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">464</span><span id="line.464">            }</span>
<span class="source-line-no">465</span><span id="line.465">        }</span>
<span class="source-line-no">466</span><span id="line.466">        counts = new int[width * ySections];</span>
<span class="source-line-no">467</span><span id="line.467">        tallied = false;</span>
<span class="source-line-no">468</span><span id="line.468">    }</span>
<span class="source-line-no">469</span><span id="line.469"></span>
<span class="source-line-no">470</span><span id="line.470">    /**</span>
<span class="source-line-no">471</span><span id="line.471">     * Reassigns this GreasedRegion with the given rectangular int array, reusing the current data storage (without</span>
<span class="source-line-no">472</span><span id="line.472">     * extra allocations) if this.width == map.length and this.height == map[0].length. The current values stored in</span>
<span class="source-line-no">473</span><span id="line.473">     * this are always cleared, then cells are treated as on if they are greater than or equal to lower and less than</span>
<span class="source-line-no">474</span><span id="line.474">     * upper, or off otherwise.</span>
<span class="source-line-no">475</span><span id="line.475">     * @param map a rectangular 2D int array that should have some values between lower and upper</span>
<span class="source-line-no">476</span><span id="line.476">     * @param lower lower bound, inclusive; all on cells will have values in map that are at least equal to lower</span>
<span class="source-line-no">477</span><span id="line.477">     * @param upper upper bound, exclusive; all on cells will have values in map that are less than upper</span>
<span class="source-line-no">478</span><span id="line.478">     * @return this for chaining</span>
<span class="source-line-no">479</span><span id="line.479">     */</span>
<span class="source-line-no">480</span><span id="line.480">    public GreasedRegion refill(final int[][] map, final int lower, final int upper) {</span>
<span class="source-line-no">481</span><span id="line.481">        if (map != null &amp;&amp; map.length &gt; 0 &amp;&amp; width == map.length &amp;&amp; height == map[0].length) {</span>
<span class="source-line-no">482</span><span id="line.482">            Arrays.fill(data, 0L);</span>
<span class="source-line-no">483</span><span id="line.483">            int[] column;</span>
<span class="source-line-no">484</span><span id="line.484">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">485</span><span id="line.485">                column = map[x];</span>
<span class="source-line-no">486</span><span id="line.486">                for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">487</span><span id="line.487">                    data[x * ySections + (y &gt;&gt; 6)] |= ((column[y] &gt;= lower &amp;&amp; column[y] &lt; upper) ? 1L : 0L) &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">488</span><span id="line.488">                }</span>
<span class="source-line-no">489</span><span id="line.489">            }</span>
<span class="source-line-no">490</span><span id="line.490">            tallied = false;</span>
<span class="source-line-no">491</span><span id="line.491">            return this;</span>
<span class="source-line-no">492</span><span id="line.492">        } else {</span>
<span class="source-line-no">493</span><span id="line.493">            width = (map == null) ? 0 : map.length;</span>
<span class="source-line-no">494</span><span id="line.494">            height = (map == null || map.length &lt;= 0) ? 0 : map[0].length;</span>
<span class="source-line-no">495</span><span id="line.495">            ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">496</span><span id="line.496">            yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">497</span><span id="line.497">            data = new long[width * ySections];</span>
<span class="source-line-no">498</span><span id="line.498">            int[] column;</span>
<span class="source-line-no">499</span><span id="line.499">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">500</span><span id="line.500">                column = map[x];</span>
<span class="source-line-no">501</span><span id="line.501">                for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">502</span><span id="line.502">                    if(column[y] &gt;= lower &amp;&amp; column[y] &lt; upper) data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">503</span><span id="line.503">                }</span>
<span class="source-line-no">504</span><span id="line.504">            }</span>
<span class="source-line-no">505</span><span id="line.505">            counts = new int[width * ySections];</span>
<span class="source-line-no">506</span><span id="line.506">            tallied = false;</span>
<span class="source-line-no">507</span><span id="line.507">            return this;</span>
<span class="source-line-no">508</span><span id="line.508">        }</span>
<span class="source-line-no">509</span><span id="line.509">    }</span>
<span class="source-line-no">510</span><span id="line.510"></span>
<span class="source-line-no">511</span><span id="line.511">    /**</span>
<span class="source-line-no">512</span><span id="line.512">     * Constructs this GreasedRegion using a byte[][], treating cells as on if they are greater than or equal to lower</span>
<span class="source-line-no">513</span><span id="line.513">     * and less than upper, or off otherwise.</span>
<span class="source-line-no">514</span><span id="line.514">     * @param map a byte[][] that should have some bytes between lower and upper</span>
<span class="source-line-no">515</span><span id="line.515">     * @param lower lower bound, inclusive; all on cells will have values in map that are at least equal to lower</span>
<span class="source-line-no">516</span><span id="line.516">     * @param upper upper bound, exclusive; all on cells will have values in map that are less than upper</span>
<span class="source-line-no">517</span><span id="line.517">     */</span>
<span class="source-line-no">518</span><span id="line.518">    public GreasedRegion(final byte[][] map, final int lower, final int upper)</span>
<span class="source-line-no">519</span><span id="line.519">    {</span>
<span class="source-line-no">520</span><span id="line.520">        width = map.length;</span>
<span class="source-line-no">521</span><span id="line.521">        height = map[0].length;</span>
<span class="source-line-no">522</span><span id="line.522">        ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">523</span><span id="line.523">        yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">524</span><span id="line.524">        data = new long[width * ySections];</span>
<span class="source-line-no">525</span><span id="line.525">        byte[] column;</span>
<span class="source-line-no">526</span><span id="line.526">        for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">527</span><span id="line.527">            column = map[x];</span>
<span class="source-line-no">528</span><span id="line.528">            for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">529</span><span id="line.529">                if(column[y] &gt;= lower &amp;&amp; column[y] &lt; upper) data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">530</span><span id="line.530">            }</span>
<span class="source-line-no">531</span><span id="line.531">        }</span>
<span class="source-line-no">532</span><span id="line.532">        counts = new int[width * ySections];</span>
<span class="source-line-no">533</span><span id="line.533">        tallied = false;</span>
<span class="source-line-no">534</span><span id="line.534">    }</span>
<span class="source-line-no">535</span><span id="line.535"></span>
<span class="source-line-no">536</span><span id="line.536">    /**</span>
<span class="source-line-no">537</span><span id="line.537">     * Reassigns this GreasedRegion with the given rectangular byte array, reusing the current data storage (without</span>
<span class="source-line-no">538</span><span id="line.538">     * extra allocations) if this.width == map.length and this.height == map[0].length. The current values stored in</span>
<span class="source-line-no">539</span><span id="line.539">     * this are always cleared, then cells are treated as on if they are greater than or equal to lower and less than</span>
<span class="source-line-no">540</span><span id="line.540">     * upper, or off otherwise.</span>
<span class="source-line-no">541</span><span id="line.541">     * @param map a rectangular 2D byte array that should have some values between lower and upper</span>
<span class="source-line-no">542</span><span id="line.542">     * @param lower lower bound, inclusive; all on cells will have values in map that are at least equal to lower</span>
<span class="source-line-no">543</span><span id="line.543">     * @param upper upper bound, exclusive; all on cells will have values in map that are less than upper</span>
<span class="source-line-no">544</span><span id="line.544">     * @return this for chaining</span>
<span class="source-line-no">545</span><span id="line.545">     */</span>
<span class="source-line-no">546</span><span id="line.546">    public GreasedRegion refill(final byte[][] map, final int lower, final int upper) {</span>
<span class="source-line-no">547</span><span id="line.547">        if (map != null &amp;&amp; map.length &gt; 0 &amp;&amp; width == map.length &amp;&amp; height == map[0].length) {</span>
<span class="source-line-no">548</span><span id="line.548">            Arrays.fill(data, 0L);</span>
<span class="source-line-no">549</span><span id="line.549">            byte[] column;</span>
<span class="source-line-no">550</span><span id="line.550">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">551</span><span id="line.551">                column = map[x];</span>
<span class="source-line-no">552</span><span id="line.552">                for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">553</span><span id="line.553">                    data[x * ySections + (y &gt;&gt; 6)] |= ((column[y] &gt;= lower &amp;&amp; column[y] &lt; upper) ? 1L : 0L) &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">554</span><span id="line.554">                }</span>
<span class="source-line-no">555</span><span id="line.555">            }</span>
<span class="source-line-no">556</span><span id="line.556">            tallied = false;</span>
<span class="source-line-no">557</span><span id="line.557">            return this;</span>
<span class="source-line-no">558</span><span id="line.558">        } else {</span>
<span class="source-line-no">559</span><span id="line.559">            width = (map == null) ? 0 : map.length;</span>
<span class="source-line-no">560</span><span id="line.560">            height = (map == null || map.length &lt;= 0) ? 0 : map[0].length;</span>
<span class="source-line-no">561</span><span id="line.561">            ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">562</span><span id="line.562">            yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">563</span><span id="line.563">            data = new long[width * ySections];</span>
<span class="source-line-no">564</span><span id="line.564">            byte[] column;</span>
<span class="source-line-no">565</span><span id="line.565">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">566</span><span id="line.566">                column = map[x];</span>
<span class="source-line-no">567</span><span id="line.567">                for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">568</span><span id="line.568">                    if(column[y] &gt;= lower &amp;&amp; column[y] &lt; upper) data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">569</span><span id="line.569">                }</span>
<span class="source-line-no">570</span><span id="line.570">            }</span>
<span class="source-line-no">571</span><span id="line.571">            counts = new int[width * ySections];</span>
<span class="source-line-no">572</span><span id="line.572">            tallied = false;</span>
<span class="source-line-no">573</span><span id="line.573">            return this;</span>
<span class="source-line-no">574</span><span id="line.574">        }</span>
<span class="source-line-no">575</span><span id="line.575">    }</span>
<span class="source-line-no">576</span><span id="line.576"></span>
<span class="source-line-no">577</span><span id="line.577"></span>
<span class="source-line-no">578</span><span id="line.578">    /**</span>
<span class="source-line-no">579</span><span id="line.579">     * Constructs this GreasedRegion using a short[][], treating cells as on if they are greater than or equal to lower</span>
<span class="source-line-no">580</span><span id="line.580">     * and less than upper, or off otherwise.</span>
<span class="source-line-no">581</span><span id="line.581">     * @param map a short[][] that should have some shorts between lower and upper</span>
<span class="source-line-no">582</span><span id="line.582">     * @param lower lower bound, inclusive; all on cells will have values in map that are at least equal to lower</span>
<span class="source-line-no">583</span><span id="line.583">     * @param upper upper bound, exclusive; all on cells will have values in map that are less than upper</span>
<span class="source-line-no">584</span><span id="line.584">     */</span>
<span class="source-line-no">585</span><span id="line.585">    public GreasedRegion(final short[][] map, final int lower, final int upper)</span>
<span class="source-line-no">586</span><span id="line.586">    {</span>
<span class="source-line-no">587</span><span id="line.587">        width = map.length;</span>
<span class="source-line-no">588</span><span id="line.588">        height = map[0].length;</span>
<span class="source-line-no">589</span><span id="line.589">        ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">590</span><span id="line.590">        yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">591</span><span id="line.591">        data = new long[width * ySections];</span>
<span class="source-line-no">592</span><span id="line.592">        short[] column;</span>
<span class="source-line-no">593</span><span id="line.593">        for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">594</span><span id="line.594">            column = map[x];</span>
<span class="source-line-no">595</span><span id="line.595">            for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">596</span><span id="line.596">                if(column[y] &gt;= lower &amp;&amp; column[y] &lt; upper) data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">597</span><span id="line.597">            }</span>
<span class="source-line-no">598</span><span id="line.598">        }</span>
<span class="source-line-no">599</span><span id="line.599">        counts = new int[width * ySections];</span>
<span class="source-line-no">600</span><span id="line.600">        tallied = false;</span>
<span class="source-line-no">601</span><span id="line.601">    }</span>
<span class="source-line-no">602</span><span id="line.602"></span>
<span class="source-line-no">603</span><span id="line.603">    /**</span>
<span class="source-line-no">604</span><span id="line.604">     * Reassigns this GreasedRegion with the given rectangular short array, reusing the current data storage (without</span>
<span class="source-line-no">605</span><span id="line.605">     * extra allocations) if this.width == map.length and this.height == map[0].length. The current values stored in</span>
<span class="source-line-no">606</span><span id="line.606">     * this are always cleared, then cells are treated as on if they are greater than or equal to lower and less than</span>
<span class="source-line-no">607</span><span id="line.607">     * upper, or off otherwise.</span>
<span class="source-line-no">608</span><span id="line.608">     * @param map a rectangular 2D short array that should have some values between lower and upper</span>
<span class="source-line-no">609</span><span id="line.609">     * @param lower lower bound, inclusive; all on cells will have values in map that are at least equal to lower</span>
<span class="source-line-no">610</span><span id="line.610">     * @param upper upper bound, exclusive; all on cells will have values in map that are less than upper</span>
<span class="source-line-no">611</span><span id="line.611">     * @return this for chaining</span>
<span class="source-line-no">612</span><span id="line.612">     */</span>
<span class="source-line-no">613</span><span id="line.613">    public GreasedRegion refill(final short[][] map, final int lower, final int upper) {</span>
<span class="source-line-no">614</span><span id="line.614">        if (map != null &amp;&amp; map.length &gt; 0 &amp;&amp; width == map.length &amp;&amp; height == map[0].length) {</span>
<span class="source-line-no">615</span><span id="line.615">            Arrays.fill(data, 0L);</span>
<span class="source-line-no">616</span><span id="line.616">            short[] column;</span>
<span class="source-line-no">617</span><span id="line.617">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">618</span><span id="line.618">                column = map[x];</span>
<span class="source-line-no">619</span><span id="line.619">                for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">620</span><span id="line.620">                    data[x * ySections + (y &gt;&gt; 6)] |= ((column[y] &gt;= lower &amp;&amp; column[y] &lt; upper) ? 1L : 0L) &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">621</span><span id="line.621">                }</span>
<span class="source-line-no">622</span><span id="line.622">            }</span>
<span class="source-line-no">623</span><span id="line.623">            tallied = false;</span>
<span class="source-line-no">624</span><span id="line.624">            return this;</span>
<span class="source-line-no">625</span><span id="line.625">        } else {</span>
<span class="source-line-no">626</span><span id="line.626">            width = (map == null) ? 0 : map.length;</span>
<span class="source-line-no">627</span><span id="line.627">            height = (map == null || map.length &lt;= 0) ? 0 : map[0].length;</span>
<span class="source-line-no">628</span><span id="line.628">            ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">629</span><span id="line.629">            yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">630</span><span id="line.630">            data = new long[width * ySections];</span>
<span class="source-line-no">631</span><span id="line.631">            short[] column;</span>
<span class="source-line-no">632</span><span id="line.632">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">633</span><span id="line.633">                column = map[x];</span>
<span class="source-line-no">634</span><span id="line.634">                for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">635</span><span id="line.635">                    if(column[y] &gt;= lower &amp;&amp; column[y] &lt; upper) data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">636</span><span id="line.636">                }</span>
<span class="source-line-no">637</span><span id="line.637">            }</span>
<span class="source-line-no">638</span><span id="line.638">            counts = new int[width * ySections];</span>
<span class="source-line-no">639</span><span id="line.639">            tallied = false;</span>
<span class="source-line-no">640</span><span id="line.640">            return this;</span>
<span class="source-line-no">641</span><span id="line.641">        }</span>
<span class="source-line-no">642</span><span id="line.642">    }</span>
<span class="source-line-no">643</span><span id="line.643">    /**</span>
<span class="source-line-no">644</span><span id="line.644">     * Constructs this GreasedRegion using a double[][] (typically one generated by</span>
<span class="source-line-no">645</span><span id="line.645">     * {@link squidpony.squidai.DijkstraMap}) that only stores two relevant states:  an "on" state for values less than</span>
<span class="source-line-no">646</span><span id="line.646">     * or equal to upperBound (inclusive), and an "off" state for anything else.</span>
<span class="source-line-no">647</span><span id="line.647">     * @param map a double[][] that probably relates in some way to DijkstraMap.</span>
<span class="source-line-no">648</span><span id="line.648">     * @param upperBound upper inclusive; any double greater than this will be off, any others will be on</span>
<span class="source-line-no">649</span><span id="line.649">     */</span>
<span class="source-line-no">650</span><span id="line.650">    public GreasedRegion(final double[][] map, final double upperBound)</span>
<span class="source-line-no">651</span><span id="line.651">    {</span>
<span class="source-line-no">652</span><span id="line.652">        width = map.length;</span>
<span class="source-line-no">653</span><span id="line.653">        height = map[0].length;</span>
<span class="source-line-no">654</span><span id="line.654">        ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">655</span><span id="line.655">        yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">656</span><span id="line.656">        data = new long[width * ySections];</span>
<span class="source-line-no">657</span><span id="line.657">        for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">658</span><span id="line.658">            for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">659</span><span id="line.659">                if(map[x][y] &lt;= upperBound)</span>
<span class="source-line-no">660</span><span id="line.660">                    data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">661</span><span id="line.661">            }</span>
<span class="source-line-no">662</span><span id="line.662">        }</span>
<span class="source-line-no">663</span><span id="line.663">        counts = new int[width * ySections];</span>
<span class="source-line-no">664</span><span id="line.664">        tallied = false;</span>
<span class="source-line-no">665</span><span id="line.665">    }</span>
<span class="source-line-no">666</span><span id="line.666">    /**</span>
<span class="source-line-no">667</span><span id="line.667">     * Reassigns this GreasedRegion with the given rectangular double array, reusing the current data storage (without</span>
<span class="source-line-no">668</span><span id="line.668">     * extra allocations) if this.width == map.length and this.height == map[0].length. The current values stored in</span>
<span class="source-line-no">669</span><span id="line.669">     * this are always cleared, then cells are treated as on if they are less than or equal to upperBound, or off</span>
<span class="source-line-no">670</span><span id="line.670">     * otherwise.</span>
<span class="source-line-no">671</span><span id="line.671">     * @param map a rectangular 2D double array that should usually have some values less than or equal to upperBound</span>
<span class="source-line-no">672</span><span id="line.672">     * @param upperBound upper bound, inclusive; all on cells will have values in map that are less than or equal to this</span>
<span class="source-line-no">673</span><span id="line.673">     * @return this for chaining</span>
<span class="source-line-no">674</span><span id="line.674">     */</span>
<span class="source-line-no">675</span><span id="line.675">    public GreasedRegion refill(final double[][] map, final double upperBound) {</span>
<span class="source-line-no">676</span><span id="line.676">        if (map != null &amp;&amp; map.length &gt; 0 &amp;&amp; width == map.length &amp;&amp; height == map[0].length) {</span>
<span class="source-line-no">677</span><span id="line.677">            Arrays.fill(data, 0L);</span>
<span class="source-line-no">678</span><span id="line.678">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">679</span><span id="line.679">                for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">680</span><span id="line.680">                    if(map[x][y] &lt;= upperBound) data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">681</span><span id="line.681">                }</span>
<span class="source-line-no">682</span><span id="line.682">            }</span>
<span class="source-line-no">683</span><span id="line.683">            tallied = false;</span>
<span class="source-line-no">684</span><span id="line.684">            return this;</span>
<span class="source-line-no">685</span><span id="line.685">        } else {</span>
<span class="source-line-no">686</span><span id="line.686">            width = (map == null) ? 0 : map.length;</span>
<span class="source-line-no">687</span><span id="line.687">            height = (map == null || map.length &lt;= 0) ? 0 : map[0].length;</span>
<span class="source-line-no">688</span><span id="line.688">            ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">689</span><span id="line.689">            yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">690</span><span id="line.690">            data = new long[width * ySections];</span>
<span class="source-line-no">691</span><span id="line.691">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">692</span><span id="line.692">                for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">693</span><span id="line.693">                    if(map[x][y] &lt;= upperBound) data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">694</span><span id="line.694">                }</span>
<span class="source-line-no">695</span><span id="line.695">            }</span>
<span class="source-line-no">696</span><span id="line.696">            counts = new int[width * ySections];</span>
<span class="source-line-no">697</span><span id="line.697">            tallied = false;</span>
<span class="source-line-no">698</span><span id="line.698">            return this;</span>
<span class="source-line-no">699</span><span id="line.699">        }</span>
<span class="source-line-no">700</span><span id="line.700">    }</span>
<span class="source-line-no">701</span><span id="line.701"></span>
<span class="source-line-no">702</span><span id="line.702">    /**</span>
<span class="source-line-no">703</span><span id="line.703">     * Constructs this GreasedRegion using a double[][] (typically one generated by</span>
<span class="source-line-no">704</span><span id="line.704">     * {@link squidpony.squidai.DijkstraMap}) that only stores two relevant states:  an "on" state for values between</span>
<span class="source-line-no">705</span><span id="line.705">     * lowerBound (inclusive) and upperBound (exclusive), and an "off" state for anything else.</span>
<span class="source-line-no">706</span><span id="line.706">     * @param map a double[][] that probably relates in some way to DijkstraMap.</span>
<span class="source-line-no">707</span><span id="line.707">     * @param lowerBound lower inclusive; any double lower than this will be off, any equal to or greater than this,</span>
<span class="source-line-no">708</span><span id="line.708">     *                   but less than upper, will be on</span>
<span class="source-line-no">709</span><span id="line.709">     * @param upperBound upper exclusive; any double greater than or equal to this this will be off, any doubles both</span>
<span class="source-line-no">710</span><span id="line.710">     *                   less than this and equal to or greater than lower will be on</span>
<span class="source-line-no">711</span><span id="line.711">     */</span>
<span class="source-line-no">712</span><span id="line.712">    public GreasedRegion(final double[][] map, final double lowerBound, final double upperBound)</span>
<span class="source-line-no">713</span><span id="line.713">    {</span>
<span class="source-line-no">714</span><span id="line.714">        width = map.length;</span>
<span class="source-line-no">715</span><span id="line.715">        height = map[0].length;</span>
<span class="source-line-no">716</span><span id="line.716">        ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">717</span><span id="line.717">        yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">718</span><span id="line.718">        data = new long[width * ySections];</span>
<span class="source-line-no">719</span><span id="line.719">        for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">720</span><span id="line.720">            for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">721</span><span id="line.721">                if(map[x][y] &gt;= lowerBound &amp;&amp; map[x][y] &lt; upperBound)</span>
<span class="source-line-no">722</span><span id="line.722">                    data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">723</span><span id="line.723">            }</span>
<span class="source-line-no">724</span><span id="line.724">        }</span>
<span class="source-line-no">725</span><span id="line.725">        counts = new int[width * ySections];</span>
<span class="source-line-no">726</span><span id="line.726">        tallied = false;</span>
<span class="source-line-no">727</span><span id="line.727">    }</span>
<span class="source-line-no">728</span><span id="line.728">    /**</span>
<span class="source-line-no">729</span><span id="line.729">     * Reassigns this GreasedRegion with the given rectangular double array, reusing the current data storage (without</span>
<span class="source-line-no">730</span><span id="line.730">     * extra allocations) if this.width == map.length and this.height == map[0].length. The current values stored in</span>
<span class="source-line-no">731</span><span id="line.731">     * this are always cleared, then cells are treated as on if they are greater than or equal to lower and less than</span>
<span class="source-line-no">732</span><span id="line.732">     * upper, or off otherwise.</span>
<span class="source-line-no">733</span><span id="line.733">     * @param map a rectangular 2D double array that should have some values between lower and upper</span>
<span class="source-line-no">734</span><span id="line.734">     * @param lower lower bound, inclusive; all on cells will have values in map that are at least equal to lower</span>
<span class="source-line-no">735</span><span id="line.735">     * @param upper upper bound, exclusive; all on cells will have values in map that are less than upper</span>
<span class="source-line-no">736</span><span id="line.736">     * @return this for chaining</span>
<span class="source-line-no">737</span><span id="line.737">     */</span>
<span class="source-line-no">738</span><span id="line.738">    public GreasedRegion refill(final double[][] map, final double lower, final double upper) {</span>
<span class="source-line-no">739</span><span id="line.739">        if (map != null &amp;&amp; map.length &gt; 0 &amp;&amp; width == map.length &amp;&amp; height == map[0].length) {</span>
<span class="source-line-no">740</span><span id="line.740">            Arrays.fill(data, 0L);</span>
<span class="source-line-no">741</span><span id="line.741">            double[] column;</span>
<span class="source-line-no">742</span><span id="line.742">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">743</span><span id="line.743">                column = map[x];</span>
<span class="source-line-no">744</span><span id="line.744">                for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">745</span><span id="line.745">                    data[x * ySections + (y &gt;&gt; 6)] |= ((column[y] &gt;= lower &amp;&amp; column[y] &lt; upper) ? 1L : 0L) &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">746</span><span id="line.746">                }</span>
<span class="source-line-no">747</span><span id="line.747">            }</span>
<span class="source-line-no">748</span><span id="line.748">            tallied = false;</span>
<span class="source-line-no">749</span><span id="line.749">            return this;</span>
<span class="source-line-no">750</span><span id="line.750">        } else {</span>
<span class="source-line-no">751</span><span id="line.751">            width = (map == null) ? 0 : map.length;</span>
<span class="source-line-no">752</span><span id="line.752">            height = (map == null || map.length &lt;= 0) ? 0 : map[0].length;</span>
<span class="source-line-no">753</span><span id="line.753">            ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">754</span><span id="line.754">            yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">755</span><span id="line.755">            data = new long[width * ySections];</span>
<span class="source-line-no">756</span><span id="line.756">            double[] column;</span>
<span class="source-line-no">757</span><span id="line.757">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">758</span><span id="line.758">                column = map[x];</span>
<span class="source-line-no">759</span><span id="line.759">                for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">760</span><span id="line.760">                    if(column[y] &gt;= lower &amp;&amp; column[y] &lt; upper) data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">761</span><span id="line.761">                }</span>
<span class="source-line-no">762</span><span id="line.762">            }</span>
<span class="source-line-no">763</span><span id="line.763">            counts = new int[width * ySections];</span>
<span class="source-line-no">764</span><span id="line.764">            tallied = false;</span>
<span class="source-line-no">765</span><span id="line.765">            return this;</span>
<span class="source-line-no">766</span><span id="line.766">        }</span>
<span class="source-line-no">767</span><span id="line.767">    }</span>
<span class="source-line-no">768</span><span id="line.768"></span>
<span class="source-line-no">769</span><span id="line.769">    /**</span>
<span class="source-line-no">770</span><span id="line.770">     * Constructs this GreasedRegion using a double[][] that only stores two relevant states: an "on" state for values</span>
<span class="source-line-no">771</span><span id="line.771">     * between lowerBound (inclusive) and upperBound (exclusive), and an "off" state for anything else. This variant</span>
<span class="source-line-no">772</span><span id="line.772">     * scales the input so each "on" position in map produces a 2x2 on area if scale is 2, a 3x3 area if scale is 3, and</span>
<span class="source-line-no">773</span><span id="line.773">     * so on.</span>
<span class="source-line-no">774</span><span id="line.774">     * @param map a double[][]; depending on scale, the GreasedRegion may have different width and height</span>
<span class="source-line-no">775</span><span id="line.775">     * @param lowerBound lower inclusive; any double lower than this will be off, any equal to or greater than this,</span>
<span class="source-line-no">776</span><span id="line.776">     *                   but less than upper, will be on</span>
<span class="source-line-no">777</span><span id="line.777">     * @param upperBound upper exclusive; any double greater than or equal to this this will be off, any doubles both</span>
<span class="source-line-no">778</span><span id="line.778">     *                   less than this and equal to or greater than lower will be on</span>
<span class="source-line-no">779</span><span id="line.779">     * @param scale      the size of the square of cells in this that each "on" value in map will correspond to</span>
<span class="source-line-no">780</span><span id="line.780">     */</span>
<span class="source-line-no">781</span><span id="line.781">    public GreasedRegion(final double[][] map, final double lowerBound, final double upperBound, int scale)</span>
<span class="source-line-no">782</span><span id="line.782">    {</span>
<span class="source-line-no">783</span><span id="line.783">        scale = Math.min(63, Math.max(1, scale));</span>
<span class="source-line-no">784</span><span id="line.784">        int baseWidth = map.length, baseHeight = map[0].length;</span>
<span class="source-line-no">785</span><span id="line.785">        width =  baseWidth * scale;</span>
<span class="source-line-no">786</span><span id="line.786">        height = baseHeight * scale;</span>
<span class="source-line-no">787</span><span id="line.787">        ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">788</span><span id="line.788">        yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">789</span><span id="line.789">        data = new long[width * ySections];</span>
<span class="source-line-no">790</span><span id="line.790">        long shape = (1L &lt;&lt; scale) - 1L, leftover;</span>
<span class="source-line-no">791</span><span id="line.791">        for (int bx = 0, x = 0; bx &lt; baseWidth; bx++, x += scale) {</span>
<span class="source-line-no">792</span><span id="line.792">            for (int by = 0, y = 0; by &lt; baseHeight; by++, y += scale) {</span>
<span class="source-line-no">793</span><span id="line.793">                if(map[bx][by] &gt;= lowerBound &amp;&amp; map[bx][by] &lt; upperBound) {</span>
<span class="source-line-no">794</span><span id="line.794">                    for (int i = 0; i &lt; scale; i++) {</span>
<span class="source-line-no">795</span><span id="line.795">                        data[(x + i) * ySections + (y &gt;&gt; 6)] |= shape &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">796</span><span id="line.796">                        if((leftover = (y + scale - 1 &amp; 63) + 1) &lt; (y &amp; 63) + 1 &amp;&amp; (y + leftover &gt;&gt; 6) &lt; ySections)</span>
<span class="source-line-no">797</span><span id="line.797">                        {</span>
<span class="source-line-no">798</span><span id="line.798">                            data[(x + i) * ySections + (y &gt;&gt; 6) + 1] |= (1L &lt;&lt; leftover) - 1L;</span>
<span class="source-line-no">799</span><span id="line.799">                        }</span>
<span class="source-line-no">800</span><span id="line.800">                    }</span>
<span class="source-line-no">801</span><span id="line.801">                }</span>
<span class="source-line-no">802</span><span id="line.802">            }</span>
<span class="source-line-no">803</span><span id="line.803">        }</span>
<span class="source-line-no">804</span><span id="line.804">        counts = new int[width * ySections];</span>
<span class="source-line-no">805</span><span id="line.805">        tallied = false;</span>
<span class="source-line-no">806</span><span id="line.806">    }</span>
<span class="source-line-no">807</span><span id="line.807">    /**</span>
<span class="source-line-no">808</span><span id="line.808">     * Reassigns this GreasedRegion with the given rectangular double array, reusing the current data storage (without</span>
<span class="source-line-no">809</span><span id="line.809">     * extra allocations) if {@code this.width == map.length * scale &amp;&amp; this.height == map[0].length * scale}. The</span>
<span class="source-line-no">810</span><span id="line.810">     * current values stored in this are always cleared, then cells are treated as on if they are greater than or equal</span>
<span class="source-line-no">811</span><span id="line.811">     * to lower and less than upper, or off otherwise, before considering scaling. This variant scales the input so each</span>
<span class="source-line-no">812</span><span id="line.812">     * "on" position in map produces a 2x2 on area if scale is 2, a 3x3 area if scale is 3, and so on.</span>
<span class="source-line-no">813</span><span id="line.813">     * @param map a double[][]; depending on scale, the GreasedRegion may have different width and height</span>
<span class="source-line-no">814</span><span id="line.814">     * @param lowerBound lower inclusive; any double lower than this will be off, any equal to or greater than this,</span>
<span class="source-line-no">815</span><span id="line.815">     *                   but less than upper, will be on</span>
<span class="source-line-no">816</span><span id="line.816">     * @param upperBound upper exclusive; any double greater than or equal to this this will be off, any doubles both</span>
<span class="source-line-no">817</span><span id="line.817">     *                   less than this and equal to or greater than lower will be on</span>
<span class="source-line-no">818</span><span id="line.818">     * @param scale      the size of the square of cells in this that each "on" value in map will correspond to</span>
<span class="source-line-no">819</span><span id="line.819">     * @return this for chaining</span>
<span class="source-line-no">820</span><span id="line.820">     */</span>
<span class="source-line-no">821</span><span id="line.821">    public GreasedRegion refill(final double[][] map, final double lowerBound, final double upperBound, int scale) {</span>
<span class="source-line-no">822</span><span id="line.822">        scale = Math.min(63, Math.max(1, scale));</span>
<span class="source-line-no">823</span><span id="line.823">        if (map != null &amp;&amp; map.length &gt; 0 &amp;&amp; width == map.length * scale &amp;&amp; height == map[0].length * scale) {</span>
<span class="source-line-no">824</span><span id="line.824">            Arrays.fill(data, 0L);</span>
<span class="source-line-no">825</span><span id="line.825">            double[] column;</span>
<span class="source-line-no">826</span><span id="line.826">            int baseWidth = map.length, baseHeight = map[0].length;</span>
<span class="source-line-no">827</span><span id="line.827">            long shape = (1L &lt;&lt; scale) - 1L, leftover;</span>
<span class="source-line-no">828</span><span id="line.828">            for (int bx = 0, x = 0; bx &lt; baseWidth; bx++, x += scale) {</span>
<span class="source-line-no">829</span><span id="line.829">                column = map[bx];</span>
<span class="source-line-no">830</span><span id="line.830">                for (int by = 0, y = 0; by &lt; baseHeight; by++, y += scale) {</span>
<span class="source-line-no">831</span><span id="line.831">                    if(column[by] &gt;= lowerBound &amp;&amp; column[by] &lt; upperBound) {</span>
<span class="source-line-no">832</span><span id="line.832">                        for (int i = 0; i &lt; scale; i++) {</span>
<span class="source-line-no">833</span><span id="line.833">                            data[(x + i) * ySections + (y &gt;&gt; 6)] |= shape &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">834</span><span id="line.834">                            if((leftover = (y + scale - 1 &amp; 63) + 1) &lt; (y &amp; 63) + 1 &amp;&amp; (y + leftover &gt;&gt; 6) &lt; ySections)</span>
<span class="source-line-no">835</span><span id="line.835">                            {</span>
<span class="source-line-no">836</span><span id="line.836">                                data[(x + i) * ySections + (y &gt;&gt; 6) + 1] |= (1L &lt;&lt; leftover) - 1L;</span>
<span class="source-line-no">837</span><span id="line.837">                            }</span>
<span class="source-line-no">838</span><span id="line.838">                        }</span>
<span class="source-line-no">839</span><span id="line.839">                    }</span>
<span class="source-line-no">840</span><span id="line.840">                }</span>
<span class="source-line-no">841</span><span id="line.841">            }</span>
<span class="source-line-no">842</span><span id="line.842">            tallied = false;</span>
<span class="source-line-no">843</span><span id="line.843">            return this;</span>
<span class="source-line-no">844</span><span id="line.844">        } else {</span>
<span class="source-line-no">845</span><span id="line.845">            int baseWidth = (map == null) ? 0 : map.length,</span>
<span class="source-line-no">846</span><span id="line.846">                    baseHeight = (map == null || map.length &lt;= 0) ? 0 : map[0].length;</span>
<span class="source-line-no">847</span><span id="line.847">            width =  baseWidth * scale;</span>
<span class="source-line-no">848</span><span id="line.848">            height = baseHeight * scale;</span>
<span class="source-line-no">849</span><span id="line.849">            ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">850</span><span id="line.850">            yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">851</span><span id="line.851">            data = new long[width * ySections];</span>
<span class="source-line-no">852</span><span id="line.852">            long shape = (1L &lt;&lt; scale) - 1L, leftover;</span>
<span class="source-line-no">853</span><span id="line.853">            for (int bx = 0, x = 0; bx &lt; baseWidth; bx++, x += scale) {</span>
<span class="source-line-no">854</span><span id="line.854">                for (int by = 0, y = 0; by &lt; baseHeight; by++, y += scale) {</span>
<span class="source-line-no">855</span><span id="line.855">                    if(map[bx][by] &gt;= lowerBound &amp;&amp; map[bx][by] &lt; upperBound) {</span>
<span class="source-line-no">856</span><span id="line.856">                        for (int i = 0; i &lt; scale; i++) {</span>
<span class="source-line-no">857</span><span id="line.857">                            data[(x + i) * ySections + (y &gt;&gt; 6)] |= shape &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">858</span><span id="line.858">                            if((leftover = (y + scale - 1 &amp; 63)) &lt; y &amp;&amp; y &lt; height - leftover)</span>
<span class="source-line-no">859</span><span id="line.859">                            {</span>
<span class="source-line-no">860</span><span id="line.860">                                data[(x + i) * ySections + (y &gt;&gt; 6) + 1] |= (1L &lt;&lt; leftover) - 1L;</span>
<span class="source-line-no">861</span><span id="line.861">                            }</span>
<span class="source-line-no">862</span><span id="line.862">                        }</span>
<span class="source-line-no">863</span><span id="line.863">                    }</span>
<span class="source-line-no">864</span><span id="line.864">                }</span>
<span class="source-line-no">865</span><span id="line.865">            }</span>
<span class="source-line-no">866</span><span id="line.866">            counts = new int[width * ySections];</span>
<span class="source-line-no">867</span><span id="line.867">            tallied = false;</span>
<span class="source-line-no">868</span><span id="line.868">            return this;</span>
<span class="source-line-no">869</span><span id="line.869">        }</span>
<span class="source-line-no">870</span><span id="line.870">    }</span>
<span class="source-line-no">871</span><span id="line.871"></span>
<span class="source-line-no">872</span><span id="line.872">    /**</span>
<span class="source-line-no">873</span><span id="line.873">     * Constructs a GreasedRegion with the given 1D boolean array, with the given width and height, where an [x][y]</span>
<span class="source-line-no">874</span><span id="line.874">     * position is obtained from bits given an index n with x = n / height, y = n % height, any value of true</span>
<span class="source-line-no">875</span><span id="line.875">     * considered "on", and any value of false considered "off."</span>
<span class="source-line-no">876</span><span id="line.876">     * @param bits a 1D boolean array where true is on and false is off</span>
<span class="source-line-no">877</span><span id="line.877">     * @param width the width of the desired GreasedRegion; width * height should equal bits.length</span>
<span class="source-line-no">878</span><span id="line.878">     * @param height the height of the desired GreasedRegion; width * height should equal bits.length</span>
<span class="source-line-no">879</span><span id="line.879">     */</span>
<span class="source-line-no">880</span><span id="line.880">    public GreasedRegion(final boolean[] bits, final int width, final int height)</span>
<span class="source-line-no">881</span><span id="line.881">    {</span>
<span class="source-line-no">882</span><span id="line.882">        this.width = width;</span>
<span class="source-line-no">883</span><span id="line.883">        this.height = height;</span>
<span class="source-line-no">884</span><span id="line.884">        ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">885</span><span id="line.885">        yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">886</span><span id="line.886">        data = new long[width * ySections];</span>
<span class="source-line-no">887</span><span id="line.887">        for (int a = 0, x = 0, y = 0; a &lt; bits.length; a++, x = a / height, y = a % height) {</span>
<span class="source-line-no">888</span><span id="line.888">            if(bits[a]) data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">889</span><span id="line.889">        }</span>
<span class="source-line-no">890</span><span id="line.890">        counts = new int[width * ySections];</span>
<span class="source-line-no">891</span><span id="line.891">        tallied = false;</span>
<span class="source-line-no">892</span><span id="line.892">    }</span>
<span class="source-line-no">893</span><span id="line.893">    /**</span>
<span class="source-line-no">894</span><span id="line.894">     * Reassigns this GreasedRegion with the given 1D boolean array, reusing the current data storage (without</span>
<span class="source-line-no">895</span><span id="line.895">     * extra allocations) if this.width == width and this.height == height, where an [x][y]</span>
<span class="source-line-no">896</span><span id="line.896">     * position is obtained from bits given an index n with x = n / height, y = n % height, any value of true</span>
<span class="source-line-no">897</span><span id="line.897">     * considered "on", and any value of false considered "off."</span>
<span class="source-line-no">898</span><span id="line.898">     * @param bits a 1D boolean array where true is on and false is off</span>
<span class="source-line-no">899</span><span id="line.899">     * @param width the width of the desired GreasedRegion; width * height should equal bits.length</span>
<span class="source-line-no">900</span><span id="line.900">     * @param height the height of the desired GreasedRegion; width * height should equal bits.length</span>
<span class="source-line-no">901</span><span id="line.901">     * @return this for chaining</span>
<span class="source-line-no">902</span><span id="line.902">     */</span>
<span class="source-line-no">903</span><span id="line.903">    public GreasedRegion refill(final boolean[] bits, final int width, final int height) {</span>
<span class="source-line-no">904</span><span id="line.904">        if (bits != null &amp;&amp; this.width == width &amp;&amp; this.height == height) {</span>
<span class="source-line-no">905</span><span id="line.905">            Arrays.fill(data, 0L);</span>
<span class="source-line-no">906</span><span id="line.906">            for (int a = 0, x = 0, y = 0; a &lt; bits.length; a++, x = a / height, y = a % height) {</span>
<span class="source-line-no">907</span><span id="line.907">                data[x * ySections + (y &gt;&gt; 6)] |= (bits[a] ? 1L : 0L) &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">908</span><span id="line.908">            }</span>
<span class="source-line-no">909</span><span id="line.909">            tallied = false;</span>
<span class="source-line-no">910</span><span id="line.910">            return this;</span>
<span class="source-line-no">911</span><span id="line.911">        } else {</span>
<span class="source-line-no">912</span><span id="line.912">            this.width = (bits == null || width &lt; 0) ? 0 : width;</span>
<span class="source-line-no">913</span><span id="line.913">            this.height = (bits == null || bits.length &lt;= 0 || height &lt; 0) ? 0 : height;</span>
<span class="source-line-no">914</span><span id="line.914">            ySections = (this.height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">915</span><span id="line.915">            yEndMask = -1L &gt;&gt;&gt; (64 - (this.height &amp; 63));</span>
<span class="source-line-no">916</span><span id="line.916">            data = new long[this.width * ySections];</span>
<span class="source-line-no">917</span><span id="line.917">            if(bits != null) {</span>
<span class="source-line-no">918</span><span id="line.918">                for (int a = 0, x = 0, y = 0; a &lt; bits.length; a++, x = a / this.height, y = a % this.height) {</span>
<span class="source-line-no">919</span><span id="line.919">                    if (bits[a]) data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">920</span><span id="line.920">                }</span>
<span class="source-line-no">921</span><span id="line.921">            }</span>
<span class="source-line-no">922</span><span id="line.922">            counts = new int[width * ySections];</span>
<span class="source-line-no">923</span><span id="line.923">            tallied = false;</span>
<span class="source-line-no">924</span><span id="line.924">            return this;</span>
<span class="source-line-no">925</span><span id="line.925">        }</span>
<span class="source-line-no">926</span><span id="line.926">    }</span>
<span class="source-line-no">927</span><span id="line.927"></span>
<span class="source-line-no">928</span><span id="line.928">    /**</span>
<span class="source-line-no">929</span><span id="line.929">     * Constructor for an empty GreasedRegion of the given width and height.</span>
<span class="source-line-no">930</span><span id="line.930">     * GreasedRegions are mutable, so you can add to this with insert() or insertSeveral(), among others.</span>
<span class="source-line-no">931</span><span id="line.931">     * @param width the maximum width for the GreasedRegion</span>
<span class="source-line-no">932</span><span id="line.932">     * @param height the maximum height for the GreasedRegion</span>
<span class="source-line-no">933</span><span id="line.933">     */</span>
<span class="source-line-no">934</span><span id="line.934">    public GreasedRegion(final int width, final int height)</span>
<span class="source-line-no">935</span><span id="line.935">    {</span>
<span class="source-line-no">936</span><span id="line.936">        this.width = width;</span>
<span class="source-line-no">937</span><span id="line.937">        this.height = height;</span>
<span class="source-line-no">938</span><span id="line.938">        ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">939</span><span id="line.939">        yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">940</span><span id="line.940">        data = new long[width * ySections];</span>
<span class="source-line-no">941</span><span id="line.941">        counts = new int[width  * ySections];</span>
<span class="source-line-no">942</span><span id="line.942">        ct = 0;</span>
<span class="source-line-no">943</span><span id="line.943">        tallied = true;</span>
<span class="source-line-no">944</span><span id="line.944">    }</span>
<span class="source-line-no">945</span><span id="line.945"></span>
<span class="source-line-no">946</span><span id="line.946">    /**</span>
<span class="source-line-no">947</span><span id="line.947">     * If this GreasedRegion has the same width and height passed as parameters, this acts the same as {@link #empty()},</span>
<span class="source-line-no">948</span><span id="line.948">     * makes no allocations, and returns this GreasedRegion with its contents all "off"; otherwise, this does allocate</span>
<span class="source-line-no">949</span><span id="line.949">     * a differently-sized amount of internal data to match the new width and height, sets the fields to all match the</span>
<span class="source-line-no">950</span><span id="line.950">     * new width and height, and returns this GreasedRegion with its new width and height, with all contents "off". This</span>
<span class="source-line-no">951</span><span id="line.951">     * is meant for cases where a GreasedRegion may be reused effectively, but its size may not always be the same.</span>
<span class="source-line-no">952</span><span id="line.952">     * @param width the width to potentially resize this GreasedRegion to</span>
<span class="source-line-no">953</span><span id="line.953">     * @param height the height to potentially resize this GreasedRegion to</span>
<span class="source-line-no">954</span><span id="line.954">     * @return this GreasedRegion, always with all contents "off", and with the height and width set.</span>
<span class="source-line-no">955</span><span id="line.955">     */</span>
<span class="source-line-no">956</span><span id="line.956">    public GreasedRegion resizeAndEmpty(final int width, final int height) {</span>
<span class="source-line-no">957</span><span id="line.957">        if (width == this.width &amp;&amp; height == this.height) {</span>
<span class="source-line-no">958</span><span id="line.958">            Arrays.fill(data, 0L);</span>
<span class="source-line-no">959</span><span id="line.959">            Arrays.fill(counts, 0);</span>
<span class="source-line-no">960</span><span id="line.960">            ct = 0;</span>
<span class="source-line-no">961</span><span id="line.961">            tallied = true;</span>
<span class="source-line-no">962</span><span id="line.962">        } else {</span>
<span class="source-line-no">963</span><span id="line.963">            this.width = Math.max(width, 0);</span>
<span class="source-line-no">964</span><span id="line.964">            this.height = Math.max(height, 0);</span>
<span class="source-line-no">965</span><span id="line.965">            ySections = (this.height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">966</span><span id="line.966">            yEndMask = -1L &gt;&gt;&gt; (64 - (this.height &amp; 63));</span>
<span class="source-line-no">967</span><span id="line.967">            data = new long[this.width * ySections];</span>
<span class="source-line-no">968</span><span id="line.968">            counts = new int[this.width * ySections];</span>
<span class="source-line-no">969</span><span id="line.969">            ct = 0;</span>
<span class="source-line-no">970</span><span id="line.970">            tallied = true;</span>
<span class="source-line-no">971</span><span id="line.971">        }</span>
<span class="source-line-no">972</span><span id="line.972">        return this;</span>
<span class="source-line-no">973</span><span id="line.973"></span>
<span class="source-line-no">974</span><span id="line.974">    }</span>
<span class="source-line-no">975</span><span id="line.975"></span>
<span class="source-line-no">976</span><span id="line.976">    /**</span>
<span class="source-line-no">977</span><span id="line.977">     * Constructor for a GreasedRegion that contains a single "on" cell, and has the given width and height.</span>
<span class="source-line-no">978</span><span id="line.978">     * Note that to avoid confusion with the constructor that takes multiple Coord values, this takes the single "on"</span>
<span class="source-line-no">979</span><span id="line.979">     * Coord first, while the multiple-Coord constructor takes its vararg or array of Coords last.</span>
<span class="source-line-no">980</span><span id="line.980">     * @param single the one (x,y) point to store as "on" in this GreasedRegion</span>
<span class="source-line-no">981</span><span id="line.981">     * @param width the maximum width for the GreasedRegion</span>
<span class="source-line-no">982</span><span id="line.982">     * @param height the maximum height for the GreasedRegion</span>
<span class="source-line-no">983</span><span id="line.983">     */</span>
<span class="source-line-no">984</span><span id="line.984">    public GreasedRegion(final Coord single, final int width, final int height)</span>
<span class="source-line-no">985</span><span id="line.985">    {</span>
<span class="source-line-no">986</span><span id="line.986">        this.width = width;</span>
<span class="source-line-no">987</span><span id="line.987">        this.height = height;</span>
<span class="source-line-no">988</span><span id="line.988">        ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">989</span><span id="line.989">        yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">990</span><span id="line.990">        data = new long[width * ySections];</span>
<span class="source-line-no">991</span><span id="line.991">        counts = new int[width * ySections];</span>
<span class="source-line-no">992</span><span id="line.992">        if(single.x &lt; width &amp;&amp; single.y &lt; height &amp;&amp; single.x &gt;= 0 &amp;&amp; single.y &gt;= 0)</span>
<span class="source-line-no">993</span><span id="line.993">        {</span>
<span class="source-line-no">994</span><span id="line.994">            data[ct = single.x * ySections + (single.y &gt;&gt; 6)] |= 1L &lt;&lt; (single.y &amp; 63);</span>
<span class="source-line-no">995</span><span id="line.995">            counts[ct] = 1;</span>
<span class="source-line-no">996</span><span id="line.996">            ct = 1;</span>
<span class="source-line-no">997</span><span id="line.997">            tallied = true;</span>
<span class="source-line-no">998</span><span id="line.998">        }</span>
<span class="source-line-no">999</span><span id="line.999">        else</span>
<span class="source-line-no">1000</span><span id="line.1000">        {</span>
<span class="source-line-no">1001</span><span id="line.1001">            ct = 0;</span>
<span class="source-line-no">1002</span><span id="line.1002">            tallied = true;</span>
<span class="source-line-no">1003</span><span id="line.1003">        }</span>
<span class="source-line-no">1004</span><span id="line.1004">    }</span>
<span class="source-line-no">1005</span><span id="line.1005"></span>
<span class="source-line-no">1006</span><span id="line.1006">    /**</span>
<span class="source-line-no">1007</span><span id="line.1007">     * Constructor for a GreasedRegion that can have several "on" cells specified, and has the given width and height.</span>
<span class="source-line-no">1008</span><span id="line.1008">     * Note that to avoid confusion with the constructor that takes one Coord value, this takes the vararg or array of</span>
<span class="source-line-no">1009</span><span id="line.1009">     * Coords last, while the single-Coord constructor takes its one Coord first.</span>
<span class="source-line-no">1010</span><span id="line.1010">     * @param width the maximum width for the GreasedRegion</span>
<span class="source-line-no">1011</span><span id="line.1011">     * @param height the maximum height for the GreasedRegion</span>
<span class="source-line-no">1012</span><span id="line.1012">     * @param points an array or vararg of Coord to store as "on" in this GreasedRegion</span>
<span class="source-line-no">1013</span><span id="line.1013">     */</span>
<span class="source-line-no">1014</span><span id="line.1014">    public GreasedRegion(final int width, final  int height, final Coord... points)</span>
<span class="source-line-no">1015</span><span id="line.1015">    {</span>
<span class="source-line-no">1016</span><span id="line.1016">        this.width = width;</span>
<span class="source-line-no">1017</span><span id="line.1017">        this.height = height;</span>
<span class="source-line-no">1018</span><span id="line.1018">        ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">1019</span><span id="line.1019">        yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">1020</span><span id="line.1020">        data = new long[width * ySections];</span>
<span class="source-line-no">1021</span><span id="line.1021">        if(points != null)</span>
<span class="source-line-no">1022</span><span id="line.1022">        {</span>
<span class="source-line-no">1023</span><span id="line.1023">            for (int i = 0, x, y; i &lt; points.length; i++) {</span>
<span class="source-line-no">1024</span><span id="line.1024">                x = points[i].x;</span>
<span class="source-line-no">1025</span><span id="line.1025">                y = points[i].y;</span>
<span class="source-line-no">1026</span><span id="line.1026">                if(x &lt; width &amp;&amp; y &lt; height &amp;&amp; x &gt;= 0 &amp;&amp; y &gt;= 0)</span>
<span class="source-line-no">1027</span><span id="line.1027">                    data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">1028</span><span id="line.1028">            }</span>
<span class="source-line-no">1029</span><span id="line.1029">        }</span>
<span class="source-line-no">1030</span><span id="line.1030">        counts = new int[width * ySections];</span>
<span class="source-line-no">1031</span><span id="line.1031">        tallied = false;</span>
<span class="source-line-no">1032</span><span id="line.1032">    }</span>
<span class="source-line-no">1033</span><span id="line.1033"></span>
<span class="source-line-no">1034</span><span id="line.1034">    /**</span>
<span class="source-line-no">1035</span><span id="line.1035">     * Constructor for a GreasedRegion that can have several "on" cells specified, and has the given width and height.</span>
<span class="source-line-no">1036</span><span id="line.1036">     * Note that to avoid confusion with the constructor that takes one Coord value, this takes the Iterable of</span>
<span class="source-line-no">1037</span><span id="line.1037">     * Coords last, while the single-Coord constructor takes its one Coord first.</span>
<span class="source-line-no">1038</span><span id="line.1038">     * @param width the maximum width for the GreasedRegion</span>
<span class="source-line-no">1039</span><span id="line.1039">     * @param height the maximum height for the GreasedRegion</span>
<span class="source-line-no">1040</span><span id="line.1040">     * @param points an array or vararg of Coord to store as "on" in this GreasedRegion</span>
<span class="source-line-no">1041</span><span id="line.1041">     */</span>
<span class="source-line-no">1042</span><span id="line.1042">    public GreasedRegion(final int width, final int height, final Iterable&lt;Coord&gt; points)</span>
<span class="source-line-no">1043</span><span id="line.1043">    {</span>
<span class="source-line-no">1044</span><span id="line.1044">        this.width = width;</span>
<span class="source-line-no">1045</span><span id="line.1045">        this.height = height;</span>
<span class="source-line-no">1046</span><span id="line.1046">        ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">1047</span><span id="line.1047">        yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">1048</span><span id="line.1048">        data = new long[width * ySections];</span>
<span class="source-line-no">1049</span><span id="line.1049">        if(points != null) {</span>
<span class="source-line-no">1050</span><span id="line.1050">            int x, y;</span>
<span class="source-line-no">1051</span><span id="line.1051">            for (Coord c : points) {</span>
<span class="source-line-no">1052</span><span id="line.1052">                x = c.x;</span>
<span class="source-line-no">1053</span><span id="line.1053">                y = c.y;</span>
<span class="source-line-no">1054</span><span id="line.1054">                if (x &lt; width &amp;&amp; y &lt; height &amp;&amp; x &gt;= 0 &amp;&amp; y &gt;= 0)</span>
<span class="source-line-no">1055</span><span id="line.1055">                    data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">1056</span><span id="line.1056">            }</span>
<span class="source-line-no">1057</span><span id="line.1057">        }</span>
<span class="source-line-no">1058</span><span id="line.1058">        counts = new int[width * ySections];</span>
<span class="source-line-no">1059</span><span id="line.1059">        tallied = false;</span>
<span class="source-line-no">1060</span><span id="line.1060"></span>
<span class="source-line-no">1061</span><span id="line.1061">    }</span>
<span class="source-line-no">1062</span><span id="line.1062"></span>
<span class="source-line-no">1063</span><span id="line.1063">    /**</span>
<span class="source-line-no">1064</span><span id="line.1064">     * Constructor for a random GreasedRegion of the given width and height, typically assigning approximately half of</span>
<span class="source-line-no">1065</span><span id="line.1065">     * the cells in this to "on" and the rest to off. A RandomnessSource can be slightly more efficient than an RNG when</span>
<span class="source-line-no">1066</span><span id="line.1066">     * you're making a lot of calls on it.</span>
<span class="source-line-no">1067</span><span id="line.1067">     * @param random a RandomnessSource that should have a good nextLong() method; DiverRNG is excellent but Lathe32RNG is faster on GWT (only there) </span>
<span class="source-line-no">1068</span><span id="line.1068">     * @param width the maximum width for the GreasedRegion</span>
<span class="source-line-no">1069</span><span id="line.1069">     * @param height the maximum height for the GreasedRegion</span>
<span class="source-line-no">1070</span><span id="line.1070">     */</span>
<span class="source-line-no">1071</span><span id="line.1071">    public GreasedRegion(final RandomnessSource random, final int width, final int height)</span>
<span class="source-line-no">1072</span><span id="line.1072">    {</span>
<span class="source-line-no">1073</span><span id="line.1073">        this.width = width;</span>
<span class="source-line-no">1074</span><span id="line.1074">        this.height = height;</span>
<span class="source-line-no">1075</span><span id="line.1075">        ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">1076</span><span id="line.1076">        yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">1077</span><span id="line.1077">        data = new long[width * ySections];</span>
<span class="source-line-no">1078</span><span id="line.1078">        for (int i = 0; i &lt; width * ySections; i++) {</span>
<span class="source-line-no">1079</span><span id="line.1079">            data[i] = random.nextLong();</span>
<span class="source-line-no">1080</span><span id="line.1080">        }</span>
<span class="source-line-no">1081</span><span id="line.1081">        if(ySections &gt; 0 &amp;&amp; yEndMask != -1) {</span>
<span class="source-line-no">1082</span><span id="line.1082">            for (int a = ySections - 1; a &lt; data.length; a += ySections) {</span>
<span class="source-line-no">1083</span><span id="line.1083">                data[a] &amp;= yEndMask;</span>
<span class="source-line-no">1084</span><span id="line.1084">            }</span>
<span class="source-line-no">1085</span><span id="line.1085">        }</span>
<span class="source-line-no">1086</span><span id="line.1086">        counts = new int[width * ySections];</span>
<span class="source-line-no">1087</span><span id="line.1087">        tallied = false;</span>
<span class="source-line-no">1088</span><span id="line.1088">    }</span>
<span class="source-line-no">1089</span><span id="line.1089">    /**</span>
<span class="source-line-no">1090</span><span id="line.1090">     * Reassigns this GreasedRegion by filling it with random values from random, reusing the current data storage</span>
<span class="source-line-no">1091</span><span id="line.1091">     * (without extra allocations) if this.width == width and this.height == height, and typically assigning</span>
<span class="source-line-no">1092</span><span id="line.1092">     * approximately half of the cells in this to "on" and the rest to off. A RandomnessSource can be slightly more</span>
<span class="source-line-no">1093</span><span id="line.1093">     * efficient than an RNG when you're making a lot of calls on it.</span>
<span class="source-line-no">1094</span><span id="line.1094">     * @param random a RandomnessSource that should have a good nextLong() method; DiverRNG is excellent but Lathe32RNG is faster on GWT (only there) </span>
<span class="source-line-no">1095</span><span id="line.1095">     * @param width the width of the desired GreasedRegion</span>
<span class="source-line-no">1096</span><span id="line.1096">     * @param height the height of the desired GreasedRegion</span>
<span class="source-line-no">1097</span><span id="line.1097">     * @return this for chaining</span>
<span class="source-line-no">1098</span><span id="line.1098">     */</span>
<span class="source-line-no">1099</span><span id="line.1099">    public GreasedRegion refill(final RandomnessSource random, final int width, final int height) {</span>
<span class="source-line-no">1100</span><span id="line.1100">        if (random != null){</span>
<span class="source-line-no">1101</span><span id="line.1101">            if(this.width == width &amp;&amp; this.height == height) {</span>
<span class="source-line-no">1102</span><span id="line.1102">                for (int i = 0; i &lt; width * ySections; i++) {</span>
<span class="source-line-no">1103</span><span id="line.1103">                    data[i] = random.nextLong();</span>
<span class="source-line-no">1104</span><span id="line.1104">                }</span>
<span class="source-line-no">1105</span><span id="line.1105">            } else {</span>
<span class="source-line-no">1106</span><span id="line.1106">                this.width = Math.max(width, 0);</span>
<span class="source-line-no">1107</span><span id="line.1107">                this.height = Math.max(height, 0);</span>
<span class="source-line-no">1108</span><span id="line.1108">                ySections = (this.height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">1109</span><span id="line.1109">                yEndMask = -1L &gt;&gt;&gt; (64 - (this.height &amp; 63));</span>
<span class="source-line-no">1110</span><span id="line.1110">                data = new long[this.width * ySections];</span>
<span class="source-line-no">1111</span><span id="line.1111">                for (int i = 0; i &lt; this.width * ySections; i++) {</span>
<span class="source-line-no">1112</span><span id="line.1112">                    data[i] = random.nextLong();</span>
<span class="source-line-no">1113</span><span id="line.1113">                }</span>
<span class="source-line-no">1114</span><span id="line.1114">                counts = new int[this.width * ySections];</span>
<span class="source-line-no">1115</span><span id="line.1115">            }</span>
<span class="source-line-no">1116</span><span id="line.1116">            if(ySections &gt; 0 &amp;&amp; yEndMask != -1) {</span>
<span class="source-line-no">1117</span><span id="line.1117">                for (int a = ySections - 1; a &lt; data.length; a += ySections) {</span>
<span class="source-line-no">1118</span><span id="line.1118">                    data[a] &amp;= yEndMask;</span>
<span class="source-line-no">1119</span><span id="line.1119">                }</span>
<span class="source-line-no">1120</span><span id="line.1120">            }</span>
<span class="source-line-no">1121</span><span id="line.1121">            tallied = false;</span>
<span class="source-line-no">1122</span><span id="line.1122">        }</span>
<span class="source-line-no">1123</span><span id="line.1123">        return this;</span>
<span class="source-line-no">1124</span><span id="line.1124">    }</span>
<span class="source-line-no">1125</span><span id="line.1125"></span>
<span class="source-line-no">1126</span><span id="line.1126">    /**</span>
<span class="source-line-no">1127</span><span id="line.1127">     * Constructor for a random GreasedRegion of the given width and height, typically assigning approximately half of</span>
<span class="source-line-no">1128</span><span id="line.1128">     * the cells in this to "on" and the rest to off. A RandomnessSource can be slightly more efficient than an RNG when</span>
<span class="source-line-no">1129</span><span id="line.1129">     * you're making a lot of calls on it, so you may prefer {@link #GreasedRegion(RandomnessSource, int, int)}.</span>
<span class="source-line-no">1130</span><span id="line.1130">     * @param random an IRNG, such as an RNG, that this will use to generate its contents</span>
<span class="source-line-no">1131</span><span id="line.1131">     * @param width the maximum width for the GreasedRegion</span>
<span class="source-line-no">1132</span><span id="line.1132">     * @param height the maximum height for the GreasedRegion</span>
<span class="source-line-no">1133</span><span id="line.1133">     */</span>
<span class="source-line-no">1134</span><span id="line.1134">    public GreasedRegion(final IRNG random, final int width, final int height)</span>
<span class="source-line-no">1135</span><span id="line.1135">    {</span>
<span class="source-line-no">1136</span><span id="line.1136">        this.width = width;</span>
<span class="source-line-no">1137</span><span id="line.1137">        this.height = height;</span>
<span class="source-line-no">1138</span><span id="line.1138">        ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">1139</span><span id="line.1139">        yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">1140</span><span id="line.1140">        data = new long[width * ySections];</span>
<span class="source-line-no">1141</span><span id="line.1141">        for (int i = 0; i &lt; width * ySections; i++) {</span>
<span class="source-line-no">1142</span><span id="line.1142">            data[i] = random.nextLong();</span>
<span class="source-line-no">1143</span><span id="line.1143">        }</span>
<span class="source-line-no">1144</span><span id="line.1144">        if(ySections &gt; 0 &amp;&amp; yEndMask != -1) {</span>
<span class="source-line-no">1145</span><span id="line.1145">            for (int a = ySections - 1; a &lt; data.length; a += ySections) {</span>
<span class="source-line-no">1146</span><span id="line.1146">                data[a] &amp;= yEndMask;</span>
<span class="source-line-no">1147</span><span id="line.1147">            }</span>
<span class="source-line-no">1148</span><span id="line.1148">        }</span>
<span class="source-line-no">1149</span><span id="line.1149">        counts = new int[width * ySections];</span>
<span class="source-line-no">1150</span><span id="line.1150">        tallied = false;</span>
<span class="source-line-no">1151</span><span id="line.1151">    }</span>
<span class="source-line-no">1152</span><span id="line.1152">    /**</span>
<span class="source-line-no">1153</span><span id="line.1153">     * Reassigns this GreasedRegion by filling it with random values from random, reusing the current data storage</span>
<span class="source-line-no">1154</span><span id="line.1154">     * (without extra allocations) if this.width == width and this.height == height, and typically assigning</span>
<span class="source-line-no">1155</span><span id="line.1155">     * approximately half of the cells in this to "on" and the rest to off.</span>
<span class="source-line-no">1156</span><span id="line.1156">     * @param random an IRNG that should have a good nextLong() method; an RNG constructed with the default RandomnessSource will be fine</span>
<span class="source-line-no">1157</span><span id="line.1157">     * @param width the width of the desired GreasedRegion</span>
<span class="source-line-no">1158</span><span id="line.1158">     * @param height the height of the desired GreasedRegion</span>
<span class="source-line-no">1159</span><span id="line.1159">     * @return this for chaining</span>
<span class="source-line-no">1160</span><span id="line.1160">     */</span>
<span class="source-line-no">1161</span><span id="line.1161">    public GreasedRegion refill(final IRNG random, final int width, final int height) {</span>
<span class="source-line-no">1162</span><span id="line.1162">        if (random != null){</span>
<span class="source-line-no">1163</span><span id="line.1163">            if(this.width == width &amp;&amp; this.height == height) {</span>
<span class="source-line-no">1164</span><span id="line.1164">                for (int i = 0; i &lt; width * ySections; i++) {</span>
<span class="source-line-no">1165</span><span id="line.1165">                    data[i] = random.nextLong();</span>
<span class="source-line-no">1166</span><span id="line.1166">                }</span>
<span class="source-line-no">1167</span><span id="line.1167">            } else {</span>
<span class="source-line-no">1168</span><span id="line.1168">                this.width = Math.max(width, 0);</span>
<span class="source-line-no">1169</span><span id="line.1169">                this.height = Math.max(height, 0);</span>
<span class="source-line-no">1170</span><span id="line.1170">                ySections = (this.height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">1171</span><span id="line.1171">                yEndMask = -1L &gt;&gt;&gt; (64 - (this.height &amp; 63));</span>
<span class="source-line-no">1172</span><span id="line.1172">                data = new long[this.width * ySections];</span>
<span class="source-line-no">1173</span><span id="line.1173">                for (int i = 0; i &lt; this.width * ySections; i++) {</span>
<span class="source-line-no">1174</span><span id="line.1174">                    data[i] = random.nextLong();</span>
<span class="source-line-no">1175</span><span id="line.1175">                }</span>
<span class="source-line-no">1176</span><span id="line.1176">                counts = new int[width * ySections];</span>
<span class="source-line-no">1177</span><span id="line.1177">            }</span>
<span class="source-line-no">1178</span><span id="line.1178">            if(ySections &gt; 0 &amp;&amp; yEndMask != -1) {</span>
<span class="source-line-no">1179</span><span id="line.1179">                for (int a = ySections - 1; a &lt; data.length; a += ySections) {</span>
<span class="source-line-no">1180</span><span id="line.1180">                    data[a] &amp;= yEndMask;</span>
<span class="source-line-no">1181</span><span id="line.1181">                }</span>
<span class="source-line-no">1182</span><span id="line.1182">            }</span>
<span class="source-line-no">1183</span><span id="line.1183">            tallied = false;</span>
<span class="source-line-no">1184</span><span id="line.1184">        }</span>
<span class="source-line-no">1185</span><span id="line.1185">        return this;</span>
<span class="source-line-no">1186</span><span id="line.1186">    }</span>
<span class="source-line-no">1187</span><span id="line.1187"></span>
<span class="source-line-no">1188</span><span id="line.1188">    /**</span>
<span class="source-line-no">1189</span><span id="line.1189">     * Constructor for a random GreasedRegion of the given width and height, trying to set the given fraction of cells</span>
<span class="source-line-no">1190</span><span id="line.1190">     * to on. Depending on the value of fraction, this makes between 0 and 6 calls to the nextLong() method of random's</span>
<span class="source-line-no">1191</span><span id="line.1191">     * internal RandomnessSource, per 64 cells of this GreasedRegion (if height is not a multiple of 64, round up to get</span>
<span class="source-line-no">1192</span><span id="line.1192">     * the number of calls this makes). As such, this sacrifices the precision of the fraction to obtain significantly</span>
<span class="source-line-no">1193</span><span id="line.1193">     * better speed than generating one random number per cell, although the precision is probably good enough (fraction</span>
<span class="source-line-no">1194</span><span id="line.1194">     * is effectively rounded down to the nearest multiple of 0.015625, and clamped between 0.0 and 1.0). The parameter</span>
<span class="source-line-no">1195</span><span id="line.1195">     * {@code random} can be an object like a {@link DiverRNG}, an {@link RNG} backed by a well-distributed</span>
<span class="source-line-no">1196</span><span id="line.1196">     * RandomnessSource like its default, DiverRNG, a {@link GWTRNG} (especially if you target GWT, where it will</span>
<span class="source-line-no">1197</span><span id="line.1197">     * perform much better than most alternatives), or any of various other RandomnessSource implementations that</span>
<span class="source-line-no">1198</span><span id="line.1198">     * distribute bits well for {@link RandomnessSource#nextLong()}, but should not be intentionally-biased RNGs like</span>
<span class="source-line-no">1199</span><span id="line.1199">     * {@link DharmaRNG} or {@link EditRNG}, nor double-based QRNGs like {@link VanDerCorputQRNG} or {@link SobolQRNG}.</span>
<span class="source-line-no">1200</span><span id="line.1200">     * @param random a RandomnessSource that should produce high-quality long values, like the defaults for {@link RNG}</span>
<span class="source-line-no">1201</span><span id="line.1201">     * @param fraction between 0.0 and 1.0 (clamped), only considering a precision of 1/64.0 (0.015625) between steps</span>
<span class="source-line-no">1202</span><span id="line.1202">     * @param width the maximum width for the GreasedRegion</span>
<span class="source-line-no">1203</span><span id="line.1203">     * @param height the maximum height for the GreasedRegion</span>
<span class="source-line-no">1204</span><span id="line.1204">     */</span>
<span class="source-line-no">1205</span><span id="line.1205">    public GreasedRegion(final RandomnessSource random, final double fraction, final int width, final int height)</span>
<span class="source-line-no">1206</span><span id="line.1206">    {</span>
<span class="source-line-no">1207</span><span id="line.1207">        this.width = width;</span>
<span class="source-line-no">1208</span><span id="line.1208">        this.height = height;</span>
<span class="source-line-no">1209</span><span id="line.1209">        int bitCount = (int) (fraction * 64);</span>
<span class="source-line-no">1210</span><span id="line.1210">        ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">1211</span><span id="line.1211">        yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">1212</span><span id="line.1212">        data = new long[width * ySections];</span>
<span class="source-line-no">1213</span><span id="line.1213">        for (int i = 0; i &lt; width * ySections; i++) {</span>
<span class="source-line-no">1214</span><span id="line.1214">            data[i] = approximateBits(random, bitCount);</span>
<span class="source-line-no">1215</span><span id="line.1215">        }</span>
<span class="source-line-no">1216</span><span id="line.1216">        if(ySections &gt; 0 &amp;&amp; yEndMask != -1) {</span>
<span class="source-line-no">1217</span><span id="line.1217">            for (int a = ySections - 1; a &lt; data.length; a += ySections) {</span>
<span class="source-line-no">1218</span><span id="line.1218">                data[a] &amp;= yEndMask;</span>
<span class="source-line-no">1219</span><span id="line.1219">            }</span>
<span class="source-line-no">1220</span><span id="line.1220">        }</span>
<span class="source-line-no">1221</span><span id="line.1221">        counts = new int[width * ySections];</span>
<span class="source-line-no">1222</span><span id="line.1222">        tallied = false;</span>
<span class="source-line-no">1223</span><span id="line.1223">    }</span>
<span class="source-line-no">1224</span><span id="line.1224">    /**</span>
<span class="source-line-no">1225</span><span id="line.1225">     * Reassigns this GreasedRegion randomly, reusing the current data storage (without extra allocations) if this.width</span>
<span class="source-line-no">1226</span><span id="line.1226">     * == width and this.height == height, while trying to set the given fraction of cells to on. Depending on the value</span>
<span class="source-line-no">1227</span><span id="line.1227">     * of fraction, this makes between 0 and 6 calls to the nextLong() method of random's internal RandomnessSource, per</span>
<span class="source-line-no">1228</span><span id="line.1228">     * 64 cells of this GreasedRegion (if height is not a multiple of 64, round up to get the number of calls this</span>
<span class="source-line-no">1229</span><span id="line.1229">     * makes). As such, this sacrifices the precision of the fraction to obtain significantly better speed than</span>
<span class="source-line-no">1230</span><span id="line.1230">     * generating one random number per cell, although the precision is probably good enough (fraction is effectively</span>
<span class="source-line-no">1231</span><span id="line.1231">     * rounded down to the nearest multiple of 0.015625, and clamped between 0.0 and 1.0). The parameter {@code random}</span>
<span class="source-line-no">1232</span><span id="line.1232">     * can be an object like a {@link DiverRNG}, an {@link RNG} backed by a well-distributed RandomnessSource like its</span>
<span class="source-line-no">1233</span><span id="line.1233">     * default, DiverRNG, a {@link GWTRNG} (especially if you target GWT, where it will perform much better than most</span>
<span class="source-line-no">1234</span><span id="line.1234">     * alternatives), or any of various other RandomnessSource implementations that distribute bits well for</span>
<span class="source-line-no">1235</span><span id="line.1235">     * {@link RandomnessSource#nextLong()}, but should not be intentionally-biased RNGs like {@link DharmaRNG} or</span>
<span class="source-line-no">1236</span><span id="line.1236">     * {@link EditRNG}, nor double-based QRNGs like {@link VanDerCorputQRNG} or {@link SobolQRNG}.</span>
<span class="source-line-no">1237</span><span id="line.1237">     * @param random a RandomnessSource that should produce high-quality long values, like the defaults for {@link RNG}</span>
<span class="source-line-no">1238</span><span id="line.1238">     * @param fraction between 0.0 and 1.0 (clamped), only considering a precision of 1/64.0 (0.015625) between steps</span>
<span class="source-line-no">1239</span><span id="line.1239">     * @param width the maximum width for the GreasedRegion</span>
<span class="source-line-no">1240</span><span id="line.1240">     * @param height the maximum height for the GreasedRegion</span>
<span class="source-line-no">1241</span><span id="line.1241">     * @return this for chaining</span>
<span class="source-line-no">1242</span><span id="line.1242">     */</span>
<span class="source-line-no">1243</span><span id="line.1243">    public GreasedRegion refill(final RandomnessSource random, final double fraction, final int width, final int height) {</span>
<span class="source-line-no">1244</span><span id="line.1244">        if (random != null){</span>
<span class="source-line-no">1245</span><span id="line.1245">            int bitCount = (int) (fraction * 64);</span>
<span class="source-line-no">1246</span><span id="line.1246">            if(this.width == width &amp;&amp; this.height == height) {</span>
<span class="source-line-no">1247</span><span id="line.1247">                for (int i = 0; i &lt; width * ySections; i++) {</span>
<span class="source-line-no">1248</span><span id="line.1248">                    data[i] = approximateBits(random, bitCount);</span>
<span class="source-line-no">1249</span><span id="line.1249">                }</span>
<span class="source-line-no">1250</span><span id="line.1250">            } else {</span>
<span class="source-line-no">1251</span><span id="line.1251">                this.width = Math.max(width, 0);</span>
<span class="source-line-no">1252</span><span id="line.1252">                this.height = Math.max(height, 0);</span>
<span class="source-line-no">1253</span><span id="line.1253">                ySections = (this.height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">1254</span><span id="line.1254">                yEndMask = -1L &gt;&gt;&gt; (64 - (this.height &amp; 63));</span>
<span class="source-line-no">1255</span><span id="line.1255">                data = new long[this.width * ySections];</span>
<span class="source-line-no">1256</span><span id="line.1256">                for (int i = 0; i &lt; this.width * ySections; i++) {</span>
<span class="source-line-no">1257</span><span id="line.1257">                    data[i] = approximateBits(random, bitCount);</span>
<span class="source-line-no">1258</span><span id="line.1258">                }</span>
<span class="source-line-no">1259</span><span id="line.1259">                counts = new int[width * ySections];</span>
<span class="source-line-no">1260</span><span id="line.1260">            }</span>
<span class="source-line-no">1261</span><span id="line.1261">            if(ySections &gt; 0 &amp;&amp; yEndMask != -1) {</span>
<span class="source-line-no">1262</span><span id="line.1262">                for (int a = ySections - 1; a &lt; data.length; a += ySections) {</span>
<span class="source-line-no">1263</span><span id="line.1263">                    data[a] &amp;= yEndMask;</span>
<span class="source-line-no">1264</span><span id="line.1264">                }</span>
<span class="source-line-no">1265</span><span id="line.1265">            }</span>
<span class="source-line-no">1266</span><span id="line.1266">        }</span>
<span class="source-line-no">1267</span><span id="line.1267">        tallied = false;</span>
<span class="source-line-no">1268</span><span id="line.1268">        return this;</span>
<span class="source-line-no">1269</span><span id="line.1269">    }</span>
<span class="source-line-no">1270</span><span id="line.1270"></span>
<span class="source-line-no">1271</span><span id="line.1271">    /**</span>
<span class="source-line-no">1272</span><span id="line.1272">     * Copy constructor that takes another GreasedRegion and copies all of its data into this new one.</span>
<span class="source-line-no">1273</span><span id="line.1273">     * If you find yourself frequently using this constructor and assigning it to the same variable, consider using the</span>
<span class="source-line-no">1274</span><span id="line.1274">     * {@link #remake(GreasedRegion)} method on the variable instead, which will, if it has the same width and height</span>
<span class="source-line-no">1275</span><span id="line.1275">     * as the other GreasedRegion, avoid creating garbage and quickly fill the variable with the other's contents.</span>
<span class="source-line-no">1276</span><span id="line.1276">     * @see #copy() for a convenience method that just uses this constructor</span>
<span class="source-line-no">1277</span><span id="line.1277">     * @param other another GreasedRegion that will be copied into this new GreasedRegion</span>
<span class="source-line-no">1278</span><span id="line.1278">     */</span>
<span class="source-line-no">1279</span><span id="line.1279">    public GreasedRegion(final GreasedRegion other)</span>
<span class="source-line-no">1280</span><span id="line.1280">    {</span>
<span class="source-line-no">1281</span><span id="line.1281">        width = other.width;</span>
<span class="source-line-no">1282</span><span id="line.1282">        height = other.height;</span>
<span class="source-line-no">1283</span><span id="line.1283">        ySections = other.ySections;</span>
<span class="source-line-no">1284</span><span id="line.1284">        yEndMask = other.yEndMask;</span>
<span class="source-line-no">1285</span><span id="line.1285">        data = new long[width * ySections];</span>
<span class="source-line-no">1286</span><span id="line.1286">        counts = new int[width * ySections];</span>
<span class="source-line-no">1287</span><span id="line.1287">        System.arraycopy(other.data, 0, data, 0, width * ySections);</span>
<span class="source-line-no">1288</span><span id="line.1288">        System.arraycopy(other.counts, 0, counts, 0, width * ySections);</span>
<span class="source-line-no">1289</span><span id="line.1289">        ct  = other.ct;</span>
<span class="source-line-no">1290</span><span id="line.1290">        tallied = other.tallied;</span>
<span class="source-line-no">1291</span><span id="line.1291">    }</span>
<span class="source-line-no">1292</span><span id="line.1292"></span>
<span class="source-line-no">1293</span><span id="line.1293">    /**</span>
<span class="source-line-no">1294</span><span id="line.1294">     * Primarily for internal use, this constructor copies data2 exactly into the internal long array the new</span>
<span class="source-line-no">1295</span><span id="line.1295">     * GreasedRegion will use, and does not perform any validation steps to ensure that cells that would be "on" but are</span>
<span class="source-line-no">1296</span><span id="line.1296">     * outside the actual height of the GreasedRegion are actually removed (this only matters if height is not a</span>
<span class="source-line-no">1297</span><span id="line.1297">     * multiple of 64).</span>
<span class="source-line-no">1298</span><span id="line.1298">     * @param data2 a long array that is typically from another GreasedRegion, and would be hard to make otherwise</span>
<span class="source-line-no">1299</span><span id="line.1299">     * @param width the width of the GreasedRegion to construct</span>
<span class="source-line-no">1300</span><span id="line.1300">     * @param height the height of the GreasedRegion to construct</span>
<span class="source-line-no">1301</span><span id="line.1301">     */</span>
<span class="source-line-no">1302</span><span id="line.1302">    public GreasedRegion(final long[] data2, final int width, final int height)</span>
<span class="source-line-no">1303</span><span id="line.1303">    {</span>
<span class="source-line-no">1304</span><span id="line.1304">        this.width = width;</span>
<span class="source-line-no">1305</span><span id="line.1305">        this.height = height;</span>
<span class="source-line-no">1306</span><span id="line.1306">        ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">1307</span><span id="line.1307">        yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">1308</span><span id="line.1308">        data = new long[width * ySections];</span>
<span class="source-line-no">1309</span><span id="line.1309">        System.arraycopy(data2, 0, data, 0, width * ySections);</span>
<span class="source-line-no">1310</span><span id="line.1310">        if(ySections &gt; 0 &amp;&amp; yEndMask != -1) {</span>
<span class="source-line-no">1311</span><span id="line.1311">            for (int a = ySections - 1; a &lt; data.length; a += ySections) {</span>
<span class="source-line-no">1312</span><span id="line.1312">                data[a] &amp;= yEndMask;</span>
<span class="source-line-no">1313</span><span id="line.1313">            }</span>
<span class="source-line-no">1314</span><span id="line.1314">        }</span>
<span class="source-line-no">1315</span><span id="line.1315">        counts = new int[width * ySections];</span>
<span class="source-line-no">1316</span><span id="line.1316">        tallied = false;</span>
<span class="source-line-no">1317</span><span id="line.1317">    }</span>
<span class="source-line-no">1318</span><span id="line.1318"></span>
<span class="source-line-no">1319</span><span id="line.1319">    /**</span>
<span class="source-line-no">1320</span><span id="line.1320">     * Primarily for internal use, this constructor copies data2 into the internal long array the new GreasedRegion will</span>
<span class="source-line-no">1321</span><span id="line.1321">     * use, but treats data2 as having the dimensions [dataWidth][dataHeight], and uses the potentially-different</span>
<span class="source-line-no">1322</span><span id="line.1322">     * dimensions [width][height] for the constructed GreasedRegion. This will truncate data2 on width, height, or both</span>
<span class="source-line-no">1323</span><span id="line.1323">     * if width or height is smaller than dataWidth or dataHeight. It will fill extra space with all "off" if width or</span>
<span class="source-line-no">1324</span><span id="line.1324">     * height is larger than dataWidth or dataHeight. It will interpret data2 as the same 2D shape regardless of the</span>
<span class="source-line-no">1325</span><span id="line.1325">     * width or height it is being assigned to, and data2 will not be reshaped by truncation.</span>
<span class="source-line-no">1326</span><span id="line.1326">     * @param data2 a long array that is typically from another GreasedRegion, and would be hard to make otherwise</span>
<span class="source-line-no">1327</span><span id="line.1327">     * @param dataWidth the width to interpret data2 as having</span>
<span class="source-line-no">1328</span><span id="line.1328">     * @param dataHeight the height to interpret data2 as having</span>
<span class="source-line-no">1329</span><span id="line.1329">     * @param width the width of the GreasedRegion to construct</span>
<span class="source-line-no">1330</span><span id="line.1330">     * @param height the height of the GreasedRegion to construct</span>
<span class="source-line-no">1331</span><span id="line.1331">     */</span>
<span class="source-line-no">1332</span><span id="line.1332">    public GreasedRegion(final long[] data2, final int dataWidth, final int dataHeight, final int width, final int height)</span>
<span class="source-line-no">1333</span><span id="line.1333">    {</span>
<span class="source-line-no">1334</span><span id="line.1334">        this.width = width;</span>
<span class="source-line-no">1335</span><span id="line.1335">        this.height = height;</span>
<span class="source-line-no">1336</span><span id="line.1336">        ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">1337</span><span id="line.1337">        yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">1338</span><span id="line.1338">        data = new long[width * ySections];</span>
<span class="source-line-no">1339</span><span id="line.1339"></span>
<span class="source-line-no">1340</span><span id="line.1340">        final int ySections2 = (dataHeight + 63) &gt;&gt; 6;</span>
<span class="source-line-no">1341</span><span id="line.1341">        if(ySections2 == 0)</span>
<span class="source-line-no">1342</span><span id="line.1342">        {</span>
<span class="source-line-no">1343</span><span id="line.1343">            counts = new int[0];</span>
<span class="source-line-no">1344</span><span id="line.1344">            tallied = false;</span>
<span class="source-line-no">1345</span><span id="line.1345">            return;</span>
<span class="source-line-no">1346</span><span id="line.1346">        }</span>
<span class="source-line-no">1347</span><span id="line.1347">        if(ySections == 1) {</span>
<span class="source-line-no">1348</span><span id="line.1348">            System.arraycopy(data2, 0, data, 0, Math.min(dataWidth, width));</span>
<span class="source-line-no">1349</span><span id="line.1349">        }</span>
<span class="source-line-no">1350</span><span id="line.1350">        else</span>
<span class="source-line-no">1351</span><span id="line.1351">        {</span>
<span class="source-line-no">1352</span><span id="line.1352">            if(dataHeight &gt;= height) {</span>
<span class="source-line-no">1353</span><span id="line.1353">                for (int i = 0, j = 0; i &lt; width &amp;&amp; i &lt; dataWidth; i += ySections2, j += ySections) {</span>
<span class="source-line-no">1354</span><span id="line.1354">                    System.arraycopy(data2, i, data, j, ySections);</span>
<span class="source-line-no">1355</span><span id="line.1355">                }</span>
<span class="source-line-no">1356</span><span id="line.1356">            }</span>
<span class="source-line-no">1357</span><span id="line.1357">            else</span>
<span class="source-line-no">1358</span><span id="line.1358">            {</span>
<span class="source-line-no">1359</span><span id="line.1359">                for (int i = 0, j = 0; i &lt; width &amp;&amp; i &lt; dataWidth; i += ySections2, j += ySections) {</span>
<span class="source-line-no">1360</span><span id="line.1360">                    System.arraycopy(data2, i, data, j, ySections2);</span>
<span class="source-line-no">1361</span><span id="line.1361">                }</span>
<span class="source-line-no">1362</span><span id="line.1362">            }</span>
<span class="source-line-no">1363</span><span id="line.1363">        }</span>
<span class="source-line-no">1364</span><span id="line.1364">        if(ySections &gt; 0 &amp;&amp; yEndMask != -1) {</span>
<span class="source-line-no">1365</span><span id="line.1365">            for (int a = ySections - 1; a &lt; data.length; a += ySections) {</span>
<span class="source-line-no">1366</span><span id="line.1366">                data[a] &amp;= yEndMask;</span>
<span class="source-line-no">1367</span><span id="line.1367">            }</span>
<span class="source-line-no">1368</span><span id="line.1368">        }</span>
<span class="source-line-no">1369</span><span id="line.1369">        counts = new int[width * ySections];</span>
<span class="source-line-no">1370</span><span id="line.1370">        tallied = false;</span>
<span class="source-line-no">1371</span><span id="line.1371">    }</span>
<span class="source-line-no">1372</span><span id="line.1372">    /**</span>
<span class="source-line-no">1373</span><span id="line.1373">     * Primarily for internal use, this method copies data2 into the internal long array the new GreasedRegion will</span>
<span class="source-line-no">1374</span><span id="line.1374">     * use, but treats data2 as having the dimensions [dataWidth][dataHeight], and uses the potentially-different</span>
<span class="source-line-no">1375</span><span id="line.1375">     * dimensions [width][height] for this GreasedRegion, potentially re-allocating the internal data this uses if width</span>
<span class="source-line-no">1376</span><span id="line.1376">     * and/or height are different from what they were. This will truncate data2 on width, height, or both if width or</span>
<span class="source-line-no">1377</span><span id="line.1377">     * height is smaller than dataWidth or dataHeight. It will fill extra space with all "off" if width or height is</span>
<span class="source-line-no">1378</span><span id="line.1378">     * larger than dataWidth or dataHeight. It will interpret data2 as the same 2D shape regardless of the width or</span>
<span class="source-line-no">1379</span><span id="line.1379">     * height it is being assigned to, and data2 will not be reshaped by truncation.</span>
<span class="source-line-no">1380</span><span id="line.1380">     * @param data2 a long array that is typically from another GreasedRegion, and would be hard to make otherwise</span>
<span class="source-line-no">1381</span><span id="line.1381">     * @param dataWidth the width to interpret data2 as having</span>
<span class="source-line-no">1382</span><span id="line.1382">     * @param dataHeight the height to interpret data2 as having</span>
<span class="source-line-no">1383</span><span id="line.1383">     * @param width the width to set this GreasedRegion to have</span>
<span class="source-line-no">1384</span><span id="line.1384">     * @param height the height to set this GreasedRegion to have</span>
<span class="source-line-no">1385</span><span id="line.1385">     */</span>
<span class="source-line-no">1386</span><span id="line.1386">    public GreasedRegion refill(final long[] data2, final int dataWidth, final int dataHeight, final int width, final int height)</span>
<span class="source-line-no">1387</span><span id="line.1387">    {</span>
<span class="source-line-no">1388</span><span id="line.1388">        if(width != this.width || height != this.height) {</span>
<span class="source-line-no">1389</span><span id="line.1389">            this.width = width;</span>
<span class="source-line-no">1390</span><span id="line.1390">            this.height = height;</span>
<span class="source-line-no">1391</span><span id="line.1391">            ySections = (height + 63) &gt;&gt; 6;</span>
<span class="source-line-no">1392</span><span id="line.1392">            yEndMask = -1L &gt;&gt;&gt; (64 - (height &amp; 63));</span>
<span class="source-line-no">1393</span><span id="line.1393">            data = new long[width * ySections];</span>
<span class="source-line-no">1394</span><span id="line.1394">            counts = new int[width * ySections];</span>
<span class="source-line-no">1395</span><span id="line.1395">        }</span>
<span class="source-line-no">1396</span><span id="line.1396">        else {</span>
<span class="source-line-no">1397</span><span id="line.1397">            Arrays.fill(data, 0L);</span>
<span class="source-line-no">1398</span><span id="line.1398">        }</span>
<span class="source-line-no">1399</span><span id="line.1399">        final int ySections2 = (dataHeight + 63) &gt;&gt; 6;</span>
<span class="source-line-no">1400</span><span id="line.1400">        if(ySections2 == 0)</span>
<span class="source-line-no">1401</span><span id="line.1401">            return this;</span>
<span class="source-line-no">1402</span><span id="line.1402">        if(ySections == 1) {</span>
<span class="source-line-no">1403</span><span id="line.1403">            System.arraycopy(data2, 0, data, 0, Math.min(dataWidth, width));</span>
<span class="source-line-no">1404</span><span id="line.1404">        }</span>
<span class="source-line-no">1405</span><span id="line.1405">        else</span>
<span class="source-line-no">1406</span><span id="line.1406">        {</span>
<span class="source-line-no">1407</span><span id="line.1407">            if(dataHeight &gt;= height) {</span>
<span class="source-line-no">1408</span><span id="line.1408">                for (int i = 0, j = 0; i &lt; width &amp;&amp; i &lt; dataWidth; i += ySections2, j += ySections) {</span>
<span class="source-line-no">1409</span><span id="line.1409">                    System.arraycopy(data2, i, data, j, ySections);</span>
<span class="source-line-no">1410</span><span id="line.1410">                }</span>
<span class="source-line-no">1411</span><span id="line.1411">            }</span>
<span class="source-line-no">1412</span><span id="line.1412">            else</span>
<span class="source-line-no">1413</span><span id="line.1413">            {</span>
<span class="source-line-no">1414</span><span id="line.1414">                for (int i = 0, j = 0; i &lt; width &amp;&amp; i &lt; dataWidth; i += ySections2, j += ySections) {</span>
<span class="source-line-no">1415</span><span id="line.1415">                    System.arraycopy(data2, i, data, j, ySections2);</span>
<span class="source-line-no">1416</span><span id="line.1416">                }</span>
<span class="source-line-no">1417</span><span id="line.1417">            }</span>
<span class="source-line-no">1418</span><span id="line.1418">        }</span>
<span class="source-line-no">1419</span><span id="line.1419">        if(ySections &gt; 0 &amp;&amp; yEndMask != -1) {</span>
<span class="source-line-no">1420</span><span id="line.1420">            for (int a = ySections - 1; a &lt; data.length; a += ySections) {</span>
<span class="source-line-no">1421</span><span id="line.1421">                data[a] &amp;= yEndMask;</span>
<span class="source-line-no">1422</span><span id="line.1422">            }</span>
<span class="source-line-no">1423</span><span id="line.1423">        }</span>
<span class="source-line-no">1424</span><span id="line.1424">        tallied = false;</span>
<span class="source-line-no">1425</span><span id="line.1425">        return this;</span>
<span class="source-line-no">1426</span><span id="line.1426">    }</span>
<span class="source-line-no">1427</span><span id="line.1427"></span>
<span class="source-line-no">1428</span><span id="line.1428">    /**</span>
<span class="source-line-no">1429</span><span id="line.1429">     * A useful method for efficiency, remake() reassigns this GreasedRegion to have its contents replaced by other. If</span>
<span class="source-line-no">1430</span><span id="line.1430">     * other and this GreasedRegion have identical width and height, this is very efficient and performs no additional</span>
<span class="source-line-no">1431</span><span id="line.1431">     * allocations, simply replacing the cell data in this with the cell data from other. If width and height are not</span>
<span class="source-line-no">1432</span><span id="line.1432">     * both equal between this and other, this does allocate a new data array, but still reassigns this GreasedRegion</span>
<span class="source-line-no">1433</span><span id="line.1433">     * in-place and acts similarly to when width and height are both equal (it just uses some more memory).</span>
<span class="source-line-no">1434</span><span id="line.1434">     * &lt;br&gt;</span>
<span class="source-line-no">1435</span><span id="line.1435">     * Using remake() or the similar refill() methods in chains of operations on multiple GreasedRegions can be key to</span>
<span class="source-line-no">1436</span><span id="line.1436">     * maintaining good performance and memory usage. You often can recycle a no-longer-used GreasedRegion by assigning</span>
<span class="source-line-no">1437</span><span id="line.1437">     * a GreasedRegion you want to keep to it with remake(), then mutating either the remade value or the one that was</span>
<span class="source-line-no">1438</span><span id="line.1438">     * just filled into this but keeping one version around for later usage.</span>
<span class="source-line-no">1439</span><span id="line.1439">     * @param other another GreasedRegion to replace the data in this GreasedRegion with</span>
<span class="source-line-no">1440</span><span id="line.1440">     * @return this for chaining</span>
<span class="source-line-no">1441</span><span id="line.1441">     */</span>
<span class="source-line-no">1442</span><span id="line.1442">    public GreasedRegion remake(GreasedRegion other) {</span>
<span class="source-line-no">1443</span><span id="line.1443">        if (width == other.width &amp;&amp; height == other.height) {</span>
<span class="source-line-no">1444</span><span id="line.1444">            System.arraycopy(other.data, 0, data, 0, width * ySections);</span>
<span class="source-line-no">1445</span><span id="line.1445">            System.arraycopy(other.counts, 0, counts, 0, width * ySections);</span>
<span class="source-line-no">1446</span><span id="line.1446">            ct = other.ct;</span>
<span class="source-line-no">1447</span><span id="line.1447">            tallied = other.tallied;</span>
<span class="source-line-no">1448</span><span id="line.1448">            return this;</span>
<span class="source-line-no">1449</span><span id="line.1449">        } else {</span>
<span class="source-line-no">1450</span><span id="line.1450">            width = other.width;</span>
<span class="source-line-no">1451</span><span id="line.1451">            height = other.height;</span>
<span class="source-line-no">1452</span><span id="line.1452">            ySections = other.ySections;</span>
<span class="source-line-no">1453</span><span id="line.1453">            yEndMask = other.yEndMask;</span>
<span class="source-line-no">1454</span><span id="line.1454">            data = new long[width * ySections];</span>
<span class="source-line-no">1455</span><span id="line.1455">            counts = new int[width * ySections];</span>
<span class="source-line-no">1456</span><span id="line.1456">            System.arraycopy(other.data, 0, data, 0, width * ySections);</span>
<span class="source-line-no">1457</span><span id="line.1457">            System.arraycopy(other.counts, 0, counts, 0, width * ySections);</span>
<span class="source-line-no">1458</span><span id="line.1458">            ct = other.ct;</span>
<span class="source-line-no">1459</span><span id="line.1459">            tallied = other.tallied;</span>
<span class="source-line-no">1460</span><span id="line.1460">            return this;</span>
<span class="source-line-no">1461</span><span id="line.1461">        }</span>
<span class="source-line-no">1462</span><span id="line.1462">    }</span>
<span class="source-line-no">1463</span><span id="line.1463"></span>
<span class="source-line-no">1464</span><span id="line.1464">    /**</span>
<span class="source-line-no">1465</span><span id="line.1465">     * Changes the width and/or height of this GreasedRegion, enlarging or shrinking starting at the edges where</span>
<span class="source-line-no">1466</span><span id="line.1466">     * {@code x == width - 1} and {@code y == height - 1}. There isn't an especially efficient way to expand from the</span>
<span class="source-line-no">1467</span><span id="line.1467">     * other edges, but this method is able to copy data in bulk, so at least this method should be very fast. You can</span>
<span class="source-line-no">1468</span><span id="line.1468">     * use {@code insert(int, int, GreasedRegion)} if you want to place one GreasedRegion inside another one,</span>
<span class="source-line-no">1469</span><span id="line.1469">     * potentially with a different size. The space created by any enlargement starts all off; shrinking doesn't change</span>
<span class="source-line-no">1470</span><span id="line.1470">     * the existing data where it isn't removed by the shrink.</span>
<span class="source-line-no">1471</span><span id="line.1471">     * @param widthChange the amount to change width by; can be positive, negative, or zero</span>
<span class="source-line-no">1472</span><span id="line.1472">     * @param heightChange the amount to change height by; can be positive, negative, or zero</span>
<span class="source-line-no">1473</span><span id="line.1473">     * @return this for chaining</span>
<span class="source-line-no">1474</span><span id="line.1474">     */</span>
<span class="source-line-no">1475</span><span id="line.1475">    public GreasedRegion alterBounds(int widthChange, int heightChange)</span>
<span class="source-line-no">1476</span><span id="line.1476">    {</span>
<span class="source-line-no">1477</span><span id="line.1477">        int newWidth = width + widthChange;</span>
<span class="source-line-no">1478</span><span id="line.1478">        int newHeight = height + heightChange;</span>
<span class="source-line-no">1479</span><span id="line.1479">        if(newWidth &lt;= 0 || newHeight &lt;= 0)</span>
<span class="source-line-no">1480</span><span id="line.1480">        {</span>
<span class="source-line-no">1481</span><span id="line.1481">            width = 0;</span>
<span class="source-line-no">1482</span><span id="line.1482">            height = 0;</span>
<span class="source-line-no">1483</span><span id="line.1483">            ySections= 0;</span>
<span class="source-line-no">1484</span><span id="line.1484">            yEndMask = -1;</span>
<span class="source-line-no">1485</span><span id="line.1485">            data = new long[0];</span>
<span class="source-line-no">1486</span><span id="line.1486">            counts = new int[0];</span>
<span class="source-line-no">1487</span><span id="line.1487">            ct = 0;</span>
<span class="source-line-no">1488</span><span id="line.1488">            tallied = true;</span>
<span class="source-line-no">1489</span><span id="line.1489">            return this;</span>
<span class="source-line-no">1490</span><span id="line.1490">        }</span>
<span class="source-line-no">1491</span><span id="line.1491">        int newYSections = (newHeight + 63) &gt;&gt; 6;</span>
<span class="source-line-no">1492</span><span id="line.1492">        yEndMask = -1L &gt;&gt;&gt; (64 - (newHeight &amp; 63));</span>
<span class="source-line-no">1493</span><span id="line.1493">        long[] newData = new long[newWidth * newYSections];         </span>
<span class="source-line-no">1494</span><span id="line.1494">        counts = new int[newWidth * newYSections];</span>
<span class="source-line-no">1495</span><span id="line.1495">        </span>
<span class="source-line-no">1496</span><span id="line.1496">        for (int x = 0; x &lt; width &amp;&amp; x &lt; newWidth; x++) {</span>
<span class="source-line-no">1497</span><span id="line.1497">            for (int ys = 0; ys &lt; ySections &amp;&amp; ys &lt; newYSections; ys++) {</span>
<span class="source-line-no">1498</span><span id="line.1498">                newData[x * newYSections + ys] = data[x * ySections + ys];</span>
<span class="source-line-no">1499</span><span id="line.1499">            }</span>
<span class="source-line-no">1500</span><span id="line.1500">        }</span>
<span class="source-line-no">1501</span><span id="line.1501">        ySections = newYSections;</span>
<span class="source-line-no">1502</span><span id="line.1502">        width = newWidth;</span>
<span class="source-line-no">1503</span><span id="line.1503">        height = newHeight;</span>
<span class="source-line-no">1504</span><span id="line.1504">        data = newData;</span>
<span class="source-line-no">1505</span><span id="line.1505">        if(ySections &gt; 0 &amp;&amp; yEndMask != -1) {</span>
<span class="source-line-no">1506</span><span id="line.1506">            for (int a = ySections - 1; a &lt; data.length; a += ySections) {</span>
<span class="source-line-no">1507</span><span id="line.1507">                data[a] &amp;= yEndMask;</span>
<span class="source-line-no">1508</span><span id="line.1508">            }</span>
<span class="source-line-no">1509</span><span id="line.1509">        }</span>
<span class="source-line-no">1510</span><span id="line.1510">        tallied = false;</span>
<span class="source-line-no">1511</span><span id="line.1511">        return this;</span>
<span class="source-line-no">1512</span><span id="line.1512">    }</span>
<span class="source-line-no">1513</span><span id="line.1513"></span>
<span class="source-line-no">1514</span><span id="line.1514">    /**</span>
<span class="source-line-no">1515</span><span id="line.1515">     * Makes a copy of this GreasedRegion that has been rotated 90 degrees {@code turns} times. If using y-down</span>
<span class="source-line-no">1516</span><span id="line.1516">     * coordinates, then these rotations are clockwise; otherwise, they are counter-clockwise. This uses a copy because</span>
<span class="source-line-no">1517</span><span id="line.1517">     * in many caseswhere the GreasedRegion has non-equal width and height, the rotated version has different</span>
<span class="source-line-no">1518</span><span id="line.1518">     * dimensions, and that requires allocating most of a new GreasedRegion anyway. This GreasedRegion is never modifed</span>
<span class="source-line-no">1519</span><span id="line.1519">     * as a result of this method.</span>
<span class="source-line-no">1520</span><span id="line.1520">     * @param turns how many times to rotate the copy (clockwise if using y-down, counterclockwise otherwise)</span>
<span class="source-line-no">1521</span><span id="line.1521">     * @return a potentially-rotated copy of this GreasedRegion</span>
<span class="source-line-no">1522</span><span id="line.1522">     */</span>
<span class="source-line-no">1523</span><span id="line.1523">    public GreasedRegion copyRotated(int turns)</span>
<span class="source-line-no">1524</span><span id="line.1524">    {</span>
<span class="source-line-no">1525</span><span id="line.1525">        switch (turns &amp; 3) {</span>
<span class="source-line-no">1526</span><span id="line.1526">            case 0: {</span>
<span class="source-line-no">1527</span><span id="line.1527">                return copy();</span>
<span class="source-line-no">1528</span><span id="line.1528">            }</span>
<span class="source-line-no">1529</span><span id="line.1529">            case 1: {</span>
<span class="source-line-no">1530</span><span id="line.1530">                GreasedRegion next = new GreasedRegion(height, width);</span>
<span class="source-line-no">1531</span><span id="line.1531">                for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">1532</span><span id="line.1532">                    for (int y = 0, iy = height - 1; y &lt; height; y++, iy--) {</span>
<span class="source-line-no">1533</span><span id="line.1533">                        if((data[x * ySections + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0L)</span>
<span class="source-line-no">1534</span><span id="line.1534">                            next.data[iy * ySections + (x &gt;&gt; 6)] |= 1L &lt;&lt; (x &amp; 63);</span>
<span class="source-line-no">1535</span><span id="line.1535">                    }</span>
<span class="source-line-no">1536</span><span id="line.1536">                }</span>
<span class="source-line-no">1537</span><span id="line.1537">                return next;</span>
<span class="source-line-no">1538</span><span id="line.1538">            }</span>
<span class="source-line-no">1539</span><span id="line.1539">            case 2: {</span>
<span class="source-line-no">1540</span><span id="line.1540">                GreasedRegion next = new GreasedRegion(width, height);</span>
<span class="source-line-no">1541</span><span id="line.1541">                for (int x = 0, ix = width - 1; x &lt; width; x++, ix--) {</span>
<span class="source-line-no">1542</span><span id="line.1542">                    for (int y = 0, iy = height - 1; y &lt; height; y++, iy--) {</span>
<span class="source-line-no">1543</span><span id="line.1543">                        if((data[x * ySections + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0L)</span>
<span class="source-line-no">1544</span><span id="line.1544">                            next.data[ix * ySections + (iy &gt;&gt; 6)] |= 1L &lt;&lt; (iy &amp; 63);</span>
<span class="source-line-no">1545</span><span id="line.1545">                    }</span>
<span class="source-line-no">1546</span><span id="line.1546">                }</span>
<span class="source-line-no">1547</span><span id="line.1547">                return next;</span>
<span class="source-line-no">1548</span><span id="line.1548">            }</span>
<span class="source-line-no">1549</span><span id="line.1549">            default: {</span>
<span class="source-line-no">1550</span><span id="line.1550">                GreasedRegion next = new GreasedRegion(height, width);</span>
<span class="source-line-no">1551</span><span id="line.1551">                for (int x = 0, ix = width - 1; x &lt; width; x++, ix--) {</span>
<span class="source-line-no">1552</span><span id="line.1552">                    for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">1553</span><span id="line.1553">                        if((data[x * ySections + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0L)</span>
<span class="source-line-no">1554</span><span id="line.1554">                            next.data[y * ySections + (ix &gt;&gt; 6)] |= 1L &lt;&lt; (ix &amp; 63);</span>
<span class="source-line-no">1555</span><span id="line.1555">                    }</span>
<span class="source-line-no">1556</span><span id="line.1556">                }</span>
<span class="source-line-no">1557</span><span id="line.1557">                return next;</span>
<span class="source-line-no">1558</span><span id="line.1558">            }</span>
<span class="source-line-no">1559</span><span id="line.1559">        }</span>
<span class="source-line-no">1560</span><span id="line.1560">    }</span>
<span class="source-line-no">1561</span><span id="line.1561">    </span>
<span class="source-line-no">1562</span><span id="line.1562">    public GreasedRegion flip(boolean leftRight, boolean upDown) {</span>
<span class="source-line-no">1563</span><span id="line.1563">        if(ySections &lt;= 0) return this;</span>
<span class="source-line-no">1564</span><span id="line.1564">        if(leftRight) {</span>
<span class="source-line-no">1565</span><span id="line.1565">            long t;</span>
<span class="source-line-no">1566</span><span id="line.1566">            for (int x = 0, o = width - 1; x &lt; (width &gt;&gt;&gt; 1); x++, o--) {</span>
<span class="source-line-no">1567</span><span id="line.1567">                for (int y = 0; y &lt; ySections; y++) {</span>
<span class="source-line-no">1568</span><span id="line.1568">                    t = data[x * ySections + y];</span>
<span class="source-line-no">1569</span><span id="line.1569">                    data[x * ySections + y] = data[o * ySections + y];</span>
<span class="source-line-no">1570</span><span id="line.1570">                    data[o * ySections + y] = t;</span>
<span class="source-line-no">1571</span><span id="line.1571">                }</span>
<span class="source-line-no">1572</span><span id="line.1572">            }</span>
<span class="source-line-no">1573</span><span id="line.1573">        }</span>
<span class="source-line-no">1574</span><span id="line.1574">        if(upDown) {</span>
<span class="source-line-no">1575</span><span id="line.1575">            if(yEndMask == -1L) {</span>
<span class="source-line-no">1576</span><span id="line.1576">                long t;</span>
<span class="source-line-no">1577</span><span id="line.1577">                for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">1578</span><span id="line.1578">                    for (int y = 0, o = ySections - 1; y &lt; (ySections &gt;&gt;&gt; 1); y++, o--) {</span>
<span class="source-line-no">1579</span><span id="line.1579">                        t = Long.reverse(data[x * ySections + y]);</span>
<span class="source-line-no">1580</span><span id="line.1580">                        data[x * ySections + y] = Long.reverse(data[x * ySections + o]);</span>
<span class="source-line-no">1581</span><span id="line.1581">                        data[x * ySections + o] = t;</span>
<span class="source-line-no">1582</span><span id="line.1582">                    }</span>
<span class="source-line-no">1583</span><span id="line.1583">                    if((ySections &amp; 1) == 1){</span>
<span class="source-line-no">1584</span><span id="line.1584">                        data[x * ySections + (ySections &gt;&gt;&gt; 1)] = Long.reverse(data[x * ySections + (ySections &gt;&gt;&gt; 1)]);</span>
<span class="source-line-no">1585</span><span id="line.1585">                    }</span>
<span class="source-line-no">1586</span><span id="line.1586">                }</span>
<span class="source-line-no">1587</span><span id="line.1587">            }</span>
<span class="source-line-no">1588</span><span id="line.1588">            else {</span>
<span class="source-line-no">1589</span><span id="line.1589">                int shift = Long.numberOfLeadingZeros(yEndMask);</span>
<span class="source-line-no">1590</span><span id="line.1590">                if (ySections == 1) {</span>
<span class="source-line-no">1591</span><span id="line.1591">                    for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">1592</span><span id="line.1592">                        data[x] = Long.reverse(data[x]) &gt;&gt;&gt; shift;</span>
<span class="source-line-no">1593</span><span id="line.1593">                    }</span>
<span class="source-line-no">1594</span><span id="line.1594">                } else {</span>
<span class="source-line-no">1595</span><span id="line.1595">                    for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">1596</span><span id="line.1596">                        int ie = x * ySections + ySections - 1;</span>
<span class="source-line-no">1597</span><span id="line.1597">                        int ib = x * ySections + ySections - 2;</span>
<span class="source-line-no">1598</span><span id="line.1598">                        int il = x * ySections + 1;</span>
<span class="source-line-no">1599</span><span id="line.1599">                        int is = x * ySections;</span>
<span class="source-line-no">1600</span><span id="line.1600">                        long end = Long.reverse(data[ie]);</span>
<span class="source-line-no">1601</span><span id="line.1601">                        long big = Long.reverse(data[ib]);</span>
<span class="source-line-no">1602</span><span id="line.1602">                        long little = Long.reverse(data[il]);</span>
<span class="source-line-no">1603</span><span id="line.1603">                        long start = Long.reverse(data[is]);</span>
<span class="source-line-no">1604</span><span id="line.1604">                        data[ie] = start &gt;&gt;&gt; shift;</span>
<span class="source-line-no">1605</span><span id="line.1605">                        data[is] = end &gt;&gt;&gt; shift;</span>
<span class="source-line-no">1606</span><span id="line.1606">                        data[is] |= big &lt;&lt; 64 - shift;</span>
<span class="source-line-no">1607</span><span id="line.1607">                        data[ib] = start &lt;&lt; 64 - shift;</span>
<span class="source-line-no">1608</span><span id="line.1608">                        data[ib] |= little &gt;&gt;&gt; shift;</span>
<span class="source-line-no">1609</span><span id="line.1609">                        </span>
<span class="source-line-no">1610</span><span id="line.1610">                        for (int y = 1; y &lt; (ySections &gt;&gt;&gt; 1); y++) {</span>
<span class="source-line-no">1611</span><span id="line.1611">                            end = big;</span>
<span class="source-line-no">1612</span><span id="line.1612">                            start = little;</span>
<span class="source-line-no">1613</span><span id="line.1613">                            big = Long.reverse(data[--ib]);</span>
<span class="source-line-no">1614</span><span id="line.1614">                            little = Long.reverse(data[++il]);</span>
<span class="source-line-no">1615</span><span id="line.1615">                            ++is;</span>
<span class="source-line-no">1616</span><span id="line.1616">                            data[is] = end &gt;&gt;&gt; shift;</span>
<span class="source-line-no">1617</span><span id="line.1617">                            data[is] |= big &lt;&lt; 64 - shift;</span>
<span class="source-line-no">1618</span><span id="line.1618">                            data[ib] = start &lt;&lt; 64 - shift;</span>
<span class="source-line-no">1619</span><span id="line.1619">                            data[ib] |= little &gt;&gt;&gt; shift;</span>
<span class="source-line-no">1620</span><span id="line.1620">                        }</span>
<span class="source-line-no">1621</span><span id="line.1621">                    }</span>
<span class="source-line-no">1622</span><span id="line.1622">                }</span>
<span class="source-line-no">1623</span><span id="line.1623">            }</span>
<span class="source-line-no">1624</span><span id="line.1624">        }</span>
<span class="source-line-no">1625</span><span id="line.1625">        return this;</span>
<span class="source-line-no">1626</span><span id="line.1626">    }</span>
<span class="source-line-no">1627</span><span id="line.1627"></span>
<span class="source-line-no">1628</span><span id="line.1628">    /**</span>
<span class="source-line-no">1629</span><span id="line.1629">     * Sets the cell at x,y to on if value is true or off if value is false. Does nothing if x,y is out of bounds.</span>
<span class="source-line-no">1630</span><span id="line.1630">     * @param value the value to set in the cell</span>
<span class="source-line-no">1631</span><span id="line.1631">     * @param x the x-position of the cell</span>
<span class="source-line-no">1632</span><span id="line.1632">     * @param y the y-position of the cell</span>
<span class="source-line-no">1633</span><span id="line.1633">     * @return this for chaining</span>
<span class="source-line-no">1634</span><span id="line.1634">     */</span>
<span class="source-line-no">1635</span><span id="line.1635">    public GreasedRegion set(boolean value, int x, int y)</span>
<span class="source-line-no">1636</span><span id="line.1636">    {</span>
<span class="source-line-no">1637</span><span id="line.1637">        if(x &lt; width &amp;&amp; y &lt; height &amp;&amp; x &gt;= 0 &amp;&amp; y &gt;= 0) {</span>
<span class="source-line-no">1638</span><span id="line.1638">            if(value)</span>
<span class="source-line-no">1639</span><span id="line.1639">                data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">1640</span><span id="line.1640">            else</span>
<span class="source-line-no">1641</span><span id="line.1641">                data[x * ySections + (y &gt;&gt; 6)] &amp;= ~(1L &lt;&lt; (y &amp; 63));</span>
<span class="source-line-no">1642</span><span id="line.1642">            tallied = false;</span>
<span class="source-line-no">1643</span><span id="line.1643">        }</span>
<span class="source-line-no">1644</span><span id="line.1644">        return this;</span>
<span class="source-line-no">1645</span><span id="line.1645">    }</span>
<span class="source-line-no">1646</span><span id="line.1646"></span>
<span class="source-line-no">1647</span><span id="line.1647">    /**</span>
<span class="source-line-no">1648</span><span id="line.1648">     * Sets the cell at point to on if value is true or off if value is false. Does nothing if point is out of bounds,</span>
<span class="source-line-no">1649</span><span id="line.1649">     * or if point is null.</span>
<span class="source-line-no">1650</span><span id="line.1650">     * @param value the value to set in the cell</span>
<span class="source-line-no">1651</span><span id="line.1651">     * @param point the x,y Coord of the cell to set</span>
<span class="source-line-no">1652</span><span id="line.1652">     * @return this for chaining</span>
<span class="source-line-no">1653</span><span id="line.1653">     */</span>
<span class="source-line-no">1654</span><span id="line.1654">    public GreasedRegion set(boolean value, Coord point)</span>
<span class="source-line-no">1655</span><span id="line.1655">    {</span>
<span class="source-line-no">1656</span><span id="line.1656">        if(point == null) return this;</span>
<span class="source-line-no">1657</span><span id="line.1657">        return set(value, point.x, point.y);</span>
<span class="source-line-no">1658</span><span id="line.1658">    }</span>
<span class="source-line-no">1659</span><span id="line.1659"></span>
<span class="source-line-no">1660</span><span id="line.1660">    /**</span>
<span class="source-line-no">1661</span><span id="line.1661">     * Sets the cell at x,y to "on". Does nothing if x,y is out of bounds.</span>
<span class="source-line-no">1662</span><span id="line.1662">     * More efficient, slightly, than {@link #set(boolean, int, int)} if you just need to set a cell to "on".</span>
<span class="source-line-no">1663</span><span id="line.1663">     * @param x the x-position of the cell</span>
<span class="source-line-no">1664</span><span id="line.1664">     * @param y the y-position of the cell</span>
<span class="source-line-no">1665</span><span id="line.1665">     * @return this for chaining</span>
<span class="source-line-no">1666</span><span id="line.1666">     */</span>
<span class="source-line-no">1667</span><span id="line.1667">    public GreasedRegion insert(int x, int y)</span>
<span class="source-line-no">1668</span><span id="line.1668">    {</span>
<span class="source-line-no">1669</span><span id="line.1669">        if(x &lt; width &amp;&amp; y &lt; height &amp;&amp; x &gt;= 0 &amp;&amp; y &gt;= 0)</span>
<span class="source-line-no">1670</span><span id="line.1670">        {</span>
<span class="source-line-no">1671</span><span id="line.1671">            data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">1672</span><span id="line.1672">            tallied = false;</span>
<span class="source-line-no">1673</span><span id="line.1673">        }</span>
<span class="source-line-no">1674</span><span id="line.1674">        return this;</span>
<span class="source-line-no">1675</span><span id="line.1675">    }</span>
<span class="source-line-no">1676</span><span id="line.1676"></span>
<span class="source-line-no">1677</span><span id="line.1677">    /**</span>
<span class="source-line-no">1678</span><span id="line.1678">     * Sets the given cell, "tightly" encoded for a specific width/height as by {@link #asTightEncoded()}, to "on".</span>
<span class="source-line-no">1679</span><span id="line.1679">     * Does nothing if the cell is out of bounds.</span>
<span class="source-line-no">1680</span><span id="line.1680">     * @param tight a cell tightly encoded for this GreasedRegion's width and height</span>
<span class="source-line-no">1681</span><span id="line.1681">     * @return this for chaining</span>
<span class="source-line-no">1682</span><span id="line.1682">     */</span>
<span class="source-line-no">1683</span><span id="line.1683">    public GreasedRegion insert(int tight)</span>
<span class="source-line-no">1684</span><span id="line.1684">    {</span>
<span class="source-line-no">1685</span><span id="line.1685">        if(tight &lt; width * height &amp;&amp; tight &gt;= 0)</span>
<span class="source-line-no">1686</span><span id="line.1686">        {</span>
<span class="source-line-no">1687</span><span id="line.1687">            data[(tight % width) * ySections + ((tight / width) &gt;&gt;&gt; 6)] |= 1L &lt;&lt; ((tight / width) &amp; 63);</span>
<span class="source-line-no">1688</span><span id="line.1688">            tallied = false;</span>
<span class="source-line-no">1689</span><span id="line.1689">        }</span>
<span class="source-line-no">1690</span><span id="line.1690">        return this;</span>
<span class="source-line-no">1691</span><span id="line.1691">    }</span>
<span class="source-line-no">1692</span><span id="line.1692">    /**</span>
<span class="source-line-no">1693</span><span id="line.1693">     * Sets the cell at point to "on". Does nothing if point is out of bounds, or if point is null.</span>
<span class="source-line-no">1694</span><span id="line.1694">     * More efficient, slightly, than {@link #set(boolean, Coord)} if you just need to set a cell to "on".</span>
<span class="source-line-no">1695</span><span id="line.1695">     * @param point the x,y Coord of the cell</span>
<span class="source-line-no">1696</span><span id="line.1696">     * @return this for chaining</span>
<span class="source-line-no">1697</span><span id="line.1697">     */</span>
<span class="source-line-no">1698</span><span id="line.1698">    public GreasedRegion insert(Coord point)</span>
<span class="source-line-no">1699</span><span id="line.1699">    {</span>
<span class="source-line-no">1700</span><span id="line.1700"></span>
<span class="source-line-no">1701</span><span id="line.1701">        if(point == null) return this;</span>
<span class="source-line-no">1702</span><span id="line.1702">        return insert(point.x, point.y);</span>
<span class="source-line-no">1703</span><span id="line.1703">    }</span>
<span class="source-line-no">1704</span><span id="line.1704"></span>
<span class="source-line-no">1705</span><span id="line.1705">    /**</span>
<span class="source-line-no">1706</span><span id="line.1706">     * Takes another GreasedRegion, called other, with potentially different size and inserts its "on" cells into thi</span>
<span class="source-line-no">1707</span><span id="line.1707">     * GreasedRegion at the given x,y offset, allowing negative x and/or y to put only part of other in this.</span>
<span class="source-line-no">1708</span><span id="line.1708">     * &lt;br&gt;</span>
<span class="source-line-no">1709</span><span id="line.1709">     * This is a rather complex method internally, but should be about as efficient as a general insert-region method</span>
<span class="source-line-no">1710</span><span id="line.1710">     * can be.</span>
<span class="source-line-no">1711</span><span id="line.1711">     * @param x the x offset to start inserting other at; may be negative</span>
<span class="source-line-no">1712</span><span id="line.1712">     * @param y the y offset to start inserting other at; may be negative</span>
<span class="source-line-no">1713</span><span id="line.1713">     * @param other the other GreasedRegion to insert</span>
<span class="source-line-no">1714</span><span id="line.1714">     * @return this for chaining</span>
<span class="source-line-no">1715</span><span id="line.1715">     */</span>
<span class="source-line-no">1716</span><span id="line.1716">    public GreasedRegion insert(int x, int y, GreasedRegion other)</span>
<span class="source-line-no">1717</span><span id="line.1717">    {</span>
<span class="source-line-no">1718</span><span id="line.1718">        if(other == null || other.ySections &lt;= 0 || other.width &lt;= 0)</span>
<span class="source-line-no">1719</span><span id="line.1719">            return this;</span>
<span class="source-line-no">1720</span><span id="line.1720"></span>
<span class="source-line-no">1721</span><span id="line.1721">        int start = Math.max(0, x), len = Math.min(width, Math.min(other.width, other.width + x) - start),</span>
<span class="source-line-no">1722</span><span id="line.1722">        oys = other.ySections, jump = (y == 0) ? 0 : (y &lt; 0) ? -(-y &gt;&gt;&gt; 6) : (y &gt;&gt;&gt; 6), lily = (y &lt; 0) ? -(-y &amp; 63) : (y &amp; 63),</span>
<span class="source-line-no">1723</span><span id="line.1723">        originalJump = Math.max(0, -jump), alterJump = Math.max(0, jump);</span>
<span class="source-line-no">1724</span><span id="line.1724">        long[] data2 = new long[other.width * ySections];</span>
<span class="source-line-no">1725</span><span id="line.1725"></span>
<span class="source-line-no">1726</span><span id="line.1726">        long prev, tmp;</span>
<span class="source-line-no">1727</span><span id="line.1727">        if(oys == ySections) {</span>
<span class="source-line-no">1728</span><span id="line.1728">            if (x &lt; 0) {</span>
<span class="source-line-no">1729</span><span id="line.1729">                for (int i = alterJump, oi = originalJump; i &lt; ySections &amp;&amp; oi &lt; oys; i++, oi++) {</span>
<span class="source-line-no">1730</span><span id="line.1730">                    for (int j = Math.max(0, -x), jj = 0; jj &lt; len; j++, jj++) {</span>
<span class="source-line-no">1731</span><span id="line.1731">                        data2[jj * ySections + i] = other.data[j * oys + oi];</span>
<span class="source-line-no">1732</span><span id="line.1732">                    }</span>
<span class="source-line-no">1733</span><span id="line.1733">                }</span>
<span class="source-line-no">1734</span><span id="line.1734">            } else if (x &gt; 0) {</span>
<span class="source-line-no">1735</span><span id="line.1735">                for (int i = alterJump, oi = originalJump; i &lt; ySections &amp;&amp; oi &lt; oys; i++, oi++) {</span>
<span class="source-line-no">1736</span><span id="line.1736">                    for (int j = 0, jj = start; j &lt; len; j++, jj++) {</span>
<span class="source-line-no">1737</span><span id="line.1737">                        data2[jj * ySections + i] = other.data[j * ySections + oi];</span>
<span class="source-line-no">1738</span><span id="line.1738">                    }</span>
<span class="source-line-no">1739</span><span id="line.1739">                }</span>
<span class="source-line-no">1740</span><span id="line.1740">            } else {</span>
<span class="source-line-no">1741</span><span id="line.1741">                for (int i = alterJump, oi = originalJump; i &lt; ySections &amp;&amp; oi &lt; oys; i++, oi++) {</span>
<span class="source-line-no">1742</span><span id="line.1742">                    for (int j = 0; j &lt; len; j++) {</span>
<span class="source-line-no">1743</span><span id="line.1743">                        data2[j * ySections + i] = other.data[j * ySections + oi];</span>
<span class="source-line-no">1744</span><span id="line.1744">                    }</span>
<span class="source-line-no">1745</span><span id="line.1745">                }</span>
<span class="source-line-no">1746</span><span id="line.1746">            }</span>
<span class="source-line-no">1747</span><span id="line.1747">        }</span>
<span class="source-line-no">1748</span><span id="line.1748">        else if(oys &lt; ySections)</span>
<span class="source-line-no">1749</span><span id="line.1749">        {</span>
<span class="source-line-no">1750</span><span id="line.1750">            if (x &lt; 0) {</span>
<span class="source-line-no">1751</span><span id="line.1751">                for (int i = alterJump, oi = originalJump; i &lt; ySections &amp;&amp; oi &lt; oys; i++, oi++) {</span>
<span class="source-line-no">1752</span><span id="line.1752">                    for (int j = Math.max(0, -x), jj = 0; jj &lt; len; j++, jj++) {</span>
<span class="source-line-no">1753</span><span id="line.1753">                        data2[jj * ySections + i] = other.data[j * oys + oi];</span>
<span class="source-line-no">1754</span><span id="line.1754">                    }</span>
<span class="source-line-no">1755</span><span id="line.1755">                }</span>
<span class="source-line-no">1756</span><span id="line.1756">            } else if (x &gt; 0) {</span>
<span class="source-line-no">1757</span><span id="line.1757">                for (int i = alterJump, oi = originalJump; i &lt; ySections &amp;&amp; oi &lt; oys; i++, oi++) {// oi &lt; oys - Math.max(0, jump)</span>
<span class="source-line-no">1758</span><span id="line.1758">                    for (int j = 0, jj = start; j &lt; len; j++, jj++) {</span>
<span class="source-line-no">1759</span><span id="line.1759">                        data2[jj * ySections + i] = other.data[j * oys + oi];</span>
<span class="source-line-no">1760</span><span id="line.1760">                    }</span>
<span class="source-line-no">1761</span><span id="line.1761">                }</span>
<span class="source-line-no">1762</span><span id="line.1762">            } else {</span>
<span class="source-line-no">1763</span><span id="line.1763">                for (int i = alterJump, oi = originalJump; i &lt; ySections &amp;&amp; oi &lt; oys; i++, oi++) {</span>
<span class="source-line-no">1764</span><span id="line.1764">                    for (int j = 0; j &lt; len; j++) {</span>
<span class="source-line-no">1765</span><span id="line.1765">                        data2[j * ySections + i] = other.data[j * oys + oi];</span>
<span class="source-line-no">1766</span><span id="line.1766">                    }</span>
<span class="source-line-no">1767</span><span id="line.1767">                }</span>
<span class="source-line-no">1768</span><span id="line.1768">            }</span>
<span class="source-line-no">1769</span><span id="line.1769">        }</span>
<span class="source-line-no">1770</span><span id="line.1770">        else</span>
<span class="source-line-no">1771</span><span id="line.1771">        {</span>
<span class="source-line-no">1772</span><span id="line.1772">            if (x &lt; 0) {</span>
<span class="source-line-no">1773</span><span id="line.1773">                for (int i = alterJump, oi = originalJump; i &lt; ySections &amp;&amp; oi &lt; oys; i++, oi++) {</span>
<span class="source-line-no">1774</span><span id="line.1774">                    for (int j = Math.max(0, -x), jj = 0; jj &lt; len; j++, jj++) {</span>
<span class="source-line-no">1775</span><span id="line.1775">                        data2[jj * ySections + i] = other.data[j * oys + oi];</span>
<span class="source-line-no">1776</span><span id="line.1776">                    }</span>
<span class="source-line-no">1777</span><span id="line.1777">                }</span>
<span class="source-line-no">1778</span><span id="line.1778">            } else if (x &gt; 0) {</span>
<span class="source-line-no">1779</span><span id="line.1779">                for (int i = alterJump, oi = originalJump; i &lt; ySections &amp;&amp; oi &lt; oys; i++, oi++) {</span>
<span class="source-line-no">1780</span><span id="line.1780">                    for (int j = 0, jj = start; j &lt; len; j++, jj++) {</span>
<span class="source-line-no">1781</span><span id="line.1781">                        data2[jj * ySections + i] = other.data[j * oys + oi];</span>
<span class="source-line-no">1782</span><span id="line.1782">                    }</span>
<span class="source-line-no">1783</span><span id="line.1783">                }</span>
<span class="source-line-no">1784</span><span id="line.1784">            } else {</span>
<span class="source-line-no">1785</span><span id="line.1785">                for (int i = alterJump, oi = originalJump; i &lt; ySections &amp;&amp; oi &lt; oys; i++, oi++) {</span>
<span class="source-line-no">1786</span><span id="line.1786">                    for (int j = 0; j &lt; len; j++) {</span>
<span class="source-line-no">1787</span><span id="line.1787">                        data2[j * ySections + i] = other.data[j * oys + oi];</span>
<span class="source-line-no">1788</span><span id="line.1788">                    }</span>
<span class="source-line-no">1789</span><span id="line.1789">                }</span>
<span class="source-line-no">1790</span><span id="line.1790">            }</span>
<span class="source-line-no">1791</span><span id="line.1791">        }</span>
<span class="source-line-no">1792</span><span id="line.1792"></span>
<span class="source-line-no">1793</span><span id="line.1793">        if(lily &lt; 0) {</span>
<span class="source-line-no">1794</span><span id="line.1794">            for (int i = start; i &lt; len; i++) {</span>
<span class="source-line-no">1795</span><span id="line.1795">                prev = 0L;</span>
<span class="source-line-no">1796</span><span id="line.1796">                for (int j = 0; j &lt; ySections; j++) {</span>
<span class="source-line-no">1797</span><span id="line.1797">                    tmp = prev;</span>
<span class="source-line-no">1798</span><span id="line.1798">                    prev = (data2[i * ySections + j] &amp; ~(-1L &lt;&lt; -lily)) &lt;&lt; (64 + lily);</span>
<span class="source-line-no">1799</span><span id="line.1799">                    data2[i * ySections + j] &gt;&gt;&gt;= -lily;</span>
<span class="source-line-no">1800</span><span id="line.1800">                    data2[i * ySections + j] |= tmp;</span>
<span class="source-line-no">1801</span><span id="line.1801">                }</span>
<span class="source-line-no">1802</span><span id="line.1802">            }</span>
<span class="source-line-no">1803</span><span id="line.1803">        }</span>
<span class="source-line-no">1804</span><span id="line.1804">        else if(lily &gt; 0) {</span>
<span class="source-line-no">1805</span><span id="line.1805">            for (int i = start; i &lt; start + len; i++) {</span>
<span class="source-line-no">1806</span><span id="line.1806">                prev = 0L;</span>
<span class="source-line-no">1807</span><span id="line.1807">                for (int j = 0; j &lt; ySections; j++) {</span>
<span class="source-line-no">1808</span><span id="line.1808">                    tmp = prev;</span>
<span class="source-line-no">1809</span><span id="line.1809">                    prev = (data2[i * ySections + j] &amp; ~(-1L &gt;&gt;&gt; lily)) &gt;&gt;&gt; (64 - lily);</span>
<span class="source-line-no">1810</span><span id="line.1810">                    data2[i * ySections + j] &lt;&lt;= lily;</span>
<span class="source-line-no">1811</span><span id="line.1811">                    data2[i * ySections + j] |= tmp;</span>
<span class="source-line-no">1812</span><span id="line.1812">                }</span>
<span class="source-line-no">1813</span><span id="line.1813">            }</span>
<span class="source-line-no">1814</span><span id="line.1814">        }</span>
<span class="source-line-no">1815</span><span id="line.1815">        len = Math.min(width, start + len);</span>
<span class="source-line-no">1816</span><span id="line.1816">        for (int i = start; i &lt; len; i++) {</span>
<span class="source-line-no">1817</span><span id="line.1817">            for (int j = 0; j &lt; ySections; j++) {</span>
<span class="source-line-no">1818</span><span id="line.1818">                data[i * ySections + j] |= data2[i * ySections + j];</span>
<span class="source-line-no">1819</span><span id="line.1819">            }</span>
<span class="source-line-no">1820</span><span id="line.1820">        }</span>
<span class="source-line-no">1821</span><span id="line.1821"></span>
<span class="source-line-no">1822</span><span id="line.1822">        if(ySections &gt; 0 &amp;&amp; yEndMask != -1) {</span>
<span class="source-line-no">1823</span><span id="line.1823">            for (int a = ySections - 1; a &lt; data.length; a += ySections) {</span>
<span class="source-line-no">1824</span><span id="line.1824">                data[a] &amp;= yEndMask;</span>
<span class="source-line-no">1825</span><span id="line.1825">            }</span>
<span class="source-line-no">1826</span><span id="line.1826">        }</span>
<span class="source-line-no">1827</span><span id="line.1827">        tallied = false;</span>
<span class="source-line-no">1828</span><span id="line.1828">        return this;</span>
<span class="source-line-no">1829</span><span id="line.1829">    }</span>
<span class="source-line-no">1830</span><span id="line.1830"></span>
<span class="source-line-no">1831</span><span id="line.1831">    public GreasedRegion insertSeveral(Coord... points)</span>
<span class="source-line-no">1832</span><span id="line.1832">    {</span>
<span class="source-line-no">1833</span><span id="line.1833">        for (int i = 0, x, y; i &lt; points.length; i++) {</span>
<span class="source-line-no">1834</span><span id="line.1834">            x = points[i].x;</span>
<span class="source-line-no">1835</span><span id="line.1835">            y = points[i].y;</span>
<span class="source-line-no">1836</span><span id="line.1836">            if(x &lt; width &amp;&amp; y &lt; height &amp;&amp; x &gt;= 0 &amp;&amp; y &gt;= 0)</span>
<span class="source-line-no">1837</span><span id="line.1837">            {</span>
<span class="source-line-no">1838</span><span id="line.1838">                data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">1839</span><span id="line.1839">                tallied = false;</span>
<span class="source-line-no">1840</span><span id="line.1840">            }</span>
<span class="source-line-no">1841</span><span id="line.1841">        }</span>
<span class="source-line-no">1842</span><span id="line.1842">        return this;</span>
<span class="source-line-no">1843</span><span id="line.1843">    }</span>
<span class="source-line-no">1844</span><span id="line.1844"></span>
<span class="source-line-no">1845</span><span id="line.1845">    public GreasedRegion insertSeveral(final int[] points)</span>
<span class="source-line-no">1846</span><span id="line.1846">    {</span>
<span class="source-line-no">1847</span><span id="line.1847">        for (int i = 0, tight; i &lt; points.length; i++) {</span>
<span class="source-line-no">1848</span><span id="line.1848">            tight = points[i];</span>
<span class="source-line-no">1849</span><span id="line.1849">            if(tight &lt; width * height &amp;&amp; tight &gt;= 0)</span>
<span class="source-line-no">1850</span><span id="line.1850">            {</span>
<span class="source-line-no">1851</span><span id="line.1851">                data[(tight % width) * ySections + ((tight / width) &gt;&gt;&gt; 6)] |= 1L &lt;&lt; ((tight / width) &amp; 63);</span>
<span class="source-line-no">1852</span><span id="line.1852">                tallied = false;</span>
<span class="source-line-no">1853</span><span id="line.1853">            }</span>
<span class="source-line-no">1854</span><span id="line.1854">        }</span>
<span class="source-line-no">1855</span><span id="line.1855">        return this;</span>
<span class="source-line-no">1856</span><span id="line.1856">    }</span>
<span class="source-line-no">1857</span><span id="line.1857"></span>
<span class="source-line-no">1858</span><span id="line.1858">    public GreasedRegion insertSeveral(Iterable&lt;Coord&gt; points)</span>
<span class="source-line-no">1859</span><span id="line.1859">    {</span>
<span class="source-line-no">1860</span><span id="line.1860">        int x, y;</span>
<span class="source-line-no">1861</span><span id="line.1861">        for (Coord pt : points) {</span>
<span class="source-line-no">1862</span><span id="line.1862">            x = pt.x;</span>
<span class="source-line-no">1863</span><span id="line.1863">            y = pt.y;</span>
<span class="source-line-no">1864</span><span id="line.1864">            if(x &lt; width &amp;&amp; y &lt; height &amp;&amp; x &gt;= 0 &amp;&amp; y &gt;= 0)</span>
<span class="source-line-no">1865</span><span id="line.1865">            {</span>
<span class="source-line-no">1866</span><span id="line.1866">                data[x * ySections + (y &gt;&gt; 6)] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">1867</span><span id="line.1867">                tallied = false;</span>
<span class="source-line-no">1868</span><span id="line.1868">            }</span>
<span class="source-line-no">1869</span><span id="line.1869">        }</span>
<span class="source-line-no">1870</span><span id="line.1870">        return this;</span>
<span class="source-line-no">1871</span><span id="line.1871">    }</span>
<span class="source-line-no">1872</span><span id="line.1872"></span>
<span class="source-line-no">1873</span><span id="line.1873">    public GreasedRegion insertRectangle(int startX, int startY, int rectangleWidth, int rectangleHeight)</span>
<span class="source-line-no">1874</span><span id="line.1874">    {</span>
<span class="source-line-no">1875</span><span id="line.1875">        if(rectangleWidth &lt; 1 || rectangleHeight &lt; 1 || ySections &lt;= 0)</span>
<span class="source-line-no">1876</span><span id="line.1876">            return this;</span>
<span class="source-line-no">1877</span><span id="line.1877">        if(startX &lt; 0)</span>
<span class="source-line-no">1878</span><span id="line.1878">            startX = 0;</span>
<span class="source-line-no">1879</span><span id="line.1879">        else if(startX &gt;= width)</span>
<span class="source-line-no">1880</span><span id="line.1880">            startX = width - 1;</span>
<span class="source-line-no">1881</span><span id="line.1881">        if(startY &lt; 0)</span>
<span class="source-line-no">1882</span><span id="line.1882">            startY = 0;</span>
<span class="source-line-no">1883</span><span id="line.1883">        else if(startY &gt;= height)</span>
<span class="source-line-no">1884</span><span id="line.1884">            startY = height - 1;</span>
<span class="source-line-no">1885</span><span id="line.1885">        int endX = Math.min(width, startX + rectangleWidth) - 1,</span>
<span class="source-line-no">1886</span><span id="line.1886">                endY = Math.min(height, startY + rectangleHeight) - 1,</span>
<span class="source-line-no">1887</span><span id="line.1887">                startSection = startY &gt;&gt; 6, endSection = endY &gt;&gt; 6;</span>
<span class="source-line-no">1888</span><span id="line.1888">        if(startSection &lt; endSection)</span>
<span class="source-line-no">1889</span><span id="line.1889">        {</span>
<span class="source-line-no">1890</span><span id="line.1890">            long startMask = -1L &lt;&lt; (startY &amp; 63),</span>
<span class="source-line-no">1891</span><span id="line.1891">                    endMask = -1L &gt;&gt;&gt; (~endY &amp; 63);</span>
<span class="source-line-no">1892</span><span id="line.1892">            for (int a = startX * ySections + startSection; a &lt;= endX * ySections + startSection; a += ySections) {</span>
<span class="source-line-no">1893</span><span id="line.1893">                data[a] |= startMask;</span>
<span class="source-line-no">1894</span><span id="line.1894">            }</span>
<span class="source-line-no">1895</span><span id="line.1895">            if(endSection - startSection &gt; 1)</span>
<span class="source-line-no">1896</span><span id="line.1896">            {</span>
<span class="source-line-no">1897</span><span id="line.1897">                for (int b = 1; b &lt; endSection - startSection; b++) {</span>
<span class="source-line-no">1898</span><span id="line.1898">                    for (int a = startX * ySections + startSection + b; a &lt; endX * ySections + ySections; a += ySections) {</span>
<span class="source-line-no">1899</span><span id="line.1899">                        data[a] = -1;</span>
<span class="source-line-no">1900</span><span id="line.1900">                    }</span>
<span class="source-line-no">1901</span><span id="line.1901">                }</span>
<span class="source-line-no">1902</span><span id="line.1902">            }</span>
<span class="source-line-no">1903</span><span id="line.1903">            for (int a = startX * ySections + endSection; a &lt;= endX * ySections + endSection; a += ySections) {</span>
<span class="source-line-no">1904</span><span id="line.1904">                data[a] |= endMask;</span>
<span class="source-line-no">1905</span><span id="line.1905">            }</span>
<span class="source-line-no">1906</span><span id="line.1906">        }</span>
<span class="source-line-no">1907</span><span id="line.1907">        else</span>
<span class="source-line-no">1908</span><span id="line.1908">        {</span>
<span class="source-line-no">1909</span><span id="line.1909">            long mask = (-1L &lt;&lt; (startY &amp; 63)) &amp; (-1L &gt;&gt;&gt; (~endY &amp; 63));</span>
<span class="source-line-no">1910</span><span id="line.1910">            for (int a = startX * ySections + startSection; a &lt;= endX * ySections + startSection; a += ySections) {</span>
<span class="source-line-no">1911</span><span id="line.1911">                data[a] |= mask;</span>
<span class="source-line-no">1912</span><span id="line.1912">            }</span>
<span class="source-line-no">1913</span><span id="line.1913">        }</span>
<span class="source-line-no">1914</span><span id="line.1914"></span>
<span class="source-line-no">1915</span><span id="line.1915">        if(yEndMask != -1L) {</span>
<span class="source-line-no">1916</span><span id="line.1916">            for (int a = ySections - 1; a &lt; data.length; a += ySections) {</span>
<span class="source-line-no">1917</span><span id="line.1917">                data[a] &amp;= yEndMask;</span>
<span class="source-line-no">1918</span><span id="line.1918">            }</span>
<span class="source-line-no">1919</span><span id="line.1919">        }</span>
<span class="source-line-no">1920</span><span id="line.1920">        tallied = false;</span>
<span class="source-line-no">1921</span><span id="line.1921">        return this;</span>
<span class="source-line-no">1922</span><span id="line.1922">    }</span>
<span class="source-line-no">1923</span><span id="line.1923"></span>
<span class="source-line-no">1924</span><span id="line.1924">    public GreasedRegion insertCircle(Coord center, int radius)</span>
<span class="source-line-no">1925</span><span id="line.1925">    {</span>
<span class="source-line-no">1926</span><span id="line.1926">        float high, changedX;</span>
<span class="source-line-no">1927</span><span id="line.1927">        int rndX, rndY;</span>
<span class="source-line-no">1928</span><span id="line.1928">        for (int dx = -radius; dx &lt;= radius; ++dx) {</span>
<span class="source-line-no">1929</span><span id="line.1929">            changedX = dx - 0.25f * (dx &gt;&gt; 31 | -dx &gt;&gt;&gt; 31); // project nayuki signum</span>
<span class="source-line-no">1930</span><span id="line.1930">            rndX = Math.round(changedX);</span>
<span class="source-line-no">1931</span><span id="line.1931">            high = (float) Math.sqrt(radius * radius - changedX * changedX);             </span>
<span class="source-line-no">1932</span><span id="line.1932">            insert(center.x + rndX, center.y);</span>
<span class="source-line-no">1933</span><span id="line.1933">            for (float dy = high; dy &gt;= 0.75f; --dy) {</span>
<span class="source-line-no">1934</span><span id="line.1934">                rndY = Math.round(dy - 0.25f);                 </span>
<span class="source-line-no">1935</span><span id="line.1935">                insert(center.x + rndX, center.y + rndY);</span>
<span class="source-line-no">1936</span><span id="line.1936">                insert(center.x + rndX, center.y - rndY);</span>
<span class="source-line-no">1937</span><span id="line.1937">            }</span>
<span class="source-line-no">1938</span><span id="line.1938">        }</span>
<span class="source-line-no">1939</span><span id="line.1939">        return this;</span>
<span class="source-line-no">1940</span><span id="line.1940">    }</span>
<span class="source-line-no">1941</span><span id="line.1941"></span>
<span class="source-line-no">1942</span><span id="line.1942">    public GreasedRegion remove(int x, int y)</span>
<span class="source-line-no">1943</span><span id="line.1943">    {</span>
<span class="source-line-no">1944</span><span id="line.1944">        if(x &lt; width &amp;&amp; y &lt; height &amp;&amp; x &gt;= 0 &amp;&amp; y &gt;= 0)</span>
<span class="source-line-no">1945</span><span id="line.1945">        {</span>
<span class="source-line-no">1946</span><span id="line.1946">            data[x * ySections + (y &gt;&gt; 6)] &amp;= ~(1L &lt;&lt; (y &amp; 63));</span>
<span class="source-line-no">1947</span><span id="line.1947">            tallied = false;</span>
<span class="source-line-no">1948</span><span id="line.1948">        }</span>
<span class="source-line-no">1949</span><span id="line.1949">        return this;</span>
<span class="source-line-no">1950</span><span id="line.1950">    }</span>
<span class="source-line-no">1951</span><span id="line.1951">    public GreasedRegion remove(Coord point)</span>
<span class="source-line-no">1952</span><span id="line.1952">    {</span>
<span class="source-line-no">1953</span><span id="line.1953">        return remove(point.x, point.y);</span>
<span class="source-line-no">1954</span><span id="line.1954">    }</span>
<span class="source-line-no">1955</span><span id="line.1955">    /**</span>
<span class="source-line-no">1956</span><span id="line.1956">     * Takes another GreasedRegion, called other, with potentially different size and removes its "on" cells from this</span>
<span class="source-line-no">1957</span><span id="line.1957">     * GreasedRegion at the given x,y offset, allowing negative x and/or y to remove only part of other in this.</span>
<span class="source-line-no">1958</span><span id="line.1958">     * &lt;br&gt;</span>
<span class="source-line-no">1959</span><span id="line.1959">     * This is a rather complex method internally, but should be about as efficient as a general remove-region method</span>
<span class="source-line-no">1960</span><span id="line.1960">     * can be. The code is identical to {@link #insert(int, int, GreasedRegion)} except that where insert only adds</span>
<span class="source-line-no">1961</span><span id="line.1961">     * cells, this only removes cells. Essentially, insert() is to {@link #or(GreasedRegion)} as remove() is to</span>
<span class="source-line-no">1962</span><span id="line.1962">     * {@link #andNot(GreasedRegion)}.</span>
<span class="source-line-no">1963</span><span id="line.1963">     * @param x the x offset to start removing other from; may be negative</span>
<span class="source-line-no">1964</span><span id="line.1964">     * @param y the y offset to start removing other from; may be negative</span>
<span class="source-line-no">1965</span><span id="line.1965">     * @param other the other GreasedRegion to remove</span>
<span class="source-line-no">1966</span><span id="line.1966">     * @return this for chaining</span>
<span class="source-line-no">1967</span><span id="line.1967">     */</span>
<span class="source-line-no">1968</span><span id="line.1968">    public GreasedRegion remove(int x, int y, GreasedRegion other)</span>
<span class="source-line-no">1969</span><span id="line.1969">    {</span>
<span class="source-line-no">1970</span><span id="line.1970">        if(other == null || other.ySections &lt;= 0 || other.width &lt;= 0)</span>
<span class="source-line-no">1971</span><span id="line.1971">            return this;</span>
<span class="source-line-no">1972</span><span id="line.1972"></span>
<span class="source-line-no">1973</span><span id="line.1973">        int start = Math.max(0, x), len = Math.min(width, Math.min(other.width, other.width + x) - start),</span>
<span class="source-line-no">1974</span><span id="line.1974">                oys = other.ySections, jump = (y == 0) ? 0 : (y &lt; 0) ? -(-y &gt;&gt;&gt; 6) : (y-1 &gt;&gt;&gt; 6), lily = (y &lt; 0) ? -(-y &amp; 63) : (y &amp; 63),</span>
<span class="source-line-no">1975</span><span id="line.1975">                originalJump = Math.max(0, -jump), alterJump = Math.max(0, jump);</span>
<span class="source-line-no">1976</span><span id="line.1976">        long[] data2 = new long[other.width * ySections];</span>
<span class="source-line-no">1977</span><span id="line.1977"></span>
<span class="source-line-no">1978</span><span id="line.1978">        long prev, tmp;</span>
<span class="source-line-no">1979</span><span id="line.1979">        if(oys == ySections) {</span>
<span class="source-line-no">1980</span><span id="line.1980">            if (x &lt; 0) {</span>
<span class="source-line-no">1981</span><span id="line.1981">                for (int i = alterJump, oi = originalJump; i &lt; ySections &amp;&amp; oi &lt; oys; i++, oi++) {</span>
<span class="source-line-no">1982</span><span id="line.1982">                    for (int j = Math.max(0, -x), jj = 0; jj &lt; len; j++, jj++) {</span>
<span class="source-line-no">1983</span><span id="line.1983">                        data2[jj * ySections + i] = other.data[j * oys + oi];</span>
<span class="source-line-no">1984</span><span id="line.1984">                    }</span>
<span class="source-line-no">1985</span><span id="line.1985">                }</span>
<span class="source-line-no">1986</span><span id="line.1986">            } else if (x &gt; 0) {</span>
<span class="source-line-no">1987</span><span id="line.1987">                for (int i = alterJump, oi = originalJump; i &lt; ySections &amp;&amp; oi &lt; oys; i++, oi++) {</span>
<span class="source-line-no">1988</span><span id="line.1988">                    for (int j = 0, jj = start; j &lt; len; j++, jj++) {</span>
<span class="source-line-no">1989</span><span id="line.1989">                        data2[jj * ySections + i] = other.data[j * ySections + oi];</span>
<span class="source-line-no">1990</span><span id="line.1990">                    }</span>
<span class="source-line-no">1991</span><span id="line.1991">                }</span>
<span class="source-line-no">1992</span><span id="line.1992">            } else {</span>
<span class="source-line-no">1993</span><span id="line.1993">                for (int i = alterJump, oi = originalJump; i &lt; ySections &amp;&amp; oi &lt; oys; i++, oi++) {</span>
<span class="source-line-no">1994</span><span id="line.1994">                    for (int j = 0; j &lt; len; j++) {</span>
<span class="source-line-no">1995</span><span id="line.1995">                        data2[j * ySections + i] = other.data[j * ySections + oi];</span>
<span class="source-line-no">1996</span><span id="line.1996">                    }</span>
<span class="source-line-no">1997</span><span id="line.1997">                }</span>
<span class="source-line-no">1998</span><span id="line.1998">            }</span>
<span class="source-line-no">1999</span><span id="line.1999">        }</span>
<span class="source-line-no">2000</span><span id="line.2000">        else if(oys &lt; ySections)</span>
<span class="source-line-no">2001</span><span id="line.2001">        {</span>
<span class="source-line-no">2002</span><span id="line.2002">            if (x &lt; 0) {</span>
<span class="source-line-no">2003</span><span id="line.2003">                for (int i = alterJump, oi = originalJump; i &lt; ySections &amp;&amp; oi &lt; oys; i++, oi++) {</span>
<span class="source-line-no">2004</span><span id="line.2004">                    for (int j = Math.max(0, -x), jj = 0; jj &lt; len; j++, jj++) {</span>
<span class="source-line-no">2005</span><span id="line.2005">                        data2[jj * ySections + i] = other.data[j * oys + oi];</span>
<span class="source-line-no">2006</span><span id="line.2006">                    }</span>
<span class="source-line-no">2007</span><span id="line.2007">                }</span>
<span class="source-line-no">2008</span><span id="line.2008">            } else if (x &gt; 0) {</span>
<span class="source-line-no">2009</span><span id="line.2009">                for (int i = alterJump, oi = originalJump; i &lt; ySections &amp;&amp; oi &lt; oys; i++, oi++) {// oi &lt; oys - Math.max(0, jump)</span>
<span class="source-line-no">2010</span><span id="line.2010">                    for (int j = 0, jj = start; j &lt; len; j++, jj++) {</span>
<span class="source-line-no">2011</span><span id="line.2011">                        data2[jj * ySections + i] = other.data[j * oys + oi];</span>
<span class="source-line-no">2012</span><span id="line.2012">                    }</span>
<span class="source-line-no">2013</span><span id="line.2013">                }</span>
<span class="source-line-no">2014</span><span id="line.2014">            } else {</span>
<span class="source-line-no">2015</span><span id="line.2015">                for (int i = alterJump, oi = originalJump; i &lt; ySections &amp;&amp; oi &lt; oys; i++, oi++) {</span>
<span class="source-line-no">2016</span><span id="line.2016">                    for (int j = 0; j &lt; len; j++) {</span>
<span class="source-line-no">2017</span><span id="line.2017">                        data2[j * ySections + i] = other.data[j * oys + oi];</span>
<span class="source-line-no">2018</span><span id="line.2018">                    }</span>
<span class="source-line-no">2019</span><span id="line.2019">                }</span>
<span class="source-line-no">2020</span><span id="line.2020">            }</span>
<span class="source-line-no">2021</span><span id="line.2021">        }</span>
<span class="source-line-no">2022</span><span id="line.2022">        else</span>
<span class="source-line-no">2023</span><span id="line.2023">        {</span>
<span class="source-line-no">2024</span><span id="line.2024">            if (x &lt; 0) {</span>
<span class="source-line-no">2025</span><span id="line.2025">                for (int i = alterJump, oi = originalJump; i &lt; ySections &amp;&amp; oi &lt; oys; i++, oi++) {</span>
<span class="source-line-no">2026</span><span id="line.2026">                    for (int j = Math.max(0, -x), jj = 0; jj &lt; len; j++, jj++) {</span>
<span class="source-line-no">2027</span><span id="line.2027">                        data2[jj * ySections + i] = other.data[j * oys + oi];</span>
<span class="source-line-no">2028</span><span id="line.2028">                    }</span>
<span class="source-line-no">2029</span><span id="line.2029">                }</span>
<span class="source-line-no">2030</span><span id="line.2030">            } else if (x &gt; 0) {</span>
<span class="source-line-no">2031</span><span id="line.2031">                for (int i = alterJump, oi = originalJump; i &lt; ySections &amp;&amp; oi &lt; oys; i++, oi++) {</span>
<span class="source-line-no">2032</span><span id="line.2032">                    for (int j = 0, jj = start; j &lt; len; j++, jj++) {</span>
<span class="source-line-no">2033</span><span id="line.2033">                        data2[jj * ySections + i] = other.data[j * oys + oi];</span>
<span class="source-line-no">2034</span><span id="line.2034">                    }</span>
<span class="source-line-no">2035</span><span id="line.2035">                }</span>
<span class="source-line-no">2036</span><span id="line.2036">            } else {</span>
<span class="source-line-no">2037</span><span id="line.2037">                for (int i = alterJump, oi = originalJump; i &lt; ySections &amp;&amp; oi &lt; oys; i++, oi++) {</span>
<span class="source-line-no">2038</span><span id="line.2038">                    for (int j = 0; j &lt; len; j++) {</span>
<span class="source-line-no">2039</span><span id="line.2039">                        data2[j * ySections + i] = other.data[j * oys + oi];</span>
<span class="source-line-no">2040</span><span id="line.2040">                    }</span>
<span class="source-line-no">2041</span><span id="line.2041">                }</span>
<span class="source-line-no">2042</span><span id="line.2042">            }</span>
<span class="source-line-no">2043</span><span id="line.2043">        }</span>
<span class="source-line-no">2044</span><span id="line.2044"></span>
<span class="source-line-no">2045</span><span id="line.2045">        if(lily &lt; 0) {</span>
<span class="source-line-no">2046</span><span id="line.2046">            for (int i = start; i &lt; len; i++) {</span>
<span class="source-line-no">2047</span><span id="line.2047">                prev = 0L;</span>
<span class="source-line-no">2048</span><span id="line.2048">                for (int j = 0; j &lt; ySections; j++) {</span>
<span class="source-line-no">2049</span><span id="line.2049">                    tmp = prev;</span>
<span class="source-line-no">2050</span><span id="line.2050">                    prev = (data2[i * ySections + j] &amp; ~(-1L &lt;&lt; -lily)) &lt;&lt; (64 + lily);</span>
<span class="source-line-no">2051</span><span id="line.2051">                    data2[i * ySections + j] &gt;&gt;&gt;= -lily;</span>
<span class="source-line-no">2052</span><span id="line.2052">                    data2[i * ySections + j] |= tmp;</span>
<span class="source-line-no">2053</span><span id="line.2053">                }</span>
<span class="source-line-no">2054</span><span id="line.2054">            }</span>
<span class="source-line-no">2055</span><span id="line.2055">        }</span>
<span class="source-line-no">2056</span><span id="line.2056">        else if(lily &gt; 0) {</span>
<span class="source-line-no">2057</span><span id="line.2057">            for (int i = start; i &lt; start + len; i++) {</span>
<span class="source-line-no">2058</span><span id="line.2058">                prev = 0L;</span>
<span class="source-line-no">2059</span><span id="line.2059">                for (int j = 0; j &lt; ySections; j++) {</span>
<span class="source-line-no">2060</span><span id="line.2060">                    tmp = prev;</span>
<span class="source-line-no">2061</span><span id="line.2061">                    prev = (data2[i * ySections + j] &amp; ~(-1L &gt;&gt;&gt; lily)) &gt;&gt;&gt; (64 - lily);</span>
<span class="source-line-no">2062</span><span id="line.2062">                    data2[i * ySections + j] &lt;&lt;= lily;</span>
<span class="source-line-no">2063</span><span id="line.2063">                    data2[i * ySections + j] |= tmp;</span>
<span class="source-line-no">2064</span><span id="line.2064">                }</span>
<span class="source-line-no">2065</span><span id="line.2065">            }</span>
<span class="source-line-no">2066</span><span id="line.2066">        }</span>
<span class="source-line-no">2067</span><span id="line.2067">        len = Math.min(width, start + len);</span>
<span class="source-line-no">2068</span><span id="line.2068">        for (int i = start; i &lt; len; i++) {</span>
<span class="source-line-no">2069</span><span id="line.2069">            for (int j = 0; j &lt; ySections; j++) {</span>
<span class="source-line-no">2070</span><span id="line.2070">                data[i * ySections + j] &amp;= ~data2[i * ySections + j];</span>
<span class="source-line-no">2071</span><span id="line.2071">            }</span>
<span class="source-line-no">2072</span><span id="line.2072">        }</span>
<span class="source-line-no">2073</span><span id="line.2073"></span>
<span class="source-line-no">2074</span><span id="line.2074">        if(ySections &gt; 0 &amp;&amp; yEndMask != -1) {</span>
<span class="source-line-no">2075</span><span id="line.2075">            for (int a = ySections - 1; a &lt; data.length; a += ySections) {</span>
<span class="source-line-no">2076</span><span id="line.2076">                data[a] &amp;= yEndMask;</span>
<span class="source-line-no">2077</span><span id="line.2077">            }</span>
<span class="source-line-no">2078</span><span id="line.2078">        }</span>
<span class="source-line-no">2079</span><span id="line.2079">        tallied = false;</span>
<span class="source-line-no">2080</span><span id="line.2080"></span>
<span class="source-line-no">2081</span><span id="line.2081">        return this;</span>
<span class="source-line-no">2082</span><span id="line.2082">    }</span>
<span class="source-line-no">2083</span><span id="line.2083">    public GreasedRegion removeSeveral(Coord... points)</span>
<span class="source-line-no">2084</span><span id="line.2084">    {</span>
<span class="source-line-no">2085</span><span id="line.2085">        for (int i = 0, x, y; i &lt; points.length; i++) {</span>
<span class="source-line-no">2086</span><span id="line.2086">            x = points[i].x;</span>
<span class="source-line-no">2087</span><span id="line.2087">            y = points[i].y;</span>
<span class="source-line-no">2088</span><span id="line.2088">            if(x &lt; width &amp;&amp; y &lt; height &amp;&amp; x &gt;= 0 &amp;&amp; y &gt;= 0)</span>
<span class="source-line-no">2089</span><span id="line.2089">            {</span>
<span class="source-line-no">2090</span><span id="line.2090">                data[x * ySections + (y &gt;&gt; 6)] &amp;= ~(1L &lt;&lt; (y &amp; 63));</span>
<span class="source-line-no">2091</span><span id="line.2091">                tallied = false;</span>
<span class="source-line-no">2092</span><span id="line.2092">            }</span>
<span class="source-line-no">2093</span><span id="line.2093">        }</span>
<span class="source-line-no">2094</span><span id="line.2094">        return this;</span>
<span class="source-line-no">2095</span><span id="line.2095">    }</span>
<span class="source-line-no">2096</span><span id="line.2096"></span>
<span class="source-line-no">2097</span><span id="line.2097">    public GreasedRegion removeSeveral(Iterable&lt;Coord&gt; points)</span>
<span class="source-line-no">2098</span><span id="line.2098">    {</span>
<span class="source-line-no">2099</span><span id="line.2099">        int x, y;</span>
<span class="source-line-no">2100</span><span id="line.2100">        for (Coord pt : points) {</span>
<span class="source-line-no">2101</span><span id="line.2101">            x = pt.x;</span>
<span class="source-line-no">2102</span><span id="line.2102">            y = pt.y;</span>
<span class="source-line-no">2103</span><span id="line.2103">            if(x &lt; width &amp;&amp; y &lt; height &amp;&amp; x &gt;= 0 &amp;&amp; y &gt;= 0)</span>
<span class="source-line-no">2104</span><span id="line.2104">            {</span>
<span class="source-line-no">2105</span><span id="line.2105">                data[x * ySections + (y &gt;&gt; 6)] &amp;= ~(1L &lt;&lt; (y &amp; 63));</span>
<span class="source-line-no">2106</span><span id="line.2106">                tallied = false;</span>
<span class="source-line-no">2107</span><span id="line.2107">            }</span>
<span class="source-line-no">2108</span><span id="line.2108">        }</span>
<span class="source-line-no">2109</span><span id="line.2109">        return this;</span>
<span class="source-line-no">2110</span><span id="line.2110">    }</span>
<span class="source-line-no">2111</span><span id="line.2111"></span>
<span class="source-line-no">2112</span><span id="line.2112">    /**</span>
<span class="source-line-no">2113</span><span id="line.2113">     * Removes all "on" cells from (startX, startY) inclusive </span>
<span class="source-line-no">2114</span><span id="line.2114">     * to (startX+rectangleWidth, startY+rectangleHeight) exclusive, removing a total width of rectangleWidth and a</span>
<span class="source-line-no">2115</span><span id="line.2115">     * total height of rectangleHeight in cells.</span>
<span class="source-line-no">2116</span><span id="line.2116">     * @param startX left side x-coordinate</span>
<span class="source-line-no">2117</span><span id="line.2117">     * @param startY top side (or bottom if positive y is up) y-coordinate</span>
<span class="source-line-no">2118</span><span id="line.2118">     * @param rectangleWidth how many cells wide the area to remove is</span>
<span class="source-line-no">2119</span><span id="line.2119">     * @param rectangleHeight how many cells tal the area to remove is</span>
<span class="source-line-no">2120</span><span id="line.2120">     * @return this, after modification, for chaining</span>
<span class="source-line-no">2121</span><span id="line.2121">     */</span>
<span class="source-line-no">2122</span><span id="line.2122">    public GreasedRegion removeRectangle(int startX, int startY, int rectangleWidth, int rectangleHeight)</span>
<span class="source-line-no">2123</span><span id="line.2123">    {</span>
<span class="source-line-no">2124</span><span id="line.2124">        if(startX &lt; 0)</span>
<span class="source-line-no">2125</span><span id="line.2125">        {</span>
<span class="source-line-no">2126</span><span id="line.2126">            rectangleWidth += startX;</span>
<span class="source-line-no">2127</span><span id="line.2127">            startX = 0;</span>
<span class="source-line-no">2128</span><span id="line.2128">        }</span>
<span class="source-line-no">2129</span><span id="line.2129">        else if(startX &gt;= width)</span>
<span class="source-line-no">2130</span><span id="line.2130">        {</span>
<span class="source-line-no">2131</span><span id="line.2131">            rectangleWidth = 1;</span>
<span class="source-line-no">2132</span><span id="line.2132">            startX = width - 1;</span>
<span class="source-line-no">2133</span><span id="line.2133">        }</span>
<span class="source-line-no">2134</span><span id="line.2134">        if(startY &lt; 0)</span>
<span class="source-line-no">2135</span><span id="line.2135">        {</span>
<span class="source-line-no">2136</span><span id="line.2136">            rectangleHeight += startY;</span>
<span class="source-line-no">2137</span><span id="line.2137">            startY = 0;</span>
<span class="source-line-no">2138</span><span id="line.2138">        }</span>
<span class="source-line-no">2139</span><span id="line.2139">        else if(startY &gt;= height)</span>
<span class="source-line-no">2140</span><span id="line.2140">        {</span>
<span class="source-line-no">2141</span><span id="line.2141">            rectangleHeight = 1;</span>
<span class="source-line-no">2142</span><span id="line.2142">            startY = height - 1;</span>
<span class="source-line-no">2143</span><span id="line.2143">        }</span>
<span class="source-line-no">2144</span><span id="line.2144">        if(rectangleWidth &lt; 1 || rectangleHeight &lt; 1 || ySections &lt;= 0)</span>
<span class="source-line-no">2145</span><span id="line.2145">            return this;</span>
<span class="source-line-no">2146</span><span id="line.2146">        int endX = Math.min(width, startX + rectangleWidth) - 1,</span>
<span class="source-line-no">2147</span><span id="line.2147">                endY = Math.min(height, startY + rectangleHeight) - 1,</span>
<span class="source-line-no">2148</span><span id="line.2148">                startSection = startY &gt;&gt; 6, endSection = endY &gt;&gt; 6;</span>
<span class="source-line-no">2149</span><span id="line.2149">        if(startSection &lt; endSection)</span>
<span class="source-line-no">2150</span><span id="line.2150">        {</span>
<span class="source-line-no">2151</span><span id="line.2151">            long startMask = ~(-1L &lt;&lt; (startY &amp; 63)),</span>
<span class="source-line-no">2152</span><span id="line.2152">                    endMask = ~(-1L &gt;&gt;&gt; (~endY &amp; 63));</span>
<span class="source-line-no">2153</span><span id="line.2153">            for (int a = startX * ySections + startSection; a &lt;= endX * ySections + startSection; a += ySections) {</span>
<span class="source-line-no">2154</span><span id="line.2154">                data[a] &amp;= startMask;</span>
<span class="source-line-no">2155</span><span id="line.2155">            }</span>
<span class="source-line-no">2156</span><span id="line.2156">            if(endSection - startSection &gt; 1)</span>
<span class="source-line-no">2157</span><span id="line.2157">            {</span>
<span class="source-line-no">2158</span><span id="line.2158">                for (int b = 1; b &lt; endSection - startSection; b++) {</span>
<span class="source-line-no">2159</span><span id="line.2159">                    for (int a = startX * ySections + startSection + b; a &lt; endX * ySections + ySections; a += ySections) {</span>
<span class="source-line-no">2160</span><span id="line.2160">                        data[a] = 0;</span>
<span class="source-line-no">2161</span><span id="line.2161">                    }</span>
<span class="source-line-no">2162</span><span id="line.2162">                }</span>
<span class="source-line-no">2163</span><span id="line.2163">            }</span>
<span class="source-line-no">2164</span><span id="line.2164">            for (int a = startX * ySections + endSection; a &lt;= endX * ySections + endSection; a += ySections) {</span>
<span class="source-line-no">2165</span><span id="line.2165">                data[a] &amp;= endMask;</span>
<span class="source-line-no">2166</span><span id="line.2166">            }</span>
<span class="source-line-no">2167</span><span id="line.2167">        }</span>
<span class="source-line-no">2168</span><span id="line.2168">        else</span>
<span class="source-line-no">2169</span><span id="line.2169">        {</span>
<span class="source-line-no">2170</span><span id="line.2170">            long mask = ~((-1L &lt;&lt; (startY &amp; 63)) &amp; (-1L &gt;&gt;&gt; (~endY &amp; 63)));</span>
<span class="source-line-no">2171</span><span id="line.2171">            for (int a = startX * ySections + startSection; a &lt;= endX * ySections + startSection; a += ySections) {</span>
<span class="source-line-no">2172</span><span id="line.2172">                data[a] &amp;= mask;</span>
<span class="source-line-no">2173</span><span id="line.2173">            }</span>
<span class="source-line-no">2174</span><span id="line.2174">        }</span>
<span class="source-line-no">2175</span><span id="line.2175">        tallied = false;</span>
<span class="source-line-no">2176</span><span id="line.2176">        return this;</span>
<span class="source-line-no">2177</span><span id="line.2177">    }</span>
<span class="source-line-no">2178</span><span id="line.2178"></span>
<span class="source-line-no">2179</span><span id="line.2179">    public GreasedRegion removeCircle(Coord center, int radius)</span>
<span class="source-line-no">2180</span><span id="line.2180">    {</span>
<span class="source-line-no">2181</span><span id="line.2181">        float high, changedX;</span>
<span class="source-line-no">2182</span><span id="line.2182">        int rndX, rndY;</span>
<span class="source-line-no">2183</span><span id="line.2183">        for (int dx = -radius; dx &lt;= radius; ++dx) {</span>
<span class="source-line-no">2184</span><span id="line.2184">            changedX = dx - 0.25f * (dx &gt;&gt; 31 | -dx &gt;&gt;&gt; 31); // project nayuki signum</span>
<span class="source-line-no">2185</span><span id="line.2185">            rndX = Math.round(changedX);</span>
<span class="source-line-no">2186</span><span id="line.2186">            high = (float) Math.sqrt(radius * radius - changedX * changedX);</span>
<span class="source-line-no">2187</span><span id="line.2187">            remove(center.x + rndX, center.y);</span>
<span class="source-line-no">2188</span><span id="line.2188">            for (float dy = high; dy &gt;= 0.75f; --dy) {</span>
<span class="source-line-no">2189</span><span id="line.2189">                rndY = Math.round(dy - 0.25f);</span>
<span class="source-line-no">2190</span><span id="line.2190">                remove(center.x + rndX, center.y + rndY);</span>
<span class="source-line-no">2191</span><span id="line.2191">                remove(center.x + rndX, center.y - rndY);</span>
<span class="source-line-no">2192</span><span id="line.2192">            }</span>
<span class="source-line-no">2193</span><span id="line.2193">        }</span>
<span class="source-line-no">2194</span><span id="line.2194">        return this;</span>
<span class="source-line-no">2195</span><span id="line.2195">    }</span>
<span class="source-line-no">2196</span><span id="line.2196"></span>
<span class="source-line-no">2197</span><span id="line.2197">    /**</span>
<span class="source-line-no">2198</span><span id="line.2198">     * Equivalent to {@link #clear()}, setting all cells to "off," but also returns this for chaining.</span>
<span class="source-line-no">2199</span><span id="line.2199">     * @return this for chaining</span>
<span class="source-line-no">2200</span><span id="line.2200">     */</span>
<span class="source-line-no">2201</span><span id="line.2201">    public GreasedRegion empty()</span>
<span class="source-line-no">2202</span><span id="line.2202">    {</span>
<span class="source-line-no">2203</span><span id="line.2203">        Arrays.fill(data, 0L);</span>
<span class="source-line-no">2204</span><span id="line.2204">        Arrays.fill(counts, 0);</span>
<span class="source-line-no">2205</span><span id="line.2205">        ct = 0;</span>
<span class="source-line-no">2206</span><span id="line.2206">        tallied = true;</span>
<span class="source-line-no">2207</span><span id="line.2207">        return this;</span>
<span class="source-line-no">2208</span><span id="line.2208">    }</span>
<span class="source-line-no">2209</span><span id="line.2209"></span>
<span class="source-line-no">2210</span><span id="line.2210">    /**</span>
<span class="source-line-no">2211</span><span id="line.2211">     * Sets all cells in this to "on."</span>
<span class="source-line-no">2212</span><span id="line.2212">     * @return this for chaining</span>
<span class="source-line-no">2213</span><span id="line.2213">     */</span>
<span class="source-line-no">2214</span><span id="line.2214">    public GreasedRegion allOn()</span>
<span class="source-line-no">2215</span><span id="line.2215">    {</span>
<span class="source-line-no">2216</span><span id="line.2216">        if(ySections &gt; 0)</span>
<span class="source-line-no">2217</span><span id="line.2217">        {</span>
<span class="source-line-no">2218</span><span id="line.2218">            if(yEndMask == -1) {</span>
<span class="source-line-no">2219</span><span id="line.2219">                Arrays.fill(data, -1);</span>
<span class="source-line-no">2220</span><span id="line.2220">                Arrays.fill(counts, 64);</span>
<span class="source-line-no">2221</span><span id="line.2221">                ct = ySections * width &lt;&lt; 6;</span>
<span class="source-line-no">2222</span><span id="line.2222">                tallied = true;</span>
<span class="source-line-no">2223</span><span id="line.2223">            }</span>
<span class="source-line-no">2224</span><span id="line.2224">            else</span>
<span class="source-line-no">2225</span><span id="line.2225">            {</span>
<span class="source-line-no">2226</span><span id="line.2226">                ct = Long.bitCount(yEndMask);</span>
<span class="source-line-no">2227</span><span id="line.2227">                for (int a = ySections - 1; a &lt; data.length; a += ySections) {</span>
<span class="source-line-no">2228</span><span id="line.2228">                    data[a] = yEndMask;</span>
<span class="source-line-no">2229</span><span id="line.2229">                    counts[a] = ct;</span>
<span class="source-line-no">2230</span><span id="line.2230">                    for (int i = 0; i &lt; ySections - 1; i++) {</span>
<span class="source-line-no">2231</span><span id="line.2231">                        data[a-i-1] = -1;</span>
<span class="source-line-no">2232</span><span id="line.2232">                        counts[a-i-1] = 64;</span>
<span class="source-line-no">2233</span><span id="line.2233">                    }</span>
<span class="source-line-no">2234</span><span id="line.2234">                }</span>
<span class="source-line-no">2235</span><span id="line.2235">                ct *= width;</span>
<span class="source-line-no">2236</span><span id="line.2236">                ct += (ySections - 1) * width &lt;&lt; 6;</span>
<span class="source-line-no">2237</span><span id="line.2237">                tallied = true;</span>
<span class="source-line-no">2238</span><span id="line.2238">            }</span>
<span class="source-line-no">2239</span><span id="line.2239">        }</span>
<span class="source-line-no">2240</span><span id="line.2240">        return this;</span>
<span class="source-line-no">2241</span><span id="line.2241">    }</span>
<span class="source-line-no">2242</span><span id="line.2242"></span>
<span class="source-line-no">2243</span><span id="line.2243">    /**</span>
<span class="source-line-no">2244</span><span id="line.2244">     * Sets all cells in this to "on" if contents is true, or "off" if contents is false.</span>
<span class="source-line-no">2245</span><span id="line.2245">     * @param contents true to set all cells to on, false to set all cells to off</span>
<span class="source-line-no">2246</span><span id="line.2246">     * @return this for chaining</span>
<span class="source-line-no">2247</span><span id="line.2247">     */</span>
<span class="source-line-no">2248</span><span id="line.2248">    public GreasedRegion fill(boolean contents)</span>
<span class="source-line-no">2249</span><span id="line.2249">    {</span>
<span class="source-line-no">2250</span><span id="line.2250">        if(contents)</span>
<span class="source-line-no">2251</span><span id="line.2251">        {</span>
<span class="source-line-no">2252</span><span id="line.2252">            if(ySections &gt; 0)</span>
<span class="source-line-no">2253</span><span id="line.2253">            {</span>
<span class="source-line-no">2254</span><span id="line.2254">                if(yEndMask == -1) {</span>
<span class="source-line-no">2255</span><span id="line.2255">                    Arrays.fill(data, -1);</span>
<span class="source-line-no">2256</span><span id="line.2256">                    Arrays.fill(counts, 64);</span>
<span class="source-line-no">2257</span><span id="line.2257">                    ct = ySections * width &lt;&lt; 6;</span>
<span class="source-line-no">2258</span><span id="line.2258">                    tallied = true;</span>
<span class="source-line-no">2259</span><span id="line.2259">                }</span>
<span class="source-line-no">2260</span><span id="line.2260">                else</span>
<span class="source-line-no">2261</span><span id="line.2261">                {</span>
<span class="source-line-no">2262</span><span id="line.2262">                    ct = Long.bitCount(yEndMask);</span>
<span class="source-line-no">2263</span><span id="line.2263">                    for (int a = ySections - 1; a &lt; data.length; a += ySections) {</span>
<span class="source-line-no">2264</span><span id="line.2264">                        data[a] = yEndMask;</span>
<span class="source-line-no">2265</span><span id="line.2265">                        counts[a] = ct;</span>
<span class="source-line-no">2266</span><span id="line.2266">                        for (int i = 0; i &lt; ySections - 1; i++) {</span>
<span class="source-line-no">2267</span><span id="line.2267">                            data[a-i-1] = -1;</span>
<span class="source-line-no">2268</span><span id="line.2268">                            counts[a-i-1] = 64;</span>
<span class="source-line-no">2269</span><span id="line.2269">                        }</span>
<span class="source-line-no">2270</span><span id="line.2270">                    }</span>
<span class="source-line-no">2271</span><span id="line.2271">                    ct *= width;</span>
<span class="source-line-no">2272</span><span id="line.2272">                    ct += (ySections - 1) * width &lt;&lt; 6;</span>
<span class="source-line-no">2273</span><span id="line.2273">                    tallied = true;</span>
<span class="source-line-no">2274</span><span id="line.2274">                }</span>
<span class="source-line-no">2275</span><span id="line.2275">            }</span>
<span class="source-line-no">2276</span><span id="line.2276">            //else... what, if ySections is 0 there's nothing to do</span>
<span class="source-line-no">2277</span><span id="line.2277">        }</span>
<span class="source-line-no">2278</span><span id="line.2278">        else</span>
<span class="source-line-no">2279</span><span id="line.2279">        {</span>
<span class="source-line-no">2280</span><span id="line.2280">            Arrays.fill(data, 0L);</span>
<span class="source-line-no">2281</span><span id="line.2281">            Arrays.fill(counts, 0);</span>
<span class="source-line-no">2282</span><span id="line.2282">            ct = 0;</span>
<span class="source-line-no">2283</span><span id="line.2283">            tallied = true;</span>
<span class="source-line-no">2284</span><span id="line.2284">        }</span>
<span class="source-line-no">2285</span><span id="line.2285">        return this;</span>
<span class="source-line-no">2286</span><span id="line.2286">    }</span>
<span class="source-line-no">2287</span><span id="line.2287">    /**</span>
<span class="source-line-no">2288</span><span id="line.2288">     * Turns all cells that are adjacent to the boundaries of the GreasedRegion to "off".</span>
<span class="source-line-no">2289</span><span id="line.2289">     * @return this for chaining</span>
<span class="source-line-no">2290</span><span id="line.2290">     */</span>
<span class="source-line-no">2291</span><span id="line.2291">    public GreasedRegion removeEdges()</span>
<span class="source-line-no">2292</span><span id="line.2292">    {</span>
<span class="source-line-no">2293</span><span id="line.2293">        if(ySections &gt; 0) {</span>
<span class="source-line-no">2294</span><span id="line.2294">            for (int i = 0; i &lt; ySections; i++) {</span>
<span class="source-line-no">2295</span><span id="line.2295">                data[i] = 0L;</span>
<span class="source-line-no">2296</span><span id="line.2296">                data[width * ySections - 1 - i] = 0L;</span>
<span class="source-line-no">2297</span><span id="line.2297">            }</span>
<span class="source-line-no">2298</span><span id="line.2298">            if (ySections == 1) {</span>
<span class="source-line-no">2299</span><span id="line.2299">                for (int i = 0; i &lt; width; i++) {</span>
<span class="source-line-no">2300</span><span id="line.2300">                    data[i] &amp;= yEndMask &gt;&gt;&gt; 1 &amp; -2L;</span>
<span class="source-line-no">2301</span><span id="line.2301">                }</span>
<span class="source-line-no">2302</span><span id="line.2302">            } else {</span>
<span class="source-line-no">2303</span><span id="line.2303">                for (int i = ySections; i &lt; data.length - ySections; i += ySections) {</span>
<span class="source-line-no">2304</span><span id="line.2304">                    data[i] &amp;= -2L;</span>
<span class="source-line-no">2305</span><span id="line.2305">                }</span>
<span class="source-line-no">2306</span><span id="line.2306">                for (int a = ySections * 2 - 1; a &lt; data.length - ySections; a += ySections) {</span>
<span class="source-line-no">2307</span><span id="line.2307">                    data[a] &amp;= yEndMask &gt;&gt;&gt; 1;</span>
<span class="source-line-no">2308</span><span id="line.2308">                }</span>
<span class="source-line-no">2309</span><span id="line.2309">            }</span>
<span class="source-line-no">2310</span><span id="line.2310">            tallied = false;</span>
<span class="source-line-no">2311</span><span id="line.2311">        }</span>
<span class="source-line-no">2312</span><span id="line.2312">        return this;</span>
<span class="source-line-no">2313</span><span id="line.2313">    }</span>
<span class="source-line-no">2314</span><span id="line.2314"></span>
<span class="source-line-no">2315</span><span id="line.2315">    /**</span>
<span class="source-line-no">2316</span><span id="line.2316">     * Simple method that returns a newly-allocated copy of this GreasedRegion; modifications to one won't change the</span>
<span class="source-line-no">2317</span><span id="line.2317">     * other, and this method returns the copy while leaving the original unchanged.</span>
<span class="source-line-no">2318</span><span id="line.2318">     * @return a copy of this GreasedRegion; the copy can be changed without altering the original</span>
<span class="source-line-no">2319</span><span id="line.2319">     */</span>
<span class="source-line-no">2320</span><span id="line.2320">    public GreasedRegion copy()</span>
<span class="source-line-no">2321</span><span id="line.2321">    {</span>
<span class="source-line-no">2322</span><span id="line.2322">        return new GreasedRegion(this);</span>
<span class="source-line-no">2323</span><span id="line.2323">    }</span>
<span class="source-line-no">2324</span><span id="line.2324"></span>
<span class="source-line-no">2325</span><span id="line.2325">    /**</span>
<span class="source-line-no">2326</span><span id="line.2326">     * Returns this GreasedRegion's data as a 2D boolean array, [width][height] in size, with on treated as true and off</span>
<span class="source-line-no">2327</span><span id="line.2327">     * treated as false.</span>
<span class="source-line-no">2328</span><span id="line.2328">     * @return a 2D boolean array that represents this GreasedRegion's data</span>
<span class="source-line-no">2329</span><span id="line.2329">     */</span>
<span class="source-line-no">2330</span><span id="line.2330">    public boolean[][] decode()</span>
<span class="source-line-no">2331</span><span id="line.2331">    {</span>
<span class="source-line-no">2332</span><span id="line.2332">        boolean[][] bools = new boolean[width][height];</span>
<span class="source-line-no">2333</span><span id="line.2333">        for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">2334</span><span id="line.2334">            for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">2335</span><span id="line.2335">                bools[x][y] = (data[x * ySections + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0;</span>
<span class="source-line-no">2336</span><span id="line.2336">            }</span>
<span class="source-line-no">2337</span><span id="line.2337">        }</span>
<span class="source-line-no">2338</span><span id="line.2338">        return bools;</span>
<span class="source-line-no">2339</span><span id="line.2339">    }</span>
<span class="source-line-no">2340</span><span id="line.2340"></span>
<span class="source-line-no">2341</span><span id="line.2341">    /**</span>
<span class="source-line-no">2342</span><span id="line.2342">     * Fills this GreasedRegion's data into the given 2D char array, modifying it and returning it, with "on" cells</span>
<span class="source-line-no">2343</span><span id="line.2343">     * filled with the char parameter {@code on} and "off" cells with the parameter {@code off}.</span>
<span class="source-line-no">2344</span><span id="line.2344">     * @param chars a 2D char array that will be modified; must not be null, nor can it contain null elements</span>
<span class="source-line-no">2345</span><span id="line.2345">     * @param on the char to use for "on" cells</span>
<span class="source-line-no">2346</span><span id="line.2346">     * @param off the char to use for "off" cells</span>
<span class="source-line-no">2347</span><span id="line.2347">     * @return a 2D char array that represents this GreasedRegion's data</span>
<span class="source-line-no">2348</span><span id="line.2348">     */</span>
<span class="source-line-no">2349</span><span id="line.2349">    public char[][] intoChars(char[][] chars, char on, char off)</span>
<span class="source-line-no">2350</span><span id="line.2350">    {</span>
<span class="source-line-no">2351</span><span id="line.2351">        for (int x = 0; x &lt; width &amp;&amp; x &lt; chars.length; x++) {</span>
<span class="source-line-no">2352</span><span id="line.2352">            for (int y = 0; y &lt; height &amp;&amp; y &lt; chars[x].length; y++) {</span>
<span class="source-line-no">2353</span><span id="line.2353">                chars[x][y] = (data[x * ySections + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0 ? on : off;</span>
<span class="source-line-no">2354</span><span id="line.2354">            }</span>
<span class="source-line-no">2355</span><span id="line.2355">        }</span>
<span class="source-line-no">2356</span><span id="line.2356">        return chars;</span>
<span class="source-line-no">2357</span><span id="line.2357">    }</span>
<span class="source-line-no">2358</span><span id="line.2358"></span>
<span class="source-line-no">2359</span><span id="line.2359">    /**</span>
<span class="source-line-no">2360</span><span id="line.2360">     * Fills this GreasedRegion's data into the given 2D char array, modifying it and returning it, with "on" cells</span>
<span class="source-line-no">2361</span><span id="line.2361">     * filled with the char parameter {@code on} and "off" cells left as-is.</span>
<span class="source-line-no">2362</span><span id="line.2362">     * @param chars a 2D char array that will be modified; must not be null, nor can it contain null elements</span>
<span class="source-line-no">2363</span><span id="line.2363">     * @param on the char to use for "on" cells</span>
<span class="source-line-no">2364</span><span id="line.2364">     * @return a 2D char array that represents the "on" cells in this GreasedRegion's data written over chars</span>
<span class="source-line-no">2365</span><span id="line.2365">     */</span>
<span class="source-line-no">2366</span><span id="line.2366">    public char[][] intoChars(char[][] chars, char on)</span>
<span class="source-line-no">2367</span><span id="line.2367">    {</span>
<span class="source-line-no">2368</span><span id="line.2368">        for (int x = 0; x &lt; width &amp;&amp; x &lt; chars.length; x++) {</span>
<span class="source-line-no">2369</span><span id="line.2369">            for (int y = 0; y &lt; height &amp;&amp; y &lt; chars[x].length; y++) {</span>
<span class="source-line-no">2370</span><span id="line.2370">                if((data[x * ySections + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0)</span>
<span class="source-line-no">2371</span><span id="line.2371">                    chars[x][y] = on;</span>
<span class="source-line-no">2372</span><span id="line.2372">            }</span>
<span class="source-line-no">2373</span><span id="line.2373">        }</span>
<span class="source-line-no">2374</span><span id="line.2374">        return chars;</span>
<span class="source-line-no">2375</span><span id="line.2375">    }</span>
<span class="source-line-no">2376</span><span id="line.2376"></span>
<span class="source-line-no">2377</span><span id="line.2377">    /**</span>
<span class="source-line-no">2378</span><span id="line.2378">     * Returns this GreasedRegion's data as a 2D char array,  [width][height] in size, with "on" cells filled with the</span>
<span class="source-line-no">2379</span><span id="line.2379">     * char parameter on and "off" cells with the parameter off.</span>
<span class="source-line-no">2380</span><span id="line.2380">     * @param on the char to use for "on" cells</span>
<span class="source-line-no">2381</span><span id="line.2381">     * @param off the char to use for "off" cells</span>
<span class="source-line-no">2382</span><span id="line.2382">     * @return a 2D char array that represents this GreasedRegion's data</span>
<span class="source-line-no">2383</span><span id="line.2383">     */</span>
<span class="source-line-no">2384</span><span id="line.2384">    public char[][] toChars(char on, char off)</span>
<span class="source-line-no">2385</span><span id="line.2385">    {</span>
<span class="source-line-no">2386</span><span id="line.2386">        char[][] chars = new char[width][height];</span>
<span class="source-line-no">2387</span><span id="line.2387">        for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">2388</span><span id="line.2388">            for (int y = 0; y &lt; height; y++) {</span>
<span class="source-line-no">2389</span><span id="line.2389">                chars[x][y] = (data[x * ySections + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0 ? on : off;</span>
<span class="source-line-no">2390</span><span id="line.2390">            }</span>
<span class="source-line-no">2391</span><span id="line.2391">        }</span>
<span class="source-line-no">2392</span><span id="line.2392">        return chars;</span>
<span class="source-line-no">2393</span><span id="line.2393">    }</span>
<span class="source-line-no">2394</span><span id="line.2394">    /**</span>
<span class="source-line-no">2395</span><span id="line.2395">     * Returns this GreasedRegion's data as a 2D char array,  [width][height] in size, with "on" cells filled with '.'</span>
<span class="source-line-no">2396</span><span id="line.2396">     * and "off" cells with '#'.</span>
<span class="source-line-no">2397</span><span id="line.2397">     * @return a 2D char array that represents this GreasedRegion's data</span>
<span class="source-line-no">2398</span><span id="line.2398">     */</span>
<span class="source-line-no">2399</span><span id="line.2399"></span>
<span class="source-line-no">2400</span><span id="line.2400">    public char[][] toChars()</span>
<span class="source-line-no">2401</span><span id="line.2401">    {</span>
<span class="source-line-no">2402</span><span id="line.2402">        return toChars('.', '#');</span>
<span class="source-line-no">2403</span><span id="line.2403">    }</span>
<span class="source-line-no">2404</span><span id="line.2404"></span>
<span class="source-line-no">2405</span><span id="line.2405">    /**</span>
<span class="source-line-no">2406</span><span id="line.2406">     * Returns this GreasedRegion's data as a StringBuilder, with each row made of the parameter on for "on" cells and</span>
<span class="source-line-no">2407</span><span id="line.2407">     * the parameter off for "off" cells, separated by newlines, with no trailing newline at the end.</span>
<span class="source-line-no">2408</span><span id="line.2408">     * @param on the char to use for "on" cells</span>
<span class="source-line-no">2409</span><span id="line.2409">     * @param off the char to use for "off" cells</span>
<span class="source-line-no">2410</span><span id="line.2410">     * @return a StringBuilder that stores each row of this GreasedRegion as chars, with rows separated by newlines.</span>
<span class="source-line-no">2411</span><span id="line.2411">     */</span>
<span class="source-line-no">2412</span><span id="line.2412">    public StringBuilder show(char on, char off)</span>
<span class="source-line-no">2413</span><span id="line.2413">    {</span>
<span class="source-line-no">2414</span><span id="line.2414">        StringBuilder sb = new StringBuilder((width+1) * height);</span>
<span class="source-line-no">2415</span><span id="line.2415">        for (int y = 0; y &lt; height;) {</span>
<span class="source-line-no">2416</span><span id="line.2416">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">2417</span><span id="line.2417">                sb.append((data[x * ySections + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0 ? on : off);</span>
<span class="source-line-no">2418</span><span id="line.2418">            }</span>
<span class="source-line-no">2419</span><span id="line.2419">            if(++y &lt; height)</span>
<span class="source-line-no">2420</span><span id="line.2420">                sb.append('\n');</span>
<span class="source-line-no">2421</span><span id="line.2421">        }</span>
<span class="source-line-no">2422</span><span id="line.2422">        return sb;</span>
<span class="source-line-no">2423</span><span id="line.2423">    }</span>
<span class="source-line-no">2424</span><span id="line.2424"></span>
<span class="source-line-no">2425</span><span id="line.2425">    /**</span>
<span class="source-line-no">2426</span><span id="line.2426">     * Returns a legible String representation of this that can be printed over multiple lines, with all "on" cells</span>
<span class="source-line-no">2427</span><span id="line.2427">     * represented by '.' and all "off" cells by '#', in roguelike floors-on walls-off convention, separating each row</span>
<span class="source-line-no">2428</span><span id="line.2428">     * by newlines (without a final trailing newline, so you could append text right after this).</span>
<span class="source-line-no">2429</span><span id="line.2429">     * @return a String representation of this GreasedRegion using '.' for on, '#' for off, and newlines between rows</span>
<span class="source-line-no">2430</span><span id="line.2430">     */</span>
<span class="source-line-no">2431</span><span id="line.2431">    @Override</span>
<span class="source-line-no">2432</span><span id="line.2432">    public String toString()</span>
<span class="source-line-no">2433</span><span id="line.2433">    {</span>
<span class="source-line-no">2434</span><span id="line.2434">        return show('.', '#').toString();</span>
<span class="source-line-no">2435</span><span id="line.2435">    }</span>
<span class="source-line-no">2436</span><span id="line.2436"></span>
<span class="source-line-no">2437</span><span id="line.2437">    /**</span>
<span class="source-line-no">2438</span><span id="line.2438">     * Returns a copy of map where if a cell is "on" in this GreasedRegion, this keeps the value in map intact,</span>
<span class="source-line-no">2439</span><span id="line.2439">     * and where a cell is "off", it instead writes the char filler.</span>
<span class="source-line-no">2440</span><span id="line.2440">     * @param map a 2D char array that will not be modified</span>
<span class="source-line-no">2441</span><span id="line.2441">     * @param filler the char to use where this GreasedRegion stores an "off" cell</span>
<span class="source-line-no">2442</span><span id="line.2442">     * @return a masked copy of map</span>
<span class="source-line-no">2443</span><span id="line.2443">     */</span>
<span class="source-line-no">2444</span><span id="line.2444">    public char[][] mask(char[][] map, char filler)</span>
<span class="source-line-no">2445</span><span id="line.2445">    {</span>
<span class="source-line-no">2446</span><span id="line.2446">        if(map == null || map.length == 0)</span>
<span class="source-line-no">2447</span><span id="line.2447">            return new char[0][0];</span>
<span class="source-line-no">2448</span><span id="line.2448">        int width2 = Math.min(width, map.length), height2 = Math.min(height, map[0].length);</span>
<span class="source-line-no">2449</span><span id="line.2449">        char[][] chars = new char[width2][height2];</span>
<span class="source-line-no">2450</span><span id="line.2450">        for (int x = 0; x &lt; width2; x++) {</span>
<span class="source-line-no">2451</span><span id="line.2451">            for (int y = 0; y &lt; height2; y++) {</span>
<span class="source-line-no">2452</span><span id="line.2452">                chars[x][y] = (data[x * ySections + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0 ? map[x][y] : filler;</span>
<span class="source-line-no">2453</span><span id="line.2453">            }</span>
<span class="source-line-no">2454</span><span id="line.2454">        }</span>
<span class="source-line-no">2455</span><span id="line.2455">        return chars;</span>
<span class="source-line-no">2456</span><span id="line.2456">    }</span>
<span class="source-line-no">2457</span><span id="line.2457"></span>
<span class="source-line-no">2458</span><span id="line.2458">    /**</span>
<span class="source-line-no">2459</span><span id="line.2459">     * Returns a copy of map where if a cell is "on" in this GreasedRegion, this keeps the value in map intact,</span>
<span class="source-line-no">2460</span><span id="line.2460">     * and where a cell is "off", it instead writes the short filler. Meant for use with MultiSpill, but may be</span>
<span class="source-line-no">2461</span><span id="line.2461">     * used anywhere you have a 2D short array. {@link #mask(char[][], char)} is more likely to be useful.</span>
<span class="source-line-no">2462</span><span id="line.2462">     * @param map a 2D short array that will not be modified</span>
<span class="source-line-no">2463</span><span id="line.2463">     * @param filler the short to use where this GreasedRegion stores an "off" cell</span>
<span class="source-line-no">2464</span><span id="line.2464">     * @return a masked copy of map</span>
<span class="source-line-no">2465</span><span id="line.2465">     */</span>
<span class="source-line-no">2466</span><span id="line.2466">    public short[][] mask(short[][] map, short filler)</span>
<span class="source-line-no">2467</span><span id="line.2467">    {</span>
<span class="source-line-no">2468</span><span id="line.2468">        if(map == null || map.length == 0)</span>
<span class="source-line-no">2469</span><span id="line.2469">            return new short[0][0];</span>
<span class="source-line-no">2470</span><span id="line.2470">        int width2 = Math.min(width, map.length), height2 = Math.min(height, map[0].length);</span>
<span class="source-line-no">2471</span><span id="line.2471">        short[][] shorts = new short[width2][height2];</span>
<span class="source-line-no">2472</span><span id="line.2472">        for (int x = 0; x &lt; width2; x++) {</span>
<span class="source-line-no">2473</span><span id="line.2473">            for (int y = 0; y &lt; height2; y++) {</span>
<span class="source-line-no">2474</span><span id="line.2474">                shorts[x][y] = (data[x * ySections + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0 ? map[x][y] : filler;</span>
<span class="source-line-no">2475</span><span id="line.2475">            }</span>
<span class="source-line-no">2476</span><span id="line.2476">        }</span>
<span class="source-line-no">2477</span><span id="line.2477">        return shorts;</span>
<span class="source-line-no">2478</span><span id="line.2478">    }</span>
<span class="source-line-no">2479</span><span id="line.2479"></span>
<span class="source-line-no">2480</span><span id="line.2480">    /**</span>
<span class="source-line-no">2481</span><span id="line.2481">     * Returns a copy of map where if a cell is "off" in this GreasedRegion, this keeps the value in map intact,</span>
<span class="source-line-no">2482</span><span id="line.2482">     * and where a cell is "on", it instead writes the char toWrite.</span>
<span class="source-line-no">2483</span><span id="line.2483">     * @param map a 2D char array that will not be modified</span>
<span class="source-line-no">2484</span><span id="line.2484">     * @param toWrite the char to use where this GreasedRegion stores an "on" cell</span>
<span class="source-line-no">2485</span><span id="line.2485">     * @return a masked copy of map</span>
<span class="source-line-no">2486</span><span id="line.2486">     */</span>
<span class="source-line-no">2487</span><span id="line.2487">    public char[][] inverseMask(char[][] map, char toWrite)</span>
<span class="source-line-no">2488</span><span id="line.2488">    {</span>
<span class="source-line-no">2489</span><span id="line.2489">        if(map == null || map.length == 0)</span>
<span class="source-line-no">2490</span><span id="line.2490">            return new char[0][0];</span>
<span class="source-line-no">2491</span><span id="line.2491">        int width2 = Math.min(width, map.length), height2 = Math.min(height, map[0].length);</span>
<span class="source-line-no">2492</span><span id="line.2492">        char[][] chars = new char[width2][height2];</span>
<span class="source-line-no">2493</span><span id="line.2493">        for (int x = 0; x &lt; width2; x++) {</span>
<span class="source-line-no">2494</span><span id="line.2494">            for (int y = 0; y &lt; height2; y++) {</span>
<span class="source-line-no">2495</span><span id="line.2495">                chars[x][y] = (data[x * ySections + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0 ? toWrite : map[x][y];</span>
<span class="source-line-no">2496</span><span id="line.2496">            }</span>
<span class="source-line-no">2497</span><span id="line.2497">        }</span>
<span class="source-line-no">2498</span><span id="line.2498">        return chars;</span>
<span class="source-line-no">2499</span><span id="line.2499">    }</span>
<span class="source-line-no">2500</span><span id="line.2500"></span>
<span class="source-line-no">2501</span><span id="line.2501">    /**</span>
<span class="source-line-no">2502</span><span id="line.2502">     * "Inverse mask for ints;" returns a copy of map where if a cell is "off" in this GreasedRegion, this keeps</span>
<span class="source-line-no">2503</span><span id="line.2503">     * the value in map intact, and where a cell is "on", it instead writes the int toWrite.</span>
<span class="source-line-no">2504</span><span id="line.2504">     * @param map a 2D int array that will not be modified</span>
<span class="source-line-no">2505</span><span id="line.2505">     * @param toWrite the int to use where this GreasedRegion stores an "on" cell</span>
<span class="source-line-no">2506</span><span id="line.2506">     * @return an altered copy of map</span>
<span class="source-line-no">2507</span><span id="line.2507">     */</span>
<span class="source-line-no">2508</span><span id="line.2508">    public int[][] writeInts(int[][] map, int toWrite)</span>
<span class="source-line-no">2509</span><span id="line.2509">    {</span>
<span class="source-line-no">2510</span><span id="line.2510">        if(map == null || map.length == 0)</span>
<span class="source-line-no">2511</span><span id="line.2511">            return new int[0][0];</span>
<span class="source-line-no">2512</span><span id="line.2512">        int width2 = Math.min(width, map.length), height2 = Math.min(height, map[0].length);</span>
<span class="source-line-no">2513</span><span id="line.2513">        int[][] ints = new int[width2][height2];</span>
<span class="source-line-no">2514</span><span id="line.2514">        for (int x = 0; x &lt; width2; x++) {</span>
<span class="source-line-no">2515</span><span id="line.2515">            for (int y = 0; y &lt; height2; y++) {</span>
<span class="source-line-no">2516</span><span id="line.2516">                ints[x][y] = (data[x * ySections + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0 ? toWrite : map[x][y];</span>
<span class="source-line-no">2517</span><span id="line.2517">            }</span>
<span class="source-line-no">2518</span><span id="line.2518">        }</span>
<span class="source-line-no">2519</span><span id="line.2519">        return ints;</span>
<span class="source-line-no">2520</span><span id="line.2520">    }</span>
<span class="source-line-no">2521</span><span id="line.2521"></span>
<span class="source-line-no">2522</span><span id="line.2522">    /**</span>
<span class="source-line-no">2523</span><span id="line.2523">     * "Inverse mask for ints;" returns a copy of map where if a cell is "off" in this GreasedRegion, this keeps</span>
<span class="source-line-no">2524</span><span id="line.2524">     * the value in map intact, and where a cell is "on", it instead writes the int toWrite. Modifies map in-place,</span>
<span class="source-line-no">2525</span><span id="line.2525">     * unlike {@link #writeInts(int[][], int)}.</span>
<span class="source-line-no">2526</span><span id="line.2526">     * @param map a 2D int array that &lt;b&gt;will&lt;/b&gt; be modified</span>
<span class="source-line-no">2527</span><span id="line.2527">     * @param toWrite the int to use where this GreasedRegion stores an "on" cell</span>
<span class="source-line-no">2528</span><span id="line.2528">     * @return map, with the changes applied; not a copy</span>
<span class="source-line-no">2529</span><span id="line.2529">     */</span>
<span class="source-line-no">2530</span><span id="line.2530">    public int[][] writeIntsInto(int[][] map, int toWrite)</span>
<span class="source-line-no">2531</span><span id="line.2531">    {</span>
<span class="source-line-no">2532</span><span id="line.2532">        if(map == null || map.length == 0)</span>
<span class="source-line-no">2533</span><span id="line.2533">            return map;</span>
<span class="source-line-no">2534</span><span id="line.2534">        int width2 = Math.min(width, map.length), height2 = Math.min(height, map[0].length);</span>
<span class="source-line-no">2535</span><span id="line.2535">        for (int x = 0; x &lt; width2; x++) {</span>
<span class="source-line-no">2536</span><span id="line.2536">            for (int y = 0; y &lt; height2; y++) {</span>
<span class="source-line-no">2537</span><span id="line.2537">                if((data[x * ySections + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0)</span>
<span class="source-line-no">2538</span><span id="line.2538">                    map[x][y] = toWrite;</span>
<span class="source-line-no">2539</span><span id="line.2539">            }</span>
<span class="source-line-no">2540</span><span id="line.2540">        }</span>
<span class="source-line-no">2541</span><span id="line.2541">        return map;</span>
<span class="source-line-no">2542</span><span id="line.2542">    }</span>
<span class="source-line-no">2543</span><span id="line.2543">    /**</span>
<span class="source-line-no">2544</span><span id="line.2544">     * "Inverse mask for doubles;" returns a copy of map where if a cell is "off" in this GreasedRegion, this keeps</span>
<span class="source-line-no">2545</span><span id="line.2545">     * the value in map intact, and where a cell is "on", it instead writes the double toWrite.</span>
<span class="source-line-no">2546</span><span id="line.2546">     * @param map a 2D double array that will not be modified</span>
<span class="source-line-no">2547</span><span id="line.2547">     * @param toWrite the double to use where this GreasedRegion stores an "on" cell</span>
<span class="source-line-no">2548</span><span id="line.2548">     * @return an altered copy of map</span>
<span class="source-line-no">2549</span><span id="line.2549">     */</span>
<span class="source-line-no">2550</span><span id="line.2550">    public double[][] writeDoubles(double[][] map, double toWrite)</span>
<span class="source-line-no">2551</span><span id="line.2551">    {</span>
<span class="source-line-no">2552</span><span id="line.2552">        if(map == null || map.length == 0)</span>
<span class="source-line-no">2553</span><span id="line.2553">            return new double[0][0];</span>
<span class="source-line-no">2554</span><span id="line.2554">        int width2 = Math.min(width, map.length), height2 = Math.min(height, map[0].length);</span>
<span class="source-line-no">2555</span><span id="line.2555">        double[][] doubles = new double[width2][height2];</span>
<span class="source-line-no">2556</span><span id="line.2556">        for (int x = 0; x &lt; width2; x++) {</span>
<span class="source-line-no">2557</span><span id="line.2557">            for (int y = 0; y &lt; height2; y++) {</span>
<span class="source-line-no">2558</span><span id="line.2558">                doubles[x][y] = (data[x * ySections + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0 ? toWrite : map[x][y];</span>
<span class="source-line-no">2559</span><span id="line.2559">            }</span>
<span class="source-line-no">2560</span><span id="line.2560">        }</span>
<span class="source-line-no">2561</span><span id="line.2561">        return doubles;</span>
<span class="source-line-no">2562</span><span id="line.2562">    }</span>
<span class="source-line-no">2563</span><span id="line.2563"></span>
<span class="source-line-no">2564</span><span id="line.2564">    /**</span>
<span class="source-line-no">2565</span><span id="line.2565">     * "Inverse mask for doubles;" returns a copy of map where if a cell is "off" in this GreasedRegion, this keeps</span>
<span class="source-line-no">2566</span><span id="line.2566">     * the value in map intact, and where a cell is "on", it instead writes the double toWrite. Modifies map in-place,</span>
<span class="source-line-no">2567</span><span id="line.2567">     * unlike {@link #writeDoubles(double[][], double)}.</span>
<span class="source-line-no">2568</span><span id="line.2568">     * @param map a 2D double array that &lt;b&gt;will&lt;/b&gt; be modified</span>
<span class="source-line-no">2569</span><span id="line.2569">     * @param toWrite the double to use where this GreasedRegion stores an "on" cell</span>
<span class="source-line-no">2570</span><span id="line.2570">     * @return map, with the changes applied; not a copy</span>
<span class="source-line-no">2571</span><span id="line.2571">     */</span>
<span class="source-line-no">2572</span><span id="line.2572">    public double[][] writeDoublesInto(double[][] map, double toWrite)</span>
<span class="source-line-no">2573</span><span id="line.2573">    {</span>
<span class="source-line-no">2574</span><span id="line.2574">        if(map == null || map.length == 0)</span>
<span class="source-line-no">2575</span><span id="line.2575">            return map;</span>
<span class="source-line-no">2576</span><span id="line.2576">        int width2 = Math.min(width, map.length), height2 = Math.min(height, map[0].length);</span>
<span class="source-line-no">2577</span><span id="line.2577">        for (int x = 0; x &lt; width2; x++) {</span>
<span class="source-line-no">2578</span><span id="line.2578">            for (int y = 0; y &lt; height2; y++) {</span>
<span class="source-line-no">2579</span><span id="line.2579">                if((data[x * ySections + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0)</span>
<span class="source-line-no">2580</span><span id="line.2580">                    map[x][y] = toWrite;</span>
<span class="source-line-no">2581</span><span id="line.2581">            }</span>
<span class="source-line-no">2582</span><span id="line.2582">        }</span>
<span class="source-line-no">2583</span><span id="line.2583">        return map;</span>
<span class="source-line-no">2584</span><span id="line.2584">    }</span>
<span class="source-line-no">2585</span><span id="line.2585">    /**</span>
<span class="source-line-no">2586</span><span id="line.2586">     * Like {@link #inverseMask(char[][], char)}, but modifies {@code map} in-place and returns it. If a cell is "off"</span>
<span class="source-line-no">2587</span><span id="line.2587">     * in this GreasedRegion, this keeps the value in map intact, and where a cell is "on", it instead writes the char</span>
<span class="source-line-no">2588</span><span id="line.2588">     * toWrite. Modifies map in-place, unlike {@link #inverseMask(char[][], char)}.</span>
<span class="source-line-no">2589</span><span id="line.2589">     * @param map a 2D char array that &lt;b&gt;will&lt;/b&gt; be modified</span>
<span class="source-line-no">2590</span><span id="line.2590">     * @param toWrite the char to use where this GreasedRegion stores an "on" cell</span>
<span class="source-line-no">2591</span><span id="line.2591">     * @return map, with the changes applied; not a copy</span>
<span class="source-line-no">2592</span><span id="line.2592">     */</span>
<span class="source-line-no">2593</span><span id="line.2593">    public char[][] writeCharsInto(char[][] map, char toWrite)</span>
<span class="source-line-no">2594</span><span id="line.2594">    {</span>
<span class="source-line-no">2595</span><span id="line.2595">        if(map == null || map.length == 0)</span>
<span class="source-line-no">2596</span><span id="line.2596">            return map;</span>
<span class="source-line-no">2597</span><span id="line.2597">        int width2 = Math.min(width, map.length), height2 = Math.min(height, map[0].length);</span>
<span class="source-line-no">2598</span><span id="line.2598">        for (int x = 0; x &lt; width2; x++) {</span>
<span class="source-line-no">2599</span><span id="line.2599">            for (int y = 0; y &lt; height2; y++) {</span>
<span class="source-line-no">2600</span><span id="line.2600">                if((data[x * ySections + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0)</span>
<span class="source-line-no">2601</span><span id="line.2601">                    map[x][y] = toWrite;</span>
<span class="source-line-no">2602</span><span id="line.2602">            }</span>
<span class="source-line-no">2603</span><span id="line.2603">        }</span>
<span class="source-line-no">2604</span><span id="line.2604">        return map;</span>
<span class="source-line-no">2605</span><span id="line.2605">    }</span>
<span class="source-line-no">2606</span><span id="line.2606"></span>
<span class="source-line-no">2607</span><span id="line.2607">    /**</span>
<span class="source-line-no">2608</span><span id="line.2608">     * Union of two GreasedRegions, assigning the result into this GreasedRegion. Any cell that is "on" in either</span>
<span class="source-line-no">2609</span><span id="line.2609">     * GreasedRegion will be made "on" in this GreasedRegion.</span>
<span class="source-line-no">2610</span><span id="line.2610">     * @param other another GreasedRegion that will not be modified</span>
<span class="source-line-no">2611</span><span id="line.2611">     * @return this, after modification, for chaining</span>
<span class="source-line-no">2612</span><span id="line.2612">     */</span>
<span class="source-line-no">2613</span><span id="line.2613">    public GreasedRegion or(GreasedRegion other)</span>
<span class="source-line-no">2614</span><span id="line.2614">    {</span>
<span class="source-line-no">2615</span><span id="line.2615">        for (int x = 0; x &lt; width &amp;&amp; x &lt; other.width; x++) {</span>
<span class="source-line-no">2616</span><span id="line.2616">            for (int y = 0; y &lt; ySections &amp;&amp; y &lt; other.ySections; y++) {</span>
<span class="source-line-no">2617</span><span id="line.2617">                data[x * ySections + y] |= other.data[x * other.ySections + y];</span>
<span class="source-line-no">2618</span><span id="line.2618">            }</span>
<span class="source-line-no">2619</span><span id="line.2619">        }</span>
<span class="source-line-no">2620</span><span id="line.2620"></span>
<span class="source-line-no">2621</span><span id="line.2621">        if(ySections &gt; 0 &amp;&amp; yEndMask != -1) {</span>
<span class="source-line-no">2622</span><span id="line.2622">            for (int a = ySections - 1; a &lt; data.length; a += ySections) {</span>
<span class="source-line-no">2623</span><span id="line.2623">                data[a] &amp;= yEndMask;</span>
<span class="source-line-no">2624</span><span id="line.2624">            }</span>
<span class="source-line-no">2625</span><span id="line.2625">        }</span>
<span class="source-line-no">2626</span><span id="line.2626">        tallied = false;</span>
<span class="source-line-no">2627</span><span id="line.2627"></span>
<span class="source-line-no">2628</span><span id="line.2628">        return this;</span>
<span class="source-line-no">2629</span><span id="line.2629">    }</span>
<span class="source-line-no">2630</span><span id="line.2630"></span>
<span class="source-line-no">2631</span><span id="line.2631">    /**</span>
<span class="source-line-no">2632</span><span id="line.2632">     * Intersection of two GreasedRegions, assigning the result into this GreasedRegion. Any cell that is "on" in both</span>
<span class="source-line-no">2633</span><span id="line.2633">     * GreasedRegions will be kept "on" in this GreasedRegion, but all other cells will be made "off."</span>
<span class="source-line-no">2634</span><span id="line.2634">     * @param other another GreasedRegion that will not be modified</span>
<span class="source-line-no">2635</span><span id="line.2635">     * @return this, after modification, for chaining</span>
<span class="source-line-no">2636</span><span id="line.2636">     */</span>
<span class="source-line-no">2637</span><span id="line.2637">    public GreasedRegion and(GreasedRegion other)</span>
<span class="source-line-no">2638</span><span id="line.2638">    {</span>
<span class="source-line-no">2639</span><span id="line.2639">        for (int x = 0; x &lt; width &amp;&amp; x &lt; other.width; x++) {</span>
<span class="source-line-no">2640</span><span id="line.2640">            for (int y = 0; y &lt; ySections &amp;&amp; y &lt; other.ySections; y++) {</span>
<span class="source-line-no">2641</span><span id="line.2641">                data[x * ySections + y] &amp;= other.data[x * other.ySections + y];</span>
<span class="source-line-no">2642</span><span id="line.2642">            }</span>
<span class="source-line-no">2643</span><span id="line.2643">        }</span>
<span class="source-line-no">2644</span><span id="line.2644">        tallied = false;</span>
<span class="source-line-no">2645</span><span id="line.2645">        return this;</span>
<span class="source-line-no">2646</span><span id="line.2646">    }</span>
<span class="source-line-no">2647</span><span id="line.2647"></span>
<span class="source-line-no">2648</span><span id="line.2648">    /**</span>
<span class="source-line-no">2649</span><span id="line.2649">     * Intersection of two GreasedRegions, assigning the result into this GreasedRegion, with the special requirement</span>
<span class="source-line-no">2650</span><span id="line.2650">     * that other must be a 64x64 area, and the special property that other will be considered tiled to cover all of the</span>
<span class="source-line-no">2651</span><span id="line.2651">     * area of this GreasedRegion. Any cell that is "on" in both GreasedRegions (treating other as tiling) will be kept</span>
<span class="source-line-no">2652</span><span id="line.2652">     * "on" in this GreasedRegion, but all other cells will be made "off."</span>
<span class="source-line-no">2653</span><span id="line.2653">     * @param other another GreasedRegion that will not be modified but must be 64x64 in size; will act as if it tiles</span>
<span class="source-line-no">2654</span><span id="line.2654">     * @return this, after modification, for chaining</span>
<span class="source-line-no">2655</span><span id="line.2655">     */</span>
<span class="source-line-no">2656</span><span id="line.2656">    public GreasedRegion andWrapping64(GreasedRegion other)</span>
<span class="source-line-no">2657</span><span id="line.2657">    {</span>
<span class="source-line-no">2658</span><span id="line.2658">        for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">2659</span><span id="line.2659">            for (int y = 0; y &lt; ySections; y++) {</span>
<span class="source-line-no">2660</span><span id="line.2660">                data[x * ySections + y] &amp;= other.data[x &amp; 63];</span>
<span class="source-line-no">2661</span><span id="line.2661">            }</span>
<span class="source-line-no">2662</span><span id="line.2662">        }</span>
<span class="source-line-no">2663</span><span id="line.2663">        tallied = false;</span>
<span class="source-line-no">2664</span><span id="line.2664">        return this;</span>
<span class="source-line-no">2665</span><span id="line.2665">    }</span>
<span class="source-line-no">2666</span><span id="line.2666">    /**</span>
<span class="source-line-no">2667</span><span id="line.2667">     * Difference of two GreasedRegions, assigning the result into this GreasedRegion. Any cell that is "on" in this</span>
<span class="source-line-no">2668</span><span id="line.2668">     * GreasedRegion and "off" in other will be kept "on" in this GreasedRegion, but all other cells will be made "off."</span>
<span class="source-line-no">2669</span><span id="line.2669">     * @param other another GreasedRegion that will not be modified</span>
<span class="source-line-no">2670</span><span id="line.2670">     * @return this, after modification, for chaining</span>
<span class="source-line-no">2671</span><span id="line.2671">     * @see #notAnd(GreasedRegion) notAnd is a very similar method that acts sort-of in reverse of this method</span>
<span class="source-line-no">2672</span><span id="line.2672">     */</span>
<span class="source-line-no">2673</span><span id="line.2673">    public GreasedRegion andNot(GreasedRegion other)</span>
<span class="source-line-no">2674</span><span id="line.2674">    {</span>
<span class="source-line-no">2675</span><span id="line.2675">        for (int x = 0; x &lt; width &amp;&amp; x &lt; other.width; x++) {</span>
<span class="source-line-no">2676</span><span id="line.2676">            for (int y = 0; y &lt; ySections &amp;&amp; y &lt; other.ySections; y++) {</span>
<span class="source-line-no">2677</span><span id="line.2677">                data[x * ySections + y] &amp;= ~other.data[x * other.ySections + y];</span>
<span class="source-line-no">2678</span><span id="line.2678">            }</span>
<span class="source-line-no">2679</span><span id="line.2679">        }</span>
<span class="source-line-no">2680</span><span id="line.2680">        tallied = false;</span>
<span class="source-line-no">2681</span><span id="line.2681">        return this;</span>
<span class="source-line-no">2682</span><span id="line.2682">    }</span>
<span class="source-line-no">2683</span><span id="line.2683"></span>
<span class="source-line-no">2684</span><span id="line.2684">    /**</span>
<span class="source-line-no">2685</span><span id="line.2685">     * Like andNot, but subtracts this GreasedRegion from other and stores the result in this GreasedRegion, without</span>
<span class="source-line-no">2686</span><span id="line.2686">     * mutating other.</span>
<span class="source-line-no">2687</span><span id="line.2687">     * @param other another GreasedRegion that will not be modified</span>
<span class="source-line-no">2688</span><span id="line.2688">     * @return this, after modification, for chaining</span>
<span class="source-line-no">2689</span><span id="line.2689">     * @see #andNot(GreasedRegion) andNot is a very similar method that acts sort-of in reverse of this method</span>
<span class="source-line-no">2690</span><span id="line.2690">     */</span>
<span class="source-line-no">2691</span><span id="line.2691">    public GreasedRegion notAnd(GreasedRegion other)</span>
<span class="source-line-no">2692</span><span id="line.2692">    {</span>
<span class="source-line-no">2693</span><span id="line.2693">        for (int x = 0; x &lt; width &amp;&amp; x &lt; other.width; x++) {</span>
<span class="source-line-no">2694</span><span id="line.2694">            for (int y = 0; y &lt; ySections &amp;&amp; y &lt; other.ySections; y++) {</span>
<span class="source-line-no">2695</span><span id="line.2695">                data[x * ySections + y] = other.data[x * other.ySections + y] &amp; ~data[x * ySections + y];</span>
<span class="source-line-no">2696</span><span id="line.2696">            }</span>
<span class="source-line-no">2697</span><span id="line.2697">        }</span>
<span class="source-line-no">2698</span><span id="line.2698">        tallied = false;</span>
<span class="source-line-no">2699</span><span id="line.2699">        return this;</span>
<span class="source-line-no">2700</span><span id="line.2700">    }</span>
<span class="source-line-no">2701</span><span id="line.2701"></span>
<span class="source-line-no">2702</span><span id="line.2702">    /**</span>
<span class="source-line-no">2703</span><span id="line.2703">     * Symmetric difference (more commonly known as exclusive or, hence the name) of two GreasedRegions, assigning the</span>
<span class="source-line-no">2704</span><span id="line.2704">     * result into this GreasedRegion. Any cell that is "on" in this and "off" in other, or "off" in this and "on" in</span>
<span class="source-line-no">2705</span><span id="line.2705">     * other, will be made "on" in this; all other cells will be made "off." Useful to find cells that are "on" in</span>
<span class="source-line-no">2706</span><span id="line.2706">     * exactly one of two GreasedRegions (not "on" in both, or "off" in both).</span>
<span class="source-line-no">2707</span><span id="line.2707">     * @param other another GreasedRegion that will not be modified</span>
<span class="source-line-no">2708</span><span id="line.2708">     * @return this, after modification, for chaining</span>
<span class="source-line-no">2709</span><span id="line.2709">     */</span>
<span class="source-line-no">2710</span><span id="line.2710">    public GreasedRegion xor(GreasedRegion other)</span>
<span class="source-line-no">2711</span><span id="line.2711">    {</span>
<span class="source-line-no">2712</span><span id="line.2712">        for (int x = 0; x &lt; width &amp;&amp; x &lt; other.width; x++) {</span>
<span class="source-line-no">2713</span><span id="line.2713">            for (int y = 0; y &lt; ySections &amp;&amp; y &lt; other.ySections; y++) {</span>
<span class="source-line-no">2714</span><span id="line.2714">                data[x * ySections + y] ^= other.data[x * other.ySections + y];</span>
<span class="source-line-no">2715</span><span id="line.2715">            }</span>
<span class="source-line-no">2716</span><span id="line.2716">        }</span>
<span class="source-line-no">2717</span><span id="line.2717"></span>
<span class="source-line-no">2718</span><span id="line.2718">        if(ySections &gt; 0 &amp;&amp; yEndMask != -1) {</span>
<span class="source-line-no">2719</span><span id="line.2719">            for (int a = ySections - 1; a &lt; data.length; a += ySections) {</span>
<span class="source-line-no">2720</span><span id="line.2720">                data[a] &amp;= yEndMask;</span>
<span class="source-line-no">2721</span><span id="line.2721">            }</span>
<span class="source-line-no">2722</span><span id="line.2722">        }</span>
<span class="source-line-no">2723</span><span id="line.2723">        tallied = false;</span>
<span class="source-line-no">2724</span><span id="line.2724">        return this;</span>
<span class="source-line-no">2725</span><span id="line.2725">    }</span>
<span class="source-line-no">2726</span><span id="line.2726"></span>
<span class="source-line-no">2727</span><span id="line.2727">    /**</span>
<span class="source-line-no">2728</span><span id="line.2728">     * Negates this GreasedRegion, turning "on" to "off" and "off" to "on."</span>
<span class="source-line-no">2729</span><span id="line.2729">     * @return this, after modification, for chaining</span>
<span class="source-line-no">2730</span><span id="line.2730">     */</span>
<span class="source-line-no">2731</span><span id="line.2731">    public GreasedRegion not()</span>
<span class="source-line-no">2732</span><span id="line.2732">    {</span>
<span class="source-line-no">2733</span><span id="line.2733">        for (int a = 0; a &lt; data.length; a++)</span>
<span class="source-line-no">2734</span><span id="line.2734">        {</span>
<span class="source-line-no">2735</span><span id="line.2735">            data[a] = ~data[a];</span>
<span class="source-line-no">2736</span><span id="line.2736">        }</span>
<span class="source-line-no">2737</span><span id="line.2737"></span>
<span class="source-line-no">2738</span><span id="line.2738">        if(ySections &gt; 0 &amp;&amp; yEndMask != -1) {</span>
<span class="source-line-no">2739</span><span id="line.2739">            for (int a = ySections - 1; a &lt; data.length; a += ySections) {</span>
<span class="source-line-no">2740</span><span id="line.2740">                data[a] &amp;= yEndMask;</span>
<span class="source-line-no">2741</span><span id="line.2741">            }</span>
<span class="source-line-no">2742</span><span id="line.2742">        }</span>
<span class="source-line-no">2743</span><span id="line.2743">        tallied = false;</span>
<span class="source-line-no">2744</span><span id="line.2744">        return this;</span>
<span class="source-line-no">2745</span><span id="line.2745">    }</span>
<span class="source-line-no">2746</span><span id="line.2746"></span>
<span class="source-line-no">2747</span><span id="line.2747">    /**</span>
<span class="source-line-no">2748</span><span id="line.2748">     * Moves the "on" cells in this GreasedRegion to the given x and y offset, removing cells that move out of bounds.</span>
<span class="source-line-no">2749</span><span id="line.2749">     * @param x the x offset to translate by; can be negative</span>
<span class="source-line-no">2750</span><span id="line.2750">     * @param y the y offset to translate by; can be negative</span>
<span class="source-line-no">2751</span><span id="line.2751">     * @return this for chaining</span>
<span class="source-line-no">2752</span><span id="line.2752">     */</span>
<span class="source-line-no">2753</span><span id="line.2753">    public GreasedRegion translate(int x, int y) {</span>
<span class="source-line-no">2754</span><span id="line.2754">        GreasedRegion result = this;</span>
<span class="source-line-no">2755</span><span id="line.2755">        if (width &lt; 1 || ySections &lt;= 0 || (x == 0 &amp;&amp; y == 0)) {</span>
<span class="source-line-no">2756</span><span id="line.2756">        } else {</span>
<span class="source-line-no">2757</span><span id="line.2757">            int start = Math.max(0, x), len = Math.min(width, width + x) - start,</span>
<span class="source-line-no">2758</span><span id="line.2758">                    jump = (y == 0) ? 0 : (y &lt; 0) ? -(-y &gt;&gt;&gt; 6) : (y &gt;&gt;&gt; 6), lily = (y &lt; 0) ? -(-y &amp; 63) : (y &amp; 63),</span>
<span class="source-line-no">2759</span><span id="line.2759">                    originalJump = Math.max(0, -jump), alterJump = Math.max(0, jump);</span>
<span class="source-line-no">2760</span><span id="line.2760">            long[] data2 = new long[width * ySections];</span>
<span class="source-line-no">2761</span><span id="line.2761">            long prev, tmp;</span>
<span class="source-line-no">2762</span><span id="line.2762">            if (x &lt; 0) {</span>
<span class="source-line-no">2763</span><span id="line.2763">                for (int i = alterJump, oi = originalJump; i &lt; ySections &amp;&amp; oi &lt; ySections; i++, oi++) {</span>
<span class="source-line-no">2764</span><span id="line.2764">                    for (int j = Math.max(0, -x), jj = 0; jj &lt; len; j++, jj++) {</span>
<span class="source-line-no">2765</span><span id="line.2765">                        data2[jj * ySections + i] = data[j * ySections + oi];</span>
<span class="source-line-no">2766</span><span id="line.2766">                    }</span>
<span class="source-line-no">2767</span><span id="line.2767">                }</span>
<span class="source-line-no">2768</span><span id="line.2768">            } else if (x &gt; 0) {</span>
<span class="source-line-no">2769</span><span id="line.2769">                for (int i = alterJump, oi = originalJump; i &lt; ySections &amp;&amp; oi &lt; ySections; i++, oi++) {</span>
<span class="source-line-no">2770</span><span id="line.2770">                    for (int j = 0, jj = start; j &lt; len; j++, jj++) {</span>
<span class="source-line-no">2771</span><span id="line.2771">                        data2[jj * ySections + i] = data[j * ySections + oi];</span>
<span class="source-line-no">2772</span><span id="line.2772">                    }</span>
<span class="source-line-no">2773</span><span id="line.2773">                }</span>
<span class="source-line-no">2774</span><span id="line.2774">            } else {</span>
<span class="source-line-no">2775</span><span id="line.2775">                for (int i = alterJump, oi = originalJump; i &lt; ySections &amp;&amp; oi &lt; ySections; i++, oi++) {</span>
<span class="source-line-no">2776</span><span id="line.2776">                    for (int j = 0; j &lt; len; j++) {</span>
<span class="source-line-no">2777</span><span id="line.2777">                        data2[j * ySections + i] = data[j * ySections + oi];</span>
<span class="source-line-no">2778</span><span id="line.2778">                    }</span>
<span class="source-line-no">2779</span><span id="line.2779">                }</span>
<span class="source-line-no">2780</span><span id="line.2780">            }</span>
<span class="source-line-no">2781</span><span id="line.2781">            if (lily &lt; 0) {</span>
<span class="source-line-no">2782</span><span id="line.2782">                for (int i = start; i &lt; len; i++) {</span>
<span class="source-line-no">2783</span><span id="line.2783">                    prev = 0L;</span>
<span class="source-line-no">2784</span><span id="line.2784">                    for (int j = 0; j &lt; ySections; j++) {</span>
<span class="source-line-no">2785</span><span id="line.2785">                        tmp = prev;</span>
<span class="source-line-no">2786</span><span id="line.2786">                        prev = (data2[i * ySections + j] &amp; ~(-1L &lt;&lt; -lily)) &lt;&lt; (64 + lily);</span>
<span class="source-line-no">2787</span><span id="line.2787">                        data2[i * ySections + j] &gt;&gt;&gt;= -lily;</span>
<span class="source-line-no">2788</span><span id="line.2788">                        data2[i * ySections + j] |= tmp;</span>
<span class="source-line-no">2789</span><span id="line.2789">                    }</span>
<span class="source-line-no">2790</span><span id="line.2790">                }</span>
<span class="source-line-no">2791</span><span id="line.2791">            } else if (lily &gt; 0) {</span>
<span class="source-line-no">2792</span><span id="line.2792">                for (int i = start; i &lt; start + len; i++) {</span>
<span class="source-line-no">2793</span><span id="line.2793">                    prev = 0L;</span>
<span class="source-line-no">2794</span><span id="line.2794">                    for (int j = 0; j &lt; ySections; j++) {</span>
<span class="source-line-no">2795</span><span id="line.2795">                        tmp = prev;</span>
<span class="source-line-no">2796</span><span id="line.2796">                        prev = (data2[i * ySections + j] &amp; ~(-1L &gt;&gt;&gt; lily)) &gt;&gt;&gt; (64 - lily);</span>
<span class="source-line-no">2797</span><span id="line.2797">                        data2[i * ySections + j] &lt;&lt;= lily;</span>
<span class="source-line-no">2798</span><span id="line.2798">                        data2[i * ySections + j] |= tmp;</span>
<span class="source-line-no">2799</span><span id="line.2799">                    }</span>
<span class="source-line-no">2800</span><span id="line.2800">                }</span>
<span class="source-line-no">2801</span><span id="line.2801">            }</span>
<span class="source-line-no">2802</span><span id="line.2802">            if (yEndMask != -1) {</span>
<span class="source-line-no">2803</span><span id="line.2803">                for (int a = ySections - 1; a &lt; data2.length; a += ySections) {</span>
<span class="source-line-no">2804</span><span id="line.2804">                    data2[a] &amp;= yEndMask;</span>
<span class="source-line-no">2805</span><span id="line.2805">                }</span>
<span class="source-line-no">2806</span><span id="line.2806">            }</span>
<span class="source-line-no">2807</span><span id="line.2807">            data = data2;</span>
<span class="source-line-no">2808</span><span id="line.2808">            tallied = false;</span>
<span class="source-line-no">2809</span><span id="line.2809">        }</span>
<span class="source-line-no">2810</span><span id="line.2810"></span>
<span class="source-line-no">2811</span><span id="line.2811"></span>
<span class="source-line-no">2812</span><span id="line.2812">        return result;</span>
<span class="source-line-no">2813</span><span id="line.2813">    }</span>
<span class="source-line-no">2814</span><span id="line.2814"></span>
<span class="source-line-no">2815</span><span id="line.2815">    /**</span>
<span class="source-line-no">2816</span><span id="line.2816">     * Adds to this GreasedRegion with a moved set of its own "on" cells, moved to the given x and y offset.</span>
<span class="source-line-no">2817</span><span id="line.2817">     * Ignores cells that would be added out of bounds. Keeps all cells that are currently "on" unchanged.</span>
<span class="source-line-no">2818</span><span id="line.2818">     * @param x the x offset to translate by; can be negative</span>
<span class="source-line-no">2819</span><span id="line.2819">     * @param y the y offset to translate by; can be negative</span>
<span class="source-line-no">2820</span><span id="line.2820">     * @return this for chaining</span>
<span class="source-line-no">2821</span><span id="line.2821">     */</span>
<span class="source-line-no">2822</span><span id="line.2822">    public GreasedRegion insertTranslation(int x, int y) {</span>
<span class="source-line-no">2823</span><span id="line.2823">        GreasedRegion result = this;</span>
<span class="source-line-no">2824</span><span id="line.2824">        if (width &lt; 1 || ySections &lt;= 0 || (x == 0 &amp;&amp; y == 0)) {</span>
<span class="source-line-no">2825</span><span id="line.2825">        } else {</span>
<span class="source-line-no">2826</span><span id="line.2826">            int start = Math.max(0, x), len = Math.min(width, width + x) - start,</span>
<span class="source-line-no">2827</span><span id="line.2827">                    jump = (y == 0) ? 0 : (y &lt; 0) ? -(-y &gt;&gt;&gt; 6) : (y &gt;&gt;&gt; 6), lily = (y &lt; 0) ? -(-y &amp; 63) : (y &amp; 63),</span>
<span class="source-line-no">2828</span><span id="line.2828">                    originalJump = Math.max(0, -jump), alterJump = Math.max(0, jump);</span>
<span class="source-line-no">2829</span><span id="line.2829">            long[] data2 = new long[width * ySections];</span>
<span class="source-line-no">2830</span><span id="line.2830">            long prev, tmp;</span>
<span class="source-line-no">2831</span><span id="line.2831">            if (x &lt; 0) {</span>
<span class="source-line-no">2832</span><span id="line.2832">                for (int i = alterJump, oi = originalJump; i &lt; ySections &amp;&amp; oi &lt; ySections; i++, oi++) {</span>
<span class="source-line-no">2833</span><span id="line.2833">                    for (int j = Math.max(0, -x), jj = 0; jj &lt; len; j++, jj++) {</span>
<span class="source-line-no">2834</span><span id="line.2834">                        data2[jj * ySections + i] = data[j * ySections + oi];</span>
<span class="source-line-no">2835</span><span id="line.2835">                    }</span>
<span class="source-line-no">2836</span><span id="line.2836">                }</span>
<span class="source-line-no">2837</span><span id="line.2837">            } else if (x &gt; 0) {</span>
<span class="source-line-no">2838</span><span id="line.2838">                for (int i = alterJump, oi = originalJump; i &lt; ySections &amp;&amp; oi &lt; ySections; i++, oi++) {</span>
<span class="source-line-no">2839</span><span id="line.2839">                    for (int j = 0, jj = start; j &lt; len; j++, jj++) {</span>
<span class="source-line-no">2840</span><span id="line.2840">                        data2[jj * ySections + i] = data[j * ySections + oi];</span>
<span class="source-line-no">2841</span><span id="line.2841">                    }</span>
<span class="source-line-no">2842</span><span id="line.2842">                }</span>
<span class="source-line-no">2843</span><span id="line.2843">            } else {</span>
<span class="source-line-no">2844</span><span id="line.2844">                for (int i = alterJump, oi = originalJump; i &lt; ySections &amp;&amp; oi &lt; ySections; i++, oi++) {</span>
<span class="source-line-no">2845</span><span id="line.2845">                    for (int j = 0; j &lt; len; j++) {</span>
<span class="source-line-no">2846</span><span id="line.2846">                        data2[j * ySections + i] = data[j * ySections + oi];</span>
<span class="source-line-no">2847</span><span id="line.2847">                    }</span>
<span class="source-line-no">2848</span><span id="line.2848">                }</span>
<span class="source-line-no">2849</span><span id="line.2849">            }</span>
<span class="source-line-no">2850</span><span id="line.2850">            if (lily &lt; 0) {</span>
<span class="source-line-no">2851</span><span id="line.2851">                for (int i = start; i &lt; len; i++) {</span>
<span class="source-line-no">2852</span><span id="line.2852">                    prev = 0L;</span>
<span class="source-line-no">2853</span><span id="line.2853">                    for (int j = 0; j &lt; ySections; j++) {</span>
<span class="source-line-no">2854</span><span id="line.2854">                        tmp = prev;</span>
<span class="source-line-no">2855</span><span id="line.2855">                        prev = (data2[i * ySections + j] &amp; ~(-1L &lt;&lt; -lily)) &lt;&lt; (64 + lily);</span>
<span class="source-line-no">2856</span><span id="line.2856">                        data2[i * ySections + j] &gt;&gt;&gt;= -lily;</span>
<span class="source-line-no">2857</span><span id="line.2857">                        data2[i * ySections + j] |= tmp;</span>
<span class="source-line-no">2858</span><span id="line.2858">                    }</span>
<span class="source-line-no">2859</span><span id="line.2859">                }</span>
<span class="source-line-no">2860</span><span id="line.2860">            } else if (lily &gt; 0) {</span>
<span class="source-line-no">2861</span><span id="line.2861">                for (int i = start; i &lt; start + len; i++) {</span>
<span class="source-line-no">2862</span><span id="line.2862">                    prev = 0L;</span>
<span class="source-line-no">2863</span><span id="line.2863">                    for (int j = 0; j &lt; ySections; j++) {</span>
<span class="source-line-no">2864</span><span id="line.2864">                        tmp = prev;</span>
<span class="source-line-no">2865</span><span id="line.2865">                        prev = (data2[i * ySections + j] &amp; ~(-1L &gt;&gt;&gt; lily)) &gt;&gt;&gt; (64 - lily);</span>
<span class="source-line-no">2866</span><span id="line.2866">                        data2[i * ySections + j] &lt;&lt;= lily;</span>
<span class="source-line-no">2867</span><span id="line.2867">                        data2[i * ySections + j] |= tmp;</span>
<span class="source-line-no">2868</span><span id="line.2868">                    }</span>
<span class="source-line-no">2869</span><span id="line.2869">                }</span>
<span class="source-line-no">2870</span><span id="line.2870">            }</span>
<span class="source-line-no">2871</span><span id="line.2871">            for (int i = 0; i &lt; width * ySections; i++) {</span>
<span class="source-line-no">2872</span><span id="line.2872">                data2[i] |= data[i];</span>
<span class="source-line-no">2873</span><span id="line.2873">            }</span>
<span class="source-line-no">2874</span><span id="line.2874">            if (yEndMask != -1) {</span>
<span class="source-line-no">2875</span><span id="line.2875">                for (int a = ySections - 1; a &lt; data2.length; a += ySections) {</span>
<span class="source-line-no">2876</span><span id="line.2876">                    data2[a] &amp;= yEndMask;</span>
<span class="source-line-no">2877</span><span id="line.2877">                }</span>
<span class="source-line-no">2878</span><span id="line.2878">            }</span>
<span class="source-line-no">2879</span><span id="line.2879">            data = data2;</span>
<span class="source-line-no">2880</span><span id="line.2880">            tallied = false;</span>
<span class="source-line-no">2881</span><span id="line.2881">        }</span>
<span class="source-line-no">2882</span><span id="line.2882"></span>
<span class="source-line-no">2883</span><span id="line.2883"></span>
<span class="source-line-no">2884</span><span id="line.2884">        return result;</span>
<span class="source-line-no">2885</span><span id="line.2885">    }</span>
<span class="source-line-no">2886</span><span id="line.2886"></span>
<span class="source-line-no">2887</span><span id="line.2887">    /**</span>
<span class="source-line-no">2888</span><span id="line.2888">     * Effectively doubles the x and y values of each cell this contains (not scaling each cell to be larger, so each</span>
<span class="source-line-no">2889</span><span id="line.2889">     * "on" cell will be surrounded by "off" cells), and re-maps the positions so the given x and y in the doubled space</span>
<span class="source-line-no">2890</span><span id="line.2890">     * become 0,0 in the resulting GreasedRegion (which is this, assigning to itself).</span>
<span class="source-line-no">2891</span><span id="line.2891">     * @param x in the doubled coordinate space, the x position that should become 0 x in the result; can be negative</span>
<span class="source-line-no">2892</span><span id="line.2892">     * @param y in the doubled coordinate space, the y position that should become 0 y in the result; can be negative</span>
<span class="source-line-no">2893</span><span id="line.2893">     * @return this for chaining</span>
<span class="source-line-no">2894</span><span id="line.2894">     */</span>
<span class="source-line-no">2895</span><span id="line.2895">    public GreasedRegion zoom(int x, int y) {</span>
<span class="source-line-no">2896</span><span id="line.2896">        GreasedRegion result = this;</span>
<span class="source-line-no">2897</span><span id="line.2897">        if (width &lt; 1 || ySections &lt;= 0) {</span>
<span class="source-line-no">2898</span><span id="line.2898">        } else {</span>
<span class="source-line-no">2899</span><span id="line.2899">            x = -x;</span>
<span class="source-line-no">2900</span><span id="line.2900">            y = -y;</span>
<span class="source-line-no">2901</span><span id="line.2901">            int</span>
<span class="source-line-no">2902</span><span id="line.2902">                    width2 = width + 1 &gt;&gt;&gt; 1, ySections2 = ySections + 1 &gt;&gt;&gt; 1,</span>
<span class="source-line-no">2903</span><span id="line.2903">                    start = Math.max(0, x), len = Math.min(width, width + x) - start,</span>
<span class="source-line-no">2904</span><span id="line.2904">                    //tall = (Math.min(height, height + y) - Math.max(0, y)) + 63 &gt;&gt; 6,</span>
<span class="source-line-no">2905</span><span id="line.2905">                    jump = (y == 0) ? 0 : (y &lt; 0) ? -(-y &gt;&gt;&gt; 6) : (y &gt;&gt;&gt; 6), lily = (y &lt; 0) ? -(-y &amp; 63) : (y &amp; 63),</span>
<span class="source-line-no">2906</span><span id="line.2906">                    originalJump = Math.max(0, -jump), alterJump = Math.max(0, jump),</span>
<span class="source-line-no">2907</span><span id="line.2907">                    oddX = (x &amp; 1), oddY = (y &amp; 1);</span>
<span class="source-line-no">2908</span><span id="line.2908">            long[] data2 = new long[width * ySections];</span>
<span class="source-line-no">2909</span><span id="line.2909">            long prev, tmp, yEndMask2 = -1L &gt;&gt;&gt; (64 - ((height + 1 &gt;&gt;&gt; 1) &amp; 63));</span>
<span class="source-line-no">2910</span><span id="line.2910">            if (x &lt; 0) {</span>
<span class="source-line-no">2911</span><span id="line.2911">                for (int i = alterJump, oi = originalJump; i &lt;= ySections2 &amp;&amp; oi &lt; ySections; i++, oi++) {</span>
<span class="source-line-no">2912</span><span id="line.2912">                    for (int j = Math.max(0, -x), jj = 0; jj &lt; len; j++, jj++) {</span>
<span class="source-line-no">2913</span><span id="line.2913">                        data2[jj * ySections + i] = data[j * ySections + oi];</span>
<span class="source-line-no">2914</span><span id="line.2914">                    }</span>
<span class="source-line-no">2915</span><span id="line.2915">                }</span>
<span class="source-line-no">2916</span><span id="line.2916">            } else if (x &gt; 0) {</span>
<span class="source-line-no">2917</span><span id="line.2917">                for (int i = alterJump, oi = originalJump; i &lt;= ySections2 &amp;&amp; oi &lt; ySections; i++, oi++) {</span>
<span class="source-line-no">2918</span><span id="line.2918">                    for (int j = 0, jj = start; j &lt; len; j++, jj++) {</span>
<span class="source-line-no">2919</span><span id="line.2919">                        data2[jj * ySections + i] = data[j * ySections + oi];</span>
<span class="source-line-no">2920</span><span id="line.2920">                    }</span>
<span class="source-line-no">2921</span><span id="line.2921">                }</span>
<span class="source-line-no">2922</span><span id="line.2922">            } else {</span>
<span class="source-line-no">2923</span><span id="line.2923">                for (int i = alterJump, oi = originalJump; i &lt;= ySections2 &amp;&amp; oi &lt; ySections; i++, oi++) {</span>
<span class="source-line-no">2924</span><span id="line.2924">                    for (int j = 0; j &lt; len; j++) {</span>
<span class="source-line-no">2925</span><span id="line.2925">                        data2[j * ySections + i] = data[j * ySections + oi];</span>
<span class="source-line-no">2926</span><span id="line.2926">                    }</span>
<span class="source-line-no">2927</span><span id="line.2927">                }</span>
<span class="source-line-no">2928</span><span id="line.2928">            }</span>
<span class="source-line-no">2929</span><span id="line.2929">            if (lily &lt; 0) {</span>
<span class="source-line-no">2930</span><span id="line.2930">                for (int i = start; i &lt; len; i++) {</span>
<span class="source-line-no">2931</span><span id="line.2931">                    prev = 0L;</span>
<span class="source-line-no">2932</span><span id="line.2932">                    for (int j = ySections2; j &gt;= 0; j--) {</span>
<span class="source-line-no">2933</span><span id="line.2933">                        tmp = prev;</span>
<span class="source-line-no">2934</span><span id="line.2934">                        prev = (data2[i * ySections + j] &amp; ~(-1L &lt;&lt; -lily)) &lt;&lt; (64 + lily);</span>
<span class="source-line-no">2935</span><span id="line.2935">                        data2[i * ySections + j] &gt;&gt;&gt;= -lily;</span>
<span class="source-line-no">2936</span><span id="line.2936">                        data2[i * ySections + j] |= tmp;</span>
<span class="source-line-no">2937</span><span id="line.2937">                    }</span>
<span class="source-line-no">2938</span><span id="line.2938">                }</span>
<span class="source-line-no">2939</span><span id="line.2939">            } else if (lily &gt; 0) {</span>
<span class="source-line-no">2940</span><span id="line.2940">                for (int i = start; i &lt; start + len; i++) {</span>
<span class="source-line-no">2941</span><span id="line.2941">                    prev = 0L;</span>
<span class="source-line-no">2942</span><span id="line.2942">                    for (int j = 0; j &lt; ySections2; j++) {</span>
<span class="source-line-no">2943</span><span id="line.2943">                        tmp = prev;</span>
<span class="source-line-no">2944</span><span id="line.2944">                        prev = (data2[i * ySections + j] &amp; ~(-1L &gt;&gt;&gt; lily)) &gt;&gt;&gt; (64 - lily);</span>
<span class="source-line-no">2945</span><span id="line.2945">                        data2[i * ySections + j] &lt;&lt;= lily;</span>
<span class="source-line-no">2946</span><span id="line.2946">                        data2[i * ySections + j] |= tmp;</span>
<span class="source-line-no">2947</span><span id="line.2947">                    }</span>
<span class="source-line-no">2948</span><span id="line.2948">                }</span>
<span class="source-line-no">2949</span><span id="line.2949">            }</span>
<span class="source-line-no">2950</span><span id="line.2950">            if (yEndMask2 != -1) {</span>
<span class="source-line-no">2951</span><span id="line.2951">                for (int a = ySections2 - 1; a &lt; data2.length; a += ySections) {</span>
<span class="source-line-no">2952</span><span id="line.2952">                    data2[a] &amp;= yEndMask2;</span>
<span class="source-line-no">2953</span><span id="line.2953">                    if (ySections2 &lt; ySections)</span>
<span class="source-line-no">2954</span><span id="line.2954">                        data2[a + 1] = 0L;</span>
<span class="source-line-no">2955</span><span id="line.2955">                }</span>
<span class="source-line-no">2956</span><span id="line.2956">            }</span>
<span class="source-line-no">2957</span><span id="line.2957">            for (int i = 0; i &lt; width2; i++) {</span>
<span class="source-line-no">2958</span><span id="line.2958">                for (int j = 0; j &lt; ySections2; j++) {</span>
<span class="source-line-no">2959</span><span id="line.2959">                    prev = data2[i * ySections + j];</span>
<span class="source-line-no">2960</span><span id="line.2960">                    tmp = prev &gt;&gt;&gt; 32;</span>
<span class="source-line-no">2961</span><span id="line.2961">                    prev &amp;= 0xFFFFFFFFL;</span>
<span class="source-line-no">2962</span><span id="line.2962">                    prev = (prev | (prev &lt;&lt; 16)) &amp; 0x0000FFFF0000FFFFL;</span>
<span class="source-line-no">2963</span><span id="line.2963">                    prev = (prev | (prev &lt;&lt; 8)) &amp; 0x00FF00FF00FF00FFL;</span>
<span class="source-line-no">2964</span><span id="line.2964">                    prev = (prev | (prev &lt;&lt; 4)) &amp; 0x0F0F0F0F0F0F0F0FL;</span>
<span class="source-line-no">2965</span><span id="line.2965">                    prev = (prev | (prev &lt;&lt; 2)) &amp; 0x3333333333333333L;</span>
<span class="source-line-no">2966</span><span id="line.2966">                    prev = (prev | (prev &lt;&lt; 1)) &amp; 0x5555555555555555L;</span>
<span class="source-line-no">2967</span><span id="line.2967">                    prev &lt;&lt;= oddY;</span>
<span class="source-line-no">2968</span><span id="line.2968">                    if (oddX == 1) {</span>
<span class="source-line-no">2969</span><span id="line.2969">                        if (i * 2 + 1 &lt; width)</span>
<span class="source-line-no">2970</span><span id="line.2970">                            data[(i * ySections + j) * 2 + ySections] = prev;</span>
<span class="source-line-no">2971</span><span id="line.2971">                        if (i * 2 &lt; width)</span>
<span class="source-line-no">2972</span><span id="line.2972">                            data[(i * ySections + j) * 2] = 0L;</span>
<span class="source-line-no">2973</span><span id="line.2973">                    } else {</span>
<span class="source-line-no">2974</span><span id="line.2974">                        if (i * 2 &lt; width)</span>
<span class="source-line-no">2975</span><span id="line.2975">                            data[(i * ySections + j) * 2] = prev;</span>
<span class="source-line-no">2976</span><span id="line.2976">                        if (i * 2 + 1 &lt; width)</span>
<span class="source-line-no">2977</span><span id="line.2977">                            data[(i * ySections + j) * 2 + ySections] = 0L;</span>
<span class="source-line-no">2978</span><span id="line.2978">                    }</span>
<span class="source-line-no">2979</span><span id="line.2979">                    if (j * 2 + 1 &lt; ySections) {</span>
<span class="source-line-no">2980</span><span id="line.2980">                        tmp = (tmp | (tmp &lt;&lt; 16)) &amp; 0x0000FFFF0000FFFFL;</span>
<span class="source-line-no">2981</span><span id="line.2981">                        tmp = (tmp | (tmp &lt;&lt; 8)) &amp; 0x00FF00FF00FF00FFL;</span>
<span class="source-line-no">2982</span><span id="line.2982">                        tmp = (tmp | (tmp &lt;&lt; 4)) &amp; 0x0F0F0F0F0F0F0F0FL;</span>
<span class="source-line-no">2983</span><span id="line.2983">                        tmp = (tmp | (tmp &lt;&lt; 2)) &amp; 0x3333333333333333L;</span>
<span class="source-line-no">2984</span><span id="line.2984">                        tmp = (tmp | (tmp &lt;&lt; 1)) &amp; 0x5555555555555555L;</span>
<span class="source-line-no">2985</span><span id="line.2985">                        tmp &lt;&lt;= oddY;</span>
<span class="source-line-no">2986</span><span id="line.2986">                        if (oddX == 1) {</span>
<span class="source-line-no">2987</span><span id="line.2987">                            if (i * 2 + 1 &lt; width)</span>
<span class="source-line-no">2988</span><span id="line.2988">                                data[(i * ySections + j) * 2 + ySections + 1] = tmp;</span>
<span class="source-line-no">2989</span><span id="line.2989">                            if (i * 2 &lt; width)</span>
<span class="source-line-no">2990</span><span id="line.2990">                                data[(i * ySections + j) * 2 + 1] = 0L;</span>
<span class="source-line-no">2991</span><span id="line.2991">                        } else {</span>
<span class="source-line-no">2992</span><span id="line.2992">                            if (i * 2 &lt; width)</span>
<span class="source-line-no">2993</span><span id="line.2993">                                data[(i * ySections + j) * 2 + 1] = tmp;</span>
<span class="source-line-no">2994</span><span id="line.2994">                            if (i * 2 + 1 &lt; width)</span>
<span class="source-line-no">2995</span><span id="line.2995">                                data[(i * ySections + j) * 2 + ySections + 1] = 0L;</span>
<span class="source-line-no">2996</span><span id="line.2996">                        }</span>
<span class="source-line-no">2997</span><span id="line.2997">                    }</span>
<span class="source-line-no">2998</span><span id="line.2998">                }</span>
<span class="source-line-no">2999</span><span id="line.2999">            }</span>
<span class="source-line-no">3000</span><span id="line.3000">            if (yEndMask != -1) {</span>
<span class="source-line-no">3001</span><span id="line.3001">                for (int a = ySections - 1; a &lt; data.length; a += ySections) {</span>
<span class="source-line-no">3002</span><span id="line.3002">                    data[a] &amp;= yEndMask;</span>
<span class="source-line-no">3003</span><span id="line.3003">                }</span>
<span class="source-line-no">3004</span><span id="line.3004">            }</span>
<span class="source-line-no">3005</span><span id="line.3005">            tallied = false;</span>
<span class="source-line-no">3006</span><span id="line.3006">        }</span>
<span class="source-line-no">3007</span><span id="line.3007"></span>
<span class="source-line-no">3008</span><span id="line.3008"></span>
<span class="source-line-no">3009</span><span id="line.3009">        return result;</span>
<span class="source-line-no">3010</span><span id="line.3010">    }</span>
<span class="source-line-no">3011</span><span id="line.3011"></span>
<span class="source-line-no">3012</span><span id="line.3012">    /**</span>
<span class="source-line-no">3013</span><span id="line.3013">     * Takes the pairs of "on" cells in this GreasedRegion that are separated by exactly one cell in an orthogonal line,</span>
<span class="source-line-no">3014</span><span id="line.3014">     * and changes the gap cells to "on" as well.</span>
<span class="source-line-no">3015</span><span id="line.3015">     * &lt;br&gt;</span>
<span class="source-line-no">3016</span><span id="line.3016">     * This method is very efficient due to how the class is implemented, and the various spatial increase/decrease</span>
<span class="source-line-no">3017</span><span id="line.3017">     * methods (including {@link #expand()}, {@link #retract()}, {@link #fringe()}, and {@link #surface()}) all perform</span>
<span class="source-line-no">3018</span><span id="line.3018">     * very well by operating in bulk on up to 64 cells at a time.</span>
<span class="source-line-no">3019</span><span id="line.3019">     * @return this for chaining</span>
<span class="source-line-no">3020</span><span id="line.3020">     */</span>
<span class="source-line-no">3021</span><span id="line.3021">    public GreasedRegion connect() {</span>
<span class="source-line-no">3022</span><span id="line.3022">        GreasedRegion result = this;</span>
<span class="source-line-no">3023</span><span id="line.3023">        if (width &lt; 2 || ySections == 0) {</span>
<span class="source-line-no">3024</span><span id="line.3024">        } else {</span>
<span class="source-line-no">3025</span><span id="line.3025">            final long[] next = new long[width * ySections];</span>
<span class="source-line-no">3026</span><span id="line.3026">            System.arraycopy(data, 0, next, 0, width * ySections);</span>
<span class="source-line-no">3027</span><span id="line.3027">            for (int a = 0; a &lt; ySections; a++) {</span>
<span class="source-line-no">3028</span><span id="line.3028">                next[a] |= ((data[a] &lt;&lt; 1) &amp; (data[a] &gt;&gt;&gt; 1)) | data[a + ySections];</span>
<span class="source-line-no">3029</span><span id="line.3029">                next[(width - 1) * ySections + a] |= ((data[(width - 1) * ySections + a] &lt;&lt; 1) &amp; (data[(width - 1) * ySections + a] &gt;&gt;&gt; 1)) | data[(width - 2) * ySections + a];</span>
<span class="source-line-no">3030</span><span id="line.3030"></span>
<span class="source-line-no">3031</span><span id="line.3031">                for (int i = ySections + a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3032</span><span id="line.3032">                    next[i] |= ((data[i] &lt;&lt; 1) &amp; (data[i] &gt;&gt;&gt; 1)) | (data[i - ySections] &amp; data[i + ySections]);</span>
<span class="source-line-no">3033</span><span id="line.3033">                }</span>
<span class="source-line-no">3034</span><span id="line.3034"></span>
<span class="source-line-no">3035</span><span id="line.3035">                if (a &gt; 0) {</span>
<span class="source-line-no">3036</span><span id="line.3036">                    for (int i = ySections + a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3037</span><span id="line.3037">                        next[i] |= (data[i - 1] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63 &amp; (data[i] &gt;&gt;&gt; 1);</span>
<span class="source-line-no">3038</span><span id="line.3038">                    }</span>
<span class="source-line-no">3039</span><span id="line.3039">                } else {</span>
<span class="source-line-no">3040</span><span id="line.3040">                    for (int i = ySections; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3041</span><span id="line.3041">                        next[i] |= (data[i] &gt;&gt;&gt; 1 &amp; 1L);</span>
<span class="source-line-no">3042</span><span id="line.3042">                    }</span>
<span class="source-line-no">3043</span><span id="line.3043">                }</span>
<span class="source-line-no">3044</span><span id="line.3044"></span>
<span class="source-line-no">3045</span><span id="line.3045">                if (a &lt; ySections - 1) {</span>
<span class="source-line-no">3046</span><span id="line.3046">                    for (int i = ySections + a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3047</span><span id="line.3047">                        next[i] |= (data[i + 1] &amp; 1L) &lt;&lt; 63 &amp; (data[i] &lt;&lt; 1);</span>
<span class="source-line-no">3048</span><span id="line.3048">                    }</span>
<span class="source-line-no">3049</span><span id="line.3049">                } else {</span>
<span class="source-line-no">3050</span><span id="line.3050">                    for (int i = ySections + a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3051</span><span id="line.3051">                        next[i] |= (data[i] &lt;&lt; 1 &amp; 0x8000000000000000L);</span>
<span class="source-line-no">3052</span><span id="line.3052">                    }</span>
<span class="source-line-no">3053</span><span id="line.3053"></span>
<span class="source-line-no">3054</span><span id="line.3054">                }</span>
<span class="source-line-no">3055</span><span id="line.3055">            }</span>
<span class="source-line-no">3056</span><span id="line.3056">            if (ySections &gt; 0 &amp;&amp; yEndMask != -1) {</span>
<span class="source-line-no">3057</span><span id="line.3057">                for (int a = ySections - 1; a &lt; next.length; a += ySections) {</span>
<span class="source-line-no">3058</span><span id="line.3058">                    next[a] &amp;= yEndMask;</span>
<span class="source-line-no">3059</span><span id="line.3059">                }</span>
<span class="source-line-no">3060</span><span id="line.3060">            }</span>
<span class="source-line-no">3061</span><span id="line.3061">            data = next;</span>
<span class="source-line-no">3062</span><span id="line.3062">            tallied = false;</span>
<span class="source-line-no">3063</span><span id="line.3063">        }</span>
<span class="source-line-no">3064</span><span id="line.3064"></span>
<span class="source-line-no">3065</span><span id="line.3065">        return result;</span>
<span class="source-line-no">3066</span><span id="line.3066">    }</span>
<span class="source-line-no">3067</span><span id="line.3067"></span>
<span class="source-line-no">3068</span><span id="line.3068">    /**</span>
<span class="source-line-no">3069</span><span id="line.3069">     * Takes the pairs of "on" cells in this GreasedRegion that are separated by exactly one cell in an orthogonal or</span>
<span class="source-line-no">3070</span><span id="line.3070">     * diagonal line, and changes the gap cells to "on" as well.</span>
<span class="source-line-no">3071</span><span id="line.3071">     * &lt;br&gt;</span>
<span class="source-line-no">3072</span><span id="line.3072">     * This method is very efficient due to how the class is implemented, and the various spatial increase/decrease</span>
<span class="source-line-no">3073</span><span id="line.3073">     * methods (including {@link #expand()}, {@link #retract()}, {@link #fringe()}, and {@link #surface()}) all perform</span>
<span class="source-line-no">3074</span><span id="line.3074">     * very well by operating in bulk on up to 64 cells at a time.</span>
<span class="source-line-no">3075</span><span id="line.3075">     * @return this for chaining</span>
<span class="source-line-no">3076</span><span id="line.3076">     */</span>
<span class="source-line-no">3077</span><span id="line.3077">    public GreasedRegion connect8way() {</span>
<span class="source-line-no">3078</span><span id="line.3078">        GreasedRegion result = this;</span>
<span class="source-line-no">3079</span><span id="line.3079">        if (width &lt; 2 || ySections == 0) {</span>
<span class="source-line-no">3080</span><span id="line.3080">        } else {</span>
<span class="source-line-no">3081</span><span id="line.3081">            final long[] next = new long[width * ySections];</span>
<span class="source-line-no">3082</span><span id="line.3082">            System.arraycopy(data, 0, next, 0, width * ySections);</span>
<span class="source-line-no">3083</span><span id="line.3083">            for (int a = 0; a &lt; ySections; a++) {</span>
<span class="source-line-no">3084</span><span id="line.3084">                next[a] |= ((data[a] &lt;&lt; 1) &amp; (data[a] &gt;&gt;&gt; 1)) | data[a + ySections] | (data[a + ySections] &lt;&lt; 1) | (data[a + ySections] &gt;&gt;&gt; 1);</span>
<span class="source-line-no">3085</span><span id="line.3085">                next[(width - 1) * ySections + a] |= ((data[(width - 1) * ySections + a] &lt;&lt; 1) &amp; (data[(width - 1) * ySections + a] &gt;&gt;&gt; 1))</span>
<span class="source-line-no">3086</span><span id="line.3086">                        | data[(width - 2) * ySections + a] | (data[(width - 2) * ySections + a] &lt;&lt; 1) | (data[(width - 2) * ySections + a] &gt;&gt;&gt; 1);</span>
<span class="source-line-no">3087</span><span id="line.3087"></span>
<span class="source-line-no">3088</span><span id="line.3088">                for (int i = ySections + a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3089</span><span id="line.3089">                    next[i] |= ((data[i] &lt;&lt; 1) &amp; (data[i] &gt;&gt;&gt; 1)) | (data[i - ySections] &amp; data[i + ySections])</span>
<span class="source-line-no">3090</span><span id="line.3090">                            | ((data[i - ySections] &lt;&lt; 1) &amp; (data[i + ySections] &gt;&gt;&gt; 1))</span>
<span class="source-line-no">3091</span><span id="line.3091">                            | ((data[i + ySections] &lt;&lt; 1) &amp; (data[i - ySections] &gt;&gt;&gt; 1));</span>
<span class="source-line-no">3092</span><span id="line.3092">                }</span>
<span class="source-line-no">3093</span><span id="line.3093"></span>
<span class="source-line-no">3094</span><span id="line.3094">                if (a &gt; 0) {</span>
<span class="source-line-no">3095</span><span id="line.3095">                    for (int i = ySections + a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3096</span><span id="line.3096">                        next[i] |= ((data[i - 1] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63 &amp; (data[i] &gt;&gt;&gt; 1)) |</span>
<span class="source-line-no">3097</span><span id="line.3097">                                ((data[i - ySections - 1] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63 &amp; (data[i + ySections] &gt;&gt;&gt; 1)) |</span>
<span class="source-line-no">3098</span><span id="line.3098">                                ((data[i + ySections - 1] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63 &amp; (data[i - ySections] &gt;&gt;&gt; 1));</span>
<span class="source-line-no">3099</span><span id="line.3099">                    }</span>
<span class="source-line-no">3100</span><span id="line.3100">                } else {</span>
<span class="source-line-no">3101</span><span id="line.3101">                    for (int i = ySections; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3102</span><span id="line.3102">                        next[i] |= (data[i] &gt;&gt;&gt; 1 &amp; 1L) | (data[i - ySections] &gt;&gt;&gt; 1 &amp; 1L) | (data[i + ySections] &gt;&gt;&gt; 1 &amp; 1L);</span>
<span class="source-line-no">3103</span><span id="line.3103">                    }</span>
<span class="source-line-no">3104</span><span id="line.3104">                }</span>
<span class="source-line-no">3105</span><span id="line.3105"></span>
<span class="source-line-no">3106</span><span id="line.3106">                if (a &lt; ySections - 1) {</span>
<span class="source-line-no">3107</span><span id="line.3107">                    for (int i = ySections + a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3108</span><span id="line.3108">                        next[i] |= ((data[i + 1] &amp; 1L) &lt;&lt; 63 &amp; (data[i] &lt;&lt; 1)) |</span>
<span class="source-line-no">3109</span><span id="line.3109">                                ((data[i - ySections + 1] &amp; 1L) &lt;&lt; 63 &amp; (data[i + ySections] &lt;&lt; 1)) |</span>
<span class="source-line-no">3110</span><span id="line.3110">                                ((data[i + ySections + 1] &amp; 1L) &lt;&lt; 63 &amp; (data[i - ySections] &lt;&lt; 1));</span>
<span class="source-line-no">3111</span><span id="line.3111">                    }</span>
<span class="source-line-no">3112</span><span id="line.3112">                } else {</span>
<span class="source-line-no">3113</span><span id="line.3113">                    for (int i = ySections + a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3114</span><span id="line.3114">                        next[i] |= (data[i] &lt;&lt; 1 &amp; 0x8000000000000000L)</span>
<span class="source-line-no">3115</span><span id="line.3115">                                | (data[i - ySections] &lt;&lt; 1 &amp; 0x8000000000000000L) | (data[i + ySections] &lt;&lt; 1 &amp; 0x8000000000000000L);</span>
<span class="source-line-no">3116</span><span id="line.3116">                    }</span>
<span class="source-line-no">3117</span><span id="line.3117"></span>
<span class="source-line-no">3118</span><span id="line.3118">                }</span>
<span class="source-line-no">3119</span><span id="line.3119">            }</span>
<span class="source-line-no">3120</span><span id="line.3120">            if (ySections &gt; 0 &amp;&amp; yEndMask != -1) {</span>
<span class="source-line-no">3121</span><span id="line.3121">                for (int a = ySections - 1; a &lt; next.length; a += ySections) {</span>
<span class="source-line-no">3122</span><span id="line.3122">                    next[a] &amp;= yEndMask;</span>
<span class="source-line-no">3123</span><span id="line.3123">                }</span>
<span class="source-line-no">3124</span><span id="line.3124">            }</span>
<span class="source-line-no">3125</span><span id="line.3125">            data = next;</span>
<span class="source-line-no">3126</span><span id="line.3126">            tallied = false;</span>
<span class="source-line-no">3127</span><span id="line.3127">        }</span>
<span class="source-line-no">3128</span><span id="line.3128"></span>
<span class="source-line-no">3129</span><span id="line.3129">        return result;</span>
<span class="source-line-no">3130</span><span id="line.3130">    }</span>
<span class="source-line-no">3131</span><span id="line.3131">    /**</span>
<span class="source-line-no">3132</span><span id="line.3132">     * Takes the pairs of "on" cells in this GreasedRegion that are separated by exactly one cell in an orthogonal or</span>
<span class="source-line-no">3133</span><span id="line.3133">     * diagonal line, and changes the gap cells to "on" as well. As a special case, this requires diagonals to either</span>
<span class="source-line-no">3134</span><span id="line.3134">     * have no "on" cells adjacent along the perpendicular diagonal, or both cells on that perpendicular diagonal need</span>
<span class="source-line-no">3135</span><span id="line.3135">     * to be "on." This is useful to counteract some less-desirable behavior of {@link #connect8way()}, where a right</span>
<span class="source-line-no">3136</span><span id="line.3136">     * angle would always get the inner corners filled because it was considered a diagonal.</span>
<span class="source-line-no">3137</span><span id="line.3137">     * &lt;br&gt;</span>
<span class="source-line-no">3138</span><span id="line.3138">     * This method is very efficient due to how the class is implemented, and the various spatial increase/decrease</span>
<span class="source-line-no">3139</span><span id="line.3139">     * methods (including {@link #expand()}, {@link #retract()}, {@link #fringe()}, and {@link #surface()}) all perform</span>
<span class="source-line-no">3140</span><span id="line.3140">     * very well by operating in bulk on up to 64 cells at a time.</span>
<span class="source-line-no">3141</span><span id="line.3141">     * @return this for chaining</span>
<span class="source-line-no">3142</span><span id="line.3142">     */</span>
<span class="source-line-no">3143</span><span id="line.3143">    public GreasedRegion connectLines() {</span>
<span class="source-line-no">3144</span><span id="line.3144">        GreasedRegion result = this;</span>
<span class="source-line-no">3145</span><span id="line.3145">        if (width &lt; 2 || ySections == 0) {</span>
<span class="source-line-no">3146</span><span id="line.3146">        } else {</span>
<span class="source-line-no">3147</span><span id="line.3147">            final long[] next = new long[width * ySections];</span>
<span class="source-line-no">3148</span><span id="line.3148">            System.arraycopy(data, 0, next, 0, width * ySections);</span>
<span class="source-line-no">3149</span><span id="line.3149">            for (int a = 0; a &lt; ySections; a++) {</span>
<span class="source-line-no">3150</span><span id="line.3150">                next[a] |= ((data[a] &lt;&lt; 1) &amp; (data[a] &gt;&gt;&gt; 1)) | data[a + ySections] | (data[a + ySections] &lt;&lt; 1) | (data[a + ySections] &gt;&gt;&gt; 1);</span>
<span class="source-line-no">3151</span><span id="line.3151">                next[(width - 1) * ySections + a] |= ((data[(width - 1) * ySections + a] &lt;&lt; 1) &amp; (data[(width - 1) * ySections + a] &gt;&gt;&gt; 1))</span>
<span class="source-line-no">3152</span><span id="line.3152">                        | data[(width - 2) * ySections + a] | (data[(width - 2) * ySections + a] &lt;&lt; 1) | (data[(width - 2) * ySections + a] &gt;&gt;&gt; 1);</span>
<span class="source-line-no">3153</span><span id="line.3153"></span>
<span class="source-line-no">3154</span><span id="line.3154">                for (int i = ySections + a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3155</span><span id="line.3155">                    next[i] |= ((data[i] &lt;&lt; 1) &amp; (data[i] &gt;&gt;&gt; 1)) | (data[i - ySections] &amp; data[i + ySections])</span>
<span class="source-line-no">3156</span><span id="line.3156">                            | (((data[i - ySections] &lt;&lt; 1) &amp; (data[i + ySections] &gt;&gt;&gt; 1))</span>
<span class="source-line-no">3157</span><span id="line.3157">                            ^ ((data[i + ySections] &lt;&lt; 1) &amp; (data[i - ySections] &gt;&gt;&gt; 1)));</span>
<span class="source-line-no">3158</span><span id="line.3158">                }</span>
<span class="source-line-no">3159</span><span id="line.3159"></span>
<span class="source-line-no">3160</span><span id="line.3160">                if (a &gt; 0) {</span>
<span class="source-line-no">3161</span><span id="line.3161">                    for (int i = ySections + a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3162</span><span id="line.3162">                        next[i] |= ((data[i - 1] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63 &amp; (data[i] &gt;&gt;&gt; 1))</span>
<span class="source-line-no">3163</span><span id="line.3163">                                | (((data[i - ySections - 1] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63 &amp; (data[i + ySections] &gt;&gt;&gt; 1))</span>
<span class="source-line-no">3164</span><span id="line.3164">                                ^ ((data[i + ySections - 1] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63 &amp; (data[i - ySections] &gt;&gt;&gt; 1)));</span>
<span class="source-line-no">3165</span><span id="line.3165">                    }</span>
<span class="source-line-no">3166</span><span id="line.3166">                } else {</span>
<span class="source-line-no">3167</span><span id="line.3167">                    for (int i = ySections; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3168</span><span id="line.3168">                        next[i] |= (data[i] &gt;&gt;&gt; 1 &amp; 1L) | (data[i - ySections] &gt;&gt;&gt; 1 &amp; 1L) | (data[i + ySections] &gt;&gt;&gt; 1 &amp; 1L);</span>
<span class="source-line-no">3169</span><span id="line.3169">                    }</span>
<span class="source-line-no">3170</span><span id="line.3170">                }</span>
<span class="source-line-no">3171</span><span id="line.3171"></span>
<span class="source-line-no">3172</span><span id="line.3172">                if (a &lt; ySections - 1) {</span>
<span class="source-line-no">3173</span><span id="line.3173">                    for (int i = ySections + a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3174</span><span id="line.3174">                        next[i] |= ((data[i + 1] &amp; 1L) &lt;&lt; 63 &amp; (data[i] &lt;&lt; 1))</span>
<span class="source-line-no">3175</span><span id="line.3175">                                | (((data[i - ySections + 1] &amp; 1L) &lt;&lt; 63 &amp; (data[i + ySections] &lt;&lt; 1))</span>
<span class="source-line-no">3176</span><span id="line.3176">                                ^ ((data[i + ySections + 1] &amp; 1L) &lt;&lt; 63 &amp; (data[i - ySections] &lt;&lt; 1)));</span>
<span class="source-line-no">3177</span><span id="line.3177">                    }</span>
<span class="source-line-no">3178</span><span id="line.3178">                } else {</span>
<span class="source-line-no">3179</span><span id="line.3179">                    for (int i = ySections + a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3180</span><span id="line.3180">                        next[i] |= (data[i] &lt;&lt; 1 &amp; 0x8000000000000000L)</span>
<span class="source-line-no">3181</span><span id="line.3181">                                | (data[i - ySections] &lt;&lt; 1 &amp; 0x8000000000000000L) | (data[i + ySections] &lt;&lt; 1 &amp; 0x8000000000000000L);</span>
<span class="source-line-no">3182</span><span id="line.3182">                    }</span>
<span class="source-line-no">3183</span><span id="line.3183"></span>
<span class="source-line-no">3184</span><span id="line.3184">                }</span>
<span class="source-line-no">3185</span><span id="line.3185">            }</span>
<span class="source-line-no">3186</span><span id="line.3186">            if (ySections &gt; 0 &amp;&amp; yEndMask != -1) {</span>
<span class="source-line-no">3187</span><span id="line.3187">                for (int a = ySections - 1; a &lt; next.length; a += ySections) {</span>
<span class="source-line-no">3188</span><span id="line.3188">                    next[a] &amp;= yEndMask;</span>
<span class="source-line-no">3189</span><span id="line.3189">                }</span>
<span class="source-line-no">3190</span><span id="line.3190">            }</span>
<span class="source-line-no">3191</span><span id="line.3191">            data = next;</span>
<span class="source-line-no">3192</span><span id="line.3192">            tallied = false;</span>
<span class="source-line-no">3193</span><span id="line.3193">        }</span>
<span class="source-line-no">3194</span><span id="line.3194"></span>
<span class="source-line-no">3195</span><span id="line.3195">        return result;</span>
<span class="source-line-no">3196</span><span id="line.3196">    }</span>
<span class="source-line-no">3197</span><span id="line.3197"></span>
<span class="source-line-no">3198</span><span id="line.3198">    /**</span>
<span class="source-line-no">3199</span><span id="line.3199">     * Like {@link #retract()}, this reduces the width of thick areas of this GreasedRegion, but thin() will not remove</span>
<span class="source-line-no">3200</span><span id="line.3200">     * areas that would be identical in a subsequent call to retract(), such as if the area would be eliminated. This</span>
<span class="source-line-no">3201</span><span id="line.3201">     * is useful primarily for adjusting areas so they do not exceed a width of 2 cells, though their length (the longer</span>
<span class="source-line-no">3202</span><span id="line.3202">     * of the two dimensions) will be unaffected by this. Especially wide, irregularly-shaped areas may have unintended</span>
<span class="source-line-no">3203</span><span id="line.3203">     * appearances if you call this repeatedly or use {@link #thinFully()}; consider using this sparingly, or primarily</span>
<span class="source-line-no">3204</span><span id="line.3204">     * when an area has just gotten thicker than desired.</span>
<span class="source-line-no">3205</span><span id="line.3205">     * &lt;br&gt;</span>
<span class="source-line-no">3206</span><span id="line.3206">     * This currently uses 4-way adjacency, but had previously used 8-way; if you want the behavior this previously had,</span>
<span class="source-line-no">3207</span><span id="line.3207">     * you can use {@link #thin8way()}, but it may be a good idea to try this method as well (some of the old behavior</span>
<span class="source-line-no">3208</span><span id="line.3208">     * had problems where it yielded significantly larger minimum widths in some areas).</span>
<span class="source-line-no">3209</span><span id="line.3209">     * @return this for chaining</span>
<span class="source-line-no">3210</span><span id="line.3210">     */</span>
<span class="source-line-no">3211</span><span id="line.3211">    public GreasedRegion thin() {</span>
<span class="source-line-no">3212</span><span id="line.3212">        GreasedRegion result = this;</span>
<span class="source-line-no">3213</span><span id="line.3213">        if (width &lt;= 2 || ySections &lt;= 0) {</span>
<span class="source-line-no">3214</span><span id="line.3214">        } else {</span>
<span class="source-line-no">3215</span><span id="line.3215">            GreasedRegion c1 = new GreasedRegion(this).retract(),</span>
<span class="source-line-no">3216</span><span id="line.3216">                    c2 = new GreasedRegion(c1).expand().xor(this).expand().and(this);</span>
<span class="source-line-no">3217</span><span id="line.3217">            remake(c1).or(c2);/*</span>
<span class="source-line-no">3218</span><span id="line.3218">        System.out.println("\n\nc1:\n" + c1.toString() + "\n");</span>
<span class="source-line-no">3219</span><span id="line.3219">        System.out.println("\n\nc2:\n" + c2.toString() + "\n");</span>
<span class="source-line-no">3220</span><span id="line.3220">        System.out.println("\n\nthis:\n" + toString() + "\n");</span>
<span class="source-line-no">3221</span><span id="line.3221">        */</span>
<span class="source-line-no">3222</span><span id="line.3222">        }</span>
<span class="source-line-no">3223</span><span id="line.3223">        return result;</span>
<span class="source-line-no">3224</span><span id="line.3224">    }</span>
<span class="source-line-no">3225</span><span id="line.3225"></span>
<span class="source-line-no">3226</span><span id="line.3226">    /**</span>
<span class="source-line-no">3227</span><span id="line.3227">     * Calls {@link #thin()} repeatedly, until the result is unchanged from the last call. Consider using the idiom</span>
<span class="source-line-no">3228</span><span id="line.3228">     * {@code expand8way().retract().thinFully()} to help change a possibly-strange appearance when the GreasedRegion</span>
<span class="source-line-no">3229</span><span id="line.3229">     * this is called on touches the edges of the grid. In general, this method is likely to go too far when it tries to</span>
<span class="source-line-no">3230</span><span id="line.3230">     * thin a round or irregular area, and this often results in many diagonal lines spanning the formerly-thick area.</span>
<span class="source-line-no">3231</span><span id="line.3231">     * &lt;br&gt;</span>
<span class="source-line-no">3232</span><span id="line.3232">     * This currently uses 4-way adjacency, but had previously used 8-way; if you want the behavior this previously had,</span>
<span class="source-line-no">3233</span><span id="line.3233">     * you can use {@link #thinFully8way()}, but it may be a good idea to try this method as well (some of the old</span>
<span class="source-line-no">3234</span><span id="line.3234">     * behavior had problems where it yielded significantly larger minimum widths in some areas).</span>
<span class="source-line-no">3235</span><span id="line.3235">     * @return this for chaining</span>
<span class="source-line-no">3236</span><span id="line.3236">     */</span>
<span class="source-line-no">3237</span><span id="line.3237">    public GreasedRegion thinFully()</span>
<span class="source-line-no">3238</span><span id="line.3238">    {</span>
<span class="source-line-no">3239</span><span id="line.3239">        while (size() != thin().size());</span>
<span class="source-line-no">3240</span><span id="line.3240">        return this;</span>
<span class="source-line-no">3241</span><span id="line.3241">    }</span>
<span class="source-line-no">3242</span><span id="line.3242"></span>
<span class="source-line-no">3243</span><span id="line.3243"></span>
<span class="source-line-no">3244</span><span id="line.3244">    /**</span>
<span class="source-line-no">3245</span><span id="line.3245">     * Like {@link #retract8way()}, this reduces the width of thick areas of this GreasedRegion, but thin8way() will not</span>
<span class="source-line-no">3246</span><span id="line.3246">     * remove areas that would be identical in a subsequent call to retract8way(), such as if the area would be</span>
<span class="source-line-no">3247</span><span id="line.3247">     * eliminated. This is useful primarily for adjusting areas so they do not exceed a width of 2 cells, though their</span>
<span class="source-line-no">3248</span><span id="line.3248">     * length (the longer of the two dimensions) will be unaffected by this. Especially wide, irregularly-shaped areas</span>
<span class="source-line-no">3249</span><span id="line.3249">     * may have unintended appearances if you call this repeatedly or use {@link #thinFully8way()}; consider using this</span>
<span class="source-line-no">3250</span><span id="line.3250">     * sparingly, or primarily when an area has just gotten thicker than desired.</span>
<span class="source-line-no">3251</span><span id="line.3251">     * &lt;br&gt;</span>
<span class="source-line-no">3252</span><span id="line.3252">     * This method was called {@link #thin()}, but now that name refers to a variant that uses 4-way adjacency.</span>
<span class="source-line-no">3253</span><span id="line.3253">     * @return this for chaining</span>
<span class="source-line-no">3254</span><span id="line.3254">     */</span>
<span class="source-line-no">3255</span><span id="line.3255">    public GreasedRegion thin8way() {</span>
<span class="source-line-no">3256</span><span id="line.3256">        GreasedRegion result = this;</span>
<span class="source-line-no">3257</span><span id="line.3257">        if (width &lt;= 2 || ySections &lt;= 0) {</span>
<span class="source-line-no">3258</span><span id="line.3258">        } else {</span>
<span class="source-line-no">3259</span><span id="line.3259">            GreasedRegion c1 = new GreasedRegion(this).retract8way(),</span>
<span class="source-line-no">3260</span><span id="line.3260">                    c2 = new GreasedRegion(c1).expand8way().xor(this).expand8way().and(this);</span>
<span class="source-line-no">3261</span><span id="line.3261">            remake(c1).or(c2);</span>
<span class="source-line-no">3262</span><span id="line.3262">        }</span>
<span class="source-line-no">3263</span><span id="line.3263">        return result;</span>
<span class="source-line-no">3264</span><span id="line.3264">    }</span>
<span class="source-line-no">3265</span><span id="line.3265"></span>
<span class="source-line-no">3266</span><span id="line.3266">    /**</span>
<span class="source-line-no">3267</span><span id="line.3267">     * Calls {@link #thin8way()} repeatedly, until the result is unchanged from the last call. Consider using the idiom</span>
<span class="source-line-no">3268</span><span id="line.3268">     * {@code expand8way().retract().thinFully8way()} to help change a strange appearance when the GreasedRegion this is</span>
<span class="source-line-no">3269</span><span id="line.3269">     * called on touches the edges of the grid. In general, this method is likely to go too far when it tries to thin a</span>
<span class="source-line-no">3270</span><span id="line.3270">     * round or irregular area, and this often results in many diagonal lines spanning the formerly-thick area.</span>
<span class="source-line-no">3271</span><span id="line.3271">     * &lt;br&gt;</span>
<span class="source-line-no">3272</span><span id="line.3272">     * This method was called {@link #thinFully()}, but now that name refers to a variant that uses 4-way adjacency.</span>
<span class="source-line-no">3273</span><span id="line.3273">     * @return this for chaining</span>
<span class="source-line-no">3274</span><span id="line.3274">     */</span>
<span class="source-line-no">3275</span><span id="line.3275">    public GreasedRegion thinFully8way()</span>
<span class="source-line-no">3276</span><span id="line.3276">    {</span>
<span class="source-line-no">3277</span><span id="line.3277">        while (size() != thin8way().size());</span>
<span class="source-line-no">3278</span><span id="line.3278">        return this;</span>
<span class="source-line-no">3279</span><span id="line.3279">    }</span>
<span class="source-line-no">3280</span><span id="line.3280"></span>
<span class="source-line-no">3281</span><span id="line.3281"></span>
<span class="source-line-no">3282</span><span id="line.3282">    /**</span>
<span class="source-line-no">3283</span><span id="line.3283">     * Removes "on" cells that are orthogonally adjacent to other "on" cells, keeping at least one cell in a group "on."</span>
<span class="source-line-no">3284</span><span id="line.3284">     * Uses a "checkerboard" pattern to determine which cells to turn  off, with all cells that would be black on a</span>
<span class="source-line-no">3285</span><span id="line.3285">     * checkerboard turned off and all others kept as-is.</span>
<span class="source-line-no">3286</span><span id="line.3286">     * @return this for chaining</span>
<span class="source-line-no">3287</span><span id="line.3287">     */</span>
<span class="source-line-no">3288</span><span id="line.3288">    public GreasedRegion disperse() {</span>
<span class="source-line-no">3289</span><span id="line.3289">        GreasedRegion result = this;</span>
<span class="source-line-no">3290</span><span id="line.3290">        if (width &lt; 1 || ySections &lt;= 0) {</span>
<span class="source-line-no">3291</span><span id="line.3291">        } else {</span>
<span class="source-line-no">3292</span><span id="line.3292">            long mask = 0x5555555555555555L;</span>
<span class="source-line-no">3293</span><span id="line.3293">            for (int i = 0; i &lt; width; i++) {</span>
<span class="source-line-no">3294</span><span id="line.3294">                for (int j = 0; j &lt; ySections; j++) {</span>
<span class="source-line-no">3295</span><span id="line.3295">                    data[j] &amp;= mask;</span>
<span class="source-line-no">3296</span><span id="line.3296">                }</span>
<span class="source-line-no">3297</span><span id="line.3297">                mask = ~mask;</span>
<span class="source-line-no">3298</span><span id="line.3298">            }</span>
<span class="source-line-no">3299</span><span id="line.3299">            tallied = false;</span>
<span class="source-line-no">3300</span><span id="line.3300">        }</span>
<span class="source-line-no">3301</span><span id="line.3301">        return result;</span>
<span class="source-line-no">3302</span><span id="line.3302">    }</span>
<span class="source-line-no">3303</span><span id="line.3303">    /**</span>
<span class="source-line-no">3304</span><span id="line.3304">     * Removes "on" cells that are 8-way adjacent to other "on" cells, keeping at least one cell in a group "on."</span>
<span class="source-line-no">3305</span><span id="line.3305">     * Uses a "grid-like" pattern to determine which cells to turn off, with all cells with even x and even y kept as-is</span>
<span class="source-line-no">3306</span><span id="line.3306">     * but all other cells (with either or both odd x or odd y) turned off.</span>
<span class="source-line-no">3307</span><span id="line.3307">     * @return this for chaining</span>
<span class="source-line-no">3308</span><span id="line.3308">     */</span>
<span class="source-line-no">3309</span><span id="line.3309">    public GreasedRegion disperse8way() {</span>
<span class="source-line-no">3310</span><span id="line.3310">        GreasedRegion result = this;</span>
<span class="source-line-no">3311</span><span id="line.3311">        if (width &lt; 1 || ySections &lt;= 0) {</span>
<span class="source-line-no">3312</span><span id="line.3312">        } else {</span>
<span class="source-line-no">3313</span><span id="line.3313">            int len = data.length;</span>
<span class="source-line-no">3314</span><span id="line.3314">            long mask = 0x5555555555555555L;</span>
<span class="source-line-no">3315</span><span id="line.3315">            for (int j = 0; j &lt; len - 1; j += 2) {</span>
<span class="source-line-no">3316</span><span id="line.3316">                data[j] &amp;= mask;</span>
<span class="source-line-no">3317</span><span id="line.3317">                data[j + 1] = 0;</span>
<span class="source-line-no">3318</span><span id="line.3318">            }</span>
<span class="source-line-no">3319</span><span id="line.3319">            tallied = false;</span>
<span class="source-line-no">3320</span><span id="line.3320">        }</span>
<span class="source-line-no">3321</span><span id="line.3321">        return result;</span>
<span class="source-line-no">3322</span><span id="line.3322">    }</span>
<span class="source-line-no">3323</span><span id="line.3323">    /**</span>
<span class="source-line-no">3324</span><span id="line.3324">     * Removes "on" cells that are nearby other "on" cells, with a random factor to which bits are actually turned off</span>
<span class="source-line-no">3325</span><span id="line.3325">     * that still ensures exactly half of the bits are kept as-is (the one exception is when height is an odd number,</span>
<span class="source-line-no">3326</span><span id="line.3326">     * which makes the bottom row slightly random).</span>
<span class="source-line-no">3327</span><span id="line.3327">     * @param random the RNG used for a random factor</span>
<span class="source-line-no">3328</span><span id="line.3328">     * @return this for chaining</span>
<span class="source-line-no">3329</span><span id="line.3329">     */</span>
<span class="source-line-no">3330</span><span id="line.3330">    public GreasedRegion disperseRandom(RandomnessSource random) {</span>
<span class="source-line-no">3331</span><span id="line.3331">        GreasedRegion result = this;</span>
<span class="source-line-no">3332</span><span id="line.3332">        if (width &lt; 1 || ySections &lt;= 0) {</span>
<span class="source-line-no">3333</span><span id="line.3333">        } else {</span>
<span class="source-line-no">3334</span><span id="line.3334">            int len = data.length;</span>
<span class="source-line-no">3335</span><span id="line.3335">            for (int j = 0; j &lt; len; j++) {</span>
<span class="source-line-no">3336</span><span id="line.3336">                data[j] &amp;= randomInterleave(random);</span>
<span class="source-line-no">3337</span><span id="line.3337">            }</span>
<span class="source-line-no">3338</span><span id="line.3338">            tallied = false;</span>
<span class="source-line-no">3339</span><span id="line.3339">        }</span>
<span class="source-line-no">3340</span><span id="line.3340">        return result;</span>
<span class="source-line-no">3341</span><span id="line.3341">    }</span>
<span class="source-line-no">3342</span><span id="line.3342">    /**</span>
<span class="source-line-no">3343</span><span id="line.3343">     * Generates a random 64-bit long with a number of '1' bits (Hamming weight) equal on average to bitCount.</span>
<span class="source-line-no">3344</span><span id="line.3344">     * For example, calling this with a parameter of 32 will be equivalent to calling nextLong() on the given</span>
<span class="source-line-no">3345</span><span id="line.3345">     * RandomnessSource, which could be an {@link RNG} or any RandomnessSource with good 64-bit generation quality.</span>
<span class="source-line-no">3346</span><span id="line.3346">     * Calling this with a parameter of 16 will have on average 16 of the 64 bits in the returned long set to '1',</span>
<span class="source-line-no">3347</span><span id="line.3347">     * distributed pseudo-randomly, while a parameter of 47 will have on average 47 bits set. This can be useful for</span>
<span class="source-line-no">3348</span><span id="line.3348">     * certain code that uses bits to represent data but needs a different ratio of set bits to unset bits than 1:1.</span>
<span class="source-line-no">3349</span><span id="line.3349">     * &lt;br&gt;</span>
<span class="source-line-no">3350</span><span id="line.3350">     * The parameter {@code random} can be an object like a {@link DiverRNG}, an {@link RNG} backed by a</span>
<span class="source-line-no">3351</span><span id="line.3351">     * well-distributed RandomnessSource like its default, DiverRNG, a {@link GWTRNG} (especially if you target GWT,</span>
<span class="source-line-no">3352</span><span id="line.3352">     * where it will perform much better than most alternatives), or any of various other RandomnessSource</span>
<span class="source-line-no">3353</span><span id="line.3353">     * implementations that distribute bits well for {@link RandomnessSource#nextLong()}, but should not be</span>
<span class="source-line-no">3354</span><span id="line.3354">     * intentionally-biased RNGs like {@link DharmaRNG} or {@link EditRNG}, nor double-based QRNGs like</span>
<span class="source-line-no">3355</span><span id="line.3355">     * {@link VanDerCorputQRNG} or {@link SobolQRNG}.</span>
<span class="source-line-no">3356</span><span id="line.3356">     * @param random used to determine random factors; likely to be an {@link RNG}, {@link DiverRNG}, or {@link GWTRNG}</span>
<span class="source-line-no">3357</span><span id="line.3357">     * @param bitCount an int, only considered if between 0 and 64, that is the average number of bits to set</span>
<span class="source-line-no">3358</span><span id="line.3358">     * @return a 64-bit long that, on average, should have bitCount bits set to 1, potentially anywhere in the long</span>
<span class="source-line-no">3359</span><span id="line.3359">     */</span>
<span class="source-line-no">3360</span><span id="line.3360">    public static long approximateBits(RandomnessSource random, int bitCount) {</span>
<span class="source-line-no">3361</span><span id="line.3361">        long result;</span>
<span class="source-line-no">3362</span><span id="line.3362">        if (bitCount &lt;= 0) {</span>
<span class="source-line-no">3363</span><span id="line.3363">            result = 0L;</span>
<span class="source-line-no">3364</span><span id="line.3364">        } else if (bitCount &gt;= 64) {</span>
<span class="source-line-no">3365</span><span id="line.3365">            result = -1L;</span>
<span class="source-line-no">3366</span><span id="line.3366">        } else if (bitCount == 32) {</span>
<span class="source-line-no">3367</span><span id="line.3367">            result = random.nextLong();</span>
<span class="source-line-no">3368</span><span id="line.3368">        } else {</span>
<span class="source-line-no">3369</span><span id="line.3369">            boolean high = bitCount &gt; 32;</span>
<span class="source-line-no">3370</span><span id="line.3370">            int altered = (high ? 64 - bitCount : bitCount), lsb = NumberTools.lowestOneBit(altered);</span>
<span class="source-line-no">3371</span><span id="line.3371">            long data = random.nextLong();</span>
<span class="source-line-no">3372</span><span id="line.3372">            for (int i = lsb &lt;&lt; 1; i &lt;= 16; i &lt;&lt;= 1) {</span>
<span class="source-line-no">3373</span><span id="line.3373">                if ((altered &amp; i) == 0)</span>
<span class="source-line-no">3374</span><span id="line.3374">                    data &amp;= random.nextLong();</span>
<span class="source-line-no">3375</span><span id="line.3375">                else</span>
<span class="source-line-no">3376</span><span id="line.3376">                    data |= random.nextLong();</span>
<span class="source-line-no">3377</span><span id="line.3377">            }</span>
<span class="source-line-no">3378</span><span id="line.3378">            result = high ? ~(random.nextLong() &amp; data) : (random.nextLong() &amp; data);</span>
<span class="source-line-no">3379</span><span id="line.3379">        }</span>
<span class="source-line-no">3380</span><span id="line.3380">        return result;</span>
<span class="source-line-no">3381</span><span id="line.3381">    }</span>
<span class="source-line-no">3382</span><span id="line.3382"></span>
<span class="source-line-no">3383</span><span id="line.3383">    /**</span>
<span class="source-line-no">3384</span><span id="line.3384">     * Gets a somewhat-random long with exactly 32 bits set; in each pair of bits starting at bit 0 and bit 1, then bit</span>
<span class="source-line-no">3385</span><span id="line.3385">     * 2 and bit 3, up to bit 62 and bit 3, one bit will be 1 and one bit will be 0 in each pair.</span>
<span class="source-line-no">3386</span><span id="line.3386">     * &lt;br&gt;</span>
<span class="source-line-no">3387</span><span id="line.3387">     * Not exactly general-use; meant for generating data for GreasedRegion.</span>
<span class="source-line-no">3388</span><span id="line.3388">     * @return a random long with 32 "1" bits, distributed so exactly one bit is "1" for each pair of bits</span>
<span class="source-line-no">3389</span><span id="line.3389">     */</span>
<span class="source-line-no">3390</span><span id="line.3390">    public static long randomInterleave(RandomnessSource random) {</span>
<span class="source-line-no">3391</span><span id="line.3391">        long bits = random.nextLong() &amp; 0xFFFFFFFFL, ib = ~bits &amp; 0xFFFFFFFFL;</span>
<span class="source-line-no">3392</span><span id="line.3392">        bits |= (bits &lt;&lt; 16);</span>
<span class="source-line-no">3393</span><span id="line.3393">        ib |= (ib &lt;&lt; 16);</span>
<span class="source-line-no">3394</span><span id="line.3394">        bits &amp;= 0x0000FFFF0000FFFFL;</span>
<span class="source-line-no">3395</span><span id="line.3395">        ib &amp;= 0x0000FFFF0000FFFFL;</span>
<span class="source-line-no">3396</span><span id="line.3396">        bits |= (bits &lt;&lt; 8);</span>
<span class="source-line-no">3397</span><span id="line.3397">        ib |= (ib &lt;&lt; 8);</span>
<span class="source-line-no">3398</span><span id="line.3398">        bits &amp;= 0x00FF00FF00FF00FFL;</span>
<span class="source-line-no">3399</span><span id="line.3399">        ib &amp;= 0x00FF00FF00FF00FFL;</span>
<span class="source-line-no">3400</span><span id="line.3400">        bits |= (bits &lt;&lt; 4);</span>
<span class="source-line-no">3401</span><span id="line.3401">        ib |= (ib &lt;&lt; 4);</span>
<span class="source-line-no">3402</span><span id="line.3402">        bits &amp;= 0x0F0F0F0F0F0F0F0FL;</span>
<span class="source-line-no">3403</span><span id="line.3403">        ib &amp;= 0x0F0F0F0F0F0F0F0FL;</span>
<span class="source-line-no">3404</span><span id="line.3404">        bits |= (bits &lt;&lt; 2);</span>
<span class="source-line-no">3405</span><span id="line.3405">        ib |= (ib &lt;&lt; 2);</span>
<span class="source-line-no">3406</span><span id="line.3406">        bits &amp;= 0x3333333333333333L;</span>
<span class="source-line-no">3407</span><span id="line.3407">        ib &amp;= 0x3333333333333333L;</span>
<span class="source-line-no">3408</span><span id="line.3408">        bits |= (bits &lt;&lt; 1);</span>
<span class="source-line-no">3409</span><span id="line.3409">        ib |= (ib &lt;&lt; 1);</span>
<span class="source-line-no">3410</span><span id="line.3410">        bits &amp;= 0x5555555555555555L;</span>
<span class="source-line-no">3411</span><span id="line.3411">        ib &amp;= 0x5555555555555555L;</span>
<span class="source-line-no">3412</span><span id="line.3412">        return (bits | (ib &lt;&lt; 1));</span>
<span class="source-line-no">3413</span><span id="line.3413">    }</span>
<span class="source-line-no">3414</span><span id="line.3414"></span>
<span class="source-line-no">3415</span><span id="line.3415">    /**</span>
<span class="source-line-no">3416</span><span id="line.3416">     * Takes the "on" cells in this GreasedRegion and expands them by one cell in the 4 orthogonal directions, making</span>
<span class="source-line-no">3417</span><span id="line.3417">     * each "on" cell take up a plus-shaped area that may overlap with other "on" cells (which is just a normal "on"</span>
<span class="source-line-no">3418</span><span id="line.3418">     * cell then).</span>
<span class="source-line-no">3419</span><span id="line.3419">     * &lt;br&gt;</span>
<span class="source-line-no">3420</span><span id="line.3420">     * This method is very efficient due to how the class is implemented, and the various spatial increase/decrease</span>
<span class="source-line-no">3421</span><span id="line.3421">     * methods (including expand(), {@link #retract()}, {@link #fringe()}, and {@link #surface()}) all perform</span>
<span class="source-line-no">3422</span><span id="line.3422">     * very well by operating in bulk on up to 64 cells at a time.</span>
<span class="source-line-no">3423</span><span id="line.3423">     * @return this for chaining</span>
<span class="source-line-no">3424</span><span id="line.3424">     */</span>
<span class="source-line-no">3425</span><span id="line.3425">    public GreasedRegion expand() {</span>
<span class="source-line-no">3426</span><span id="line.3426">        GreasedRegion result = this;</span>
<span class="source-line-no">3427</span><span id="line.3427">        if (width &lt; 2 || ySections == 0) {</span>
<span class="source-line-no">3428</span><span id="line.3428">        } else {</span>
<span class="source-line-no">3429</span><span id="line.3429">            final long[] next = new long[width * ySections];</span>
<span class="source-line-no">3430</span><span id="line.3430">            System.arraycopy(data, 0, next, 0, width * ySections);</span>
<span class="source-line-no">3431</span><span id="line.3431">            for (int a = 0; a &lt; ySections; a++) {</span>
<span class="source-line-no">3432</span><span id="line.3432">                next[a] |= (data[a] &lt;&lt; 1) | (data[a] &gt;&gt;&gt; 1) | data[a + ySections];</span>
<span class="source-line-no">3433</span><span id="line.3433">                next[(width - 1) * ySections + a] |= (data[(width - 1) * ySections + a] &lt;&lt; 1) | (data[(width - 1) * ySections + a] &gt;&gt;&gt; 1) | data[(width - 2) * ySections + a];</span>
<span class="source-line-no">3434</span><span id="line.3434"></span>
<span class="source-line-no">3435</span><span id="line.3435">                for (int i = ySections + a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3436</span><span id="line.3436">                    next[i] |= (data[i] &lt;&lt; 1) | (data[i] &gt;&gt;&gt; 1) | data[i - ySections] | data[i + ySections];</span>
<span class="source-line-no">3437</span><span id="line.3437">                }</span>
<span class="source-line-no">3438</span><span id="line.3438"></span>
<span class="source-line-no">3439</span><span id="line.3439">                if (a &gt; 0) {</span>
<span class="source-line-no">3440</span><span id="line.3440">                    for (int i = ySections + a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3441</span><span id="line.3441">                        next[i] |= (data[i - 1] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63;</span>
<span class="source-line-no">3442</span><span id="line.3442">                    }</span>
<span class="source-line-no">3443</span><span id="line.3443">                }</span>
<span class="source-line-no">3444</span><span id="line.3444"></span>
<span class="source-line-no">3445</span><span id="line.3445">                if (a &lt; ySections - 1) {</span>
<span class="source-line-no">3446</span><span id="line.3446">                    for (int i = ySections + a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3447</span><span id="line.3447">                        next[i] |= (data[i + 1] &amp; 1L) &lt;&lt; 63;</span>
<span class="source-line-no">3448</span><span id="line.3448">                    }</span>
<span class="source-line-no">3449</span><span id="line.3449">                }</span>
<span class="source-line-no">3450</span><span id="line.3450">            }</span>
<span class="source-line-no">3451</span><span id="line.3451">            if (ySections &gt; 0 &amp;&amp; yEndMask != -1) {</span>
<span class="source-line-no">3452</span><span id="line.3452">                for (int a = ySections - 1; a &lt; next.length; a += ySections) {</span>
<span class="source-line-no">3453</span><span id="line.3453">                    next[a] &amp;= yEndMask;</span>
<span class="source-line-no">3454</span><span id="line.3454">                }</span>
<span class="source-line-no">3455</span><span id="line.3455">            }</span>
<span class="source-line-no">3456</span><span id="line.3456">            data = next;</span>
<span class="source-line-no">3457</span><span id="line.3457">            tallied = false;</span>
<span class="source-line-no">3458</span><span id="line.3458">        }</span>
<span class="source-line-no">3459</span><span id="line.3459"></span>
<span class="source-line-no">3460</span><span id="line.3460">        return result;</span>
<span class="source-line-no">3461</span><span id="line.3461">    }</span>
<span class="source-line-no">3462</span><span id="line.3462">    /**</span>
<span class="source-line-no">3463</span><span id="line.3463">     * Takes the "on" cells in this GreasedRegion and expands them by amount cells in the 4 orthogonal directions,</span>
<span class="source-line-no">3464</span><span id="line.3464">     * making each "on" cell take up a plus-shaped area that may overlap with other "on" cells (which is just a normal</span>
<span class="source-line-no">3465</span><span id="line.3465">     * "on" cell then).</span>
<span class="source-line-no">3466</span><span id="line.3466">     * &lt;br&gt;</span>
<span class="source-line-no">3467</span><span id="line.3467">     * This method is very efficient due to how the class is implemented, and the various spatial increase/decrease</span>
<span class="source-line-no">3468</span><span id="line.3468">     * methods (including {@link #expand()}, {@link #retract()}, {@link #fringe()}, and {@link #surface()}) all perform</span>
<span class="source-line-no">3469</span><span id="line.3469">     * very well by operating in bulk on up to 64 cells at a time.</span>
<span class="source-line-no">3470</span><span id="line.3470">     * @return this for chaining</span>
<span class="source-line-no">3471</span><span id="line.3471">     */</span>
<span class="source-line-no">3472</span><span id="line.3472">    @Override</span>
<span class="source-line-no">3473</span><span id="line.3473">    public GreasedRegion expand(int amount)</span>
<span class="source-line-no">3474</span><span id="line.3474">    {</span>
<span class="source-line-no">3475</span><span id="line.3475">        for (int i = 0; i &lt; amount; i++) {</span>
<span class="source-line-no">3476</span><span id="line.3476">            expand();</span>
<span class="source-line-no">3477</span><span id="line.3477">        }</span>
<span class="source-line-no">3478</span><span id="line.3478">        return this;</span>
<span class="source-line-no">3479</span><span id="line.3479">    }</span>
<span class="source-line-no">3480</span><span id="line.3480">    /**</span>
<span class="source-line-no">3481</span><span id="line.3481">     * Takes the "on" cells in this GreasedRegion and produces amount GreasedRegions, each one expanded by 1 cell in</span>
<span class="source-line-no">3482</span><span id="line.3482">     * the 4 orthogonal directions relative to the previous GreasedRegion, making each "on" cell take up a plus-shaped</span>
<span class="source-line-no">3483</span><span id="line.3483">     * area that may overlap with other "on" cells (which is just a normal "on" cell then). This returns an array of</span>
<span class="source-line-no">3484</span><span id="line.3484">     * GreasedRegions with progressively greater expansions, and does not modify this GreasedRegion.</span>
<span class="source-line-no">3485</span><span id="line.3485">     * &lt;br&gt;</span>
<span class="source-line-no">3486</span><span id="line.3486">     * This method is very efficient due to how the class is implemented, and the various spatial increase/decrease</span>
<span class="source-line-no">3487</span><span id="line.3487">     * methods (including {@link #expand()}, {@link #retract()}, {@link #fringe()}, and {@link #surface()}) all perform</span>
<span class="source-line-no">3488</span><span id="line.3488">     * very well by operating in bulk on up to 64 cells at a time.</span>
<span class="source-line-no">3489</span><span id="line.3489">     * @return an array of new GreasedRegions, length == amount, where each one is expanded by 1 relative to the last</span>
<span class="source-line-no">3490</span><span id="line.3490">     */</span>
<span class="source-line-no">3491</span><span id="line.3491">    public GreasedRegion[] expandSeries(int amount) {</span>
<span class="source-line-no">3492</span><span id="line.3492">        GreasedRegion[] result;</span>
<span class="source-line-no">3493</span><span id="line.3493">        if (amount &lt;= 0) {</span>
<span class="source-line-no">3494</span><span id="line.3494">            result = new GreasedRegion[0];</span>
<span class="source-line-no">3495</span><span id="line.3495">        } else {</span>
<span class="source-line-no">3496</span><span id="line.3496">            GreasedRegion[] regions = new GreasedRegion[amount];</span>
<span class="source-line-no">3497</span><span id="line.3497">            GreasedRegion temp = new GreasedRegion(this);</span>
<span class="source-line-no">3498</span><span id="line.3498">            for (int i = 0; i &lt; amount; i++) {</span>
<span class="source-line-no">3499</span><span id="line.3499">                regions[i] = new GreasedRegion(temp.expand());</span>
<span class="source-line-no">3500</span><span id="line.3500">            }</span>
<span class="source-line-no">3501</span><span id="line.3501">            result = regions;</span>
<span class="source-line-no">3502</span><span id="line.3502">        }</span>
<span class="source-line-no">3503</span><span id="line.3503">        return result;</span>
<span class="source-line-no">3504</span><span id="line.3504">    }</span>
<span class="source-line-no">3505</span><span id="line.3505"></span>
<span class="source-line-no">3506</span><span id="line.3506">    public ArrayList&lt;GreasedRegion&gt; expandSeriesToLimit()</span>
<span class="source-line-no">3507</span><span id="line.3507">    {</span>
<span class="source-line-no">3508</span><span id="line.3508">        ArrayList&lt;GreasedRegion&gt; regions = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">3509</span><span id="line.3509">        GreasedRegion temp = new GreasedRegion(this);</span>
<span class="source-line-no">3510</span><span id="line.3510">        while (temp.size() != temp.expand().size()) {</span>
<span class="source-line-no">3511</span><span id="line.3511">            regions.add(new GreasedRegion(temp));</span>
<span class="source-line-no">3512</span><span id="line.3512">        }</span>
<span class="source-line-no">3513</span><span id="line.3513">        return regions;</span>
<span class="source-line-no">3514</span><span id="line.3514">    }</span>
<span class="source-line-no">3515</span><span id="line.3515">    /**</span>
<span class="source-line-no">3516</span><span id="line.3516">     * Takes the "on" cells in this GreasedRegion and expands them by one cell in the 4 orthogonal directions, producing</span>
<span class="source-line-no">3517</span><span id="line.3517">     * a diamoond shape, then removes the original area before expansion, producing only the cells that were "off" in</span>
<span class="source-line-no">3518</span><span id="line.3518">     * this and within 1 cell (orthogonal-only) of an "on" cell. This method is similar to {@link #surface()}, but</span>
<span class="source-line-no">3519</span><span id="line.3519">     * surface finds cells inside the current GreasedRegion, while fringe finds cells outside it.</span>
<span class="source-line-no">3520</span><span id="line.3520">     * &lt;br&gt;</span>
<span class="source-line-no">3521</span><span id="line.3521">     * This method is very efficient due to how the class is implemented, and the various spatial increase/decrease</span>
<span class="source-line-no">3522</span><span id="line.3522">     * methods (including {@link #expand()}, {@link #retract()}, {@link #fringe()}, and {@link #surface()}) all perform</span>
<span class="source-line-no">3523</span><span id="line.3523">     * very well by operating in bulk on up to 64 cells at a time. The surface and fringe methods do allocate one</span>
<span class="source-line-no">3524</span><span id="line.3524">     * temporary GreasedRegion to store the original before modification, but the others generally don't.</span>
<span class="source-line-no">3525</span><span id="line.3525">     * @return this for chaining</span>
<span class="source-line-no">3526</span><span id="line.3526">     */</span>
<span class="source-line-no">3527</span><span id="line.3527">    public GreasedRegion fringe()</span>
<span class="source-line-no">3528</span><span id="line.3528">    {</span>
<span class="source-line-no">3529</span><span id="line.3529">        GreasedRegion cpy = new GreasedRegion(this);</span>
<span class="source-line-no">3530</span><span id="line.3530">        expand();</span>
<span class="source-line-no">3531</span><span id="line.3531">        return andNot(cpy);</span>
<span class="source-line-no">3532</span><span id="line.3532">    }</span>
<span class="source-line-no">3533</span><span id="line.3533">    /**</span>
<span class="source-line-no">3534</span><span id="line.3534">     * Takes the "on" cells in this GreasedRegion and expands them by amount cells in the 4 orthogonal directions</span>
<span class="source-line-no">3535</span><span id="line.3535">     * (iteratively, producing a diamond shape), then removes the original area before expansion, producing only the</span>
<span class="source-line-no">3536</span><span id="line.3536">     * cells that were "off" in this and within amount cells (orthogonal-only) of an "on" cell. This method is similar</span>
<span class="source-line-no">3537</span><span id="line.3537">     * to {@link #surface()}, but surface finds cells inside the current GreasedRegion, while fringe finds cells outside</span>
<span class="source-line-no">3538</span><span id="line.3538">     * it.</span>
<span class="source-line-no">3539</span><span id="line.3539">     * &lt;br&gt;</span>
<span class="source-line-no">3540</span><span id="line.3540">     * This method is very efficient due to how the class is implemented, and the various spatial increase/decrease</span>
<span class="source-line-no">3541</span><span id="line.3541">     * methods (including {@link #expand()}, {@link #retract()}, {@link #fringe()}, and {@link #surface()}) all perform</span>
<span class="source-line-no">3542</span><span id="line.3542">     * very well by operating in bulk on up to 64 cells at a time. The surface and fringe methods do allocate one</span>
<span class="source-line-no">3543</span><span id="line.3543">     * temporary GreasedRegion to store the original before modification, but the others generally don't.</span>
<span class="source-line-no">3544</span><span id="line.3544">     * @return this for chaining</span>
<span class="source-line-no">3545</span><span id="line.3545">     */</span>
<span class="source-line-no">3546</span><span id="line.3546"></span>
<span class="source-line-no">3547</span><span id="line.3547">    public GreasedRegion fringe(int amount)</span>
<span class="source-line-no">3548</span><span id="line.3548">    {</span>
<span class="source-line-no">3549</span><span id="line.3549">        GreasedRegion cpy = new GreasedRegion(this);</span>
<span class="source-line-no">3550</span><span id="line.3550">        expand(amount);</span>
<span class="source-line-no">3551</span><span id="line.3551">        return andNot(cpy);</span>
<span class="source-line-no">3552</span><span id="line.3552">    }</span>
<span class="source-line-no">3553</span><span id="line.3553"></span>
<span class="source-line-no">3554</span><span id="line.3554">    /**</span>
<span class="source-line-no">3555</span><span id="line.3555">     * Takes the "on" cells in this GreasedRegion and produces amount GreasedRegions, each one expanded by 1 cell in</span>
<span class="source-line-no">3556</span><span id="line.3556">     * the 4 orthogonal directions relative to the previous GreasedRegion, making each "on" cell take up a diamond-</span>
<span class="source-line-no">3557</span><span id="line.3557">     * shaped area. After producing the expansions, this removes the previous GreasedRegion from the next GreasedRegion</span>
<span class="source-line-no">3558</span><span id="line.3558">     * in the array, making each "fringe" in the series have 1 "thickness," which can be useful for finding which layer</span>
<span class="source-line-no">3559</span><span id="line.3559">     * of expansion a cell lies in. This returns an array of GreasedRegions with progressively greater expansions</span>
<span class="source-line-no">3560</span><span id="line.3560">     * without the cells of this GreasedRegion, and does not modify this GreasedRegion.</span>
<span class="source-line-no">3561</span><span id="line.3561">     * &lt;br&gt;</span>
<span class="source-line-no">3562</span><span id="line.3562">     * This method is very efficient due to how the class is implemented, and the various spatial increase/decrease</span>
<span class="source-line-no">3563</span><span id="line.3563">     * methods (including {@link #expand()}, {@link #retract()}, {@link #fringe()}, and {@link #surface()}) all perform</span>
<span class="source-line-no">3564</span><span id="line.3564">     * very well by operating in bulk on up to 64 cells at a time.</span>
<span class="source-line-no">3565</span><span id="line.3565">     * @return an array of new GreasedRegions, length == amount, where each one is a 1-depth fringe pushed further out from this</span>
<span class="source-line-no">3566</span><span id="line.3566">     */</span>
<span class="source-line-no">3567</span><span id="line.3567">    public GreasedRegion[] fringeSeries(int amount) {</span>
<span class="source-line-no">3568</span><span id="line.3568">        GreasedRegion[] result;</span>
<span class="source-line-no">3569</span><span id="line.3569">        if (amount &lt;= 0) {</span>
<span class="source-line-no">3570</span><span id="line.3570">            result = new GreasedRegion[0];</span>
<span class="source-line-no">3571</span><span id="line.3571">        } else {</span>
<span class="source-line-no">3572</span><span id="line.3572">            GreasedRegion[] regions = new GreasedRegion[amount];</span>
<span class="source-line-no">3573</span><span id="line.3573">            GreasedRegion temp = new GreasedRegion(this);</span>
<span class="source-line-no">3574</span><span id="line.3574">            regions[0] = new GreasedRegion(temp);</span>
<span class="source-line-no">3575</span><span id="line.3575">            for (int i = 1; i &lt; amount; i++) {</span>
<span class="source-line-no">3576</span><span id="line.3576">                regions[i] = new GreasedRegion(temp.expand());</span>
<span class="source-line-no">3577</span><span id="line.3577">            }</span>
<span class="source-line-no">3578</span><span id="line.3578">            for (int i = 0; i &lt; amount - 1; i++) {</span>
<span class="source-line-no">3579</span><span id="line.3579">                regions[i].xor(regions[i + 1]);</span>
<span class="source-line-no">3580</span><span id="line.3580">            }</span>
<span class="source-line-no">3581</span><span id="line.3581">            regions[amount - 1].fringe();</span>
<span class="source-line-no">3582</span><span id="line.3582">            result = regions;</span>
<span class="source-line-no">3583</span><span id="line.3583">        }</span>
<span class="source-line-no">3584</span><span id="line.3584">        return result;</span>
<span class="source-line-no">3585</span><span id="line.3585">    }</span>
<span class="source-line-no">3586</span><span id="line.3586">    public ArrayList&lt;GreasedRegion&gt; fringeSeriesToLimit()</span>
<span class="source-line-no">3587</span><span id="line.3587">    {</span>
<span class="source-line-no">3588</span><span id="line.3588">        ArrayList&lt;GreasedRegion&gt; regions = expandSeriesToLimit();</span>
<span class="source-line-no">3589</span><span id="line.3589">        for (int i = regions.size() - 1; i &gt; 0; i--) {</span>
<span class="source-line-no">3590</span><span id="line.3590">            regions.get(i).xor(regions.get(i-1));</span>
<span class="source-line-no">3591</span><span id="line.3591">        }</span>
<span class="source-line-no">3592</span><span id="line.3592">        regions.get(0).xor(this);</span>
<span class="source-line-no">3593</span><span id="line.3593">        return regions;</span>
<span class="source-line-no">3594</span><span id="line.3594">    }</span>
<span class="source-line-no">3595</span><span id="line.3595"></span>
<span class="source-line-no">3596</span><span id="line.3596">    /**</span>
<span class="source-line-no">3597</span><span id="line.3597">     * Takes the "on" cells in this GreasedRegion and retracts them by one cell in the 4 orthogonal directions,</span>
<span class="source-line-no">3598</span><span id="line.3598">     * making each "on" cell that was orthogonally adjacent to an "off" cell into an "off" cell.</span>
<span class="source-line-no">3599</span><span id="line.3599">     * &lt;br&gt;</span>
<span class="source-line-no">3600</span><span id="line.3600">     * This method is very efficient due to how the class is implemented, and the various spatial increase/decrease</span>
<span class="source-line-no">3601</span><span id="line.3601">     * methods (including {@link #expand()}, retract(), {@link #fringe()}, and {@link #surface()}) all perform</span>
<span class="source-line-no">3602</span><span id="line.3602">     * very well by operating in bulk on up to 64 cells at a time.</span>
<span class="source-line-no">3603</span><span id="line.3603">     * @return this for chaining</span>
<span class="source-line-no">3604</span><span id="line.3604">     */</span>
<span class="source-line-no">3605</span><span id="line.3605">    public GreasedRegion retract() {</span>
<span class="source-line-no">3606</span><span id="line.3606">        GreasedRegion result = this;</span>
<span class="source-line-no">3607</span><span id="line.3607">        if (width &lt;= 2 || ySections &lt;= 0) {</span>
<span class="source-line-no">3608</span><span id="line.3608">        } else {</span>
<span class="source-line-no">3609</span><span id="line.3609">            final long[] next = new long[width * ySections];</span>
<span class="source-line-no">3610</span><span id="line.3610">            System.arraycopy(data, ySections, next, ySections, (width - 2) * ySections);</span>
<span class="source-line-no">3611</span><span id="line.3611">            for (int a = 0; a &lt; ySections; a++) {</span>
<span class="source-line-no">3612</span><span id="line.3612">                if (a &gt; 0 &amp;&amp; a &lt; ySections - 1) {</span>
<span class="source-line-no">3613</span><span id="line.3613">                    for (int i = ySections + a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3614</span><span id="line.3614">                        next[i] &amp;= ((data[i] &lt;&lt; 1) | ((data[i - 1] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63))</span>
<span class="source-line-no">3615</span><span id="line.3615">                                &amp; ((data[i] &gt;&gt;&gt; 1) | ((data[i + 1] &amp; 1L) &lt;&lt; 63))</span>
<span class="source-line-no">3616</span><span id="line.3616">                                &amp; data[i - ySections]</span>
<span class="source-line-no">3617</span><span id="line.3617">                                &amp; data[i + ySections];</span>
<span class="source-line-no">3618</span><span id="line.3618">                    }</span>
<span class="source-line-no">3619</span><span id="line.3619">                } else if (a &gt; 0) {</span>
<span class="source-line-no">3620</span><span id="line.3620">                    for (int i = ySections + a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3621</span><span id="line.3621">                        next[i] &amp;= ((data[i] &lt;&lt; 1) | ((data[i - 1] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63))</span>
<span class="source-line-no">3622</span><span id="line.3622">                                &amp; (data[i] &gt;&gt;&gt; 1)</span>
<span class="source-line-no">3623</span><span id="line.3623">                                &amp; data[i - ySections]</span>
<span class="source-line-no">3624</span><span id="line.3624">                                &amp; data[i + ySections];</span>
<span class="source-line-no">3625</span><span id="line.3625">                    }</span>
<span class="source-line-no">3626</span><span id="line.3626">                } else if (a &lt; ySections - 1) {</span>
<span class="source-line-no">3627</span><span id="line.3627">                    for (int i = ySections + a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3628</span><span id="line.3628">                        next[i] &amp;= (data[i] &lt;&lt; 1)</span>
<span class="source-line-no">3629</span><span id="line.3629">                                &amp; ((data[i] &gt;&gt;&gt; 1) | ((data[i + 1] &amp; 1L) &lt;&lt; 63))</span>
<span class="source-line-no">3630</span><span id="line.3630">                                &amp; data[i - ySections]</span>
<span class="source-line-no">3631</span><span id="line.3631">                                &amp; data[i + ySections];</span>
<span class="source-line-no">3632</span><span id="line.3632">                    }</span>
<span class="source-line-no">3633</span><span id="line.3633">                } else // only the case when ySections == 1</span>
<span class="source-line-no">3634</span><span id="line.3634">                {</span>
<span class="source-line-no">3635</span><span id="line.3635">                    for (int i = ySections + a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3636</span><span id="line.3636">                        next[i] &amp;= (data[i] &lt;&lt; 1) &amp; (data[i] &gt;&gt;&gt; 1) &amp; data[i - ySections] &amp; data[i + ySections];</span>
<span class="source-line-no">3637</span><span id="line.3637">                    }</span>
<span class="source-line-no">3638</span><span id="line.3638">                }</span>
<span class="source-line-no">3639</span><span id="line.3639">            }</span>
<span class="source-line-no">3640</span><span id="line.3640">            if (yEndMask != -1) {</span>
<span class="source-line-no">3641</span><span id="line.3641">                for (int a = ySections - 1; a &lt; next.length; a += ySections) {</span>
<span class="source-line-no">3642</span><span id="line.3642">                    next[a] &amp;= yEndMask;</span>
<span class="source-line-no">3643</span><span id="line.3643">                }</span>
<span class="source-line-no">3644</span><span id="line.3644">            }</span>
<span class="source-line-no">3645</span><span id="line.3645">            data = next;</span>
<span class="source-line-no">3646</span><span id="line.3646">            tallied = false;</span>
<span class="source-line-no">3647</span><span id="line.3647">        }</span>
<span class="source-line-no">3648</span><span id="line.3648"></span>
<span class="source-line-no">3649</span><span id="line.3649">        return result;</span>
<span class="source-line-no">3650</span><span id="line.3650">    }</span>
<span class="source-line-no">3651</span><span id="line.3651"></span>
<span class="source-line-no">3652</span><span id="line.3652">    /**</span>
<span class="source-line-no">3653</span><span id="line.3653">     * Takes the "on" cells in this GreasedRegion and retracts them by one cell in the 4 orthogonal directions, doing</span>
<span class="source-line-no">3654</span><span id="line.3654">     * this iteeratively amount times, making each "on" cell that was within amount orthogonal distance to an "off" cell</span>
<span class="source-line-no">3655</span><span id="line.3655">     * into an "off" cell.</span>
<span class="source-line-no">3656</span><span id="line.3656">     * &lt;br&gt;</span>
<span class="source-line-no">3657</span><span id="line.3657">     * This method is very efficient due to how the class is implemented, and the various spatial increase/decrease</span>
<span class="source-line-no">3658</span><span id="line.3658">     * methods (including {@link #expand()}, {@link #retract()}, {@link #fringe()}, and {@link #surface()}) all perform</span>
<span class="source-line-no">3659</span><span id="line.3659">     * very well by operating in bulk on up to 64 cells at a time.</span>
<span class="source-line-no">3660</span><span id="line.3660">     * @return this for chaining</span>
<span class="source-line-no">3661</span><span id="line.3661">     */</span>
<span class="source-line-no">3662</span><span id="line.3662">    public GreasedRegion retract(int amount)</span>
<span class="source-line-no">3663</span><span id="line.3663">    {</span>
<span class="source-line-no">3664</span><span id="line.3664">        for (int i = 0; i &lt; amount; i++) {</span>
<span class="source-line-no">3665</span><span id="line.3665">            retract();</span>
<span class="source-line-no">3666</span><span id="line.3666">        }</span>
<span class="source-line-no">3667</span><span id="line.3667">        return this;</span>
<span class="source-line-no">3668</span><span id="line.3668">    }</span>
<span class="source-line-no">3669</span><span id="line.3669"></span>
<span class="source-line-no">3670</span><span id="line.3670">    public GreasedRegion[] retractSeries(int amount) {</span>
<span class="source-line-no">3671</span><span id="line.3671">        GreasedRegion[] result;</span>
<span class="source-line-no">3672</span><span id="line.3672">        if (amount &lt;= 0) {</span>
<span class="source-line-no">3673</span><span id="line.3673">            result = new GreasedRegion[0];</span>
<span class="source-line-no">3674</span><span id="line.3674">        } else {</span>
<span class="source-line-no">3675</span><span id="line.3675">            GreasedRegion[] regions = new GreasedRegion[amount];</span>
<span class="source-line-no">3676</span><span id="line.3676">            GreasedRegion temp = new GreasedRegion(this);</span>
<span class="source-line-no">3677</span><span id="line.3677">            for (int i = 0; i &lt; amount; i++) {</span>
<span class="source-line-no">3678</span><span id="line.3678">                regions[i] = new GreasedRegion(temp.retract());</span>
<span class="source-line-no">3679</span><span id="line.3679">            }</span>
<span class="source-line-no">3680</span><span id="line.3680">            result = regions;</span>
<span class="source-line-no">3681</span><span id="line.3681">        }</span>
<span class="source-line-no">3682</span><span id="line.3682">        return result;</span>
<span class="source-line-no">3683</span><span id="line.3683">    }</span>
<span class="source-line-no">3684</span><span id="line.3684"></span>
<span class="source-line-no">3685</span><span id="line.3685">    public ArrayList&lt;GreasedRegion&gt; retractSeriesToLimit()</span>
<span class="source-line-no">3686</span><span id="line.3686">    {</span>
<span class="source-line-no">3687</span><span id="line.3687">        ArrayList&lt;GreasedRegion&gt; regions = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">3688</span><span id="line.3688">        GreasedRegion temp = new GreasedRegion(this);</span>
<span class="source-line-no">3689</span><span id="line.3689">        while (!temp.retract().isEmpty()) {</span>
<span class="source-line-no">3690</span><span id="line.3690">            regions.add(new GreasedRegion(temp));</span>
<span class="source-line-no">3691</span><span id="line.3691">        }</span>
<span class="source-line-no">3692</span><span id="line.3692">        return regions;</span>
<span class="source-line-no">3693</span><span id="line.3693">    }</span>
<span class="source-line-no">3694</span><span id="line.3694"></span>
<span class="source-line-no">3695</span><span id="line.3695">    public GreasedRegion surface()</span>
<span class="source-line-no">3696</span><span id="line.3696">    {</span>
<span class="source-line-no">3697</span><span id="line.3697">        GreasedRegion cpy = new GreasedRegion(this).retract();</span>
<span class="source-line-no">3698</span><span id="line.3698">        return xor(cpy);</span>
<span class="source-line-no">3699</span><span id="line.3699">    }</span>
<span class="source-line-no">3700</span><span id="line.3700">    public GreasedRegion surface(int amount)</span>
<span class="source-line-no">3701</span><span id="line.3701">    {</span>
<span class="source-line-no">3702</span><span id="line.3702">        GreasedRegion cpy = new GreasedRegion(this).retract(amount);</span>
<span class="source-line-no">3703</span><span id="line.3703">        return xor(cpy);</span>
<span class="source-line-no">3704</span><span id="line.3704">    }</span>
<span class="source-line-no">3705</span><span id="line.3705"></span>
<span class="source-line-no">3706</span><span id="line.3706">    public GreasedRegion[] surfaceSeries(int amount)</span>
<span class="source-line-no">3707</span><span id="line.3707">    {</span>
<span class="source-line-no">3708</span><span id="line.3708">        if(amount &lt;= 0) return new GreasedRegion[0];</span>
<span class="source-line-no">3709</span><span id="line.3709">        GreasedRegion[] regions = new GreasedRegion[amount];</span>
<span class="source-line-no">3710</span><span id="line.3710">        GreasedRegion temp = new GreasedRegion(this);</span>
<span class="source-line-no">3711</span><span id="line.3711">        regions[0] = new GreasedRegion(temp);</span>
<span class="source-line-no">3712</span><span id="line.3712">        for (int i = 1; i &lt; amount; i++) {</span>
<span class="source-line-no">3713</span><span id="line.3713">            regions[i] = new GreasedRegion(temp.retract());</span>
<span class="source-line-no">3714</span><span id="line.3714">        }</span>
<span class="source-line-no">3715</span><span id="line.3715">        for (int i = 0; i &lt; amount - 1; i++) {</span>
<span class="source-line-no">3716</span><span id="line.3716">            regions[i].xor(regions[i + 1]);</span>
<span class="source-line-no">3717</span><span id="line.3717">        }</span>
<span class="source-line-no">3718</span><span id="line.3718">        regions[amount - 1].surface();</span>
<span class="source-line-no">3719</span><span id="line.3719">        return regions;</span>
<span class="source-line-no">3720</span><span id="line.3720">    }</span>
<span class="source-line-no">3721</span><span id="line.3721"></span>
<span class="source-line-no">3722</span><span id="line.3722">    public ArrayList&lt;GreasedRegion&gt; surfaceSeriesToLimit() {</span>
<span class="source-line-no">3723</span><span id="line.3723">        ArrayList&lt;GreasedRegion&gt; result;</span>
<span class="source-line-no">3724</span><span id="line.3724">        ArrayList&lt;GreasedRegion&gt; regions = retractSeriesToLimit();</span>
<span class="source-line-no">3725</span><span id="line.3725">        if (regions.isEmpty()) {</span>
<span class="source-line-no">3726</span><span id="line.3726">            result = regions;</span>
<span class="source-line-no">3727</span><span id="line.3727">        } else {</span>
<span class="source-line-no">3728</span><span id="line.3728">            regions.add(0, regions.get(0).copy().xor(this));</span>
<span class="source-line-no">3729</span><span id="line.3729">            for (int i = 1; i &lt; regions.size() - 1; i++) {</span>
<span class="source-line-no">3730</span><span id="line.3730">                regions.get(i).xor(regions.get(i + 1));</span>
<span class="source-line-no">3731</span><span id="line.3731">            }</span>
<span class="source-line-no">3732</span><span id="line.3732">            result = regions;</span>
<span class="source-line-no">3733</span><span id="line.3733">        }</span>
<span class="source-line-no">3734</span><span id="line.3734">        return result;</span>
<span class="source-line-no">3735</span><span id="line.3735">    }</span>
<span class="source-line-no">3736</span><span id="line.3736">    public GreasedRegion expand8way() {</span>
<span class="source-line-no">3737</span><span id="line.3737">        GreasedRegion result = this;</span>
<span class="source-line-no">3738</span><span id="line.3738">        if (width &lt; 2 || ySections &lt;= 0) {</span>
<span class="source-line-no">3739</span><span id="line.3739">        } else {</span>
<span class="source-line-no">3740</span><span id="line.3740">            final long[] next = new long[width * ySections];</span>
<span class="source-line-no">3741</span><span id="line.3741">            System.arraycopy(data, 0, next, 0, width * ySections);</span>
<span class="source-line-no">3742</span><span id="line.3742">            for (int a = 0; a &lt; ySections; a++) {</span>
<span class="source-line-no">3743</span><span id="line.3743">                next[a] |= (data[a] &lt;&lt; 1) | (data[a] &gt;&gt;&gt; 1)</span>
<span class="source-line-no">3744</span><span id="line.3744">                        | data[a + ySections] | (data[a + ySections] &lt;&lt; 1) | (data[a + ySections] &gt;&gt;&gt; 1);</span>
<span class="source-line-no">3745</span><span id="line.3745">                next[(width - 1) * ySections + a] |= (data[(width - 1) * ySections + a] &lt;&lt; 1) | (data[(width - 1) * ySections + a] &gt;&gt;&gt; 1)</span>
<span class="source-line-no">3746</span><span id="line.3746">                        | data[(width - 2) * ySections + a] | (data[(width - 2) * ySections + a] &lt;&lt; 1) | (data[(width - 2) * ySections + a] &gt;&gt;&gt; 1);</span>
<span class="source-line-no">3747</span><span id="line.3747"></span>
<span class="source-line-no">3748</span><span id="line.3748">                for (int i = ySections + a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3749</span><span id="line.3749">                    next[i] |= (data[i] &lt;&lt; 1) | (data[i] &gt;&gt;&gt; 1)</span>
<span class="source-line-no">3750</span><span id="line.3750">                            | data[i - ySections] | (data[i - ySections] &lt;&lt; 1) | (data[i - ySections] &gt;&gt;&gt; 1)</span>
<span class="source-line-no">3751</span><span id="line.3751">                            | data[i + ySections] | (data[i + ySections] &lt;&lt; 1) | (data[i + ySections] &gt;&gt;&gt; 1);</span>
<span class="source-line-no">3752</span><span id="line.3752">                }</span>
<span class="source-line-no">3753</span><span id="line.3753"></span>
<span class="source-line-no">3754</span><span id="line.3754">                if (a &gt; 0) {</span>
<span class="source-line-no">3755</span><span id="line.3755">                    for (int i = ySections + a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3756</span><span id="line.3756">                        next[i] |= ((data[i - 1] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63) |</span>
<span class="source-line-no">3757</span><span id="line.3757">                                ((data[i - ySections - 1] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63) |</span>
<span class="source-line-no">3758</span><span id="line.3758">                                ((data[i + ySections - 1] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63);</span>
<span class="source-line-no">3759</span><span id="line.3759">                    }</span>
<span class="source-line-no">3760</span><span id="line.3760">                }</span>
<span class="source-line-no">3761</span><span id="line.3761"></span>
<span class="source-line-no">3762</span><span id="line.3762">                if (a &lt; ySections - 1) {</span>
<span class="source-line-no">3763</span><span id="line.3763">                    for (int i = ySections + a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3764</span><span id="line.3764">                        next[i] |= ((data[i + 1] &amp; 1L) &lt;&lt; 63) |</span>
<span class="source-line-no">3765</span><span id="line.3765">                                ((data[i - ySections + 1] &amp; 1L) &lt;&lt; 63) |</span>
<span class="source-line-no">3766</span><span id="line.3766">                                ((data[i + ySections + 1] &amp; 1L) &lt;&lt; 63);</span>
<span class="source-line-no">3767</span><span id="line.3767">                    }</span>
<span class="source-line-no">3768</span><span id="line.3768">                }</span>
<span class="source-line-no">3769</span><span id="line.3769">            }</span>
<span class="source-line-no">3770</span><span id="line.3770">            if (ySections &gt; 0 &amp;&amp; yEndMask != -1) {</span>
<span class="source-line-no">3771</span><span id="line.3771">                for (int a = ySections - 1; a &lt; next.length; a += ySections) {</span>
<span class="source-line-no">3772</span><span id="line.3772">                    next[a] &amp;= yEndMask;</span>
<span class="source-line-no">3773</span><span id="line.3773">                }</span>
<span class="source-line-no">3774</span><span id="line.3774">            }</span>
<span class="source-line-no">3775</span><span id="line.3775">            data = next;</span>
<span class="source-line-no">3776</span><span id="line.3776">            tallied = false;</span>
<span class="source-line-no">3777</span><span id="line.3777">        }</span>
<span class="source-line-no">3778</span><span id="line.3778"></span>
<span class="source-line-no">3779</span><span id="line.3779">        return result;</span>
<span class="source-line-no">3780</span><span id="line.3780">    }</span>
<span class="source-line-no">3781</span><span id="line.3781"></span>
<span class="source-line-no">3782</span><span id="line.3782">    @Override</span>
<span class="source-line-no">3783</span><span id="line.3783">    public GreasedRegion expand8way(int amount)</span>
<span class="source-line-no">3784</span><span id="line.3784">    {</span>
<span class="source-line-no">3785</span><span id="line.3785">        for (int i = 0; i &lt; amount; i++) {</span>
<span class="source-line-no">3786</span><span id="line.3786">            expand8way();</span>
<span class="source-line-no">3787</span><span id="line.3787">        }</span>
<span class="source-line-no">3788</span><span id="line.3788">        return this;</span>
<span class="source-line-no">3789</span><span id="line.3789">    }</span>
<span class="source-line-no">3790</span><span id="line.3790"></span>
<span class="source-line-no">3791</span><span id="line.3791">    public GreasedRegion[] expandSeries8way(int amount) {</span>
<span class="source-line-no">3792</span><span id="line.3792">        GreasedRegion[] result;</span>
<span class="source-line-no">3793</span><span id="line.3793">        if (amount &lt;= 0) {</span>
<span class="source-line-no">3794</span><span id="line.3794">            result = new GreasedRegion[0];</span>
<span class="source-line-no">3795</span><span id="line.3795">        } else {</span>
<span class="source-line-no">3796</span><span id="line.3796">            GreasedRegion[] regions = new GreasedRegion[amount];</span>
<span class="source-line-no">3797</span><span id="line.3797">            GreasedRegion temp = new GreasedRegion(this);</span>
<span class="source-line-no">3798</span><span id="line.3798">            for (int i = 0; i &lt; amount; i++) {</span>
<span class="source-line-no">3799</span><span id="line.3799">                regions[i] = new GreasedRegion(temp.expand8way());</span>
<span class="source-line-no">3800</span><span id="line.3800">            }</span>
<span class="source-line-no">3801</span><span id="line.3801">            result = regions;</span>
<span class="source-line-no">3802</span><span id="line.3802">        }</span>
<span class="source-line-no">3803</span><span id="line.3803">        return result;</span>
<span class="source-line-no">3804</span><span id="line.3804">    }</span>
<span class="source-line-no">3805</span><span id="line.3805">    public ArrayList&lt;GreasedRegion&gt; expandSeriesToLimit8way()</span>
<span class="source-line-no">3806</span><span id="line.3806">    {</span>
<span class="source-line-no">3807</span><span id="line.3807">        ArrayList&lt;GreasedRegion&gt; regions = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">3808</span><span id="line.3808">        GreasedRegion temp = new GreasedRegion(this);</span>
<span class="source-line-no">3809</span><span id="line.3809">        while (temp.size() != temp.expand8way().size()) {</span>
<span class="source-line-no">3810</span><span id="line.3810">            regions.add(new GreasedRegion(temp));</span>
<span class="source-line-no">3811</span><span id="line.3811">        }</span>
<span class="source-line-no">3812</span><span id="line.3812">        return regions;</span>
<span class="source-line-no">3813</span><span id="line.3813">    }</span>
<span class="source-line-no">3814</span><span id="line.3814"></span>
<span class="source-line-no">3815</span><span id="line.3815">    public GreasedRegion fringe8way()</span>
<span class="source-line-no">3816</span><span id="line.3816">    {</span>
<span class="source-line-no">3817</span><span id="line.3817">        GreasedRegion cpy = new GreasedRegion(this);</span>
<span class="source-line-no">3818</span><span id="line.3818">        expand8way();</span>
<span class="source-line-no">3819</span><span id="line.3819">        return andNot(cpy);</span>
<span class="source-line-no">3820</span><span id="line.3820">    }</span>
<span class="source-line-no">3821</span><span id="line.3821">    public GreasedRegion fringe8way(int amount)</span>
<span class="source-line-no">3822</span><span id="line.3822">    {</span>
<span class="source-line-no">3823</span><span id="line.3823">        GreasedRegion cpy = new GreasedRegion(this);</span>
<span class="source-line-no">3824</span><span id="line.3824">        expand8way(amount);</span>
<span class="source-line-no">3825</span><span id="line.3825">        return andNot(cpy);</span>
<span class="source-line-no">3826</span><span id="line.3826">    }</span>
<span class="source-line-no">3827</span><span id="line.3827"></span>
<span class="source-line-no">3828</span><span id="line.3828">    public GreasedRegion[] fringeSeries8way(int amount) {</span>
<span class="source-line-no">3829</span><span id="line.3829">        GreasedRegion[] result;</span>
<span class="source-line-no">3830</span><span id="line.3830">        if (amount &lt;= 0) {</span>
<span class="source-line-no">3831</span><span id="line.3831">            result = new GreasedRegion[0];</span>
<span class="source-line-no">3832</span><span id="line.3832">        } else {</span>
<span class="source-line-no">3833</span><span id="line.3833">            GreasedRegion[] regions = new GreasedRegion[amount];</span>
<span class="source-line-no">3834</span><span id="line.3834">            GreasedRegion temp = new GreasedRegion(this);</span>
<span class="source-line-no">3835</span><span id="line.3835">            regions[0] = new GreasedRegion(temp);</span>
<span class="source-line-no">3836</span><span id="line.3836">            for (int i = 1; i &lt; amount; i++) {</span>
<span class="source-line-no">3837</span><span id="line.3837">                regions[i] = new GreasedRegion(temp.expand8way());</span>
<span class="source-line-no">3838</span><span id="line.3838">            }</span>
<span class="source-line-no">3839</span><span id="line.3839">            for (int i = 0; i &lt; amount - 1; i++) {</span>
<span class="source-line-no">3840</span><span id="line.3840">                regions[i].xor(regions[i + 1]);</span>
<span class="source-line-no">3841</span><span id="line.3841">            }</span>
<span class="source-line-no">3842</span><span id="line.3842">            regions[amount - 1].fringe8way();</span>
<span class="source-line-no">3843</span><span id="line.3843">            result = regions;</span>
<span class="source-line-no">3844</span><span id="line.3844">        }</span>
<span class="source-line-no">3845</span><span id="line.3845">        return result;</span>
<span class="source-line-no">3846</span><span id="line.3846">    }</span>
<span class="source-line-no">3847</span><span id="line.3847">    public ArrayList&lt;GreasedRegion&gt; fringeSeriesToLimit8way()</span>
<span class="source-line-no">3848</span><span id="line.3848">    {</span>
<span class="source-line-no">3849</span><span id="line.3849">        ArrayList&lt;GreasedRegion&gt; regions = expandSeriesToLimit8way();</span>
<span class="source-line-no">3850</span><span id="line.3850">        for (int i = regions.size() - 1; i &gt; 0; i--) {</span>
<span class="source-line-no">3851</span><span id="line.3851">            regions.get(i).xor(regions.get(i-1));</span>
<span class="source-line-no">3852</span><span id="line.3852">        }</span>
<span class="source-line-no">3853</span><span id="line.3853">        regions.get(0).xor(this);</span>
<span class="source-line-no">3854</span><span id="line.3854">        return regions;</span>
<span class="source-line-no">3855</span><span id="line.3855">    }</span>
<span class="source-line-no">3856</span><span id="line.3856"></span>
<span class="source-line-no">3857</span><span id="line.3857">    public GreasedRegion retract8way() {</span>
<span class="source-line-no">3858</span><span id="line.3858">        GreasedRegion result = this;</span>
<span class="source-line-no">3859</span><span id="line.3859">        if (width &lt;= 2 || ySections &lt;= 0) {</span>
<span class="source-line-no">3860</span><span id="line.3860">        } else {</span>
<span class="source-line-no">3861</span><span id="line.3861">            final long[] next = new long[width * ySections];</span>
<span class="source-line-no">3862</span><span id="line.3862">            System.arraycopy(data, ySections, next, ySections, (width - 2) * ySections);</span>
<span class="source-line-no">3863</span><span id="line.3863">            for (int a = 0; a &lt; ySections; a++) {</span>
<span class="source-line-no">3864</span><span id="line.3864">                if (a &gt; 0 &amp;&amp; a &lt; ySections - 1) {</span>
<span class="source-line-no">3865</span><span id="line.3865">                    for (int i = ySections + a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3866</span><span id="line.3866">                        next[i] &amp;= ((data[i] &lt;&lt; 1) | ((data[i - 1] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63))</span>
<span class="source-line-no">3867</span><span id="line.3867">                                &amp; ((data[i] &gt;&gt;&gt; 1) | ((data[i + 1] &amp; 1L) &lt;&lt; 63))</span>
<span class="source-line-no">3868</span><span id="line.3868">                                &amp; data[i - ySections]</span>
<span class="source-line-no">3869</span><span id="line.3869">                                &amp; data[i + ySections]</span>
<span class="source-line-no">3870</span><span id="line.3870">                                &amp; ((data[i - ySections] &lt;&lt; 1) | ((data[i - 1 - ySections] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63))</span>
<span class="source-line-no">3871</span><span id="line.3871">                                &amp; ((data[i + ySections] &lt;&lt; 1) | ((data[i - 1 + ySections] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63))</span>
<span class="source-line-no">3872</span><span id="line.3872">                                &amp; ((data[i - ySections] &gt;&gt;&gt; 1) | ((data[i + 1 - ySections] &amp; 1L) &lt;&lt; 63))</span>
<span class="source-line-no">3873</span><span id="line.3873">                                &amp; ((data[i + ySections] &gt;&gt;&gt; 1) | ((data[i + 1 + ySections] &amp; 1L) &lt;&lt; 63));</span>
<span class="source-line-no">3874</span><span id="line.3874">                    }</span>
<span class="source-line-no">3875</span><span id="line.3875">                } else if (a &gt; 0) {</span>
<span class="source-line-no">3876</span><span id="line.3876">                    for (int i = ySections + a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3877</span><span id="line.3877">                        next[i] &amp;= ((data[i] &lt;&lt; 1) | ((data[i - 1] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63))</span>
<span class="source-line-no">3878</span><span id="line.3878">                                &amp; (data[i] &gt;&gt;&gt; 1)</span>
<span class="source-line-no">3879</span><span id="line.3879">                                &amp; data[i - ySections]</span>
<span class="source-line-no">3880</span><span id="line.3880">                                &amp; data[i + ySections]</span>
<span class="source-line-no">3881</span><span id="line.3881">                                &amp; ((data[i - ySections] &lt;&lt; 1) | ((data[i - 1 - ySections] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63))</span>
<span class="source-line-no">3882</span><span id="line.3882">                                &amp; ((data[i + ySections] &lt;&lt; 1) | ((data[i - 1 + ySections] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63))</span>
<span class="source-line-no">3883</span><span id="line.3883">                                &amp; (data[i - ySections] &gt;&gt;&gt; 1)</span>
<span class="source-line-no">3884</span><span id="line.3884">                                &amp; (data[i + ySections] &gt;&gt;&gt; 1);</span>
<span class="source-line-no">3885</span><span id="line.3885">                    }</span>
<span class="source-line-no">3886</span><span id="line.3886">                } else if (a &lt; ySections - 1) {</span>
<span class="source-line-no">3887</span><span id="line.3887">                    for (int i = ySections + a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3888</span><span id="line.3888">                        next[i] &amp;= (data[i] &lt;&lt; 1)</span>
<span class="source-line-no">3889</span><span id="line.3889">                                &amp; ((data[i] &gt;&gt;&gt; 1) | ((data[i + 1] &amp; 1L) &lt;&lt; 63))</span>
<span class="source-line-no">3890</span><span id="line.3890">                                &amp; data[i - ySections]</span>
<span class="source-line-no">3891</span><span id="line.3891">                                &amp; data[i + ySections]</span>
<span class="source-line-no">3892</span><span id="line.3892">                                &amp; (data[i - ySections] &lt;&lt; 1)</span>
<span class="source-line-no">3893</span><span id="line.3893">                                &amp; (data[i + ySections] &lt;&lt; 1)</span>
<span class="source-line-no">3894</span><span id="line.3894">                                &amp; ((data[i - ySections] &gt;&gt;&gt; 1) | ((data[i + 1 - ySections] &amp; 1L) &lt;&lt; 63))</span>
<span class="source-line-no">3895</span><span id="line.3895">                                &amp; ((data[i + ySections] &gt;&gt;&gt; 1) | ((data[i + 1 + ySections] &amp; 1L) &lt;&lt; 63));</span>
<span class="source-line-no">3896</span><span id="line.3896">                    }</span>
<span class="source-line-no">3897</span><span id="line.3897">                } else // only the case when ySections == 1</span>
<span class="source-line-no">3898</span><span id="line.3898">                {</span>
<span class="source-line-no">3899</span><span id="line.3899">                    for (int i = ySections + a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">3900</span><span id="line.3900">                        next[i] &amp;= (data[i] &lt;&lt; 1)</span>
<span class="source-line-no">3901</span><span id="line.3901">                                &amp; (data[i] &gt;&gt;&gt; 1)</span>
<span class="source-line-no">3902</span><span id="line.3902">                                &amp; data[i - ySections]</span>
<span class="source-line-no">3903</span><span id="line.3903">                                &amp; data[i + ySections]</span>
<span class="source-line-no">3904</span><span id="line.3904">                                &amp; (data[i - ySections] &lt;&lt; 1)</span>
<span class="source-line-no">3905</span><span id="line.3905">                                &amp; (data[i + ySections] &lt;&lt; 1)</span>
<span class="source-line-no">3906</span><span id="line.3906">                                &amp; (data[i - ySections] &gt;&gt;&gt; 1)</span>
<span class="source-line-no">3907</span><span id="line.3907">                                &amp; (data[i + ySections] &gt;&gt;&gt; 1);</span>
<span class="source-line-no">3908</span><span id="line.3908">                    }</span>
<span class="source-line-no">3909</span><span id="line.3909">                }</span>
<span class="source-line-no">3910</span><span id="line.3910">            }</span>
<span class="source-line-no">3911</span><span id="line.3911">            if (yEndMask != -1) {</span>
<span class="source-line-no">3912</span><span id="line.3912">                for (int a = ySections - 1; a &lt; next.length; a += ySections) {</span>
<span class="source-line-no">3913</span><span id="line.3913">                    next[a] &amp;= yEndMask;</span>
<span class="source-line-no">3914</span><span id="line.3914">                }</span>
<span class="source-line-no">3915</span><span id="line.3915">            }</span>
<span class="source-line-no">3916</span><span id="line.3916">            data = next;</span>
<span class="source-line-no">3917</span><span id="line.3917">            tallied = false;</span>
<span class="source-line-no">3918</span><span id="line.3918">        }</span>
<span class="source-line-no">3919</span><span id="line.3919"></span>
<span class="source-line-no">3920</span><span id="line.3920">        return result;</span>
<span class="source-line-no">3921</span><span id="line.3921">    }</span>
<span class="source-line-no">3922</span><span id="line.3922"></span>
<span class="source-line-no">3923</span><span id="line.3923">    public GreasedRegion retract8way(int amount)</span>
<span class="source-line-no">3924</span><span id="line.3924">    {</span>
<span class="source-line-no">3925</span><span id="line.3925">        for (int i = 0; i &lt; amount; i++) {</span>
<span class="source-line-no">3926</span><span id="line.3926">            retract8way();</span>
<span class="source-line-no">3927</span><span id="line.3927">        }</span>
<span class="source-line-no">3928</span><span id="line.3928">        return this;</span>
<span class="source-line-no">3929</span><span id="line.3929">    }</span>
<span class="source-line-no">3930</span><span id="line.3930"></span>
<span class="source-line-no">3931</span><span id="line.3931">    public GreasedRegion[] retractSeries8way(int amount) {</span>
<span class="source-line-no">3932</span><span id="line.3932">        GreasedRegion[] result;</span>
<span class="source-line-no">3933</span><span id="line.3933">        if (amount &lt;= 0) {</span>
<span class="source-line-no">3934</span><span id="line.3934">            result = new GreasedRegion[0];</span>
<span class="source-line-no">3935</span><span id="line.3935">        } else {</span>
<span class="source-line-no">3936</span><span id="line.3936">            GreasedRegion[] regions = new GreasedRegion[amount];</span>
<span class="source-line-no">3937</span><span id="line.3937">            GreasedRegion temp = new GreasedRegion(this);</span>
<span class="source-line-no">3938</span><span id="line.3938">            for (int i = 0; i &lt; amount; i++) {</span>
<span class="source-line-no">3939</span><span id="line.3939">                regions[i] = new GreasedRegion(temp.retract8way());</span>
<span class="source-line-no">3940</span><span id="line.3940">            }</span>
<span class="source-line-no">3941</span><span id="line.3941">            result = regions;</span>
<span class="source-line-no">3942</span><span id="line.3942">        }</span>
<span class="source-line-no">3943</span><span id="line.3943">        return result;</span>
<span class="source-line-no">3944</span><span id="line.3944">    }</span>
<span class="source-line-no">3945</span><span id="line.3945"></span>
<span class="source-line-no">3946</span><span id="line.3946">    public ArrayList&lt;GreasedRegion&gt; retractSeriesToLimit8way()</span>
<span class="source-line-no">3947</span><span id="line.3947">    {</span>
<span class="source-line-no">3948</span><span id="line.3948">        ArrayList&lt;GreasedRegion&gt; regions = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">3949</span><span id="line.3949">        GreasedRegion temp = new GreasedRegion(this);</span>
<span class="source-line-no">3950</span><span id="line.3950">        while (!temp.retract8way().isEmpty()) {</span>
<span class="source-line-no">3951</span><span id="line.3951">            regions.add(new GreasedRegion(temp));</span>
<span class="source-line-no">3952</span><span id="line.3952">        }</span>
<span class="source-line-no">3953</span><span id="line.3953">        return regions;</span>
<span class="source-line-no">3954</span><span id="line.3954">    }</span>
<span class="source-line-no">3955</span><span id="line.3955"></span>
<span class="source-line-no">3956</span><span id="line.3956">    public GreasedRegion surface8way()</span>
<span class="source-line-no">3957</span><span id="line.3957">    {</span>
<span class="source-line-no">3958</span><span id="line.3958">        GreasedRegion cpy = new GreasedRegion(this).retract8way();</span>
<span class="source-line-no">3959</span><span id="line.3959">        return xor(cpy);</span>
<span class="source-line-no">3960</span><span id="line.3960">    }</span>
<span class="source-line-no">3961</span><span id="line.3961"></span>
<span class="source-line-no">3962</span><span id="line.3962">    public GreasedRegion surface8way(int amount)</span>
<span class="source-line-no">3963</span><span id="line.3963">    {</span>
<span class="source-line-no">3964</span><span id="line.3964">        GreasedRegion cpy = new GreasedRegion(this).retract8way(amount);</span>
<span class="source-line-no">3965</span><span id="line.3965">        return xor(cpy);</span>
<span class="source-line-no">3966</span><span id="line.3966">    }</span>
<span class="source-line-no">3967</span><span id="line.3967"></span>
<span class="source-line-no">3968</span><span id="line.3968">    public GreasedRegion[] surfaceSeries8way(int amount) {</span>
<span class="source-line-no">3969</span><span id="line.3969">        GreasedRegion[] result;</span>
<span class="source-line-no">3970</span><span id="line.3970">        if (amount &lt;= 0) {</span>
<span class="source-line-no">3971</span><span id="line.3971">            result = new GreasedRegion[0];</span>
<span class="source-line-no">3972</span><span id="line.3972">        } else {</span>
<span class="source-line-no">3973</span><span id="line.3973">            GreasedRegion[] regions = new GreasedRegion[amount];</span>
<span class="source-line-no">3974</span><span id="line.3974">            GreasedRegion temp = new GreasedRegion(this);</span>
<span class="source-line-no">3975</span><span id="line.3975">            regions[0] = new GreasedRegion(temp);</span>
<span class="source-line-no">3976</span><span id="line.3976">            for (int i = 1; i &lt; amount; i++) {</span>
<span class="source-line-no">3977</span><span id="line.3977">                regions[i] = new GreasedRegion(temp.retract8way());</span>
<span class="source-line-no">3978</span><span id="line.3978">            }</span>
<span class="source-line-no">3979</span><span id="line.3979">            for (int i = 0; i &lt; amount - 1; i++) {</span>
<span class="source-line-no">3980</span><span id="line.3980">                regions[i].xor(regions[i + 1]);</span>
<span class="source-line-no">3981</span><span id="line.3981">            }</span>
<span class="source-line-no">3982</span><span id="line.3982">            regions[amount - 1].surface8way();</span>
<span class="source-line-no">3983</span><span id="line.3983">            result = regions;</span>
<span class="source-line-no">3984</span><span id="line.3984">        }</span>
<span class="source-line-no">3985</span><span id="line.3985">        return result;</span>
<span class="source-line-no">3986</span><span id="line.3986">    }</span>
<span class="source-line-no">3987</span><span id="line.3987">    public ArrayList&lt;GreasedRegion&gt; surfaceSeriesToLimit8way() {</span>
<span class="source-line-no">3988</span><span id="line.3988">        ArrayList&lt;GreasedRegion&gt; result;</span>
<span class="source-line-no">3989</span><span id="line.3989">        ArrayList&lt;GreasedRegion&gt; regions = retractSeriesToLimit8way();</span>
<span class="source-line-no">3990</span><span id="line.3990">        if (regions.isEmpty()) {</span>
<span class="source-line-no">3991</span><span id="line.3991">            result = regions;</span>
<span class="source-line-no">3992</span><span id="line.3992">        } else {</span>
<span class="source-line-no">3993</span><span id="line.3993">            regions.add(0, regions.get(0).copy().xor(this));</span>
<span class="source-line-no">3994</span><span id="line.3994">            for (int i = 1; i &lt; regions.size() - 1; i++) {</span>
<span class="source-line-no">3995</span><span id="line.3995">                regions.get(i).xor(regions.get(i + 1));</span>
<span class="source-line-no">3996</span><span id="line.3996">            }</span>
<span class="source-line-no">3997</span><span id="line.3997">            result = regions;</span>
<span class="source-line-no">3998</span><span id="line.3998">        }</span>
<span class="source-line-no">3999</span><span id="line.3999">        return result;</span>
<span class="source-line-no">4000</span><span id="line.4000">    }</span>
<span class="source-line-no">4001</span><span id="line.4001"></span>
<span class="source-line-no">4002</span><span id="line.4002">    /**</span>
<span class="source-line-no">4003</span><span id="line.4003">     * Like {@link #expand()}, but limits expansion to the "on" cells of {@code bounds}. Expands in all 4-way directions</span>
<span class="source-line-no">4004</span><span id="line.4004">     * by one cell simultaneously, and only successfully affects the cells that are adjacent to this and are in bounds.</span>
<span class="source-line-no">4005</span><span id="line.4005">     * @param bounds the set of "on" cells that limits where this can expand into</span>
<span class="source-line-no">4006</span><span id="line.4006">     * @return this, after expanding, for chaining</span>
<span class="source-line-no">4007</span><span id="line.4007">     */</span>
<span class="source-line-no">4008</span><span id="line.4008">    public GreasedRegion flood(GreasedRegion bounds) {</span>
<span class="source-line-no">4009</span><span id="line.4009">        GreasedRegion result = this;</span>
<span class="source-line-no">4010</span><span id="line.4010">        if (width &lt; 2 || ySections &lt;= 0 || bounds == null || bounds.width &lt; 2 || bounds.ySections &lt;= 0) {</span>
<span class="source-line-no">4011</span><span id="line.4011">        } else {</span>
<span class="source-line-no">4012</span><span id="line.4012">            final long[] next = new long[width * ySections];</span>
<span class="source-line-no">4013</span><span id="line.4013">            for (int a = 0; a &lt; ySections &amp;&amp; a &lt; bounds.ySections; a++) {</span>
<span class="source-line-no">4014</span><span id="line.4014">                next[a] |= (data[a] | (data[a] &lt;&lt; 1) | (data[a] &gt;&gt;&gt; 1) | data[a + ySections]) &amp; bounds.data[a];</span>
<span class="source-line-no">4015</span><span id="line.4015">                next[(width - 1) * ySections + a] |= (data[(width - 1) * ySections + a] | (data[(width - 1) * ySections + a] &lt;&lt; 1)</span>
<span class="source-line-no">4016</span><span id="line.4016">                        | (data[(width - 1) * ySections + a] &gt;&gt;&gt; 1) | data[(width - 2) * ySections + a]) &amp; bounds.data[(width - 1) * bounds.ySections + a];</span>
<span class="source-line-no">4017</span><span id="line.4017"></span>
<span class="source-line-no">4018</span><span id="line.4018">                for (int i = ySections + a, j = bounds.ySections + a; i &lt; (width - 1) * ySections &amp;&amp;</span>
<span class="source-line-no">4019</span><span id="line.4019">                        j &lt; (bounds.width - 1) * bounds.ySections; i += ySections, j += bounds.ySections) {</span>
<span class="source-line-no">4020</span><span id="line.4020">                    next[i] |= (data[i] | (data[i] &lt;&lt; 1) | (data[i] &gt;&gt;&gt; 1) | data[i - ySections] | data[i + ySections]) &amp; bounds.data[j];</span>
<span class="source-line-no">4021</span><span id="line.4021">                }</span>
<span class="source-line-no">4022</span><span id="line.4022"></span>
<span class="source-line-no">4023</span><span id="line.4023">                if (a &gt; 0) {</span>
<span class="source-line-no">4024</span><span id="line.4024">                    for (int i = ySections + a, j = bounds.ySections + a; i &lt; (width - 1) * ySections &amp;&amp; j &lt; (bounds.width - 1) * bounds.ySections;</span>
<span class="source-line-no">4025</span><span id="line.4025">                         i += ySections, j += bounds.ySections) {</span>
<span class="source-line-no">4026</span><span id="line.4026">                        next[i] |= (data[i] | ((data[i - 1] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63)) &amp; bounds.data[j];</span>
<span class="source-line-no">4027</span><span id="line.4027">                    }</span>
<span class="source-line-no">4028</span><span id="line.4028">                }</span>
<span class="source-line-no">4029</span><span id="line.4029"></span>
<span class="source-line-no">4030</span><span id="line.4030">                if (a &lt; ySections - 1 &amp;&amp; a &lt; bounds.ySections - 1) {</span>
<span class="source-line-no">4031</span><span id="line.4031">                    for (int i = ySections + a, j = bounds.ySections + a;</span>
<span class="source-line-no">4032</span><span id="line.4032">                         i &lt; (width - 1) * ySections &amp;&amp; j &lt; (bounds.width - 1) * bounds.ySections; i += ySections, j += bounds.ySections) {</span>
<span class="source-line-no">4033</span><span id="line.4033">                        next[i] |= (data[i] | ((data[i + 1] &amp; 1L) &lt;&lt; 63)) &amp; bounds.data[j];</span>
<span class="source-line-no">4034</span><span id="line.4034">                    }</span>
<span class="source-line-no">4035</span><span id="line.4035">                }</span>
<span class="source-line-no">4036</span><span id="line.4036">            }</span>
<span class="source-line-no">4037</span><span id="line.4037">            if (yEndMask != -1 &amp;&amp; bounds.yEndMask != -1) {</span>
<span class="source-line-no">4038</span><span id="line.4038">                if (ySections == bounds.ySections) {</span>
<span class="source-line-no">4039</span><span id="line.4039">                    long mask = ((yEndMask &gt;&gt;&gt; 1) &lt;= (bounds.yEndMask &gt;&gt;&gt; 1))</span>
<span class="source-line-no">4040</span><span id="line.4040">                            ? yEndMask : bounds.yEndMask;</span>
<span class="source-line-no">4041</span><span id="line.4041">                    for (int a = ySections - 1; a &lt; next.length; a += ySections) {</span>
<span class="source-line-no">4042</span><span id="line.4042">                        next[a] &amp;= mask;</span>
<span class="source-line-no">4043</span><span id="line.4043">                    }</span>
<span class="source-line-no">4044</span><span id="line.4044">                } else if (ySections &lt; bounds.ySections) {</span>
<span class="source-line-no">4045</span><span id="line.4045">                    for (int a = ySections - 1; a &lt; next.length; a += ySections) {</span>
<span class="source-line-no">4046</span><span id="line.4046">                        next[a] &amp;= yEndMask;</span>
<span class="source-line-no">4047</span><span id="line.4047">                    }</span>
<span class="source-line-no">4048</span><span id="line.4048">                } else {</span>
<span class="source-line-no">4049</span><span id="line.4049">                    for (int a = bounds.ySections - 1; a &lt; next.length; a += ySections) {</span>
<span class="source-line-no">4050</span><span id="line.4050">                        next[a] &amp;= bounds.yEndMask;</span>
<span class="source-line-no">4051</span><span id="line.4051">                    }</span>
<span class="source-line-no">4052</span><span id="line.4052">                }</span>
<span class="source-line-no">4053</span><span id="line.4053">            }</span>
<span class="source-line-no">4054</span><span id="line.4054">            data = next;</span>
<span class="source-line-no">4055</span><span id="line.4055">            tallied = false;</span>
<span class="source-line-no">4056</span><span id="line.4056">        }</span>
<span class="source-line-no">4057</span><span id="line.4057"></span>
<span class="source-line-no">4058</span><span id="line.4058">        return result;</span>
<span class="source-line-no">4059</span><span id="line.4059">    }</span>
<span class="source-line-no">4060</span><span id="line.4060"></span>
<span class="source-line-no">4061</span><span id="line.4061">    /**</span>
<span class="source-line-no">4062</span><span id="line.4062">     * Like {@link #expand(int)}, but limits expansion to the "on" cells of {@code bounds}. Repeatedly expands in the</span>
<span class="source-line-no">4063</span><span id="line.4063">     * 4-way directions by one cell simultaneously, and only successfully affects the cells that are adjacent to the</span>
<span class="source-line-no">4064</span><span id="line.4064">     * previous expansion and are in bounds. This won't skip over gaps in bounds, even if amount is high enough that a</span>
<span class="source-line-no">4065</span><span id="line.4065">     * call to {@link #expand(int)} would reach past the gap; it will stop at the gap and only pass it if expansion</span>
<span class="source-line-no">4066</span><span id="line.4066">     * takes it around.</span>
<span class="source-line-no">4067</span><span id="line.4067">     * @param bounds the set of "on" cells that limits where this can expand into</span>
<span class="source-line-no">4068</span><span id="line.4068">     * @param amount how far to expand this outward by, in cells</span>
<span class="source-line-no">4069</span><span id="line.4069">     * @return this, after expanding, for chaining</span>
<span class="source-line-no">4070</span><span id="line.4070">     */</span>
<span class="source-line-no">4071</span><span id="line.4071">    public GreasedRegion flood(GreasedRegion bounds, int amount)</span>
<span class="source-line-no">4072</span><span id="line.4072">    {</span>
<span class="source-line-no">4073</span><span id="line.4073">        int ct = size(), ct2;</span>
<span class="source-line-no">4074</span><span id="line.4074">        for (int i = 0; i &lt; amount; i++) {</span>
<span class="source-line-no">4075</span><span id="line.4075">            flood(bounds);</span>
<span class="source-line-no">4076</span><span id="line.4076">            if(ct == (ct2 = size()))</span>
<span class="source-line-no">4077</span><span id="line.4077">                break;</span>
<span class="source-line-no">4078</span><span id="line.4078">            else</span>
<span class="source-line-no">4079</span><span id="line.4079">                ct = ct2;</span>
<span class="source-line-no">4080</span><span id="line.4080"></span>
<span class="source-line-no">4081</span><span id="line.4081">        }</span>
<span class="source-line-no">4082</span><span id="line.4082">        return this;</span>
<span class="source-line-no">4083</span><span id="line.4083">    }</span>
<span class="source-line-no">4084</span><span id="line.4084"></span>
<span class="source-line-no">4085</span><span id="line.4085">    /**</span>
<span class="source-line-no">4086</span><span id="line.4086">     * Repeatedly calls {@link #flood(GreasedRegion)} {@code amount} times and returns the intermediate steps in a</span>
<span class="source-line-no">4087</span><span id="line.4087">     * GreasedRegion array of size {@code amount}. Doesn't modify this GreasedRegion, and doesn't return it in the array</span>
<span class="source-line-no">4088</span><span id="line.4088">     * (it may return a copy of it if and only if no flood8way() calls can expand the area). If this fills</span>
<span class="source-line-no">4089</span><span id="line.4089">     * {@code bounds} as fully as possible and still has steps left, the remaining steps are all copies of the</span>
<span class="source-line-no">4090</span><span id="line.4090">     * fully-filled area.</span>
<span class="source-line-no">4091</span><span id="line.4091">     * @param bounds the set of "on" cells that this will attempt to fill in steps</span>
<span class="source-line-no">4092</span><span id="line.4092">     * @param amount how many steps to flood outward, and the size of the array to return</span>
<span class="source-line-no">4093</span><span id="line.4093">     * @return an array of GreasedRegion, {@code amount} in size, containing larger and larger expansions of this</span>
<span class="source-line-no">4094</span><span id="line.4094">     */</span>
<span class="source-line-no">4095</span><span id="line.4095">    public GreasedRegion[] floodSeries(GreasedRegion bounds, int amount) {</span>
<span class="source-line-no">4096</span><span id="line.4096">        GreasedRegion[] result;</span>
<span class="source-line-no">4097</span><span id="line.4097">        if (amount &lt;= 0) {</span>
<span class="source-line-no">4098</span><span id="line.4098">            result = new GreasedRegion[0];</span>
<span class="source-line-no">4099</span><span id="line.4099">        } else {</span>
<span class="source-line-no">4100</span><span id="line.4100">            int ct = size(), ct2;</span>
<span class="source-line-no">4101</span><span id="line.4101">            GreasedRegion[] regions = new GreasedRegion[amount];</span>
<span class="source-line-no">4102</span><span id="line.4102">            boolean done = false;</span>
<span class="source-line-no">4103</span><span id="line.4103">            GreasedRegion temp = new GreasedRegion(this);</span>
<span class="source-line-no">4104</span><span id="line.4104">            for (int i = 0; i &lt; amount; i++) {</span>
<span class="source-line-no">4105</span><span id="line.4105">                if (done) {</span>
<span class="source-line-no">4106</span><span id="line.4106">                    regions[i] = new GreasedRegion(temp);</span>
<span class="source-line-no">4107</span><span id="line.4107">                } else {</span>
<span class="source-line-no">4108</span><span id="line.4108">                    regions[i] = new GreasedRegion(temp.flood(bounds));</span>
<span class="source-line-no">4109</span><span id="line.4109">                    if (ct == (ct2 = temp.size()))</span>
<span class="source-line-no">4110</span><span id="line.4110">                        done = true;</span>
<span class="source-line-no">4111</span><span id="line.4111">                    else</span>
<span class="source-line-no">4112</span><span id="line.4112">                        ct = ct2;</span>
<span class="source-line-no">4113</span><span id="line.4113">                }</span>
<span class="source-line-no">4114</span><span id="line.4114">            }</span>
<span class="source-line-no">4115</span><span id="line.4115">            result = regions;</span>
<span class="source-line-no">4116</span><span id="line.4116">        }</span>
<span class="source-line-no">4117</span><span id="line.4117">        return result;</span>
<span class="source-line-no">4118</span><span id="line.4118">    }</span>
<span class="source-line-no">4119</span><span id="line.4119"></span>
<span class="source-line-no">4120</span><span id="line.4120">    /**</span>
<span class="source-line-no">4121</span><span id="line.4121">     * Repeatedly generates new GreasedRegions, each one cell expanded in 4 directions from the previous GreasedRegion</span>
<span class="source-line-no">4122</span><span id="line.4122">     * and staying inside the "on" cells of {@code bounds}, until it can't expand any more. Returns an ArrayList of the</span>
<span class="source-line-no">4123</span><span id="line.4123">     * GreasedRegion steps this generated; this list does not include this GreasedRegion (or any unmodified copy of this</span>
<span class="source-line-no">4124</span><span id="line.4124">     * GreasedRegion), and this method does not modify it.</span>
<span class="source-line-no">4125</span><span id="line.4125">     * @param bounds the set of "on" cells that this will attempt to fill in steps</span>
<span class="source-line-no">4126</span><span id="line.4126">     * @return an ArrayList of steps from one {@link #flood(GreasedRegion)} call to possibly many chained after it</span>
<span class="source-line-no">4127</span><span id="line.4127">     */</span>
<span class="source-line-no">4128</span><span id="line.4128">    public ArrayList&lt;GreasedRegion&gt; floodSeriesToLimit(GreasedRegion bounds) {</span>
<span class="source-line-no">4129</span><span id="line.4129">        int ct = size(), ct2;</span>
<span class="source-line-no">4130</span><span id="line.4130">        ArrayList&lt;GreasedRegion&gt; regions = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">4131</span><span id="line.4131">        GreasedRegion temp = new GreasedRegion(this);</span>
<span class="source-line-no">4132</span><span id="line.4132">        while (true) {</span>
<span class="source-line-no">4133</span><span id="line.4133">            temp.flood(bounds);</span>
<span class="source-line-no">4134</span><span id="line.4134">            if (ct == (ct2 = temp.size()))</span>
<span class="source-line-no">4135</span><span id="line.4135">                return regions;</span>
<span class="source-line-no">4136</span><span id="line.4136">            else {</span>
<span class="source-line-no">4137</span><span id="line.4137">                ct = ct2;</span>
<span class="source-line-no">4138</span><span id="line.4138">                regions.add(new GreasedRegion(temp));</span>
<span class="source-line-no">4139</span><span id="line.4139">            }</span>
<span class="source-line-no">4140</span><span id="line.4140">        }</span>
<span class="source-line-no">4141</span><span id="line.4141">    }</span>
<span class="source-line-no">4142</span><span id="line.4142"></span>
<span class="source-line-no">4143</span><span id="line.4143">    /**</span>
<span class="source-line-no">4144</span><span id="line.4144">     * Like {@link #expand8way()}, but limits expansion to the "on" cells of {@code bounds}. Expands in all directions</span>
<span class="source-line-no">4145</span><span id="line.4145">     * by one cell simultaneously, and only successfully affects the cells that are adjacent to this and are in bounds.</span>
<span class="source-line-no">4146</span><span id="line.4146">     * @param bounds the set of "on" cells that limits where this can expand into</span>
<span class="source-line-no">4147</span><span id="line.4147">     * @return this, after expanding, for chaining</span>
<span class="source-line-no">4148</span><span id="line.4148">     */</span>
<span class="source-line-no">4149</span><span id="line.4149">    public GreasedRegion flood8way(GreasedRegion bounds) {</span>
<span class="source-line-no">4150</span><span id="line.4150">        GreasedRegion result = this;</span>
<span class="source-line-no">4151</span><span id="line.4151">        if (width &lt; 2 || ySections &lt;= 0 || bounds == null || bounds.width &lt; 2 || bounds.ySections &lt;= 0) {</span>
<span class="source-line-no">4152</span><span id="line.4152">        } else {</span>
<span class="source-line-no">4153</span><span id="line.4153">            final long[] next = new long[width * ySections];</span>
<span class="source-line-no">4154</span><span id="line.4154">            for (int a = 0; a &lt; ySections &amp;&amp; a &lt; bounds.ySections; a++) {</span>
<span class="source-line-no">4155</span><span id="line.4155">                next[a] |= (data[a] | (data[a] &lt;&lt; 1) | (data[a] &gt;&gt;&gt; 1)</span>
<span class="source-line-no">4156</span><span id="line.4156">                        | data[a + ySections] | (data[a + ySections] &lt;&lt; 1) | (data[a + ySections] &gt;&gt;&gt; 1)) &amp; bounds.data[a];</span>
<span class="source-line-no">4157</span><span id="line.4157">                next[(width - 1) * ySections + a] |= (data[(width - 1) * ySections + a]</span>
<span class="source-line-no">4158</span><span id="line.4158">                        | (data[(width - 1) * ySections + a] &lt;&lt; 1) | (data[(width - 1) * ySections + a] &gt;&gt;&gt; 1)</span>
<span class="source-line-no">4159</span><span id="line.4159">                        | data[(width - 2) * ySections + a] | (data[(width - 2) * ySections + a] &lt;&lt; 1) | (data[(width - 2) * ySections + a] &gt;&gt;&gt; 1))</span>
<span class="source-line-no">4160</span><span id="line.4160">                        &amp; bounds.data[(width - 1) * bounds.ySections + a];</span>
<span class="source-line-no">4161</span><span id="line.4161"></span>
<span class="source-line-no">4162</span><span id="line.4162">                for (int i = ySections + a, j = bounds.ySections + a; i &lt; (width - 1) * ySections &amp;&amp;</span>
<span class="source-line-no">4163</span><span id="line.4163">                        j &lt; (bounds.width - 1) * bounds.ySections; i += ySections, j += bounds.ySections) {</span>
<span class="source-line-no">4164</span><span id="line.4164">                    next[i] |= (data[i] | (data[i] &lt;&lt; 1) | (data[i] &gt;&gt;&gt; 1)</span>
<span class="source-line-no">4165</span><span id="line.4165">                            | data[i - ySections] | (data[i - ySections] &lt;&lt; 1) | (data[i - ySections] &gt;&gt;&gt; 1)</span>
<span class="source-line-no">4166</span><span id="line.4166">                            | data[i + ySections] | (data[i + ySections] &lt;&lt; 1) | (data[i + ySections] &gt;&gt;&gt; 1))</span>
<span class="source-line-no">4167</span><span id="line.4167">                            &amp; bounds.data[j];</span>
<span class="source-line-no">4168</span><span id="line.4168">                }</span>
<span class="source-line-no">4169</span><span id="line.4169"></span>
<span class="source-line-no">4170</span><span id="line.4170">                if (a &gt; 0) {</span>
<span class="source-line-no">4171</span><span id="line.4171">                    for (int i = ySections + a, j = bounds.ySections + a; i &lt; (width - 1) * ySections &amp;&amp; j &lt; (bounds.width - 1) * bounds.ySections;</span>
<span class="source-line-no">4172</span><span id="line.4172">                         i += ySections, j += bounds.ySections) {</span>
<span class="source-line-no">4173</span><span id="line.4173">                        next[i] |= (data[i] | ((data[i - 1] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63) |</span>
<span class="source-line-no">4174</span><span id="line.4174">                                ((data[i - ySections - 1] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63) |</span>
<span class="source-line-no">4175</span><span id="line.4175">                                ((data[i + ySections - 1] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63)) &amp; bounds.data[j];</span>
<span class="source-line-no">4176</span><span id="line.4176">                    }</span>
<span class="source-line-no">4177</span><span id="line.4177">                }</span>
<span class="source-line-no">4178</span><span id="line.4178"></span>
<span class="source-line-no">4179</span><span id="line.4179">                if (a &lt; ySections - 1 &amp;&amp; a &lt; bounds.ySections - 1) {</span>
<span class="source-line-no">4180</span><span id="line.4180">                    for (int i = ySections + a, j = bounds.ySections + a;</span>
<span class="source-line-no">4181</span><span id="line.4181">                         i &lt; (width - 1) * ySections &amp;&amp; j &lt; (bounds.width - 1) * bounds.ySections; i += ySections, j += bounds.ySections) {</span>
<span class="source-line-no">4182</span><span id="line.4182">                        next[i] |= (data[i] | ((data[i + 1] &amp; 1L) &lt;&lt; 63) |</span>
<span class="source-line-no">4183</span><span id="line.4183">                                ((data[i - ySections + 1] &amp; 1L) &lt;&lt; 63) |</span>
<span class="source-line-no">4184</span><span id="line.4184">                                ((data[i + ySections + 1] &amp; 1L) &lt;&lt; 63)) &amp; bounds.data[j];</span>
<span class="source-line-no">4185</span><span id="line.4185">                    }</span>
<span class="source-line-no">4186</span><span id="line.4186">                }</span>
<span class="source-line-no">4187</span><span id="line.4187">            }</span>
<span class="source-line-no">4188</span><span id="line.4188">            if (yEndMask != -1 &amp;&amp; bounds.yEndMask != -1) {</span>
<span class="source-line-no">4189</span><span id="line.4189">                if (ySections == bounds.ySections) {</span>
<span class="source-line-no">4190</span><span id="line.4190">                    long mask = ((yEndMask &gt;&gt;&gt; 1) &lt;= (bounds.yEndMask &gt;&gt;&gt; 1))</span>
<span class="source-line-no">4191</span><span id="line.4191">                            ? yEndMask : bounds.yEndMask;</span>
<span class="source-line-no">4192</span><span id="line.4192">                    for (int a = ySections - 1; a &lt; next.length; a += ySections) {</span>
<span class="source-line-no">4193</span><span id="line.4193">                        next[a] &amp;= mask;</span>
<span class="source-line-no">4194</span><span id="line.4194">                    }</span>
<span class="source-line-no">4195</span><span id="line.4195">                } else if (ySections &lt; bounds.ySections) {</span>
<span class="source-line-no">4196</span><span id="line.4196">                    for (int a = ySections - 1; a &lt; next.length; a += ySections) {</span>
<span class="source-line-no">4197</span><span id="line.4197">                        next[a] &amp;= yEndMask;</span>
<span class="source-line-no">4198</span><span id="line.4198">                    }</span>
<span class="source-line-no">4199</span><span id="line.4199">                } else {</span>
<span class="source-line-no">4200</span><span id="line.4200">                    for (int a = bounds.ySections - 1; a &lt; next.length; a += ySections) {</span>
<span class="source-line-no">4201</span><span id="line.4201">                        next[a] &amp;= bounds.yEndMask;</span>
<span class="source-line-no">4202</span><span id="line.4202">                    }</span>
<span class="source-line-no">4203</span><span id="line.4203">                }</span>
<span class="source-line-no">4204</span><span id="line.4204">            }</span>
<span class="source-line-no">4205</span><span id="line.4205">            data = next;</span>
<span class="source-line-no">4206</span><span id="line.4206">            tallied = false;</span>
<span class="source-line-no">4207</span><span id="line.4207">        }</span>
<span class="source-line-no">4208</span><span id="line.4208"></span>
<span class="source-line-no">4209</span><span id="line.4209">        return result;</span>
<span class="source-line-no">4210</span><span id="line.4210">    }</span>
<span class="source-line-no">4211</span><span id="line.4211">    /**</span>
<span class="source-line-no">4212</span><span id="line.4212">     * Like {@link #expand8way(int)}, but limits expansion to the "on" cells of {@code bounds}. Repeatedly expands in</span>
<span class="source-line-no">4213</span><span id="line.4213">     * all directions by one cell simultaneously, and only successfully affects the cells that are adjacent to the</span>
<span class="source-line-no">4214</span><span id="line.4214">     * previous expansion and are in bounds. This won't skip over gaps in bounds, even if amount is high enough that a</span>
<span class="source-line-no">4215</span><span id="line.4215">     * call to {@link #expand8way(int)} would reach past the gap; it will stop at the gap and only pass it if expansion</span>
<span class="source-line-no">4216</span><span id="line.4216">     * takes it around.</span>
<span class="source-line-no">4217</span><span id="line.4217">     * @param bounds the set of "on" cells that limits where this can expand into</span>
<span class="source-line-no">4218</span><span id="line.4218">     * @param amount how far to expand this outward by, in cells</span>
<span class="source-line-no">4219</span><span id="line.4219">     * @return this, after expanding, for chaining</span>
<span class="source-line-no">4220</span><span id="line.4220">     */</span>
<span class="source-line-no">4221</span><span id="line.4221">    public GreasedRegion flood8way(GreasedRegion bounds, int amount)</span>
<span class="source-line-no">4222</span><span id="line.4222">    {</span>
<span class="source-line-no">4223</span><span id="line.4223">        int ct = size(), ct2;</span>
<span class="source-line-no">4224</span><span id="line.4224">        for (int i = 0; i &lt; amount; i++) {</span>
<span class="source-line-no">4225</span><span id="line.4225">            flood8way(bounds);</span>
<span class="source-line-no">4226</span><span id="line.4226">            if(ct == (ct2 = size()))</span>
<span class="source-line-no">4227</span><span id="line.4227">                break;</span>
<span class="source-line-no">4228</span><span id="line.4228">            else</span>
<span class="source-line-no">4229</span><span id="line.4229">                ct = ct2;</span>
<span class="source-line-no">4230</span><span id="line.4230">        }</span>
<span class="source-line-no">4231</span><span id="line.4231">        return this;</span>
<span class="source-line-no">4232</span><span id="line.4232">    }</span>
<span class="source-line-no">4233</span><span id="line.4233"></span>
<span class="source-line-no">4234</span><span id="line.4234">    /**</span>
<span class="source-line-no">4235</span><span id="line.4235">     * Repeatedly calls {@link #flood8way(GreasedRegion)} {@code amount} times and returns the intermediate steps in a</span>
<span class="source-line-no">4236</span><span id="line.4236">     * GreasedRegion array of size {@code amount}. Doesn't modify this GreasedRegion, and doesn't return it in the array</span>
<span class="source-line-no">4237</span><span id="line.4237">     * (it may return a copy of it if and only if no flood8way() calls can expand the area). If this fills</span>
<span class="source-line-no">4238</span><span id="line.4238">     * {@code bounds} as fully as possible and still has steps left, the remaining steps are all copies of the</span>
<span class="source-line-no">4239</span><span id="line.4239">     * fully-filled area.</span>
<span class="source-line-no">4240</span><span id="line.4240">     * @param bounds the set of "on" cells that this will attempt to fill in steps</span>
<span class="source-line-no">4241</span><span id="line.4241">     * @param amount how many steps to flood outward, and the size of the array to return</span>
<span class="source-line-no">4242</span><span id="line.4242">     * @return an array of GreasedRegion, {@code amount} in size, containing larger and larger expansions of this</span>
<span class="source-line-no">4243</span><span id="line.4243">     */</span>
<span class="source-line-no">4244</span><span id="line.4244">    public GreasedRegion[] floodSeries8way(GreasedRegion bounds, int amount) {</span>
<span class="source-line-no">4245</span><span id="line.4245">        GreasedRegion[] result;</span>
<span class="source-line-no">4246</span><span id="line.4246">        if (amount &lt;= 0) {</span>
<span class="source-line-no">4247</span><span id="line.4247">            result = new GreasedRegion[0];</span>
<span class="source-line-no">4248</span><span id="line.4248">        } else {</span>
<span class="source-line-no">4249</span><span id="line.4249">            int ct = size(), ct2;</span>
<span class="source-line-no">4250</span><span id="line.4250">            GreasedRegion[] regions = new GreasedRegion[amount];</span>
<span class="source-line-no">4251</span><span id="line.4251">            boolean done = false;</span>
<span class="source-line-no">4252</span><span id="line.4252">            GreasedRegion temp = new GreasedRegion(this);</span>
<span class="source-line-no">4253</span><span id="line.4253">            for (int i = 0; i &lt; amount; i++) {</span>
<span class="source-line-no">4254</span><span id="line.4254">                if (done) {</span>
<span class="source-line-no">4255</span><span id="line.4255">                    regions[i] = new GreasedRegion(temp);</span>
<span class="source-line-no">4256</span><span id="line.4256">                } else {</span>
<span class="source-line-no">4257</span><span id="line.4257">                    regions[i] = new GreasedRegion(temp.flood8way(bounds));</span>
<span class="source-line-no">4258</span><span id="line.4258">                    if (ct == (ct2 = temp.size()))</span>
<span class="source-line-no">4259</span><span id="line.4259">                        done = true;</span>
<span class="source-line-no">4260</span><span id="line.4260">                    else</span>
<span class="source-line-no">4261</span><span id="line.4261">                        ct = ct2;</span>
<span class="source-line-no">4262</span><span id="line.4262">                }</span>
<span class="source-line-no">4263</span><span id="line.4263">            }</span>
<span class="source-line-no">4264</span><span id="line.4264">            result = regions;</span>
<span class="source-line-no">4265</span><span id="line.4265">        }</span>
<span class="source-line-no">4266</span><span id="line.4266">        return result;</span>
<span class="source-line-no">4267</span><span id="line.4267">    }</span>
<span class="source-line-no">4268</span><span id="line.4268"></span>
<span class="source-line-no">4269</span><span id="line.4269">    /**</span>
<span class="source-line-no">4270</span><span id="line.4270">     * Repeatedly generates new GreasedRegions, each one cell expanded in 8 directions from the previous GreasedRegion</span>
<span class="source-line-no">4271</span><span id="line.4271">     * and staying inside the "on" cells of {@code bounds}, until it can't expand any more. Returns an ArrayList of the</span>
<span class="source-line-no">4272</span><span id="line.4272">     * GreasedRegion steps this generated; this list does not include this GreasedRegion (or any unmodified copy of this</span>
<span class="source-line-no">4273</span><span id="line.4273">     * GreasedRegion), and this method does not modify it.</span>
<span class="source-line-no">4274</span><span id="line.4274">     * @param bounds the set of "on" cells that this will attempt to fill in steps</span>
<span class="source-line-no">4275</span><span id="line.4275">     * @return an ArrayList of steps from one {@link #flood8way(GreasedRegion)} call to possibly many chained after it</span>
<span class="source-line-no">4276</span><span id="line.4276">     */</span>
<span class="source-line-no">4277</span><span id="line.4277">    public ArrayList&lt;GreasedRegion&gt; floodSeriesToLimit8way(GreasedRegion bounds) {</span>
<span class="source-line-no">4278</span><span id="line.4278">        int ct = size(), ct2;</span>
<span class="source-line-no">4279</span><span id="line.4279">        ArrayList&lt;GreasedRegion&gt; regions = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">4280</span><span id="line.4280">        GreasedRegion temp = new GreasedRegion(this);</span>
<span class="source-line-no">4281</span><span id="line.4281">        while (true) {</span>
<span class="source-line-no">4282</span><span id="line.4282">            temp.flood8way(bounds);</span>
<span class="source-line-no">4283</span><span id="line.4283">            if (ct == (ct2 = temp.size()))</span>
<span class="source-line-no">4284</span><span id="line.4284">                return regions;</span>
<span class="source-line-no">4285</span><span id="line.4285">            else {</span>
<span class="source-line-no">4286</span><span id="line.4286">                ct = ct2;</span>
<span class="source-line-no">4287</span><span id="line.4287">                regions.add(new GreasedRegion(temp));</span>
<span class="source-line-no">4288</span><span id="line.4288">            }</span>
<span class="source-line-no">4289</span><span id="line.4289">        }</span>
<span class="source-line-no">4290</span><span id="line.4290">    }</span>
<span class="source-line-no">4291</span><span id="line.4291"></span>
<span class="source-line-no">4292</span><span id="line.4292">    /**</span>
<span class="source-line-no">4293</span><span id="line.4293">     * A randomized flood-fill that modifies this GreasedRegion so it randomly adds adjacent cells while staying inside</span>
<span class="source-line-no">4294</span><span id="line.4294">     * the "on" cells of {@code bounds}, until {@link #size()} is equal to {@code volume} or there are no more cells</span>
<span class="source-line-no">4295</span><span id="line.4295">     * this can expand into. This GreasedRegion acts as the initial state, and often contains just one cell before this</span>
<span class="source-line-no">4296</span><span id="line.4296">     * is called. This method is useful for imitating the movement of fluids like water or smoke within some boundaries.</span>
<span class="source-line-no">4297</span><span id="line.4297">     * @param bounds this GreasedRegion will only expand to cells that are "on" in bounds; bounds should overlap with this</span>
<span class="source-line-no">4298</span><span id="line.4298">     * @param volume the maximum {@link #size()} this GreasedRegion can reach before this stops expanding</span>
<span class="source-line-no">4299</span><span id="line.4299">     * @param rng a random number generator, like {@link RNG} or {@link GWTRNG}</span>
<span class="source-line-no">4300</span><span id="line.4300">     * @return this, after expanding randomly, for chaining</span>
<span class="source-line-no">4301</span><span id="line.4301">     */</span>
<span class="source-line-no">4302</span><span id="line.4302">    public GreasedRegion spill(GreasedRegion bounds, int volume, IRNG rng) {</span>
<span class="source-line-no">4303</span><span id="line.4303">        GreasedRegion result = this;</span>
<span class="source-line-no">4304</span><span id="line.4304">        if (width &lt; 2 || ySections &lt;= 0 || bounds == null || bounds.width &lt; 2 || bounds.ySections &lt;= 0) {</span>
<span class="source-line-no">4305</span><span id="line.4305">        } else {</span>
<span class="source-line-no">4306</span><span id="line.4306">            int current = size();</span>
<span class="source-line-no">4307</span><span id="line.4307">            if (current &gt;= volume) {</span>
<span class="source-line-no">4308</span><span id="line.4308">            } else {</span>
<span class="source-line-no">4309</span><span id="line.4309">                GreasedRegion t = new GreasedRegion(this).notAnd(bounds);</span>
<span class="source-line-no">4310</span><span id="line.4310">                long[] b2 = new long[t.data.length];</span>
<span class="source-line-no">4311</span><span id="line.4311">                System.arraycopy(t.data, 0, b2, 0, b2.length);</span>
<span class="source-line-no">4312</span><span id="line.4312">                t.remake(this).fringe().and(bounds).tally();</span>
<span class="source-line-no">4313</span><span id="line.4313">                if (t.ct &lt;= 0) {</span>
<span class="source-line-no">4314</span><span id="line.4314">                } else {</span>
<span class="source-line-no">4315</span><span id="line.4315">                    Coord c;</span>
<span class="source-line-no">4316</span><span id="line.4316">                    int x, y, p;</span>
<span class="source-line-no">4317</span><span id="line.4317">                    for (int i = current; i &lt; volume; i++) {</span>
<span class="source-line-no">4318</span><span id="line.4318">                        c = t.singleRandom(rng);</span>
<span class="source-line-no">4319</span><span id="line.4319">                        x = c.x;</span>
<span class="source-line-no">4320</span><span id="line.4320">                        y = c.y;</span>
<span class="source-line-no">4321</span><span id="line.4321">                        if (data[p = x * ySections + (y &gt;&gt; 6)] != (data[p] |= 1L &lt;&lt; (y &amp; 63))) {</span>
<span class="source-line-no">4322</span><span id="line.4322">                            counts[p]++;</span>
<span class="source-line-no">4323</span><span id="line.4323">                            for (int j = p + 1; j &lt; data.length; j++) {</span>
<span class="source-line-no">4324</span><span id="line.4324">                                if (counts[j] &gt; 0) ++counts[j];</span>
<span class="source-line-no">4325</span><span id="line.4325">                            }</span>
<span class="source-line-no">4326</span><span id="line.4326">                            ct++;</span>
<span class="source-line-no">4327</span><span id="line.4327">                            t.data[p] &amp;= ~(1L &lt;&lt; (y &amp; 63));</span>
<span class="source-line-no">4328</span><span id="line.4328">                            if (x &lt; width - 1 &amp;&amp; (b2[p = (x + 1) * ySections + (y &gt;&gt; 6)] &amp; 1L &lt;&lt; (y &amp; 63)) != 0) {</span>
<span class="source-line-no">4329</span><span id="line.4329">                                t.data[p] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">4330</span><span id="line.4330">                            }</span>
<span class="source-line-no">4331</span><span id="line.4331">                            if (y &lt; height - 1 &amp;&amp; (b2[p = x * ySections + (y + 1 &gt;&gt; 6)] &amp; 1L &lt;&lt; (y + 1 &amp; 63)) != 0) {</span>
<span class="source-line-no">4332</span><span id="line.4332">                                t.data[p] |= 1L &lt;&lt; (y + 1 &amp; 63);</span>
<span class="source-line-no">4333</span><span id="line.4333">                            }</span>
<span class="source-line-no">4334</span><span id="line.4334">                            if (y &gt; 0 &amp;&amp; (b2[p = x * ySections + (y - 1 &gt;&gt; 6)] &amp; 1L &lt;&lt; (y - 1 &amp; 63)) != 0) {</span>
<span class="source-line-no">4335</span><span id="line.4335">                                t.data[p] |= 1L &lt;&lt; (y - 1 &amp; 63);</span>
<span class="source-line-no">4336</span><span id="line.4336">                            }</span>
<span class="source-line-no">4337</span><span id="line.4337">                            if (x &gt; 0 &amp;&amp; (b2[p = (x - 1) * ySections + (y &gt;&gt; 6)] &amp; 1L &lt;&lt; (y &amp; 63)) != 0) {</span>
<span class="source-line-no">4338</span><span id="line.4338"></span>
<span class="source-line-no">4339</span><span id="line.4339">                                t.data[p] |= 1L &lt;&lt; (y &amp; 63);</span>
<span class="source-line-no">4340</span><span id="line.4340">                            }</span>
<span class="source-line-no">4341</span><span id="line.4341">                            t.tally();</span>
<span class="source-line-no">4342</span><span id="line.4342">                            if (t.ct &lt;= 0) break;</span>
<span class="source-line-no">4343</span><span id="line.4343">                        }</span>
<span class="source-line-no">4344</span><span id="line.4344">                    }</span>
<span class="source-line-no">4345</span><span id="line.4345">                    tallied = false;</span>
<span class="source-line-no">4346</span><span id="line.4346">                }</span>
<span class="source-line-no">4347</span><span id="line.4347">            }</span>
<span class="source-line-no">4348</span><span id="line.4348">        }</span>
<span class="source-line-no">4349</span><span id="line.4349">        return result;</span>
<span class="source-line-no">4350</span><span id="line.4350">    }</span>
<span class="source-line-no">4351</span><span id="line.4351"></span>
<span class="source-line-no">4352</span><span id="line.4352">    /**</span>
<span class="source-line-no">4353</span><span id="line.4353">     * Where a cell is "on" but forms a right-angle with exactly two orthogonally-adjacent "on" cells and exactly two</span>
<span class="source-line-no">4354</span><span id="line.4354">     * orthogonally-adjacent "off" cells, this turns each of those cells "off." This won't affect east-west lines of</span>
<span class="source-line-no">4355</span><span id="line.4355">     * flat "on" cells, nor north-south lines.</span>
<span class="source-line-no">4356</span><span id="line.4356">     * @return this, after removing right-angle corner "on" cells, for chaining</span>
<span class="source-line-no">4357</span><span id="line.4357">     */</span>
<span class="source-line-no">4358</span><span id="line.4358">    public GreasedRegion removeCorners()</span>
<span class="source-line-no">4359</span><span id="line.4359">    {</span>
<span class="source-line-no">4360</span><span id="line.4360">        if(width &lt;= 2 || ySections &lt;= 0)</span>
<span class="source-line-no">4361</span><span id="line.4361">            return this;</span>
<span class="source-line-no">4362</span><span id="line.4362"></span>
<span class="source-line-no">4363</span><span id="line.4363">        final long[] next = new long[width * ySections];</span>
<span class="source-line-no">4364</span><span id="line.4364">        System.arraycopy(data, 0, next, 0, width * ySections);</span>
<span class="source-line-no">4365</span><span id="line.4365">        for (int a = 0; a &lt; ySections; a++) {</span>
<span class="source-line-no">4366</span><span id="line.4366">            if(a &gt; 0 &amp;&amp; a &lt; ySections - 1) {</span>
<span class="source-line-no">4367</span><span id="line.4367">                next[a] &amp;= (((data[a] &lt;&lt; 1) | ((data[a - 1] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63))</span>
<span class="source-line-no">4368</span><span id="line.4368">                        &amp; ((data[a] &gt;&gt;&gt; 1) | ((data[a + 1] &amp; 1L) &lt;&lt; 63)));</span>
<span class="source-line-no">4369</span><span id="line.4369">                next[(width - 1) * ySections + a] &amp;= (((data[(width - 1) * ySections + a] &lt;&lt; 1)</span>
<span class="source-line-no">4370</span><span id="line.4370">                        | ((data[(width - 1) * ySections + a - 1] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63))</span>
<span class="source-line-no">4371</span><span id="line.4371">                        &amp; ((data[(width - 1) * ySections + a] &gt;&gt;&gt; 1)</span>
<span class="source-line-no">4372</span><span id="line.4372">                        | ((data[(width - 1) * ySections + a + 1] &amp; 1L) &lt;&lt; 63)));</span>
<span class="source-line-no">4373</span><span id="line.4373">                for (int i = ySections+a; i &lt; (width - 1) * ySections; i+= ySections) {</span>
<span class="source-line-no">4374</span><span id="line.4374">                    next[i] &amp;= (((data[i] &lt;&lt; 1) | ((data[i - 1] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63))</span>
<span class="source-line-no">4375</span><span id="line.4375">                            &amp; ((data[i] &gt;&gt;&gt; 1) | ((data[i + 1] &amp; 1L) &lt;&lt; 63)))</span>
<span class="source-line-no">4376</span><span id="line.4376">                            | (data[i - ySections]</span>
<span class="source-line-no">4377</span><span id="line.4377">                            &amp; data[i + ySections]);</span>
<span class="source-line-no">4378</span><span id="line.4378">                }</span>
<span class="source-line-no">4379</span><span id="line.4379">            }</span>
<span class="source-line-no">4380</span><span id="line.4380">            else if(a &gt; 0) {</span>
<span class="source-line-no">4381</span><span id="line.4381">                next[a] &amp;= (((data[a] &lt;&lt; 1) | ((data[a - 1] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63))</span>
<span class="source-line-no">4382</span><span id="line.4382">                        &amp; (data[a] &gt;&gt;&gt; 1));</span>
<span class="source-line-no">4383</span><span id="line.4383">                next[(width - 1) * ySections + a] &amp;= (((data[(width - 1) * ySections + a] &lt;&lt; 1)</span>
<span class="source-line-no">4384</span><span id="line.4384">                        | ((data[(width - 1) * ySections + a - 1] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63))</span>
<span class="source-line-no">4385</span><span id="line.4385">                        &amp; (data[(width - 1) * ySections + a] &gt;&gt;&gt; 1));</span>
<span class="source-line-no">4386</span><span id="line.4386">                for (int i = ySections+a; i &lt; (width - 1) * ySections; i+= ySections) {</span>
<span class="source-line-no">4387</span><span id="line.4387">                    next[i] &amp;= (((data[i] &lt;&lt; 1) | ((data[i - 1] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63))</span>
<span class="source-line-no">4388</span><span id="line.4388">                            &amp; (data[i] &gt;&gt;&gt; 1))</span>
<span class="source-line-no">4389</span><span id="line.4389">                            | (data[i - ySections]</span>
<span class="source-line-no">4390</span><span id="line.4390">                            &amp; data[i + ySections]);</span>
<span class="source-line-no">4391</span><span id="line.4391">                }</span>
<span class="source-line-no">4392</span><span id="line.4392">            }</span>
<span class="source-line-no">4393</span><span id="line.4393">            else if(a &lt; ySections - 1) {</span>
<span class="source-line-no">4394</span><span id="line.4394">                next[a] &amp;= ((data[a] &lt;&lt; 1)</span>
<span class="source-line-no">4395</span><span id="line.4395">                        &amp; ((data[a] &gt;&gt;&gt; 1)</span>
<span class="source-line-no">4396</span><span id="line.4396">                        | ((data[a + 1] &amp; 1L) &lt;&lt; 63)));</span>
<span class="source-line-no">4397</span><span id="line.4397">                next[(width - 1) * ySections + a] &amp;= ((data[(width - 1) * ySections + a] &lt;&lt; 1)</span>
<span class="source-line-no">4398</span><span id="line.4398">                        &amp; ((data[(width - 1) * ySections + a] &gt;&gt;&gt; 1)</span>
<span class="source-line-no">4399</span><span id="line.4399">                        | ((data[(width - 1) * ySections + a + 1] &amp; 1L) &lt;&lt; 63)));</span>
<span class="source-line-no">4400</span><span id="line.4400">                for (int i = ySections+a; i &lt; (width - 1) * ySections; i+= ySections) {</span>
<span class="source-line-no">4401</span><span id="line.4401">                    next[i] &amp;= ((data[i] &lt;&lt; 1)</span>
<span class="source-line-no">4402</span><span id="line.4402">                            &amp; ((data[i] &gt;&gt;&gt; 1) | ((data[i + 1] &amp; 1L) &lt;&lt; 63)))</span>
<span class="source-line-no">4403</span><span id="line.4403">                            | (data[i - ySections]</span>
<span class="source-line-no">4404</span><span id="line.4404">                            &amp; data[i + ySections]);</span>
<span class="source-line-no">4405</span><span id="line.4405">                }</span>
<span class="source-line-no">4406</span><span id="line.4406">            }</span>
<span class="source-line-no">4407</span><span id="line.4407">            else // only the case when ySections == 1</span>
<span class="source-line-no">4408</span><span id="line.4408">            {</span>
<span class="source-line-no">4409</span><span id="line.4409">                next[0] &amp;= (data[0] &lt;&lt; 1) &amp; (data[0] &gt;&gt;&gt; 1);</span>
<span class="source-line-no">4410</span><span id="line.4410">                next[width-1] &amp;= (data[width-1] &lt;&lt; 1) &amp; (data[width-1] &gt;&gt;&gt; 1);</span>
<span class="source-line-no">4411</span><span id="line.4411">                for (int i = 1+a; i &lt; (width - 1); i++) {</span>
<span class="source-line-no">4412</span><span id="line.4412">                    next[i] &amp;= ((data[i] &lt;&lt; 1) &amp; (data[i] &gt;&gt;&gt; 1)) | (data[i - ySections] &amp; data[i + ySections]);</span>
<span class="source-line-no">4413</span><span id="line.4413">                }</span>
<span class="source-line-no">4414</span><span id="line.4414">            }</span>
<span class="source-line-no">4415</span><span id="line.4415">        }</span>
<span class="source-line-no">4416</span><span id="line.4416"></span>
<span class="source-line-no">4417</span><span id="line.4417">        if(yEndMask != -1) {</span>
<span class="source-line-no">4418</span><span id="line.4418">            for (int a = ySections - 1; a &lt; next.length; a += ySections) {</span>
<span class="source-line-no">4419</span><span id="line.4419">                next[a] &amp;= yEndMask;</span>
<span class="source-line-no">4420</span><span id="line.4420">            }</span>
<span class="source-line-no">4421</span><span id="line.4421">        }</span>
<span class="source-line-no">4422</span><span id="line.4422">        data = next;</span>
<span class="source-line-no">4423</span><span id="line.4423">        tallied = false;</span>
<span class="source-line-no">4424</span><span id="line.4424">        return this;</span>
<span class="source-line-no">4425</span><span id="line.4425">    }</span>
<span class="source-line-no">4426</span><span id="line.4426"></span>
<span class="source-line-no">4427</span><span id="line.4427">    /**</span>
<span class="source-line-no">4428</span><span id="line.4428">     * If this GreasedRegion stores multiple unconnected "on" areas, this finds each isolated area (areas that</span>
<span class="source-line-no">4429</span><span id="line.4429">     * are only adjacent diagonally are considered separate from each other) and returns it as an element in an</span>
<span class="source-line-no">4430</span><span id="line.4430">     * ArrayList of GreasedRegion, with one GreasedRegion per isolated area. Not to be confused with</span>
<span class="source-line-no">4431</span><span id="line.4431">     * {@link #split8way()}, which considers diagonally-adjacent cells as part of one region, while this method requires</span>
<span class="source-line-no">4432</span><span id="line.4432">     * cells to be orthogonally adjacent.</span>
<span class="source-line-no">4433</span><span id="line.4433">     * &lt;br&gt;</span>
<span class="source-line-no">4434</span><span id="line.4434">     * Useful when you have, for example, all the rooms in a dungeon with their connecting corridors removed, but want</span>
<span class="source-line-no">4435</span><span id="line.4435">     * to separate the rooms. You can get the aforementioned data assuming a bare dungeon called map using:</span>
<span class="source-line-no">4436</span><span id="line.4436">     * &lt;br&gt;</span>
<span class="source-line-no">4437</span><span id="line.4437">     * {@code GreasedRegion floors = new GreasedRegion(map, '.'),</span>
<span class="source-line-no">4438</span><span id="line.4438">     * rooms = floors.copy().retract8way().flood(floors, 2),</span>
<span class="source-line-no">4439</span><span id="line.4439">     * corridors = floors.copy().andNot(rooms),</span>
<span class="source-line-no">4440</span><span id="line.4440">     * doors = rooms.copy().and(corridors.copy().fringe());}</span>
<span class="source-line-no">4441</span><span id="line.4441">     * &lt;br&gt;</span>
<span class="source-line-no">4442</span><span id="line.4442">     * You can then get all rooms as separate regions with {@code List&lt;GreasedRegion&gt; apart = split(rooms);}, or</span>
<span class="source-line-no">4443</span><span id="line.4443">     * substitute {@code split(corridors)} to get the corridors. The room-finding technique works by shrinking floors</span>
<span class="source-line-no">4444</span><span id="line.4444">     * by a radius of 1 (8-way), which causes thin areas like corridors of 2 or less width to be removed, then</span>
<span class="source-line-no">4445</span><span id="line.4445">     * flood-filling the floors out from the area that produces by 2 cells (4-way this time) to restore the original</span>
<span class="source-line-no">4446</span><span id="line.4446">     * size of non-corridor areas (plus some extra to ensure odd shapes are kept). Corridors are obtained by removing</span>
<span class="source-line-no">4447</span><span id="line.4447">     * the rooms from floors. The example code also gets the doors (which overlap with rooms, not corridors) by finding</span>
<span class="source-line-no">4448</span><span id="line.4448">     * where the a room and a corridor are adjacent. This technique is used with some enhancements in the RoomFinder</span>
<span class="source-line-no">4449</span><span id="line.4449">     * class.</span>
<span class="source-line-no">4450</span><span id="line.4450">     * @see squidpony.squidgrid.mapping.RoomFinder for a class that uses this technique without exposing GreasedRegion</span>
<span class="source-line-no">4451</span><span id="line.4451">     * @return an ArrayList containing each unconnected area from packed as a GreasedRegion element</span>
<span class="source-line-no">4452</span><span id="line.4452">     */</span>
<span class="source-line-no">4453</span><span id="line.4453">    public ArrayList&lt;GreasedRegion&gt; split()</span>
<span class="source-line-no">4454</span><span id="line.4454">    {</span>
<span class="source-line-no">4455</span><span id="line.4455">        ArrayList&lt;GreasedRegion&gt; scattered = new ArrayList&lt;&gt;(32);</span>
<span class="source-line-no">4456</span><span id="line.4456">        int fst = firstTight();</span>
<span class="source-line-no">4457</span><span id="line.4457">        GreasedRegion remaining = new GreasedRegion(this);</span>
<span class="source-line-no">4458</span><span id="line.4458">        while (fst &gt;= 0) {</span>
<span class="source-line-no">4459</span><span id="line.4459">            GreasedRegion filled = new GreasedRegion(width, height).insert(fst).flood(remaining, width * height);</span>
<span class="source-line-no">4460</span><span id="line.4460">            scattered.add(filled);</span>
<span class="source-line-no">4461</span><span id="line.4461">            remaining.andNot(filled);</span>
<span class="source-line-no">4462</span><span id="line.4462">            fst = remaining.firstTight();</span>
<span class="source-line-no">4463</span><span id="line.4463">        }</span>
<span class="source-line-no">4464</span><span id="line.4464">        return scattered;</span>
<span class="source-line-no">4465</span><span id="line.4465">    }</span>
<span class="source-line-no">4466</span><span id="line.4466">    /**</span>
<span class="source-line-no">4467</span><span id="line.4467">     * If this GreasedRegion stores multiple unconnected "on" areas, this finds each isolated area (areas that</span>
<span class="source-line-no">4468</span><span id="line.4468">     * are only adjacent diagonally are considered &lt;b&gt;one area&lt;/b&gt; with this) and returns it as an element in an</span>
<span class="source-line-no">4469</span><span id="line.4469">     * ArrayList of GreasedRegion, with one GreasedRegion per isolated area. This should not be confused with</span>
<span class="source-line-no">4470</span><span id="line.4470">     * {@link #split()}, which is almost identical except that split() considers only orthogonal connections, while this</span>
<span class="source-line-no">4471</span><span id="line.4471">     * method considers both orthogonal and diagonal connections between cells as joining an area.</span>
<span class="source-line-no">4472</span><span id="line.4472">     * &lt;br&gt;</span>
<span class="source-line-no">4473</span><span id="line.4473">     * Useful when you have, for example, all the rooms in a dungeon with their connecting corridors removed, but want</span>
<span class="source-line-no">4474</span><span id="line.4474">     * to separate the rooms. You can get the aforementioned data assuming a bare dungeon called map using:</span>
<span class="source-line-no">4475</span><span id="line.4475">     * &lt;br&gt;</span>
<span class="source-line-no">4476</span><span id="line.4476">     * {@code GreasedRegion floors = new GreasedRegion(map, '.'),</span>
<span class="source-line-no">4477</span><span id="line.4477">     * rooms = floors.copy().retract8way().flood(floors, 2),</span>
<span class="source-line-no">4478</span><span id="line.4478">     * corridors = floors.copy().andNot(rooms),</span>
<span class="source-line-no">4479</span><span id="line.4479">     * doors = rooms.copy().and(corridors.copy().fringe());}</span>
<span class="source-line-no">4480</span><span id="line.4480">     * &lt;br&gt;</span>
<span class="source-line-no">4481</span><span id="line.4481">     * You can then get all rooms as separate regions with {@code List&lt;GreasedRegion&gt; apart = split(rooms);}, or</span>
<span class="source-line-no">4482</span><span id="line.4482">     * substitute {@code split(corridors)} to get the corridors. The room-finding technique works by shrinking floors</span>
<span class="source-line-no">4483</span><span id="line.4483">     * by a radius of 1 (8-way), which causes thin areas like corridors of 2 or less width to be removed, then</span>
<span class="source-line-no">4484</span><span id="line.4484">     * flood-filling the floors out from the area that produces by 2 cells (4-way this time) to restore the original</span>
<span class="source-line-no">4485</span><span id="line.4485">     * size of non-corridor areas (plus some extra to ensure odd shapes are kept). Corridors are obtained by removing</span>
<span class="source-line-no">4486</span><span id="line.4486">     * the rooms from floors. The example code also gets the doors (which overlap with rooms, not corridors) by finding</span>
<span class="source-line-no">4487</span><span id="line.4487">     * where the a room and a corridor are adjacent. This technique is used with some enhancements in the RoomFinder</span>
<span class="source-line-no">4488</span><span id="line.4488">     * class.</span>
<span class="source-line-no">4489</span><span id="line.4489">     * @see squidpony.squidgrid.mapping.RoomFinder for a class that uses this technique without exposing GreasedRegion</span>
<span class="source-line-no">4490</span><span id="line.4490">     * @return an ArrayList containing each unconnected area from packed as a GreasedRegion element</span>
<span class="source-line-no">4491</span><span id="line.4491">     */</span>
<span class="source-line-no">4492</span><span id="line.4492">    public ArrayList&lt;GreasedRegion&gt; split8way()</span>
<span class="source-line-no">4493</span><span id="line.4493">    {</span>
<span class="source-line-no">4494</span><span id="line.4494">        ArrayList&lt;GreasedRegion&gt; scattered = new ArrayList&lt;&gt;(32);</span>
<span class="source-line-no">4495</span><span id="line.4495">        int fst = firstTight();</span>
<span class="source-line-no">4496</span><span id="line.4496">        GreasedRegion remaining = new GreasedRegion(this);</span>
<span class="source-line-no">4497</span><span id="line.4497">        while (fst &gt;= 0) {</span>
<span class="source-line-no">4498</span><span id="line.4498">            GreasedRegion filled = new GreasedRegion(width, height).insert(fst).flood8way(remaining, width * height);</span>
<span class="source-line-no">4499</span><span id="line.4499">            scattered.add(filled);</span>
<span class="source-line-no">4500</span><span id="line.4500">            remaining.andNot(filled);</span>
<span class="source-line-no">4501</span><span id="line.4501">            fst = remaining.firstTight();</span>
<span class="source-line-no">4502</span><span id="line.4502">        }</span>
<span class="source-line-no">4503</span><span id="line.4503">        return scattered;</span>
<span class="source-line-no">4504</span><span id="line.4504">    }</span>
<span class="source-line-no">4505</span><span id="line.4505"></span>
<span class="source-line-no">4506</span><span id="line.4506">    /**</span>
<span class="source-line-no">4507</span><span id="line.4507">     * Finds the largest contiguous area of "on" cells in this GreasedRegion and returns it; does not modify this</span>
<span class="source-line-no">4508</span><span id="line.4508">     * GreasedRegion. If there are multiple areas that are all equally large with no larger area, this returns the</span>
<span class="source-line-no">4509</span><span id="line.4509">     * region it checks first and still is largest (first determined by the same ordering {@link #nth(int)} takes).</span>
<span class="source-line-no">4510</span><span id="line.4510">     * This may return an empty GreasedRegion if there are no "on" cells, but it will never return null.</span>
<span class="source-line-no">4511</span><span id="line.4511">     * Here, contiguous means adjacent on an orthogonal direction, and this doesn't consider diagonally-connected cells</span>
<span class="source-line-no">4512</span><span id="line.4512">     * as contiguous unless they also have an orthogonal connection.</span>
<span class="source-line-no">4513</span><span id="line.4513">     * @return a new GreasedRegion that corresponds to the largest contiguous sub-region of "on" cells in this.</span>
<span class="source-line-no">4514</span><span id="line.4514">     */</span>
<span class="source-line-no">4515</span><span id="line.4515">    public GreasedRegion largestPart()</span>
<span class="source-line-no">4516</span><span id="line.4516">    {</span>
<span class="source-line-no">4517</span><span id="line.4517">        int fst = firstTight(), bestSize = 0, currentSize;</span>
<span class="source-line-no">4518</span><span id="line.4518">        GreasedRegion remaining = new GreasedRegion(this), filled = new GreasedRegion(width, height),</span>
<span class="source-line-no">4519</span><span id="line.4519">                choice = new GreasedRegion(width, height);</span>
<span class="source-line-no">4520</span><span id="line.4520">        while (fst &gt;= 0) {</span>
<span class="source-line-no">4521</span><span id="line.4521">            filled.empty().insert(fst).flood(remaining, width * height);</span>
<span class="source-line-no">4522</span><span id="line.4522">            if((currentSize = filled.size()) &gt; bestSize)</span>
<span class="source-line-no">4523</span><span id="line.4523">            {</span>
<span class="source-line-no">4524</span><span id="line.4524">                bestSize = currentSize;</span>
<span class="source-line-no">4525</span><span id="line.4525">                choice.remake(filled);</span>
<span class="source-line-no">4526</span><span id="line.4526">            }</span>
<span class="source-line-no">4527</span><span id="line.4527">            remaining.andNot(filled);</span>
<span class="source-line-no">4528</span><span id="line.4528">            fst = remaining.firstTight();</span>
<span class="source-line-no">4529</span><span id="line.4529">        }</span>
<span class="source-line-no">4530</span><span id="line.4530">        return choice;</span>
<span class="source-line-no">4531</span><span id="line.4531">    }</span>
<span class="source-line-no">4532</span><span id="line.4532"></span>
<span class="source-line-no">4533</span><span id="line.4533">    /**</span>
<span class="source-line-no">4534</span><span id="line.4534">     * Finds the largest contiguous area of "on" cells in this GreasedRegion and returns it; does not modify this</span>
<span class="source-line-no">4535</span><span id="line.4535">     * GreasedRegion. If there are multiple areas that are all equally large with no larger area, this returns the</span>
<span class="source-line-no">4536</span><span id="line.4536">     * region it checks first and still is largest (first determined by the same ordering {@link #nth(int)} takes).</span>
<span class="source-line-no">4537</span><span id="line.4537">     * This may return an empty GreasedRegion if there are no "on" cells, but it will never return null.</span>
<span class="source-line-no">4538</span><span id="line.4538">     * Here, contiguous means adjacent on any 8-way direction, and considers cells as part of a contiguous area even if</span>
<span class="source-line-no">4539</span><span id="line.4539">     * all connections but one, which can be orthogonal or diagonal, are blocked by "off" cells.</span>
<span class="source-line-no">4540</span><span id="line.4540">     * @return a new GreasedRegion that corresponds to the largest contiguous sub-region of "on" cells in this.</span>
<span class="source-line-no">4541</span><span id="line.4541">     */</span>
<span class="source-line-no">4542</span><span id="line.4542">    public GreasedRegion largestPart8way()</span>
<span class="source-line-no">4543</span><span id="line.4543">    {</span>
<span class="source-line-no">4544</span><span id="line.4544">        int fst = firstTight(), bestSize = 0, currentSize;</span>
<span class="source-line-no">4545</span><span id="line.4545">        GreasedRegion remaining = new GreasedRegion(this), filled = new GreasedRegion(width, height),</span>
<span class="source-line-no">4546</span><span id="line.4546">                choice = new GreasedRegion(width, height);</span>
<span class="source-line-no">4547</span><span id="line.4547">        while (fst &gt;= 0) {</span>
<span class="source-line-no">4548</span><span id="line.4548">            filled.empty().insert(fst).flood8way(remaining, width * height);</span>
<span class="source-line-no">4549</span><span id="line.4549">            if((currentSize = filled.size()) &gt; bestSize)</span>
<span class="source-line-no">4550</span><span id="line.4550">            {</span>
<span class="source-line-no">4551</span><span id="line.4551">                bestSize = currentSize;</span>
<span class="source-line-no">4552</span><span id="line.4552">                choice.remake(filled);</span>
<span class="source-line-no">4553</span><span id="line.4553">            }</span>
<span class="source-line-no">4554</span><span id="line.4554">            remaining.andNot(filled);</span>
<span class="source-line-no">4555</span><span id="line.4555">            fst = remaining.firstTight();</span>
<span class="source-line-no">4556</span><span id="line.4556">        }</span>
<span class="source-line-no">4557</span><span id="line.4557">        return choice;</span>
<span class="source-line-no">4558</span><span id="line.4558">    }</span>
<span class="source-line-no">4559</span><span id="line.4559"></span>
<span class="source-line-no">4560</span><span id="line.4560">    /**</span>
<span class="source-line-no">4561</span><span id="line.4561">     * Modifies this GreasedRegion so the only cells that will be "on" have a neighbor upwards when this is called.</span>
<span class="source-line-no">4562</span><span id="line.4562">     * Up is defined as negative y. Neighbors are "on" cells exactly one cell away. A cell can have a neighbor</span>
<span class="source-line-no">4563</span><span id="line.4563">     * without itself being on; this is useful when finding the "shadow" cast away from "on" cells in one direction.</span>
<span class="source-line-no">4564</span><span id="line.4564">     * @return this, after modifications, for chaining</span>
<span class="source-line-no">4565</span><span id="line.4565">     */</span>
<span class="source-line-no">4566</span><span id="line.4566">    public GreasedRegion neighborUp() {</span>
<span class="source-line-no">4567</span><span id="line.4567">        GreasedRegion result = this;</span>
<span class="source-line-no">4568</span><span id="line.4568">        if (width &lt; 2 || ySections &lt;= 0) {</span>
<span class="source-line-no">4569</span><span id="line.4569">        } else {</span>
<span class="source-line-no">4570</span><span id="line.4570">            for (int a = ySections - 1; a &gt;= 0; a--) {</span>
<span class="source-line-no">4571</span><span id="line.4571">                if (a &gt; 0) {</span>
<span class="source-line-no">4572</span><span id="line.4572">                    for (int i = a; i &lt; width * ySections; i += ySections) {</span>
<span class="source-line-no">4573</span><span id="line.4573">                        data[i] = (data[i] &lt;&lt; 1) | ((data[i - 1] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63);</span>
<span class="source-line-no">4574</span><span id="line.4574">                    }</span>
<span class="source-line-no">4575</span><span id="line.4575">                } else {</span>
<span class="source-line-no">4576</span><span id="line.4576">                    for (int i = a; i &lt; width * ySections; i += ySections) {</span>
<span class="source-line-no">4577</span><span id="line.4577">                        data[i] = (data[i] &lt;&lt; 1);</span>
<span class="source-line-no">4578</span><span id="line.4578">                    }</span>
<span class="source-line-no">4579</span><span id="line.4579">                }</span>
<span class="source-line-no">4580</span><span id="line.4580">            }</span>
<span class="source-line-no">4581</span><span id="line.4581">            tallied = false;</span>
<span class="source-line-no">4582</span><span id="line.4582">        }</span>
<span class="source-line-no">4583</span><span id="line.4583">        return result;</span>
<span class="source-line-no">4584</span><span id="line.4584">    }</span>
<span class="source-line-no">4585</span><span id="line.4585"></span>
<span class="source-line-no">4586</span><span id="line.4586">    /**</span>
<span class="source-line-no">4587</span><span id="line.4587">     * Modifies this GreasedRegion so the only cells that will be "on" have a neighbor downwards when this is called.</span>
<span class="source-line-no">4588</span><span id="line.4588">     * Down is defined as positive y. Neighbors are "on" cells exactly one cell away. A cell can have a neighbor</span>
<span class="source-line-no">4589</span><span id="line.4589">     * without itself being on; this is useful when finding the "shadow" cast away from "on" cells in one direction.</span>
<span class="source-line-no">4590</span><span id="line.4590">     * @return this, after modifications, for chaining</span>
<span class="source-line-no">4591</span><span id="line.4591">     */</span>
<span class="source-line-no">4592</span><span id="line.4592">    public GreasedRegion neighborDown() {</span>
<span class="source-line-no">4593</span><span id="line.4593">        GreasedRegion result = this;</span>
<span class="source-line-no">4594</span><span id="line.4594">        if (width &lt; 2 || ySections &lt;= 0) {</span>
<span class="source-line-no">4595</span><span id="line.4595">        } else {</span>
<span class="source-line-no">4596</span><span id="line.4596">            for (int a = 0; a &lt; ySections; a++) {</span>
<span class="source-line-no">4597</span><span id="line.4597">                if (a &lt; ySections - 1) {</span>
<span class="source-line-no">4598</span><span id="line.4598">                    for (int i = a; i &lt; width * ySections; i += ySections) {</span>
<span class="source-line-no">4599</span><span id="line.4599">                        data[i] = (data[i] &gt;&gt;&gt; 1) | ((data[i + 1] &amp; 1L) &lt;&lt; 63);</span>
<span class="source-line-no">4600</span><span id="line.4600">                    }</span>
<span class="source-line-no">4601</span><span id="line.4601">                } else {</span>
<span class="source-line-no">4602</span><span id="line.4602">                    for (int i = a; i &lt; width * ySections; i += ySections) {</span>
<span class="source-line-no">4603</span><span id="line.4603">                        data[i] = (data[i] &gt;&gt;&gt; 1);</span>
<span class="source-line-no">4604</span><span id="line.4604">                    }</span>
<span class="source-line-no">4605</span><span id="line.4605">                }</span>
<span class="source-line-no">4606</span><span id="line.4606">            }</span>
<span class="source-line-no">4607</span><span id="line.4607">            tallied = false;</span>
<span class="source-line-no">4608</span><span id="line.4608">        }</span>
<span class="source-line-no">4609</span><span id="line.4609">        return result;</span>
<span class="source-line-no">4610</span><span id="line.4610">    }</span>
<span class="source-line-no">4611</span><span id="line.4611"></span>
<span class="source-line-no">4612</span><span id="line.4612">    /**</span>
<span class="source-line-no">4613</span><span id="line.4613">     * Modifies this GreasedRegion so the only cells that will be "on" have a neighbor to the left when this is called.</span>
<span class="source-line-no">4614</span><span id="line.4614">     * Left is defined as negative x. Neighbors are "on" cells exactly one cell away. A cell can have a neighbor</span>
<span class="source-line-no">4615</span><span id="line.4615">     * without itself being on; this is useful when finding the "shadow" cast away from "on" cells in one direction.</span>
<span class="source-line-no">4616</span><span id="line.4616">     * @return this, after modifications, for chaining</span>
<span class="source-line-no">4617</span><span id="line.4617">     */</span>
<span class="source-line-no">4618</span><span id="line.4618">    public GreasedRegion neighborLeft() {</span>
<span class="source-line-no">4619</span><span id="line.4619">        GreasedRegion result = this;</span>
<span class="source-line-no">4620</span><span id="line.4620">        if (width &lt; 2 || ySections &lt;= 0) {</span>
<span class="source-line-no">4621</span><span id="line.4621">        } else {</span>
<span class="source-line-no">4622</span><span id="line.4622">            for (int a = 0; a &lt; ySections; a++) {</span>
<span class="source-line-no">4623</span><span id="line.4623">                for (int i = ySections * (width - 1) + a; i &gt;= ySections; i -= ySections) {</span>
<span class="source-line-no">4624</span><span id="line.4624">                    data[i] = data[i - ySections];</span>
<span class="source-line-no">4625</span><span id="line.4625">                }</span>
<span class="source-line-no">4626</span><span id="line.4626">                data[a] = 0L;</span>
<span class="source-line-no">4627</span><span id="line.4627">            }</span>
<span class="source-line-no">4628</span><span id="line.4628">            tallied = false;</span>
<span class="source-line-no">4629</span><span id="line.4629">        }</span>
<span class="source-line-no">4630</span><span id="line.4630">        return result;</span>
<span class="source-line-no">4631</span><span id="line.4631">    }</span>
<span class="source-line-no">4632</span><span id="line.4632"></span>
<span class="source-line-no">4633</span><span id="line.4633">    /**</span>
<span class="source-line-no">4634</span><span id="line.4634">     * Modifies this GreasedRegion so the only cells that will be "on" have a neighbor to the right when this is called.</span>
<span class="source-line-no">4635</span><span id="line.4635">     * Right is defined as positive x. Neighbors are "on" cells exactly one cell away. A cell can have a neighbor</span>
<span class="source-line-no">4636</span><span id="line.4636">     * without itself being on; this is useful when finding the "shadow" cast away from "on" cells in one direction.</span>
<span class="source-line-no">4637</span><span id="line.4637">     * @return this, after modifications, for chaining</span>
<span class="source-line-no">4638</span><span id="line.4638">     */</span>
<span class="source-line-no">4639</span><span id="line.4639">    public GreasedRegion neighborRight() {</span>
<span class="source-line-no">4640</span><span id="line.4640">        GreasedRegion result = this;</span>
<span class="source-line-no">4641</span><span id="line.4641">        if (width &lt; 2 || ySections &lt;= 0) {</span>
<span class="source-line-no">4642</span><span id="line.4642">        } else {</span>
<span class="source-line-no">4643</span><span id="line.4643">            for (int a = 0; a &lt; ySections; a++) {</span>
<span class="source-line-no">4644</span><span id="line.4644">                for (int i = a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">4645</span><span id="line.4645">                    data[i] = data[i + ySections];</span>
<span class="source-line-no">4646</span><span id="line.4646">                }</span>
<span class="source-line-no">4647</span><span id="line.4647">                data[(width - 1) * ySections + a] = 0L;</span>
<span class="source-line-no">4648</span><span id="line.4648">            }</span>
<span class="source-line-no">4649</span><span id="line.4649">            tallied = false;</span>
<span class="source-line-no">4650</span><span id="line.4650">        }</span>
<span class="source-line-no">4651</span><span id="line.4651">        return result;</span>
<span class="source-line-no">4652</span><span id="line.4652">    }</span>
<span class="source-line-no">4653</span><span id="line.4653"></span>
<span class="source-line-no">4654</span><span id="line.4654">    /**</span>
<span class="source-line-no">4655</span><span id="line.4655">     * Modifies this GreasedRegion so the only cells that will be "on" have a neighbor upwards and to the left when this</span>
<span class="source-line-no">4656</span><span id="line.4656">     * is called. Up is defined as negative y, left as negative x. Neighbors are "on" cells exactly one cell away. A</span>
<span class="source-line-no">4657</span><span id="line.4657">     * cell can have a neighbor without itself being on; this is useful when finding the "shadow" cast away from "on"</span>
<span class="source-line-no">4658</span><span id="line.4658">     * cells in one direction.</span>
<span class="source-line-no">4659</span><span id="line.4659">     * @return this, after modifications, for chaining</span>
<span class="source-line-no">4660</span><span id="line.4660">     */</span>
<span class="source-line-no">4661</span><span id="line.4661">    public GreasedRegion neighborUpLeft() {</span>
<span class="source-line-no">4662</span><span id="line.4662">        GreasedRegion result = this;</span>
<span class="source-line-no">4663</span><span id="line.4663">        if (width &lt; 2 || ySections &lt;= 0) {</span>
<span class="source-line-no">4664</span><span id="line.4664">        } else {</span>
<span class="source-line-no">4665</span><span id="line.4665">            for (int a = ySections - 1; a &gt;= 0; a--) {</span>
<span class="source-line-no">4666</span><span id="line.4666">                if (a &gt; 0) {</span>
<span class="source-line-no">4667</span><span id="line.4667">                    for (int i = ySections * (width - 1) + a; i &gt;= ySections; i -= ySections) {</span>
<span class="source-line-no">4668</span><span id="line.4668">                        data[i] = (data[i - ySections] &lt;&lt; 1) | ((data[i - ySections - 1] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63);</span>
<span class="source-line-no">4669</span><span id="line.4669">                    }</span>
<span class="source-line-no">4670</span><span id="line.4670">                    data[a] = 0L;</span>
<span class="source-line-no">4671</span><span id="line.4671">                } else {</span>
<span class="source-line-no">4672</span><span id="line.4672">                    for (int i = ySections * (width - 1) + a; i &gt;= ySections; i -= ySections) {</span>
<span class="source-line-no">4673</span><span id="line.4673">                        data[i] = (data[i - ySections] &lt;&lt; 1);</span>
<span class="source-line-no">4674</span><span id="line.4674">                    }</span>
<span class="source-line-no">4675</span><span id="line.4675">                    data[a] = 0L;</span>
<span class="source-line-no">4676</span><span id="line.4676">                }</span>
<span class="source-line-no">4677</span><span id="line.4677">            }</span>
<span class="source-line-no">4678</span><span id="line.4678">        }</span>
<span class="source-line-no">4679</span><span id="line.4679">        return result;</span>
<span class="source-line-no">4680</span><span id="line.4680">    }</span>
<span class="source-line-no">4681</span><span id="line.4681"></span>
<span class="source-line-no">4682</span><span id="line.4682">    /**</span>
<span class="source-line-no">4683</span><span id="line.4683">     * Modifies this GreasedRegion so the only cells that will be "on" have a neighbor upwards and to the right when</span>
<span class="source-line-no">4684</span><span id="line.4684">     * this is called. Up is defined as negative y, right as positive x. Neighbors are "on" cells exactly one cell away.</span>
<span class="source-line-no">4685</span><span id="line.4685">     * A cell can have a neighbor without itself being on; this is useful when finding the "shadow" cast away from</span>
<span class="source-line-no">4686</span><span id="line.4686">     * "on" cells in one direction.</span>
<span class="source-line-no">4687</span><span id="line.4687">     * @return this, after modifications, for chaining</span>
<span class="source-line-no">4688</span><span id="line.4688">     */</span>
<span class="source-line-no">4689</span><span id="line.4689">    public GreasedRegion neighborUpRight() {</span>
<span class="source-line-no">4690</span><span id="line.4690">        GreasedRegion result = this;</span>
<span class="source-line-no">4691</span><span id="line.4691">        if (width &lt; 2 || ySections &lt;= 0) {</span>
<span class="source-line-no">4692</span><span id="line.4692">        } else {</span>
<span class="source-line-no">4693</span><span id="line.4693">            for (int a = ySections - 1; a &gt;= 0; a--) {</span>
<span class="source-line-no">4694</span><span id="line.4694">                if (a &gt; 0) {</span>
<span class="source-line-no">4695</span><span id="line.4695">                    for (int i = a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">4696</span><span id="line.4696">                        data[i] = (data[i + ySections] &lt;&lt; 1) | ((data[i + ySections - 1] &amp; 0x8000000000000000L) &gt;&gt;&gt; 63);</span>
<span class="source-line-no">4697</span><span id="line.4697">                    }</span>
<span class="source-line-no">4698</span><span id="line.4698">                    data[(width - 1) * ySections + a] = 0L;</span>
<span class="source-line-no">4699</span><span id="line.4699">                } else {</span>
<span class="source-line-no">4700</span><span id="line.4700">                    for (int i = a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">4701</span><span id="line.4701">                        data[i] = (data[i + ySections] &lt;&lt; 1);</span>
<span class="source-line-no">4702</span><span id="line.4702">                    }</span>
<span class="source-line-no">4703</span><span id="line.4703">                    data[(width - 1) * ySections + a] = 0L;</span>
<span class="source-line-no">4704</span><span id="line.4704">                }</span>
<span class="source-line-no">4705</span><span id="line.4705">            }</span>
<span class="source-line-no">4706</span><span id="line.4706">            tallied = false;</span>
<span class="source-line-no">4707</span><span id="line.4707">        }</span>
<span class="source-line-no">4708</span><span id="line.4708">        return result;</span>
<span class="source-line-no">4709</span><span id="line.4709">    }</span>
<span class="source-line-no">4710</span><span id="line.4710"></span>
<span class="source-line-no">4711</span><span id="line.4711">    /**</span>
<span class="source-line-no">4712</span><span id="line.4712">     * Modifies this GreasedRegion so the only cells that will be "on" have a neighbor downwards and to the left when</span>
<span class="source-line-no">4713</span><span id="line.4713">     * this is called. Down is defined as positive y, left as negative x. Neighbors are "on" cells exactly one cell</span>
<span class="source-line-no">4714</span><span id="line.4714">     * away. A cell can have a neighbor without itself being on; this is useful when finding the "shadow" cast away from</span>
<span class="source-line-no">4715</span><span id="line.4715">     * "on" cells in one direction.</span>
<span class="source-line-no">4716</span><span id="line.4716">     * @return this, after modifications, for chaining</span>
<span class="source-line-no">4717</span><span id="line.4717">     */</span>
<span class="source-line-no">4718</span><span id="line.4718">    public GreasedRegion neighborDownLeft() {</span>
<span class="source-line-no">4719</span><span id="line.4719">        GreasedRegion result = this;</span>
<span class="source-line-no">4720</span><span id="line.4720">        if (width &lt; 2 || ySections &lt;= 0) {</span>
<span class="source-line-no">4721</span><span id="line.4721">        } else {</span>
<span class="source-line-no">4722</span><span id="line.4722">            for (int a = 0; a &lt; ySections; a++) {</span>
<span class="source-line-no">4723</span><span id="line.4723">                if (a &lt; ySections - 1) {</span>
<span class="source-line-no">4724</span><span id="line.4724">                    for (int i = ySections * (width - 1) + a; i &gt;= ySections; i -= ySections) {</span>
<span class="source-line-no">4725</span><span id="line.4725">                        data[i] = (data[i - ySections] &gt;&gt;&gt; 1) | ((data[i - ySections + 1] &amp; 1L) &lt;&lt; 63);</span>
<span class="source-line-no">4726</span><span id="line.4726">                    }</span>
<span class="source-line-no">4727</span><span id="line.4727">                    data[a] = 0L;</span>
<span class="source-line-no">4728</span><span id="line.4728">                } else {</span>
<span class="source-line-no">4729</span><span id="line.4729">                    for (int i = ySections * (width - 1) + a; i &gt;= ySections; i -= ySections) {</span>
<span class="source-line-no">4730</span><span id="line.4730">                        data[i] = (data[i - ySections] &gt;&gt;&gt; 1);</span>
<span class="source-line-no">4731</span><span id="line.4731">                    }</span>
<span class="source-line-no">4732</span><span id="line.4732">                    data[a] = 0L;</span>
<span class="source-line-no">4733</span><span id="line.4733">                }</span>
<span class="source-line-no">4734</span><span id="line.4734">            }</span>
<span class="source-line-no">4735</span><span id="line.4735">            tallied = false;</span>
<span class="source-line-no">4736</span><span id="line.4736">        }</span>
<span class="source-line-no">4737</span><span id="line.4737">        return result;</span>
<span class="source-line-no">4738</span><span id="line.4738">    }</span>
<span class="source-line-no">4739</span><span id="line.4739"></span>
<span class="source-line-no">4740</span><span id="line.4740">    /**</span>
<span class="source-line-no">4741</span><span id="line.4741">     * Modifies this GreasedRegion so the only cells that will be "on" have a neighbor downwards and to the right when</span>
<span class="source-line-no">4742</span><span id="line.4742">     * this is called. Down is defined as positive y, right as positive x. Neighbors are "on" cells exactly one cell</span>
<span class="source-line-no">4743</span><span id="line.4743">     * away. A cell can have a neighbor without itself being on; this is useful when finding the "shadow" cast away from</span>
<span class="source-line-no">4744</span><span id="line.4744">     * "on" cells in one direction.</span>
<span class="source-line-no">4745</span><span id="line.4745">     * @return this, after modifications, for chaining</span>
<span class="source-line-no">4746</span><span id="line.4746">     */</span>
<span class="source-line-no">4747</span><span id="line.4747">    public GreasedRegion neighborDownRight() {</span>
<span class="source-line-no">4748</span><span id="line.4748">        GreasedRegion result = this;</span>
<span class="source-line-no">4749</span><span id="line.4749">        if (width &lt; 2 || ySections &lt;= 0) {</span>
<span class="source-line-no">4750</span><span id="line.4750">        } else {</span>
<span class="source-line-no">4751</span><span id="line.4751">            for (int a = 0; a &lt; ySections; a++) {</span>
<span class="source-line-no">4752</span><span id="line.4752">                if (a &lt; ySections - 1) {</span>
<span class="source-line-no">4753</span><span id="line.4753">                    for (int i = a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">4754</span><span id="line.4754">                        data[i] = (data[i + ySections] &gt;&gt;&gt; 1) | ((data[i + ySections + 1] &amp; 1L) &lt;&lt; 63);</span>
<span class="source-line-no">4755</span><span id="line.4755">                    }</span>
<span class="source-line-no">4756</span><span id="line.4756">                    data[(width - 1) * ySections + a] = 0L;</span>
<span class="source-line-no">4757</span><span id="line.4757">                } else {</span>
<span class="source-line-no">4758</span><span id="line.4758">                    for (int i = a; i &lt; (width - 1) * ySections; i += ySections) {</span>
<span class="source-line-no">4759</span><span id="line.4759">                        data[i] = (data[i + ySections] &gt;&gt;&gt; 1);</span>
<span class="source-line-no">4760</span><span id="line.4760">                    }</span>
<span class="source-line-no">4761</span><span id="line.4761">                    data[(width - 1) * ySections + a] = 0L;</span>
<span class="source-line-no">4762</span><span id="line.4762">                }</span>
<span class="source-line-no">4763</span><span id="line.4763">            }</span>
<span class="source-line-no">4764</span><span id="line.4764">            tallied = false;</span>
<span class="source-line-no">4765</span><span id="line.4765">        }</span>
<span class="source-line-no">4766</span><span id="line.4766">        return result;</span>
<span class="source-line-no">4767</span><span id="line.4767">    }</span>
<span class="source-line-no">4768</span><span id="line.4768"></span>
<span class="source-line-no">4769</span><span id="line.4769">    public GreasedRegion removeIsolated()</span>
<span class="source-line-no">4770</span><span id="line.4770">    {</span>
<span class="source-line-no">4771</span><span id="line.4771">        int fst = firstTight();</span>
<span class="source-line-no">4772</span><span id="line.4772">        GreasedRegion remaining = new GreasedRegion(this), filled = new GreasedRegion(this);</span>
<span class="source-line-no">4773</span><span id="line.4773">        while (fst &gt;= 0) {</span>
<span class="source-line-no">4774</span><span id="line.4774">            filled.empty().insert(fst).flood(remaining, 8);</span>
<span class="source-line-no">4775</span><span id="line.4775">            if(filled.size() &lt;= 4)</span>
<span class="source-line-no">4776</span><span id="line.4776">                andNot(filled);</span>
<span class="source-line-no">4777</span><span id="line.4777">            remaining.andNot(filled);</span>
<span class="source-line-no">4778</span><span id="line.4778">            fst = remaining.firstTight();</span>
<span class="source-line-no">4779</span><span id="line.4779">        }</span>
<span class="source-line-no">4780</span><span id="line.4780">        return this;</span>
<span class="source-line-no">4781</span><span id="line.4781">    }</span>
<span class="source-line-no">4782</span><span id="line.4782"></span>
<span class="source-line-no">4783</span><span id="line.4783">    /**</span>
<span class="source-line-no">4784</span><span id="line.4784">     * Returns true if any cell is "on" in both this GreasedRegion and in other; returns false otherwise. For example,</span>
<span class="source-line-no">4785</span><span id="line.4785">     * if (1,1) is "on" in this and (1,1) is "on" in other, this would return true, regardless of other cells.</span>
<span class="source-line-no">4786</span><span id="line.4786">     * @param other another GreasedRegion; its size does not have to match this GreasedRegion's size</span>
<span class="source-line-no">4787</span><span id="line.4787">     * @return true if this shares any "on" cells with other</span>
<span class="source-line-no">4788</span><span id="line.4788">     */</span>
<span class="source-line-no">4789</span><span id="line.4789">    public boolean intersects(GreasedRegion other) {</span>
<span class="source-line-no">4790</span><span id="line.4790">        boolean result = false;</span>
<span class="source-line-no">4791</span><span id="line.4791">        if (other != null) {</span>
<span class="source-line-no">4792</span><span id="line.4792">            OUTER:</span>
<span class="source-line-no">4793</span><span id="line.4793">            for (int x = 0; x &lt; width &amp;&amp; x &lt; other.width; x++) {</span>
<span class="source-line-no">4794</span><span id="line.4794">                for (int y = 0; y &lt; ySections &amp;&amp; y &lt; other.ySections; y++) {</span>
<span class="source-line-no">4795</span><span id="line.4795">                    if ((data[x * ySections + y] &amp; other.data[x * ySections + y]) != 0) {</span>
<span class="source-line-no">4796</span><span id="line.4796">                        result = true;</span>
<span class="source-line-no">4797</span><span id="line.4797">                        break OUTER;</span>
<span class="source-line-no">4798</span><span id="line.4798">                    }</span>
<span class="source-line-no">4799</span><span id="line.4799">                }</span>
<span class="source-line-no">4800</span><span id="line.4800">            }</span>
<span class="source-line-no">4801</span><span id="line.4801">        }</span>
<span class="source-line-no">4802</span><span id="line.4802">        return result;</span>
<span class="source-line-no">4803</span><span id="line.4803">    }</span>
<span class="source-line-no">4804</span><span id="line.4804"></span>
<span class="source-line-no">4805</span><span id="line.4805">    public static OrderedSet&lt;GreasedRegion&gt; whichContain(int x, int y, GreasedRegion ... packed)</span>
<span class="source-line-no">4806</span><span id="line.4806">    {</span>
<span class="source-line-no">4807</span><span id="line.4807">        OrderedSet&lt;GreasedRegion&gt; found = new OrderedSet&lt;&gt;(packed.length);</span>
<span class="source-line-no">4808</span><span id="line.4808">        GreasedRegion tmp;</span>
<span class="source-line-no">4809</span><span id="line.4809">        for (int i = 0; i &lt; packed.length; i++) {</span>
<span class="source-line-no">4810</span><span id="line.4810">            if((tmp = packed[i]) != null &amp;&amp; tmp.contains(x, y))</span>
<span class="source-line-no">4811</span><span id="line.4811">                found.add(tmp);</span>
<span class="source-line-no">4812</span><span id="line.4812">        }</span>
<span class="source-line-no">4813</span><span id="line.4813">        return found;</span>
<span class="source-line-no">4814</span><span id="line.4814">    }</span>
<span class="source-line-no">4815</span><span id="line.4815"></span>
<span class="source-line-no">4816</span><span id="line.4816">    public static OrderedSet&lt;GreasedRegion&gt; whichContain(int x, int y, Collection&lt;GreasedRegion&gt; packed)</span>
<span class="source-line-no">4817</span><span id="line.4817">    {</span>
<span class="source-line-no">4818</span><span id="line.4818">        OrderedSet&lt;GreasedRegion&gt; found = new OrderedSet&lt;&gt;(packed.size());</span>
<span class="source-line-no">4819</span><span id="line.4819">        for (GreasedRegion tmp : packed) {</span>
<span class="source-line-no">4820</span><span id="line.4820">            if(tmp != null &amp;&amp; tmp.contains(x, y))</span>
<span class="source-line-no">4821</span><span id="line.4821">                found.add(tmp);</span>
<span class="source-line-no">4822</span><span id="line.4822">        }</span>
<span class="source-line-no">4823</span><span id="line.4823">        return found;</span>
<span class="source-line-no">4824</span><span id="line.4824">    }</span>
<span class="source-line-no">4825</span><span id="line.4825">    /**</span>
<span class="source-line-no">4826</span><span id="line.4826">     * Tries to look up the position x,y in each GreasedRegion in packed; each GreasedRegion that contains that x,y</span>
<span class="source-line-no">4827</span><span id="line.4827">     * point is appended into the Collection {@code into}.</span>
<span class="source-line-no">4828</span><span id="line.4828">     * @param into a Collection of GreasedRegion that will be modified if this succeeds</span>
<span class="source-line-no">4829</span><span id="line.4829">     * @param x the x-coordinate to look up</span>
<span class="source-line-no">4830</span><span id="line.4830">     * @param y the y-coordinate to look up</span>
<span class="source-line-no">4831</span><span id="line.4831">     * @param packed the array or varargs of GreasedRegion to try to look up the given position in</span>
<span class="source-line-no">4832</span><span id="line.4832">     * @return {@code into}, potentially modified</span>
<span class="source-line-no">4833</span><span id="line.4833">     */</span>
<span class="source-line-no">4834</span><span id="line.4834">    public static Collection&lt;GreasedRegion&gt; appendContaining(Collection&lt;GreasedRegion&gt; into, int x, int y, GreasedRegion ... packed)</span>
<span class="source-line-no">4835</span><span id="line.4835">    {</span>
<span class="source-line-no">4836</span><span id="line.4836">        GreasedRegion tmp;</span>
<span class="source-line-no">4837</span><span id="line.4837">        for (int i = 0; i &lt; packed.length; i++) {</span>
<span class="source-line-no">4838</span><span id="line.4838">            if((tmp = packed[i]) != null &amp;&amp; tmp.contains(x, y))</span>
<span class="source-line-no">4839</span><span id="line.4839">                into.add(tmp);</span>
<span class="source-line-no">4840</span><span id="line.4840">        }</span>
<span class="source-line-no">4841</span><span id="line.4841">        return into;</span>
<span class="source-line-no">4842</span><span id="line.4842">    }</span>
<span class="source-line-no">4843</span><span id="line.4843"></span>
<span class="source-line-no">4844</span><span id="line.4844">    /**</span>
<span class="source-line-no">4845</span><span id="line.4845">     * Tries to look up the position x,y in each GreasedRegion in packed; each GreasedRegion that contains that x,y</span>
<span class="source-line-no">4846</span><span id="line.4846">     * point is appended into the Collection {@code into}.</span>
<span class="source-line-no">4847</span><span id="line.4847">     * @param into a Collection of GreasedRegion that will be modified if this succeeds</span>
<span class="source-line-no">4848</span><span id="line.4848">     * @param x the x-coordinate to look up</span>
<span class="source-line-no">4849</span><span id="line.4849">     * @param y the y-coordinate to look up</span>
<span class="source-line-no">4850</span><span id="line.4850">     * @param packed the Collection of GreasedRegion to try to look up the given position in</span>
<span class="source-line-no">4851</span><span id="line.4851">     * @return {@code into}, potentially modified</span>
<span class="source-line-no">4852</span><span id="line.4852">     */</span>
<span class="source-line-no">4853</span><span id="line.4853">    public static Collection&lt;GreasedRegion&gt; appendContaining(Collection&lt;GreasedRegion&gt; into, int x, int y, Collection&lt;GreasedRegion&gt; packed)</span>
<span class="source-line-no">4854</span><span id="line.4854">    {</span>
<span class="source-line-no">4855</span><span id="line.4855">        for (GreasedRegion tmp : packed) {</span>
<span class="source-line-no">4856</span><span id="line.4856">            if(tmp != null &amp;&amp; tmp.contains(x, y))</span>
<span class="source-line-no">4857</span><span id="line.4857">                into.add(tmp);</span>
<span class="source-line-no">4858</span><span id="line.4858">        }</span>
<span class="source-line-no">4859</span><span id="line.4859">        return into;</span>
<span class="source-line-no">4860</span><span id="line.4860">    }</span>
<span class="source-line-no">4861</span><span id="line.4861"></span>
<span class="source-line-no">4862</span><span id="line.4862"></span>
<span class="source-line-no">4863</span><span id="line.4863">    public int size()</span>
<span class="source-line-no">4864</span><span id="line.4864">    {</span>
<span class="source-line-no">4865</span><span id="line.4865">        if(!tallied)</span>
<span class="source-line-no">4866</span><span id="line.4866">            tally();</span>
<span class="source-line-no">4867</span><span id="line.4867">        return ct;</span>
<span class="source-line-no">4868</span><span id="line.4868">    }</span>
<span class="source-line-no">4869</span><span id="line.4869"></span>
<span class="source-line-no">4870</span><span id="line.4870">    public Coord fit(double xFraction, double yFraction) {</span>
<span class="source-line-no">4871</span><span id="line.4871">        Coord result = null;</span>
<span class="source-line-no">4872</span><span id="line.4872">        boolean finished = false;</span>
<span class="source-line-no">4873</span><span id="line.4873">        int tmp, xTotal = 0, yTotal = 0, xTarget, yTarget, bestX = -1;</span>
<span class="source-line-no">4874</span><span id="line.4874">        long t;</span>
<span class="source-line-no">4875</span><span id="line.4875">        int[] xCounts = new int[width];</span>
<span class="source-line-no">4876</span><span id="line.4876">        for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">4877</span><span id="line.4877">            for (int s = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">4878</span><span id="line.4878">                t = data[x * ySections + s] | 0L;</span>
<span class="source-line-no">4879</span><span id="line.4879">                if (t != 0) {</span>
<span class="source-line-no">4880</span><span id="line.4880">                    tmp = Long.bitCount(t);</span>
<span class="source-line-no">4881</span><span id="line.4881">                    xCounts[x] += tmp;</span>
<span class="source-line-no">4882</span><span id="line.4882">                    xTotal += tmp;</span>
<span class="source-line-no">4883</span><span id="line.4883">                }</span>
<span class="source-line-no">4884</span><span id="line.4884">            }</span>
<span class="source-line-no">4885</span><span id="line.4885">        }</span>
<span class="source-line-no">4886</span><span id="line.4886">        xTarget = (int) (xTotal * xFraction);</span>
<span class="source-line-no">4887</span><span id="line.4887">        for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">4888</span><span id="line.4888">            if ((xTarget -= xCounts[x]) &lt; 0) {</span>
<span class="source-line-no">4889</span><span id="line.4889">                bestX = x;</span>
<span class="source-line-no">4890</span><span id="line.4890">                yTotal = xCounts[x];</span>
<span class="source-line-no">4891</span><span id="line.4891">                break;</span>
<span class="source-line-no">4892</span><span id="line.4892">            }</span>
<span class="source-line-no">4893</span><span id="line.4893">        }</span>
<span class="source-line-no">4894</span><span id="line.4894">        if (bestX &lt; 0) {</span>
<span class="source-line-no">4895</span><span id="line.4895">            result = Coord.get(-1, -1);</span>
<span class="source-line-no">4896</span><span id="line.4896">        } else {</span>
<span class="source-line-no">4897</span><span id="line.4897">            yTarget = (int) (yTotal * yFraction);</span>
<span class="source-line-no">4898</span><span id="line.4898">            for (int s = 0, y = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">4899</span><span id="line.4899">                t = data[bestX * ySections + s] | 0L;</span>
<span class="source-line-no">4900</span><span id="line.4900">                for (long cy = 1L; cy != 0L &amp;&amp; y &lt; height; y++, cy &lt;&lt;= 1) {</span>
<span class="source-line-no">4901</span><span id="line.4901">                    if ((t &amp; (cy | 0L)) != 0 &amp;&amp; --yTarget &lt; 0) {</span>
<span class="source-line-no">4902</span><span id="line.4902">                        result = Coord.get(bestX, y);</span>
<span class="source-line-no">4903</span><span id="line.4903">                        finished = true;</span>
<span class="source-line-no">4904</span><span id="line.4904">                        break;</span>
<span class="source-line-no">4905</span><span id="line.4905">                    }</span>
<span class="source-line-no">4906</span><span id="line.4906">                }</span>
<span class="source-line-no">4907</span><span id="line.4907">                if (finished) break;</span>
<span class="source-line-no">4908</span><span id="line.4908">            }</span>
<span class="source-line-no">4909</span><span id="line.4909">            if (!finished) {</span>
<span class="source-line-no">4910</span><span id="line.4910">                result = Coord.get(-1, -1);</span>
<span class="source-line-no">4911</span><span id="line.4911">            }</span>
<span class="source-line-no">4912</span><span id="line.4912">        }</span>
<span class="source-line-no">4913</span><span id="line.4913"></span>
<span class="source-line-no">4914</span><span id="line.4914">        return result;</span>
<span class="source-line-no">4915</span><span id="line.4915">    }</span>
<span class="source-line-no">4916</span><span id="line.4916"></span>
<span class="source-line-no">4917</span><span id="line.4917">    public int[][] fit(int[][] basis, int defaultValue) {</span>
<span class="source-line-no">4918</span><span id="line.4918">        int[][] result;</span>
<span class="source-line-no">4919</span><span id="line.4919">        int[][] next = ArrayTools.fill(defaultValue, width, height);</span>
<span class="source-line-no">4920</span><span id="line.4920">        if (basis == null || basis.length &lt;= 0 || basis[0] == null || basis[0].length &lt;= 0) {</span>
<span class="source-line-no">4921</span><span id="line.4921">            result = next;</span>
<span class="source-line-no">4922</span><span id="line.4922">        } else {</span>
<span class="source-line-no">4923</span><span id="line.4923">            int tmp, xTotal = 0, yTotal, xTarget, yTarget, bestX, oX = basis.length, oY = basis[0].length, ao;</span>
<span class="source-line-no">4924</span><span id="line.4924">            long t;</span>
<span class="source-line-no">4925</span><span id="line.4925">            int[] xCounts = new int[width];</span>
<span class="source-line-no">4926</span><span id="line.4926">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">4927</span><span id="line.4927">                for (int s = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">4928</span><span id="line.4928">                    t = data[x * ySections + s] | 0L;</span>
<span class="source-line-no">4929</span><span id="line.4929">                    if (t != 0) {</span>
<span class="source-line-no">4930</span><span id="line.4930">                        tmp = Long.bitCount(t);</span>
<span class="source-line-no">4931</span><span id="line.4931">                        xCounts[x] += tmp;</span>
<span class="source-line-no">4932</span><span id="line.4932">                        xTotal += tmp;</span>
<span class="source-line-no">4933</span><span id="line.4933">                    }</span>
<span class="source-line-no">4934</span><span id="line.4934">                }</span>
<span class="source-line-no">4935</span><span id="line.4935">            }</span>
<span class="source-line-no">4936</span><span id="line.4936">            if (xTotal &lt;= 0) {</span>
<span class="source-line-no">4937</span><span id="line.4937">                result = next;</span>
<span class="source-line-no">4938</span><span id="line.4938">            } else {</span>
<span class="source-line-no">4939</span><span id="line.4939">                for (int aX = 0; aX &lt; oX; aX++) {</span>
<span class="source-line-no">4940</span><span id="line.4940">                    CELL_WISE:</span>
<span class="source-line-no">4941</span><span id="line.4941">                    for (int aY = 0; aY &lt; oY; aY++) {</span>
<span class="source-line-no">4942</span><span id="line.4942">                        if ((ao = basis[aX][aY]) == defaultValue)</span>
<span class="source-line-no">4943</span><span id="line.4943">                            continue;</span>
<span class="source-line-no">4944</span><span id="line.4944">                        xTarget = xTotal * aX / oX;</span>
<span class="source-line-no">4945</span><span id="line.4945">                        for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">4946</span><span id="line.4946">                            if ((xTarget -= xCounts[x]) &lt; 0) {</span>
<span class="source-line-no">4947</span><span id="line.4947">                                bestX = x;</span>
<span class="source-line-no">4948</span><span id="line.4948">                                yTotal = xCounts[x];</span>
<span class="source-line-no">4949</span><span id="line.4949">                                yTarget = yTotal * aY / oY;</span>
<span class="source-line-no">4950</span><span id="line.4950">                                for (int s = 0, y = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">4951</span><span id="line.4951">                                    t = data[bestX * ySections + s] | 0L;</span>
<span class="source-line-no">4952</span><span id="line.4952">                                    for (long cy = 1L; cy != 0L &amp;&amp; y &lt; height; y++, cy &lt;&lt;= 1) {</span>
<span class="source-line-no">4953</span><span id="line.4953">                                        if ((t &amp; (cy | 0L)) != 0 &amp;&amp; --yTarget &lt; 0) {</span>
<span class="source-line-no">4954</span><span id="line.4954">                                            next[bestX][y] = ao;</span>
<span class="source-line-no">4955</span><span id="line.4955">                                            continue CELL_WISE;</span>
<span class="source-line-no">4956</span><span id="line.4956">                                        }</span>
<span class="source-line-no">4957</span><span id="line.4957">                                    }</span>
<span class="source-line-no">4958</span><span id="line.4958">                                }</span>
<span class="source-line-no">4959</span><span id="line.4959">                                continue CELL_WISE;</span>
<span class="source-line-no">4960</span><span id="line.4960">                            }</span>
<span class="source-line-no">4961</span><span id="line.4961">                        }</span>
<span class="source-line-no">4962</span><span id="line.4962"></span>
<span class="source-line-no">4963</span><span id="line.4963">                    }</span>
<span class="source-line-no">4964</span><span id="line.4964">                }</span>
<span class="source-line-no">4965</span><span id="line.4965">                result = next;</span>
<span class="source-line-no">4966</span><span id="line.4966">            }</span>
<span class="source-line-no">4967</span><span id="line.4967">        }</span>
<span class="source-line-no">4968</span><span id="line.4968"></span>
<span class="source-line-no">4969</span><span id="line.4969">        return result;</span>
<span class="source-line-no">4970</span><span id="line.4970">    }</span>
<span class="source-line-no">4971</span><span id="line.4971">    </span>
<span class="source-line-no">4972</span><span id="line.4972">    /**</span>
<span class="source-line-no">4973</span><span id="line.4973">     * Don't use this in new code; prefer {@link #mixedRandomSeparated(double)}, {@link #quasiRandomSeparated(double)},</span>
<span class="source-line-no">4974</span><span id="line.4974">     * or {@link #separatedZCurve(double)}. This method has issues with being unable to fill the requested fraction, but</span>
<span class="source-line-no">4975</span><span id="line.4975">     * the others mentioned don't. See their documentation for what all these group of methods do.</span>
<span class="source-line-no">4976</span><span id="line.4976">     * @param fraction between 0.0 and 1.0</span>
<span class="source-line-no">4977</span><span id="line.4977">     * @return a Coord array that may not have the full fraction used; you have been advised</span>
<span class="source-line-no">4978</span><span id="line.4978">     */</span>
<span class="source-line-no">4979</span><span id="line.4979">    public Coord[] separatedPortion(double fraction) {</span>
<span class="source-line-no">4980</span><span id="line.4980">        Coord[] result;</span>
<span class="source-line-no">4981</span><span id="line.4981">        if (fraction &lt; 0) {</span>
<span class="source-line-no">4982</span><span id="line.4982">            result = new Coord[0];</span>
<span class="source-line-no">4983</span><span id="line.4983">        } else {</span>
<span class="source-line-no">4984</span><span id="line.4984">            if (fraction &gt; 1)</span>
<span class="source-line-no">4985</span><span id="line.4985">                fraction = 1;</span>
<span class="source-line-no">4986</span><span id="line.4986">            int ct, tmp, xTotal = 0, yTotal = 0, xTarget, yTarget, bestX = -1;</span>
<span class="source-line-no">4987</span><span id="line.4987">            long t;</span>
<span class="source-line-no">4988</span><span id="line.4988">            int[] xCounts = new int[width];</span>
<span class="source-line-no">4989</span><span id="line.4989">            for (int s = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">4990</span><span id="line.4990">                for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">4991</span><span id="line.4991">                    t = data[x * ySections + s] | 0L;</span>
<span class="source-line-no">4992</span><span id="line.4992">                    if (t != 0) {</span>
<span class="source-line-no">4993</span><span id="line.4993">                        tmp = Long.bitCount(t);</span>
<span class="source-line-no">4994</span><span id="line.4994">                        xCounts[x] += tmp;</span>
<span class="source-line-no">4995</span><span id="line.4995">                        xTotal += tmp;</span>
<span class="source-line-no">4996</span><span id="line.4996">                    }</span>
<span class="source-line-no">4997</span><span id="line.4997">                }</span>
<span class="source-line-no">4998</span><span id="line.4998">            }</span>
<span class="source-line-no">4999</span><span id="line.4999">            Coord[] vl = new Coord[ct = (int) (fraction * xTotal)];</span>
<span class="source-line-no">5000</span><span id="line.5000">            double[] vec = new double[2];</span>
<span class="source-line-no">5001</span><span id="line.5001">            sobol.skipTo(1337);</span>
<span class="source-line-no">5002</span><span id="line.5002">            EACH_SOBOL:</span>
<span class="source-line-no">5003</span><span id="line.5003">            for (int i = 0; i &lt; ct; i++) {</span>
<span class="source-line-no">5004</span><span id="line.5004">                sobol.fillVector(vec);</span>
<span class="source-line-no">5005</span><span id="line.5005">                xTarget = (int) (xTotal * vec[0]);</span>
<span class="source-line-no">5006</span><span id="line.5006">                for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">5007</span><span id="line.5007">                    if ((xTarget -= xCounts[x]) &lt; 0) {</span>
<span class="source-line-no">5008</span><span id="line.5008">                        bestX = x;</span>
<span class="source-line-no">5009</span><span id="line.5009">                        yTotal = xCounts[x];</span>
<span class="source-line-no">5010</span><span id="line.5010">                        break;</span>
<span class="source-line-no">5011</span><span id="line.5011">                    }</span>
<span class="source-line-no">5012</span><span id="line.5012">                }</span>
<span class="source-line-no">5013</span><span id="line.5013">                yTarget = (int) (yTotal * vec[1]);</span>
<span class="source-line-no">5014</span><span id="line.5014"></span>
<span class="source-line-no">5015</span><span id="line.5015">                for (int s = 0, y = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">5016</span><span id="line.5016">                    t = data[bestX * ySections + s] | 0L;</span>
<span class="source-line-no">5017</span><span id="line.5017">                    for (long cy = 1L; cy != 0L &amp;&amp; y &lt; height; y++, cy &lt;&lt;= 1) {</span>
<span class="source-line-no">5018</span><span id="line.5018">                        if ((t &amp; (cy | 0L)) != 0 &amp;&amp; --yTarget &lt; 0) {</span>
<span class="source-line-no">5019</span><span id="line.5019">                            vl[i] = Coord.get(bestX, y);</span>
<span class="source-line-no">5020</span><span id="line.5020">                            continue EACH_SOBOL;</span>
<span class="source-line-no">5021</span><span id="line.5021">                        }</span>
<span class="source-line-no">5022</span><span id="line.5022">                    }</span>
<span class="source-line-no">5023</span><span id="line.5023">                }</span>
<span class="source-line-no">5024</span><span id="line.5024">            }</span>
<span class="source-line-no">5025</span><span id="line.5025">            result = vl;</span>
<span class="source-line-no">5026</span><span id="line.5026">        }</span>
<span class="source-line-no">5027</span><span id="line.5027"></span>
<span class="source-line-no">5028</span><span id="line.5028">        return result;</span>
<span class="source-line-no">5029</span><span id="line.5029">    }</span>
<span class="source-line-no">5030</span><span id="line.5030">    /**</span>
<span class="source-line-no">5031</span><span id="line.5031">     * Don't use this in new code; prefer {@link #mixedRandomSeparated(double, int, long)} with a random long as the</span>
<span class="source-line-no">5032</span><span id="line.5032">     * last parameter. This method has issues with being unable to fill the requested fraction, but mixedRandomSeparated</span>
<span class="source-line-no">5033</span><span id="line.5033">     * does not. See its documentation for what this method is supposed to do.</span>
<span class="source-line-no">5034</span><span id="line.5034">     * @param fraction between 0.0 and 1.0</span>
<span class="source-line-no">5035</span><span id="line.5035">     * @param rng an IRNG that will be used to get a random starting point in the Sobol sequence this uses internally</span>
<span class="source-line-no">5036</span><span id="line.5036">     * @return a Coord array that may not have the full fraction used; you have been advised</span>
<span class="source-line-no">5037</span><span id="line.5037">     */</span>
<span class="source-line-no">5038</span><span id="line.5038">    public Coord[] randomSeparated(double fraction, IRNG rng)</span>
<span class="source-line-no">5039</span><span id="line.5039">    {</span>
<span class="source-line-no">5040</span><span id="line.5040">        return randomSeparated(fraction, rng, -1);</span>
<span class="source-line-no">5041</span><span id="line.5041">    }</span>
<span class="source-line-no">5042</span><span id="line.5042">    /**</span>
<span class="source-line-no">5043</span><span id="line.5043">     * Don't use this in new code; prefer {@link #mixedRandomSeparated(double, int, long)} with a random long as the</span>
<span class="source-line-no">5044</span><span id="line.5044">     * last parameter. This method has issues with being unable to fill the requested fraction, but mixedRandomSeparated</span>
<span class="source-line-no">5045</span><span id="line.5045">     * does not. See its documentation for what this method is supposed to do.</span>
<span class="source-line-no">5046</span><span id="line.5046">     * @param fraction between 0.0 and 1.0</span>
<span class="source-line-no">5047</span><span id="line.5047">     * @param rng an IRNG that will be used to get a random starting point in the Sobol sequence this uses internally</span>
<span class="source-line-no">5048</span><span id="line.5048">     * @param limit how many Coord values this should return, at most; typically this will return less</span>
<span class="source-line-no">5049</span><span id="line.5049">     * @return a Coord array that may not have the full fraction used; you have been advised</span>
<span class="source-line-no">5050</span><span id="line.5050">     */</span>
<span class="source-line-no">5051</span><span id="line.5051">    public Coord[] randomSeparated(double fraction, IRNG rng, int limit) {</span>
<span class="source-line-no">5052</span><span id="line.5052">        Coord[] result;</span>
<span class="source-line-no">5053</span><span id="line.5053">        if (fraction &lt; 0) {</span>
<span class="source-line-no">5054</span><span id="line.5054">            result = new Coord[0];</span>
<span class="source-line-no">5055</span><span id="line.5055">        } else {</span>
<span class="source-line-no">5056</span><span id="line.5056">            if (fraction &gt; 1)</span>
<span class="source-line-no">5057</span><span id="line.5057">                fraction = 1;</span>
<span class="source-line-no">5058</span><span id="line.5058">            int ct, tmp, xTotal = 0, yTotal = 0, xTarget, yTarget, bestX = -1;</span>
<span class="source-line-no">5059</span><span id="line.5059">            long t;</span>
<span class="source-line-no">5060</span><span id="line.5060">            int[] xCounts = new int[width];</span>
<span class="source-line-no">5061</span><span id="line.5061">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">5062</span><span id="line.5062">                for (int s = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">5063</span><span id="line.5063">                    t = data[x * ySections + s] | 0L;</span>
<span class="source-line-no">5064</span><span id="line.5064">                    if (t != 0) {</span>
<span class="source-line-no">5065</span><span id="line.5065">                        tmp = Long.bitCount(t);</span>
<span class="source-line-no">5066</span><span id="line.5066">                        xCounts[x] += tmp;</span>
<span class="source-line-no">5067</span><span id="line.5067">                        xTotal += tmp;</span>
<span class="source-line-no">5068</span><span id="line.5068">                    }</span>
<span class="source-line-no">5069</span><span id="line.5069">                }</span>
<span class="source-line-no">5070</span><span id="line.5070">            }</span>
<span class="source-line-no">5071</span><span id="line.5071">            ct = (int) (fraction * xTotal);</span>
<span class="source-line-no">5072</span><span id="line.5072">            if (limit &gt;= 0 &amp;&amp; limit &lt; ct)</span>
<span class="source-line-no">5073</span><span id="line.5073">                ct = limit;</span>
<span class="source-line-no">5074</span><span id="line.5074">            Coord[] vl = new Coord[ct];</span>
<span class="source-line-no">5075</span><span id="line.5075">            double[] vec = new double[2];</span>
<span class="source-line-no">5076</span><span id="line.5076">            sobol.skipTo(rng.between(1000, 65000));</span>
<span class="source-line-no">5077</span><span id="line.5077">            EACH_SOBOL:</span>
<span class="source-line-no">5078</span><span id="line.5078">            for (int i = 0; i &lt; ct; i++) {</span>
<span class="source-line-no">5079</span><span id="line.5079">                sobol.fillVector(vec);</span>
<span class="source-line-no">5080</span><span id="line.5080">                xTarget = (int) (xTotal * vec[0]);</span>
<span class="source-line-no">5081</span><span id="line.5081">                for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">5082</span><span id="line.5082">                    if ((xTarget -= xCounts[x]) &lt; 0) {</span>
<span class="source-line-no">5083</span><span id="line.5083">                        bestX = x;</span>
<span class="source-line-no">5084</span><span id="line.5084">                        yTotal = xCounts[x];</span>
<span class="source-line-no">5085</span><span id="line.5085">                        break;</span>
<span class="source-line-no">5086</span><span id="line.5086">                    }</span>
<span class="source-line-no">5087</span><span id="line.5087">                }</span>
<span class="source-line-no">5088</span><span id="line.5088">                yTarget = (int) (yTotal * vec[1]);</span>
<span class="source-line-no">5089</span><span id="line.5089"></span>
<span class="source-line-no">5090</span><span id="line.5090">                for (int s = 0, y = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">5091</span><span id="line.5091">                    t = data[bestX * ySections + s] | 0L;</span>
<span class="source-line-no">5092</span><span id="line.5092">                    for (long cy = 1; cy != 0 &amp;&amp; y &lt; height; y++, cy &lt;&lt;= 1) {</span>
<span class="source-line-no">5093</span><span id="line.5093">                        if ((t &amp; (cy | 0L)) != 0 &amp;&amp; --yTarget &lt; 0) {</span>
<span class="source-line-no">5094</span><span id="line.5094">                            vl[i] = Coord.get(bestX, y);</span>
<span class="source-line-no">5095</span><span id="line.5095">                            continue EACH_SOBOL;</span>
<span class="source-line-no">5096</span><span id="line.5096">                        }</span>
<span class="source-line-no">5097</span><span id="line.5097">                    }</span>
<span class="source-line-no">5098</span><span id="line.5098">                }</span>
<span class="source-line-no">5099</span><span id="line.5099">            }</span>
<span class="source-line-no">5100</span><span id="line.5100">            result = vl;</span>
<span class="source-line-no">5101</span><span id="line.5101">        }</span>
<span class="source-line-no">5102</span><span id="line.5102"></span>
<span class="source-line-no">5103</span><span id="line.5103">        return result;</span>
<span class="source-line-no">5104</span><span id="line.5104">    }</span>
<span class="source-line-no">5105</span><span id="line.5105"></span>
<span class="source-line-no">5106</span><span id="line.5106">    /**</span>
<span class="source-line-no">5107</span><span id="line.5107">     * Gets a Coord array from the "on" contents of this GreasedRegion, using a deterministic but random-seeming</span>
<span class="source-line-no">5108</span><span id="line.5108">     * scattering of chosen cells with a count that matches the given {@code fraction} of the total amount of "on" cells</span>
<span class="source-line-no">5109</span><span id="line.5109">     * in this. This is pseudo-random with a fixed seed, but is very good at avoiding overlap (just as good as</span>
<span class="source-line-no">5110</span><span id="line.5110">     * {@link #separatedRegionZCurve(double, int)}, and probably faster). If you request too many cells (too high of a</span>
<span class="source-line-no">5111</span><span id="line.5111">     * value for fraction), it will start to overlap, but a fraction value of 0.4 reliably has had no overlap in</span>
<span class="source-line-no">5112</span><span id="line.5112">     * testing. Does not restrict the size of the returned array other than only using up to</span>
<span class="source-line-no">5113</span><span id="line.5113">     * {@code fraction * size()} cells.</span>
<span class="source-line-no">5114</span><span id="line.5114">     * @param fraction the fraction of "on" cells to randomly select, between 0.0 and 1.0</span>
<span class="source-line-no">5115</span><span id="line.5115">     * @return a freshly-allocated Coord array containing the quasi-random cells</span>
<span class="source-line-no">5116</span><span id="line.5116">     */</span>
<span class="source-line-no">5117</span><span id="line.5117">    public Coord[] mixedRandomSeparated(double fraction)</span>
<span class="source-line-no">5118</span><span id="line.5118">    {</span>
<span class="source-line-no">5119</span><span id="line.5119">        return mixedRandomSeparated(fraction, -1, 1L);</span>
<span class="source-line-no">5120</span><span id="line.5120">    }</span>
<span class="source-line-no">5121</span><span id="line.5121"></span>
<span class="source-line-no">5122</span><span id="line.5122">    /**</span>
<span class="source-line-no">5123</span><span id="line.5123">     * Gets a Coord array from the "on" contents of this GreasedRegion, using a deterministic but random-seeming</span>
<span class="source-line-no">5124</span><span id="line.5124">     * scattering of chosen cells with a count that matches the given {@code fraction} of the total amount of "on" cells</span>
<span class="source-line-no">5125</span><span id="line.5125">     * in this. This is pseudo-random with a fixed seed, but is very good at avoiding overlap (just as good as</span>
<span class="source-line-no">5126</span><span id="line.5126">     * {@link #separatedRegionZCurve(double, int)}, and probably faster). If you request too many cells (too high of a</span>
<span class="source-line-no">5127</span><span id="line.5127">     * value for fraction), it will start to overlap, but a fraction value of 0.4 reliably has had no overlap in</span>
<span class="source-line-no">5128</span><span id="line.5128">     * testing. Restricts the total size of the returned array to a maximum of {@code limit} (minimum is 0 if no cells</span>
<span class="source-line-no">5129</span><span id="line.5129">     * are "on"). If limit is negative, this will not restrict the size.</span>
<span class="source-line-no">5130</span><span id="line.5130">     * @param fraction the fraction of "on" cells to randomly select, between 0.0 and 1.0</span>
<span class="source-line-no">5131</span><span id="line.5131">     * @param limit the maximum size of the array to return</span>
<span class="source-line-no">5132</span><span id="line.5132">     * @return a freshly-allocated Coord array containing the pseudo-random cells</span>
<span class="source-line-no">5133</span><span id="line.5133">     */</span>
<span class="source-line-no">5134</span><span id="line.5134">    public Coord[] mixedRandomSeparated(double fraction, int limit)</span>
<span class="source-line-no">5135</span><span id="line.5135">    {</span>
<span class="source-line-no">5136</span><span id="line.5136">        return mixedRandomSeparated(fraction, limit, 1L);</span>
<span class="source-line-no">5137</span><span id="line.5137">    }</span>
<span class="source-line-no">5138</span><span id="line.5138"></span>
<span class="source-line-no">5139</span><span id="line.5139">    /**</span>
<span class="source-line-no">5140</span><span id="line.5140">     * Gets a Coord array from the "on" contents of this GreasedRegion, using a deterministic but random-seeming</span>
<span class="source-line-no">5141</span><span id="line.5141">     * scattering of chosen cells with a count that matches the given {@code fraction} of the total amount of "on" cells</span>
<span class="source-line-no">5142</span><span id="line.5142">     * in this. This is pseudo-random with the given seed (which will be made into an odd number if it is not one</span>
<span class="source-line-no">5143</span><span id="line.5143">     * already), and is very good at avoiding overlap (just as good as {@link #separatedZCurve(double, int)}, and</span>
<span class="source-line-no">5144</span><span id="line.5144">     * probably faster). If you request too many cells (too high of a value for fraction), it will start to overlap, but</span>
<span class="source-line-no">5145</span><span id="line.5145">     * a fraction value of 0.4 reliably has had no overlap in testing. Restricts the total size of the returned array to</span>
<span class="source-line-no">5146</span><span id="line.5146">     * a maximum of {@code limit} (minimum is 0 if no cells are "on"). If limit is negative, this will not restrict the</span>
<span class="source-line-no">5147</span><span id="line.5147">     * size.</span>
<span class="source-line-no">5148</span><span id="line.5148">     * @param fraction the fraction of "on" cells to randomly select, between 0.0 and 1.0</span>
<span class="source-line-no">5149</span><span id="line.5149">     * @param limit the maximum size of the array to return</span>
<span class="source-line-no">5150</span><span id="line.5150">     * @param seed a long seed to change the points; the most significant 21 bits (except the sign bit) and least significant bit are ignored</span>
<span class="source-line-no">5151</span><span id="line.5151">     * @return a freshly-allocated Coord array containing the pseudo-random cells</span>
<span class="source-line-no">5152</span><span id="line.5152">     */</span>
<span class="source-line-no">5153</span><span id="line.5153">    public Coord[] mixedRandomSeparated(double fraction, int limit, long seed) {</span>
<span class="source-line-no">5154</span><span id="line.5154">        Coord[] result;</span>
<span class="source-line-no">5155</span><span id="line.5155">        if (fraction &lt; 0) {</span>
<span class="source-line-no">5156</span><span id="line.5156">            result = new Coord[0];</span>
<span class="source-line-no">5157</span><span id="line.5157">        } else {</span>
<span class="source-line-no">5158</span><span id="line.5158">            if (fraction &gt; 1)</span>
<span class="source-line-no">5159</span><span id="line.5159">                fraction = 1;</span>
<span class="source-line-no">5160</span><span id="line.5160">            int tmp, ic;</span>
<span class="source-line-no">5161</span><span id="line.5161">            long t, w;</span>
<span class="source-line-no">5162</span><span id="line.5162">            seed |= 1L;</span>
<span class="source-line-no">5163</span><span id="line.5163">            final int total = size();</span>
<span class="source-line-no">5164</span><span id="line.5164">            int ct = (int) (total * fraction);</span>
<span class="source-line-no">5165</span><span id="line.5165">            if (limit &gt;= 0 &amp;&amp; limit &lt; ct)</span>
<span class="source-line-no">5166</span><span id="line.5166">                ct = limit;</span>
<span class="source-line-no">5167</span><span id="line.5167">            Coord[] vl = new Coord[ct];</span>
<span class="source-line-no">5168</span><span id="line.5168">            EACH_QUASI:</span>
<span class="source-line-no">5169</span><span id="line.5169">            for (int i = 0; i &lt; ct; i++) {</span>
<span class="source-line-no">5170</span><span id="line.5170">                tmp = (int) (VanDerCorputQRNG.altDetermine(seed, i + 1) * total);</span>
<span class="source-line-no">5171</span><span id="line.5171"></span>
<span class="source-line-no">5172</span><span id="line.5172">                for (int s = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">5173</span><span id="line.5173">                    for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">5174</span><span id="line.5174">                        if ((ic = counts[x * ySections + s]) &gt; tmp) {</span>
<span class="source-line-no">5175</span><span id="line.5175">                            t = data[x * ySections + s] | 0L;</span>
<span class="source-line-no">5176</span><span id="line.5176">                            for (--ic; t != 0; ic--) {</span>
<span class="source-line-no">5177</span><span id="line.5177">                                w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">5178</span><span id="line.5178">                                if (ic == tmp) {</span>
<span class="source-line-no">5179</span><span id="line.5179">                                    vl[i] = Coord.get(x, (s &lt;&lt; 6) | Long.bitCount(w - 1));</span>
<span class="source-line-no">5180</span><span id="line.5180">                                    continue EACH_QUASI;</span>
<span class="source-line-no">5181</span><span id="line.5181">                                }</span>
<span class="source-line-no">5182</span><span id="line.5182">                                t ^= w;</span>
<span class="source-line-no">5183</span><span id="line.5183">                            }</span>
<span class="source-line-no">5184</span><span id="line.5184">                        }</span>
<span class="source-line-no">5185</span><span id="line.5185">                    }</span>
<span class="source-line-no">5186</span><span id="line.5186">                }</span>
<span class="source-line-no">5187</span><span id="line.5187">            }</span>
<span class="source-line-no">5188</span><span id="line.5188">            result = vl;</span>
<span class="source-line-no">5189</span><span id="line.5189">        }</span>
<span class="source-line-no">5190</span><span id="line.5190">        return result;</span>
<span class="source-line-no">5191</span><span id="line.5191">    }</span>
<span class="source-line-no">5192</span><span id="line.5192"></span>
<span class="source-line-no">5193</span><span id="line.5193"></span>
<span class="source-line-no">5194</span><span id="line.5194"></span>
<span class="source-line-no">5195</span><span id="line.5195">    /**</span>
<span class="source-line-no">5196</span><span id="line.5196">     * Modifies this GreasedRegion so it contains a deterministic but random-seeming subset of its previous contents,</span>
<span class="source-line-no">5197</span><span id="line.5197">     * choosing cells so that the {@link #size()} matches the given {@code fraction} of the total amount of "on" cells</span>
<span class="source-line-no">5198</span><span id="line.5198">     * in this. This is pseudo-random with a fixed seed, and is very good at avoiding overlap (just as good as</span>
<span class="source-line-no">5199</span><span id="line.5199">     * {@link #separatedRegionZCurve(double, int)}, and probably faster). If you request too many cells (too high of a</span>
<span class="source-line-no">5200</span><span id="line.5200">     * value for fraction), it will start to overlap, but a fraction value of 0.4 reliably has had no overlap in</span>
<span class="source-line-no">5201</span><span id="line.5201">     * testing. Does not restrict the count of "on" cells after this returns other than by only using up to</span>
<span class="source-line-no">5202</span><span id="line.5202">     * {@code fraction * size()} cells.</span>
<span class="source-line-no">5203</span><span id="line.5203">     * @param fraction the fraction of "on" cells to randomly select, between 0.0 and 1.0</span>
<span class="source-line-no">5204</span><span id="line.5204">     * @return this for chaining</span>
<span class="source-line-no">5205</span><span id="line.5205">     */</span>
<span class="source-line-no">5206</span><span id="line.5206">    public GreasedRegion mixedRandomRegion(double fraction) {</span>
<span class="source-line-no">5207</span><span id="line.5207">        return mixedRandomRegion(fraction, -1, 1L);</span>
<span class="source-line-no">5208</span><span id="line.5208">    }</span>
<span class="source-line-no">5209</span><span id="line.5209">    /**</span>
<span class="source-line-no">5210</span><span id="line.5210">     * Modifies this GreasedRegion so it contains a deterministic but random-seeming subset of its previous contents,</span>
<span class="source-line-no">5211</span><span id="line.5211">     * choosing cells so that the {@link #size()} matches the given {@code fraction} of the total amount of "on" cells</span>
<span class="source-line-no">5212</span><span id="line.5212">     * in this. This is pseudo-random with a fixed seed, and is very good at avoiding overlap (just as good as</span>
<span class="source-line-no">5213</span><span id="line.5213">     * {@link #separatedRegionZCurve(double, int)}, and probably faster). If you request too many cells (too high of a</span>
<span class="source-line-no">5214</span><span id="line.5214">     * value for fraction), it will start to overlap, but a fraction value of 0.4 reliably has had no overlap in</span>
<span class="source-line-no">5215</span><span id="line.5215">     * testing. Restricts the total count of "on" cells after this returns to a maximum of {@code limit} (minimum is 0</span>
<span class="source-line-no">5216</span><span id="line.5216">     * if no cells are "on"). If limit is negative, this will not restrict the count.</span>
<span class="source-line-no">5217</span><span id="line.5217">     * @param fraction the fraction of "on" cells to randomly select, between 0.0 and 1.0</span>
<span class="source-line-no">5218</span><span id="line.5218">     * @param limit the maximum count of "on" cells to keep</span>
<span class="source-line-no">5219</span><span id="line.5219">     * @return this for chaining</span>
<span class="source-line-no">5220</span><span id="line.5220">     */</span>
<span class="source-line-no">5221</span><span id="line.5221">    public GreasedRegion mixedRandomRegion(double fraction, int limit) {</span>
<span class="source-line-no">5222</span><span id="line.5222">        return mixedRandomRegion(fraction, limit, 1L);</span>
<span class="source-line-no">5223</span><span id="line.5223">    }</span>
<span class="source-line-no">5224</span><span id="line.5224">    /**</span>
<span class="source-line-no">5225</span><span id="line.5225">     * Modifies this GreasedRegion so it contains a deterministic but random-seeming subset of its previous contents,</span>
<span class="source-line-no">5226</span><span id="line.5226">     * choosing cells so that the {@link #size()} matches the given {@code fraction} of the total amount of "on" cells</span>
<span class="source-line-no">5227</span><span id="line.5227">     * in this. This is pseudo-random with the given seed (which will be made into an odd number if it is not one</span>
<span class="source-line-no">5228</span><span id="line.5228">     * already), and is very good at avoiding overlap (just as good as {@link #separatedZCurve(double, int)}, and</span>
<span class="source-line-no">5229</span><span id="line.5229">     * probably faster). If you request too many cells (too high of a value for fraction), it will start to overlap, but</span>
<span class="source-line-no">5230</span><span id="line.5230">     * a fraction value of 0.4 reliably has had no overlap in testing. Restricts the total count of "on" cells after</span>
<span class="source-line-no">5231</span><span id="line.5231">     * this returns to a maximum of {@code limit} (minimum is 0 if no cells are "on"). If limit is negative, this will</span>
<span class="source-line-no">5232</span><span id="line.5232">     * not restrict the count.</span>
<span class="source-line-no">5233</span><span id="line.5233">     * @param fraction the fraction of "on" cells to randomly select, between 0.0 and 1.0</span>
<span class="source-line-no">5234</span><span id="line.5234">     * @param limit the maximum count of "on" cells to keep</span>
<span class="source-line-no">5235</span><span id="line.5235">     * @return this for chaining</span>
<span class="source-line-no">5236</span><span id="line.5236">     */</span>
<span class="source-line-no">5237</span><span id="line.5237">    public GreasedRegion mixedRandomRegion(double fraction, int limit, long seed) {</span>
<span class="source-line-no">5238</span><span id="line.5238">        GreasedRegion result = this;</span>
<span class="source-line-no">5239</span><span id="line.5239">        int idx, run = 0;</span>
<span class="source-line-no">5240</span><span id="line.5240">        final int total = size();</span>
<span class="source-line-no">5241</span><span id="line.5241">        if (total &lt;= limit) {</span>
<span class="source-line-no">5242</span><span id="line.5242">        } else if (total &lt;= 0) {</span>
<span class="source-line-no">5243</span><span id="line.5243">            result = empty();</span>
<span class="source-line-no">5244</span><span id="line.5244">        } else {</span>
<span class="source-line-no">5245</span><span id="line.5245">            if (limit &lt; 0)</span>
<span class="source-line-no">5246</span><span id="line.5246">                limit = (int) (fraction * ct);</span>
<span class="source-line-no">5247</span><span id="line.5247">            if (limit &lt;= 0) {</span>
<span class="source-line-no">5248</span><span id="line.5248">                result = empty();</span>
<span class="source-line-no">5249</span><span id="line.5249">            } else {</span>
<span class="source-line-no">5250</span><span id="line.5250">                seed |= 1L;</span>
<span class="source-line-no">5251</span><span id="line.5251">                int[] order = new int[limit];</span>
<span class="source-line-no">5252</span><span id="line.5252">                for (int i = 0, m = 1; i &lt; limit; i++, m++) {</span>
<span class="source-line-no">5253</span><span id="line.5253">                    idx = (int) (VanDerCorputQRNG.altDetermine(seed, m) * total);</span>
<span class="source-line-no">5254</span><span id="line.5254">                    BIG:</span>
<span class="source-line-no">5255</span><span id="line.5255">                    while (true) {</span>
<span class="source-line-no">5256</span><span id="line.5256">                        for (int j = 0; j &lt; i; j++) {</span>
<span class="source-line-no">5257</span><span id="line.5257">                            if (order[j] == idx) {</span>
<span class="source-line-no">5258</span><span id="line.5258">                                idx = (int) (VanDerCorputQRNG.altDetermine(seed, ++m) * total);</span>
<span class="source-line-no">5259</span><span id="line.5259">                                continue BIG;</span>
<span class="source-line-no">5260</span><span id="line.5260">                            }</span>
<span class="source-line-no">5261</span><span id="line.5261">                        }</span>
<span class="source-line-no">5262</span><span id="line.5262">                        break;</span>
<span class="source-line-no">5263</span><span id="line.5263">                    }</span>
<span class="source-line-no">5264</span><span id="line.5264">                    order[i] = idx;</span>
<span class="source-line-no">5265</span><span id="line.5265">                }</span>
<span class="source-line-no">5266</span><span id="line.5266">                idx = 0;</span>
<span class="source-line-no">5267</span><span id="line.5267">                Arrays.sort(order);</span>
<span class="source-line-no">5268</span><span id="line.5268">                long t, w;</span>
<span class="source-line-no">5269</span><span id="line.5269">                ALL:</span>
<span class="source-line-no">5270</span><span id="line.5270">                for (int s = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">5271</span><span id="line.5271">                    for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">5272</span><span id="line.5272">                        if ((t = data[x * ySections + s] | 0L) != 0L) {</span>
<span class="source-line-no">5273</span><span id="line.5273">                            w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">5274</span><span id="line.5274">                            while (w != 0) {</span>
<span class="source-line-no">5275</span><span id="line.5275">                                if (run++ == order[idx]) {</span>
<span class="source-line-no">5276</span><span id="line.5276">                                    if (++idx &gt;= limit) {</span>
<span class="source-line-no">5277</span><span id="line.5277">                                        data[x * ySections + s] &amp;= (w &lt;&lt; 1) - 1;</span>
<span class="source-line-no">5278</span><span id="line.5278">                                        for (int rx = x + 1; rx &lt; width; rx++) {</span>
<span class="source-line-no">5279</span><span id="line.5279">                                            data[rx * ySections + s] = 0;</span>
<span class="source-line-no">5280</span><span id="line.5280">                                        }</span>
<span class="source-line-no">5281</span><span id="line.5281">                                        for (int rs = s + 1; rs &lt; ySections; rs++) {</span>
<span class="source-line-no">5282</span><span id="line.5282">                                            for (int rx = 0; rx &lt; width; rx++) {</span>
<span class="source-line-no">5283</span><span id="line.5283">                                                data[rx * ySections + rs] = 0;</span>
<span class="source-line-no">5284</span><span id="line.5284">                                            }</span>
<span class="source-line-no">5285</span><span id="line.5285">                                        }</span>
<span class="source-line-no">5286</span><span id="line.5286">                                        break ALL;</span>
<span class="source-line-no">5287</span><span id="line.5287">                                    }</span>
<span class="source-line-no">5288</span><span id="line.5288">                                } else {</span>
<span class="source-line-no">5289</span><span id="line.5289">                                    data[x * ySections + s] ^= w;</span>
<span class="source-line-no">5290</span><span id="line.5290">                                }</span>
<span class="source-line-no">5291</span><span id="line.5291">                                t ^= w;</span>
<span class="source-line-no">5292</span><span id="line.5292">                                w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">5293</span><span id="line.5293">                            }</span>
<span class="source-line-no">5294</span><span id="line.5294">                        }</span>
<span class="source-line-no">5295</span><span id="line.5295">                    }</span>
<span class="source-line-no">5296</span><span id="line.5296">                }</span>
<span class="source-line-no">5297</span><span id="line.5297">                tallied = false;</span>
<span class="source-line-no">5298</span><span id="line.5298">            }</span>
<span class="source-line-no">5299</span><span id="line.5299">        }</span>
<span class="source-line-no">5300</span><span id="line.5300">        return result;</span>
<span class="source-line-no">5301</span><span id="line.5301">    }</span>
<span class="source-line-no">5302</span><span id="line.5302"></span>
<span class="source-line-no">5303</span><span id="line.5303">    /**</span>
<span class="source-line-no">5304</span><span id="line.5304">     * Gets a Coord array from the "on" contents of this GreasedRegion, using a quasi-random scattering of chosen cells</span>
<span class="source-line-no">5305</span><span id="line.5305">     * with a count that matches the given {@code fraction} of the total amount of "on" cells in this. This is quasi-</span>
<span class="source-line-no">5306</span><span id="line.5306">     * random instead of pseudo-random because it is somewhat less likely to produce nearby cells in the result. If you</span>
<span class="source-line-no">5307</span><span id="line.5307">     * request too many cells (too high of a value for fraction), it will start to overlap, however.</span>
<span class="source-line-no">5308</span><span id="line.5308">     * Does not restrict the size of the returned array other than only using up to {@code fraction * size()} cells.</span>
<span class="source-line-no">5309</span><span id="line.5309">     * &lt;br&gt;</span>
<span class="source-line-no">5310</span><span id="line.5310">     * You can choose between {@link #mixedRandomSeparated(double)}, {@link #separatedZCurve(double)}, </span>
<span class="source-line-no">5311</span><span id="line.5311">     * {@link #separatedBlue(double)}, and this method, where all are quasi-random, mixedRandom and</span>
<span class="source-line-no">5312</span><span id="line.5312">     * separatedBlue are probably fastest, ZCurve and separatedBlue may have better 2-dimensional gaps</span>
<span class="source-line-no">5313</span><span id="line.5313">     * between cells, and this method is somewhere in the middle.</span>
<span class="source-line-no">5314</span><span id="line.5314">     * @param fraction the fraction of "on" cells to randomly select, between 0.0 and 1.0</span>
<span class="source-line-no">5315</span><span id="line.5315">     * @return a freshly-allocated Coord array containing the quasi-random cells</span>
<span class="source-line-no">5316</span><span id="line.5316">     */</span>
<span class="source-line-no">5317</span><span id="line.5317">    public Coord[] quasiRandomSeparated(double fraction)</span>
<span class="source-line-no">5318</span><span id="line.5318">    {</span>
<span class="source-line-no">5319</span><span id="line.5319">        return quasiRandomSeparated(fraction, -1);</span>
<span class="source-line-no">5320</span><span id="line.5320">    }</span>
<span class="source-line-no">5321</span><span id="line.5321"></span>
<span class="source-line-no">5322</span><span id="line.5322">    /**</span>
<span class="source-line-no">5323</span><span id="line.5323">     * Gets a Coord array from the "on" contents of this GreasedRegion, using a quasi-random scattering of chosen cells</span>
<span class="source-line-no">5324</span><span id="line.5324">     * with a count that matches the given {@code fraction} of the total amount of "on" cells in this. This is quasi-</span>
<span class="source-line-no">5325</span><span id="line.5325">     * random instead of pseudo-random because it is somewhat less likely to produce nearby cells in the result. If you</span>
<span class="source-line-no">5326</span><span id="line.5326">     * request too many cells (too high of a value for fraction), it will start to overlap, however.</span>
<span class="source-line-no">5327</span><span id="line.5327">     * Restricts the total size of the returned array to a maximum of {@code limit} (minimum is 0 if no cells are "on").</span>
<span class="source-line-no">5328</span><span id="line.5328">     * If limit is negative, this will not restrict the size.</span>
<span class="source-line-no">5329</span><span id="line.5329">     * &lt;br&gt;</span>
<span class="source-line-no">5330</span><span id="line.5330">     * You can choose between {@link #mixedRandomSeparated(double)}, {@link #separatedZCurve(double)}, </span>
<span class="source-line-no">5331</span><span id="line.5331">     * {@link #separatedBlue(double)}, and this method, where all are quasi-random, mixedRandom and</span>
<span class="source-line-no">5332</span><span id="line.5332">     * separatedBlue are probably fastest, ZCurve and separatedBlue may have better 2-dimensional gaps</span>
<span class="source-line-no">5333</span><span id="line.5333">     * between cells, and this method is somewhere in the middle.</span>
<span class="source-line-no">5334</span><span id="line.5334">     * @param fraction the fraction of "on" cells to randomly select, between 0.0 and 1.0</span>
<span class="source-line-no">5335</span><span id="line.5335">     * @param limit the maximum size of the array to return</span>
<span class="source-line-no">5336</span><span id="line.5336">     * @return a freshly-allocated Coord array containing the quasi-random cells</span>
<span class="source-line-no">5337</span><span id="line.5337">     */</span>
<span class="source-line-no">5338</span><span id="line.5338">    public Coord[] quasiRandomSeparated(double fraction, int limit) {</span>
<span class="source-line-no">5339</span><span id="line.5339">        Coord[] result;</span>
<span class="source-line-no">5340</span><span id="line.5340">        if (fraction &lt; 0) {</span>
<span class="source-line-no">5341</span><span id="line.5341">            result = new Coord[0];</span>
<span class="source-line-no">5342</span><span id="line.5342">        } else {</span>
<span class="source-line-no">5343</span><span id="line.5343">            if (fraction &gt; 1)</span>
<span class="source-line-no">5344</span><span id="line.5344">                fraction = 1;</span>
<span class="source-line-no">5345</span><span id="line.5345">            int ct = 0, tmp, total, ic;</span>
<span class="source-line-no">5346</span><span id="line.5346">            long t, w;</span>
<span class="source-line-no">5347</span><span id="line.5347">            int[] counts = new int[width * ySections];</span>
<span class="source-line-no">5348</span><span id="line.5348">            for (int i = 0; i &lt; width * ySections; i++) {</span>
<span class="source-line-no">5349</span><span id="line.5349">                tmp = Long.bitCount(data[i]);</span>
<span class="source-line-no">5350</span><span id="line.5350">                counts[i] = tmp == 0 ? -1 : (ct += tmp);</span>
<span class="source-line-no">5351</span><span id="line.5351">            }</span>
<span class="source-line-no">5352</span><span id="line.5352">            total = ct;</span>
<span class="source-line-no">5353</span><span id="line.5353">            ct *= fraction;// (int)(fraction * ct);</span>
<span class="source-line-no">5354</span><span id="line.5354">            if (limit &gt;= 0 &amp;&amp; limit &lt; ct)</span>
<span class="source-line-no">5355</span><span id="line.5355">                ct = limit;</span>
<span class="source-line-no">5356</span><span id="line.5356">            Coord[] vl = new Coord[ct];</span>
<span class="source-line-no">5357</span><span id="line.5357">            EACH_QUASI:</span>
<span class="source-line-no">5358</span><span id="line.5358">            for (int i = 0; i &lt; ct; i++) {</span>
<span class="source-line-no">5359</span><span id="line.5359">                tmp = (int) (VanDerCorputQRNG.determine2(i ^ i &gt;&gt;&gt; 1) * total);</span>
<span class="source-line-no">5360</span><span id="line.5360">                for (int s = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">5361</span><span id="line.5361">                    for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">5362</span><span id="line.5362">                        if ((ic = counts[x * ySections + s]) &gt; tmp) {</span>
<span class="source-line-no">5363</span><span id="line.5363">                            t = data[x * ySections + s];</span>
<span class="source-line-no">5364</span><span id="line.5364">                            w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">5365</span><span id="line.5365">                            for (--ic; w != 0; ic--) {</span>
<span class="source-line-no">5366</span><span id="line.5366">                                if (ic == tmp) {</span>
<span class="source-line-no">5367</span><span id="line.5367">                                    vl[i] = Coord.get(x, (s &lt;&lt; 6) | Long.numberOfTrailingZeros(w));</span>
<span class="source-line-no">5368</span><span id="line.5368">                                    continue EACH_QUASI;</span>
<span class="source-line-no">5369</span><span id="line.5369">                                }</span>
<span class="source-line-no">5370</span><span id="line.5370">                                t ^= w;</span>
<span class="source-line-no">5371</span><span id="line.5371">                                w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">5372</span><span id="line.5372">                            }</span>
<span class="source-line-no">5373</span><span id="line.5373">                        }</span>
<span class="source-line-no">5374</span><span id="line.5374">                    }</span>
<span class="source-line-no">5375</span><span id="line.5375">                }</span>
<span class="source-line-no">5376</span><span id="line.5376">                vl[i] = atFraction(tmp);</span>
<span class="source-line-no">5377</span><span id="line.5377">            }</span>
<span class="source-line-no">5378</span><span id="line.5378">            result = vl;</span>
<span class="source-line-no">5379</span><span id="line.5379">        }</span>
<span class="source-line-no">5380</span><span id="line.5380">        return result;</span>
<span class="source-line-no">5381</span><span id="line.5381">    }</span>
<span class="source-line-no">5382</span><span id="line.5382"></span>
<span class="source-line-no">5383</span><span id="line.5383"></span>
<span class="source-line-no">5384</span><span id="line.5384"></span>
<span class="source-line-no">5385</span><span id="line.5385">    /**</span>
<span class="source-line-no">5386</span><span id="line.5386">     * Modifies this GreasedRegion so it contains a quasi-random subset of its previous contents, choosing cells so that</span>
<span class="source-line-no">5387</span><span id="line.5387">     * the {@link #size()} matches the given {@code fraction} of the total amount of "on" cells in this. This is quasi-</span>
<span class="source-line-no">5388</span><span id="line.5388">     * random instead of pseudo-random because it is somewhat less likely to produce nearby cells in the result. If you</span>
<span class="source-line-no">5389</span><span id="line.5389">     * request too many cells (too high of a value for fraction), it will start to overlap, however.</span>
<span class="source-line-no">5390</span><span id="line.5390">     * Does not restrict the count of "on" cells after this returns other than by only using up to</span>
<span class="source-line-no">5391</span><span id="line.5391">     * {@code fraction * size()} cells.</span>
<span class="source-line-no">5392</span><span id="line.5392">     * &lt;br&gt;</span>
<span class="source-line-no">5393</span><span id="line.5393">     * You can choose between {@link #mixedRandomRegion(double)}, {@link #separatedRegionZCurve(double)}, </span>
<span class="source-line-no">5394</span><span id="line.5394">     * {@link #separatedRegionBlue(double)}, and this method, where all are quasi-random, mixedRandom and</span>
<span class="source-line-no">5395</span><span id="line.5395">     * separatedRegionBlue are probably fastest, ZCurve and separatedRegionBlue may have better 2-dimensional gaps</span>
<span class="source-line-no">5396</span><span id="line.5396">     * between cells, and this method is somewhere in the middle.</span>
<span class="source-line-no">5397</span><span id="line.5397">     * @param fraction the fraction of "on" cells to randomly select, between 0.0 and 1.0</span>
<span class="source-line-no">5398</span><span id="line.5398">     * @return this for chaining</span>
<span class="source-line-no">5399</span><span id="line.5399">     */</span>
<span class="source-line-no">5400</span><span id="line.5400">    public GreasedRegion quasiRandomRegion(double fraction) {</span>
<span class="source-line-no">5401</span><span id="line.5401">        return quasiRandomRegion(fraction, -1);</span>
<span class="source-line-no">5402</span><span id="line.5402">    }</span>
<span class="source-line-no">5403</span><span id="line.5403">    /**</span>
<span class="source-line-no">5404</span><span id="line.5404">     * Modifies this GreasedRegion so it contains a quasi-random subset of its previous contents, choosing cells so that</span>
<span class="source-line-no">5405</span><span id="line.5405">     * the {@link #size()} matches the given {@code fraction} of the total amount of "on" cells in this. This is quasi-</span>
<span class="source-line-no">5406</span><span id="line.5406">     * random instead of pseudo-random because it is somewhat less likely to produce nearby cells in the result. If you</span>
<span class="source-line-no">5407</span><span id="line.5407">     * request too many cells (too high of a value for fraction), it will start to overlap, however.</span>
<span class="source-line-no">5408</span><span id="line.5408">     * Restricts the total count of "on" cells after this returns to a maximum of {@code limit} (minimum is 0 if no</span>
<span class="source-line-no">5409</span><span id="line.5409">     * cells are "on"). If limit is negative, this will not restrict the count.</span>
<span class="source-line-no">5410</span><span id="line.5410">     * &lt;br&gt;</span>
<span class="source-line-no">5411</span><span id="line.5411">     * You can choose between {@link #mixedRandomRegion(double)}, {@link #separatedRegionZCurve(double)},</span>
<span class="source-line-no">5412</span><span id="line.5412">     * {@link #separatedRegionBlue(double)}, and this method, where all are quasi-random, mixedRandom and</span>
<span class="source-line-no">5413</span><span id="line.5413">     * separatedRegionBlue are probably fastest, ZCurve and separatedRegionBlue may have better 2-dimensional gaps</span>
<span class="source-line-no">5414</span><span id="line.5414">     * between cells, and this method is somewhere in the middle.</span>
<span class="source-line-no">5415</span><span id="line.5415">     * @param fraction the fraction of "on" cells to randomly select, between 0.0 and 1.0</span>
<span class="source-line-no">5416</span><span id="line.5416">     * @param limit the maximum count of "on" cells to keep</span>
<span class="source-line-no">5417</span><span id="line.5417">     * @return this for chaining</span>
<span class="source-line-no">5418</span><span id="line.5418">     */</span>
<span class="source-line-no">5419</span><span id="line.5419">    public GreasedRegion quasiRandomRegion(double fraction, int limit) {</span>
<span class="source-line-no">5420</span><span id="line.5420">        GreasedRegion result = this;</span>
<span class="source-line-no">5421</span><span id="line.5421">        int ct = size(), idx, run = 0;</span>
<span class="source-line-no">5422</span><span id="line.5422">        if (ct &lt;= limit) {</span>
<span class="source-line-no">5423</span><span id="line.5423">        } else if (ct &lt;= 0) {</span>
<span class="source-line-no">5424</span><span id="line.5424">            result = empty();</span>
<span class="source-line-no">5425</span><span id="line.5425">        } else {</span>
<span class="source-line-no">5426</span><span id="line.5426">            if (limit &lt; 0)</span>
<span class="source-line-no">5427</span><span id="line.5427">                limit = (int) (fraction * ct);</span>
<span class="source-line-no">5428</span><span id="line.5428">            if (limit &lt;= 0) {</span>
<span class="source-line-no">5429</span><span id="line.5429">                result = empty();</span>
<span class="source-line-no">5430</span><span id="line.5430">            } else {</span>
<span class="source-line-no">5431</span><span id="line.5431">                int[] order = new int[limit];</span>
<span class="source-line-no">5432</span><span id="line.5432">                for (int i = 0, m = 1; i &lt; limit; i++, m++) {</span>
<span class="source-line-no">5433</span><span id="line.5433">                    idx = (int) (VanDerCorputQRNG.determine2(m) * ct);</span>
<span class="source-line-no">5434</span><span id="line.5434">                    BIG:</span>
<span class="source-line-no">5435</span><span id="line.5435">                    while (true) {</span>
<span class="source-line-no">5436</span><span id="line.5436">                        for (int j = 0; j &lt; i; j++) {</span>
<span class="source-line-no">5437</span><span id="line.5437">                            if (order[j] == idx) {</span>
<span class="source-line-no">5438</span><span id="line.5438">                                idx = (int) (VanDerCorputQRNG.determine2(++m) * ct);</span>
<span class="source-line-no">5439</span><span id="line.5439">                                continue BIG;</span>
<span class="source-line-no">5440</span><span id="line.5440">                            }</span>
<span class="source-line-no">5441</span><span id="line.5441">                        }</span>
<span class="source-line-no">5442</span><span id="line.5442">                        break;</span>
<span class="source-line-no">5443</span><span id="line.5443">                    }</span>
<span class="source-line-no">5444</span><span id="line.5444">                    order[i] = idx;</span>
<span class="source-line-no">5445</span><span id="line.5445">                }</span>
<span class="source-line-no">5446</span><span id="line.5446">                idx = 0;</span>
<span class="source-line-no">5447</span><span id="line.5447">                Arrays.sort(order);</span>
<span class="source-line-no">5448</span><span id="line.5448">                long t, w;</span>
<span class="source-line-no">5449</span><span id="line.5449">                ALL:</span>
<span class="source-line-no">5450</span><span id="line.5450">                for (int s = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">5451</span><span id="line.5451">                    for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">5452</span><span id="line.5452">                        if ((t = data[x * ySections + s]) != 0) {</span>
<span class="source-line-no">5453</span><span id="line.5453">                            w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">5454</span><span id="line.5454">                            while (w != 0) {</span>
<span class="source-line-no">5455</span><span id="line.5455">                                if (run++ == order[idx]) {</span>
<span class="source-line-no">5456</span><span id="line.5456">                                    if (++idx &gt;= limit) {</span>
<span class="source-line-no">5457</span><span id="line.5457">                                        data[x * ySections + s] &amp;= (w &lt;&lt; 1) - 1;</span>
<span class="source-line-no">5458</span><span id="line.5458">                                        for (int rx = x + 1; rx &lt; width; rx++) {</span>
<span class="source-line-no">5459</span><span id="line.5459">                                            data[rx * ySections + s] = 0;</span>
<span class="source-line-no">5460</span><span id="line.5460">                                        }</span>
<span class="source-line-no">5461</span><span id="line.5461">                                        for (int rs = s + 1; rs &lt; ySections; rs++) {</span>
<span class="source-line-no">5462</span><span id="line.5462">                                            for (int rx = 0; rx &lt; width; rx++) {</span>
<span class="source-line-no">5463</span><span id="line.5463">                                                data[rx * ySections + rs] = 0;</span>
<span class="source-line-no">5464</span><span id="line.5464">                                            }</span>
<span class="source-line-no">5465</span><span id="line.5465">                                        }</span>
<span class="source-line-no">5466</span><span id="line.5466">                                        break ALL;</span>
<span class="source-line-no">5467</span><span id="line.5467">                                    }</span>
<span class="source-line-no">5468</span><span id="line.5468">                                } else {</span>
<span class="source-line-no">5469</span><span id="line.5469">                                    data[x * ySections + s] ^= w;</span>
<span class="source-line-no">5470</span><span id="line.5470">                                }</span>
<span class="source-line-no">5471</span><span id="line.5471">                                t ^= w;</span>
<span class="source-line-no">5472</span><span id="line.5472">                                w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">5473</span><span id="line.5473">                            }</span>
<span class="source-line-no">5474</span><span id="line.5474">                        }</span>
<span class="source-line-no">5475</span><span id="line.5475">                    }</span>
<span class="source-line-no">5476</span><span id="line.5476">                }</span>
<span class="source-line-no">5477</span><span id="line.5477">                tallied = false;</span>
<span class="source-line-no">5478</span><span id="line.5478">            }</span>
<span class="source-line-no">5479</span><span id="line.5479">        }</span>
<span class="source-line-no">5480</span><span id="line.5480">        return result;</span>
<span class="source-line-no">5481</span><span id="line.5481">    }</span>
<span class="source-line-no">5482</span><span id="line.5482"></span>
<span class="source-line-no">5483</span><span id="line.5483">    /**</span>
<span class="source-line-no">5484</span><span id="line.5484">     * Like {@link #retract()}, this removes the "on" cells that are 4-way-adjacent to any "off" cell, but unlike that</span>
<span class="source-line-no">5485</span><span id="line.5485">     * method it keeps a fraction of those surface cells, quasi-randomly selecting them. This can be thought of as</span>
<span class="source-line-no">5486</span><span id="line.5486">     * running {@link #surface()} on a copy of this GreasedRegion, running {@link #separatedRegionBlue(double)} on that</span>
<span class="source-line-no">5487</span><span id="line.5487">     * surface with the given fractionKept, taking the original GreasedRegion and removing its whole surface with</span>
<span class="source-line-no">5488</span><span id="line.5488">     * {@link #retract()}, then inserting the quasi-randomly-removed surface into this GreasedRegion to replace its</span>
<span class="source-line-no">5489</span><span id="line.5489">     * surface with a randomly "damaged" one.</span>
<span class="source-line-no">5490</span><span id="line.5490">     * @param fractionKept the fraction between 0.0 and 1.0 of how many cells on the outer surface of this to keep "on"</span>
<span class="source-line-no">5491</span><span id="line.5491">     * @return this for chaining</span>
<span class="source-line-no">5492</span><span id="line.5492">     */</span>
<span class="source-line-no">5493</span><span id="line.5493">    public GreasedRegion fray(double fractionKept)</span>
<span class="source-line-no">5494</span><span id="line.5494">    {</span>
<span class="source-line-no">5495</span><span id="line.5495">        GreasedRegion cpy = new GreasedRegion(this).retract();</span>
<span class="source-line-no">5496</span><span id="line.5496">        return xor(cpy).separatedRegionBlue(fractionKept).or(cpy);</span>
<span class="source-line-no">5497</span><span id="line.5497">    }</span>
<span class="source-line-no">5498</span><span id="line.5498"></span>
<span class="source-line-no">5499</span><span id="line.5499">    /**</span>
<span class="source-line-no">5500</span><span id="line.5500">     * Like {@link #retract()}, this removes the "on" cells that are 4-way-adjacent to any "off" cell, but unlike that</span>
<span class="source-line-no">5501</span><span id="line.5501">     * method it keeps a fraction of those surface cells, randomly selecting them. This can be thought of as running </span>
<span class="source-line-no">5502</span><span id="line.5502">     * {@link #surface()} on a copy of this GreasedRegion, running {@link #deteriorate(RandomnessSource, double)} on</span>
<span class="source-line-no">5503</span><span id="line.5503">     * that surface with the given fractionKept, taking the original GreasedRegion and removing its whole surface with</span>
<span class="source-line-no">5504</span><span id="line.5504">     * {@link #retract()}, then inserting the randomly-removed surface into this GreasedRegion to replace its surface</span>
<span class="source-line-no">5505</span><span id="line.5505">     * with a randomly "damaged" one.</span>
<span class="source-line-no">5506</span><span id="line.5506">     * @param random any non-null RandomnessSource, such as an {@link RNG}, {@link GWTRNG}, or {@link TangleRNG}</span>
<span class="source-line-no">5507</span><span id="line.5507">     * @param fractionKept the fraction between 0.0 and 1.0 of how many cells on the outer surface of this to keep "on"</span>
<span class="source-line-no">5508</span><span id="line.5508">     * @return this for chaining</span>
<span class="source-line-no">5509</span><span id="line.5509">     */</span>
<span class="source-line-no">5510</span><span id="line.5510">    public GreasedRegion fray(RandomnessSource random, double fractionKept)</span>
<span class="source-line-no">5511</span><span id="line.5511">    {</span>
<span class="source-line-no">5512</span><span id="line.5512">        GreasedRegion cpy = new GreasedRegion(this).retract();</span>
<span class="source-line-no">5513</span><span id="line.5513">        return xor(cpy).deteriorate(random, fractionKept).or(cpy);</span>
<span class="source-line-no">5514</span><span id="line.5514">    }</span>
<span class="source-line-no">5515</span><span id="line.5515"></span>
<span class="source-line-no">5516</span><span id="line.5516">    /**</span>
<span class="source-line-no">5517</span><span id="line.5517">     * Modifies this GreasedRegion so it contains a random subset of its previous contents, choosing cells so that the</span>
<span class="source-line-no">5518</span><span id="line.5518">     * distance between any two "on" cells is at least {@code minimumDistance}, with at least one cell as "on" if any</span>
<span class="source-line-no">5519</span><span id="line.5519">     * were "on" in this originally. Does not limit the count of "on" cells in the result.</span>
<span class="source-line-no">5520</span><span id="line.5520">     * @param rng used to generate random positions</span>
<span class="source-line-no">5521</span><span id="line.5521">     * @param minimumDistance the minimum distance between "on" cells in the result</span>
<span class="source-line-no">5522</span><span id="line.5522">     * @return this for chaining</span>
<span class="source-line-no">5523</span><span id="line.5523">     */</span>
<span class="source-line-no">5524</span><span id="line.5524">    public GreasedRegion randomScatter(IRNG rng, int minimumDistance) {</span>
<span class="source-line-no">5525</span><span id="line.5525">        return randomScatter(rng, minimumDistance, -1);</span>
<span class="source-line-no">5526</span><span id="line.5526">    }</span>
<span class="source-line-no">5527</span><span id="line.5527">    /**</span>
<span class="source-line-no">5528</span><span id="line.5528">     * Modifies this GreasedRegion so it contains a random subset of its previous contents, choosing cells so that the</span>
<span class="source-line-no">5529</span><span id="line.5529">     * distance between any two "on" cells is at least {@code minimumDistance}, with at least one cell as "on" if any</span>
<span class="source-line-no">5530</span><span id="line.5530">     * were "on" in this originally.</span>
<span class="source-line-no">5531</span><span id="line.5531">     * Restricts the total count of "on" cells after this returns to a maximum of {@code limit} (minimum is 0 if no</span>
<span class="source-line-no">5532</span><span id="line.5532">     * cells are "on"). If limit is negative, this will not restrict the count.</span>
<span class="source-line-no">5533</span><span id="line.5533">     * @param rng used to generate random positions</span>
<span class="source-line-no">5534</span><span id="line.5534">     * @param minimumDistance the minimum distance between "on" cells in the result</span>
<span class="source-line-no">5535</span><span id="line.5535">     * @param limit the maximum count of "on" cells to keep</span>
<span class="source-line-no">5536</span><span id="line.5536">     * @return this for chaining</span>
<span class="source-line-no">5537</span><span id="line.5537">     */</span>
<span class="source-line-no">5538</span><span id="line.5538">    public GreasedRegion randomScatter(IRNG rng, int minimumDistance, int limit) {</span>
<span class="source-line-no">5539</span><span id="line.5539">        GreasedRegion result = this;</span>
<span class="source-line-no">5540</span><span id="line.5540">        int tmp, total = 0, ct;</span>
<span class="source-line-no">5541</span><span id="line.5541">        tally();</span>
<span class="source-line-no">5542</span><span id="line.5542">        if (this.ct == 0) {</span>
<span class="source-line-no">5543</span><span id="line.5543">        } else if (limit == 0) {</span>
<span class="source-line-no">5544</span><span id="line.5544">            result = empty();</span>
<span class="source-line-no">5545</span><span id="line.5545">        } else {</span>
<span class="source-line-no">5546</span><span id="line.5546">            if (limit &lt; 0)</span>
<span class="source-line-no">5547</span><span id="line.5547">                limit = width * height;</span>
<span class="source-line-no">5548</span><span id="line.5548">            long t, w;</span>
<span class="source-line-no">5549</span><span id="line.5549">            long[] data2 = new long[data.length];</span>
<span class="source-line-no">5550</span><span id="line.5550">            MAIN_LOOP:</span>
<span class="source-line-no">5551</span><span id="line.5551">            while (total &lt; limit) {</span>
<span class="source-line-no">5552</span><span id="line.5552">                if (!tallied)</span>
<span class="source-line-no">5553</span><span id="line.5553">                    tally();</span>
<span class="source-line-no">5554</span><span id="line.5554">                tmp = rng.nextInt(this.ct);</span>
<span class="source-line-no">5555</span><span id="line.5555"></span>
<span class="source-line-no">5556</span><span id="line.5556">                for (int s = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">5557</span><span id="line.5557">                    for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">5558</span><span id="line.5558">                        if ((ct = counts[x * ySections + s]) &gt; tmp) {</span>
<span class="source-line-no">5559</span><span id="line.5559">                            t = data[x * ySections + s];</span>
<span class="source-line-no">5560</span><span id="line.5560">                            w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">5561</span><span id="line.5561">                            for (--ct; w != 0; ct--) {</span>
<span class="source-line-no">5562</span><span id="line.5562">                                if (ct == tmp) {</span>
<span class="source-line-no">5563</span><span id="line.5563">                                    removeRectangle(x - minimumDistance,</span>
<span class="source-line-no">5564</span><span id="line.5564">                                            ((s &lt;&lt; 6) | Long.numberOfTrailingZeros(w)) - minimumDistance,</span>
<span class="source-line-no">5565</span><span id="line.5565">                                            minimumDistance &lt;&lt; 1 | 1, minimumDistance &lt;&lt; 1 | 1);</span>
<span class="source-line-no">5566</span><span id="line.5566">                                    data2[x * ySections + s] |= w;</span>
<span class="source-line-no">5567</span><span id="line.5567">                                    ++total;</span>
<span class="source-line-no">5568</span><span id="line.5568">                                    continue MAIN_LOOP;</span>
<span class="source-line-no">5569</span><span id="line.5569">                                }</span>
<span class="source-line-no">5570</span><span id="line.5570">                                t ^= w;</span>
<span class="source-line-no">5571</span><span id="line.5571">                                w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">5572</span><span id="line.5572">                            }</span>
<span class="source-line-no">5573</span><span id="line.5573">                        }</span>
<span class="source-line-no">5574</span><span id="line.5574">                    }</span>
<span class="source-line-no">5575</span><span id="line.5575">                }</span>
<span class="source-line-no">5576</span><span id="line.5576">                break;</span>
<span class="source-line-no">5577</span><span id="line.5577">            }</span>
<span class="source-line-no">5578</span><span id="line.5578">            data = data2;</span>
<span class="source-line-no">5579</span><span id="line.5579">            tallied = false;</span>
<span class="source-line-no">5580</span><span id="line.5580">        }</span>
<span class="source-line-no">5581</span><span id="line.5581">        return result;</span>
<span class="source-line-no">5582</span><span id="line.5582">    }</span>
<span class="source-line-no">5583</span><span id="line.5583"></span>
<span class="source-line-no">5584</span><span id="line.5584">    public double rateDensity() {</span>
<span class="source-line-no">5585</span><span id="line.5585">        double result = 0;</span>
<span class="source-line-no">5586</span><span id="line.5586">        double sz = height * width;</span>
<span class="source-line-no">5587</span><span id="line.5587">        if (sz != 0) {</span>
<span class="source-line-no">5588</span><span id="line.5588">            double onAmount = sz - size(), retractedOn = sz - copy().retract().size();</span>
<span class="source-line-no">5589</span><span id="line.5589">            result = (onAmount + retractedOn) / (sz * 2.0);</span>
<span class="source-line-no">5590</span><span id="line.5590">        }</span>
<span class="source-line-no">5591</span><span id="line.5591">        return result;</span>
<span class="source-line-no">5592</span><span id="line.5592">    }</span>
<span class="source-line-no">5593</span><span id="line.5593">    public double rateRegularity() {</span>
<span class="source-line-no">5594</span><span id="line.5594">        double result = 0;</span>
<span class="source-line-no">5595</span><span id="line.5595">        GreasedRegion me2 = copy().surface8way();</span>
<span class="source-line-no">5596</span><span id="line.5596">        double irregularCount = me2.size();</span>
<span class="source-line-no">5597</span><span id="line.5597">        if (irregularCount != 0) {</span>
<span class="source-line-no">5598</span><span id="line.5598">            result = me2.remake(this).surface().size() / irregularCount;</span>
<span class="source-line-no">5599</span><span id="line.5599">        }</span>
<span class="source-line-no">5600</span><span id="line.5600">        return result;</span>
<span class="source-line-no">5601</span><span id="line.5601">    }</span>
<span class="source-line-no">5602</span><span id="line.5602"></span>
<span class="source-line-no">5603</span><span id="line.5603">    private static int median(int[] working, int start, int amount) {</span>
<span class="source-line-no">5604</span><span id="line.5604">        int result;</span>
<span class="source-line-no">5605</span><span id="line.5605">        Arrays.sort(working, start, start + amount);</span>
<span class="source-line-no">5606</span><span id="line.5606">        if ((amount &amp; 1) == 0) {</span>
<span class="source-line-no">5607</span><span id="line.5607">            result = working[start + (amount &gt;&gt; 1) - 1] + working[start + (amount &gt;&gt; 1)] &gt;&gt;&gt; 1;</span>
<span class="source-line-no">5608</span><span id="line.5608">        } else {</span>
<span class="source-line-no">5609</span><span id="line.5609">            result = working[start + (amount &gt;&gt; 1)];</span>
<span class="source-line-no">5610</span><span id="line.5610">        }</span>
<span class="source-line-no">5611</span><span id="line.5611">        return result;</span>
<span class="source-line-no">5612</span><span id="line.5612">    }</span>
<span class="source-line-no">5613</span><span id="line.5613"></span>
<span class="source-line-no">5614</span><span id="line.5614">    /**</span>
<span class="source-line-no">5615</span><span id="line.5615">     * Calculates a perceptual hash for this GreasedRegion using a method that is only precise for some sizes of</span>
<span class="source-line-no">5616</span><span id="line.5616">     * GreasedRegion; it writes a result to into, and uses working as a temporary buffer. The lengths of into and</span>
<span class="source-line-no">5617</span><span id="line.5617">     * working should be related; if into is length 1, then working should be length 64, and though the hash won't be</span>
<span class="source-line-no">5618</span><span id="line.5618">     * very detailed, it will work well for images with width and height that are multiples of 8; if into is length 4,</span>
<span class="source-line-no">5619</span><span id="line.5619">     * then working should be length 256, and this will work with more detail on images that have width and height that</span>
<span class="source-line-no">5620</span><span id="line.5620">     * are multiples of 16. If working is null or is too small, then this won't reuse it and will allocate an</span>
<span class="source-line-no">5621</span><span id="line.5621">     * appropriately-sized array for internal use.</span>
<span class="source-line-no">5622</span><span id="line.5622">     * &lt;br&gt;</span>
<span class="source-line-no">5623</span><span id="line.5623">     * Ported from https://github.com/commonsmachinery/blockhash/blob/master/blockhash.c , which is MIT-licensed.</span>
<span class="source-line-no">5624</span><span id="line.5624">     * @param into should be a long array of length 1 or 4; the contents don't matter and this will be where output is written to</span>
<span class="source-line-no">5625</span><span id="line.5625">     * @param working should be an int array of length 64 (if into has length 1) or 256 (if into has length 4); may be null if you like garbage collection</span>
<span class="source-line-no">5626</span><span id="line.5626">     */</span>
<span class="source-line-no">5627</span><span id="line.5627">    public void perceptualHashQuick(long[] into, int[] working)</span>
<span class="source-line-no">5628</span><span id="line.5628">    {</span>
<span class="source-line-no">5629</span><span id="line.5629">        final int bits = 8 &lt;&lt; (Integer.numberOfTrailingZeros(Integer.highestOneBit(into.length)) &gt;&gt; 1);</span>
<span class="source-line-no">5630</span><span id="line.5630">        if(working == null || working.length &lt; bits * bits)</span>
<span class="source-line-no">5631</span><span id="line.5631">            working = new int[bits * bits];</span>
<span class="source-line-no">5632</span><span id="line.5632">        final int blockWidth = width / bits, blockHeight = height / bits, blockWidthSections = blockWidth * ySections;</span>
<span class="source-line-no">5633</span><span id="line.5633">        if(blockHeight == 1)</span>
<span class="source-line-no">5634</span><span id="line.5634">        {</span>
<span class="source-line-no">5635</span><span id="line.5635">            for (int y = 0; y &lt; bits; y++) {</span>
<span class="source-line-no">5636</span><span id="line.5636">                for (int x = 0; x &lt; bits; x++) {</span>
<span class="source-line-no">5637</span><span id="line.5637">                    int value = 0;</span>
<span class="source-line-no">5638</span><span id="line.5638">                    for (int ix = 0; ix &lt; blockWidthSections; ix += ySections) {</span>
<span class="source-line-no">5639</span><span id="line.5639">                        value += (data[x * blockWidthSections + ix + (y &gt;&gt; 6)] &gt;&gt;&gt; (y &amp; 63) &amp; 1L);</span>
<span class="source-line-no">5640</span><span id="line.5640">                    }</span>
<span class="source-line-no">5641</span><span id="line.5641">                    working[x * bits + y] = value;</span>
<span class="source-line-no">5642</span><span id="line.5642">                }</span>
<span class="source-line-no">5643</span><span id="line.5643">            }</span>
<span class="source-line-no">5644</span><span id="line.5644">        }</span>
<span class="source-line-no">5645</span><span id="line.5645">        else if(blockHeight &lt; 64 &amp;&amp; Integer.bitCount(blockHeight) == 1) {</span>
<span class="source-line-no">5646</span><span id="line.5646">            final long yBlockMask = ~(-1L &lt;&lt; blockHeight);</span>
<span class="source-line-no">5647</span><span id="line.5647">            final int divisorMask = (64 / blockHeight) - 1;</span>
<span class="source-line-no">5648</span><span id="line.5648">            long currentMask;</span>
<span class="source-line-no">5649</span><span id="line.5649">            int blockY = 0;</span>
<span class="source-line-no">5650</span><span id="line.5650">            for (int y = 0; y &lt; bits; y++, blockY += blockHeight) {</span>
<span class="source-line-no">5651</span><span id="line.5651">                currentMask = yBlockMask &lt;&lt; ((y &amp; divisorMask) &lt;&lt; blockHeight);</span>
<span class="source-line-no">5652</span><span id="line.5652">                for (int x = 0; x &lt; bits; x++) {</span>
<span class="source-line-no">5653</span><span id="line.5653">                    int value = 0;</span>
<span class="source-line-no">5654</span><span id="line.5654">                    for (int ix = 0; ix &lt; blockWidthSections; ix += ySections) {</span>
<span class="source-line-no">5655</span><span id="line.5655">                        value += Long.bitCount(data[x * blockWidthSections + ix + (blockY &gt;&gt; 6)] &amp; currentMask);</span>
<span class="source-line-no">5656</span><span id="line.5656">                    }</span>
<span class="source-line-no">5657</span><span id="line.5657">                    working[x * bits + y] = value;</span>
<span class="source-line-no">5658</span><span id="line.5658">                }</span>
<span class="source-line-no">5659</span><span id="line.5659">            }</span>
<span class="source-line-no">5660</span><span id="line.5660">        }</span>
<span class="source-line-no">5661</span><span id="line.5661">        final int cellsPerBlock = blockWidth * blockHeight, numBlocks = bits * bits,</span>
<span class="source-line-no">5662</span><span id="line.5662">                halfCellCount = cellsPerBlock &gt;&gt;&gt; 1;</span>
<span class="source-line-no">5663</span><span id="line.5663">        int bandSize = numBlocks &gt;&gt;&gt; 2;</span>
<span class="source-line-no">5664</span><span id="line.5664">        int m, v;</span>
<span class="source-line-no">5665</span><span id="line.5665">        int currentInto = 0;</span>
<span class="source-line-no">5666</span><span id="line.5666">        long currentIntoPos = 1L;</span>
<span class="source-line-no">5667</span><span id="line.5667">        for (int i = 0; i &lt; 4; i++) {</span>
<span class="source-line-no">5668</span><span id="line.5668">            m = median(working, i * bandSize, bandSize);</span>
<span class="source-line-no">5669</span><span id="line.5669">            for (int j = i * bandSize; j &lt; (i + 1) * bandSize; j++) {</span>
<span class="source-line-no">5670</span><span id="line.5670">                v = working[j];</span>
<span class="source-line-no">5671</span><span id="line.5671">                if(v &gt; m || (v - m == 0 &amp;&amp; m &gt; halfCellCount)) into[currentInto] |= currentIntoPos;</span>
<span class="source-line-no">5672</span><span id="line.5672">                if((currentIntoPos &lt;&lt;= 1) == 0)</span>
<span class="source-line-no">5673</span><span id="line.5673">                {</span>
<span class="source-line-no">5674</span><span id="line.5674">                    ++currentInto;</span>
<span class="source-line-no">5675</span><span id="line.5675">                    currentIntoPos = 1L;</span>
<span class="source-line-no">5676</span><span id="line.5676">                }</span>
<span class="source-line-no">5677</span><span id="line.5677">            }</span>
<span class="source-line-no">5678</span><span id="line.5678">        }</span>
<span class="source-line-no">5679</span><span id="line.5679">    }</span>
<span class="source-line-no">5680</span><span id="line.5680"></span>
<span class="source-line-no">5681</span><span id="line.5681">    /*</span>
<span class="source-line-no">5682</span><span id="line.5682">    // This showed a strong x-y correlation because it didn't have a way to use a non-base-2 van der Corput sequence.</span>
<span class="source-line-no">5683</span><span id="line.5683">    // It also produced very close-together points, unfortunately.</span>
<span class="source-line-no">5684</span><span id="line.5684">    public static double quasiRandomX(int idx)</span>
<span class="source-line-no">5685</span><span id="line.5685">    {</span>
<span class="source-line-no">5686</span><span id="line.5686">        return atVDCSequence(26 + idx * 5);</span>
<span class="source-line-no">5687</span><span id="line.5687">    }</span>
<span class="source-line-no">5688</span><span id="line.5688">    public static double quasiRandomY(int idx)</span>
<span class="source-line-no">5689</span><span id="line.5689">    {</span>
<span class="source-line-no">5690</span><span id="line.5690">        return atVDCSequence(19 + idx * 3);</span>
<span class="source-line-no">5691</span><span id="line.5691">    }</span>
<span class="source-line-no">5692</span><span id="line.5692"></span>
<span class="source-line-no">5693</span><span id="line.5693">    private static double atVDCSequence(int idx)</span>
<span class="source-line-no">5694</span><span id="line.5694">    {</span>
<span class="source-line-no">5695</span><span id="line.5695">        int leading = Integer.numberOfLeadingZeros(idx);</span>
<span class="source-line-no">5696</span><span id="line.5696">        return (Integer.reverse(idx) &gt;&gt;&gt; leading) / (1.0 * (1 &lt;&lt; (32 - leading)));</span>
<span class="source-line-no">5697</span><span id="line.5697">    }</span>
<span class="source-line-no">5698</span><span id="line.5698">    */</span>
<span class="source-line-no">5699</span><span id="line.5699">    public Coord[] asCoords()</span>
<span class="source-line-no">5700</span><span id="line.5700">    {</span>
<span class="source-line-no">5701</span><span id="line.5701">        return asCoords(new Coord[size()]);</span>
<span class="source-line-no">5702</span><span id="line.5702"></span>
<span class="source-line-no">5703</span><span id="line.5703">    }</span>
<span class="source-line-no">5704</span><span id="line.5704">    public Coord[] asCoords(Coord[] points) {</span>
<span class="source-line-no">5705</span><span id="line.5705">        Coord[] result = null;</span>
<span class="source-line-no">5706</span><span id="line.5706">        if (points == null)</span>
<span class="source-line-no">5707</span><span id="line.5707">            points = new Coord[size()];</span>
<span class="source-line-no">5708</span><span id="line.5708">        int idx = 0, len = points.length;</span>
<span class="source-line-no">5709</span><span id="line.5709">        long t, w;</span>
<span class="source-line-no">5710</span><span id="line.5710">        for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">5711</span><span id="line.5711">            for (int s = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">5712</span><span id="line.5712">                if ((t = data[x * ySections + s]) != 0) {</span>
<span class="source-line-no">5713</span><span id="line.5713">                    w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">5714</span><span id="line.5714">                    while (w != 0) {</span>
<span class="source-line-no">5715</span><span id="line.5715">                        if (idx &gt;= len) {</span>
<span class="source-line-no">5716</span><span id="line.5716">                            result = points;</span>
<span class="source-line-no">5717</span><span id="line.5717">                            break;</span>
<span class="source-line-no">5718</span><span id="line.5718">                        }</span>
<span class="source-line-no">5719</span><span id="line.5719">                        points[idx++] = Coord.get(x, (s &lt;&lt; 6) | Long.numberOfTrailingZeros(w));</span>
<span class="source-line-no">5720</span><span id="line.5720">                        t ^= w;</span>
<span class="source-line-no">5721</span><span id="line.5721">                        w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">5722</span><span id="line.5722">                    }</span>
<span class="source-line-no">5723</span><span id="line.5723">                    if (result != null) break;</span>
<span class="source-line-no">5724</span><span id="line.5724">                }</span>
<span class="source-line-no">5725</span><span id="line.5725">            }</span>
<span class="source-line-no">5726</span><span id="line.5726">            if (result != null) break;</span>
<span class="source-line-no">5727</span><span id="line.5727">        }</span>
<span class="source-line-no">5728</span><span id="line.5728">        if (result == null) {</span>
<span class="source-line-no">5729</span><span id="line.5729">            result = points;</span>
<span class="source-line-no">5730</span><span id="line.5730">        }</span>
<span class="source-line-no">5731</span><span id="line.5731">        return result;</span>
<span class="source-line-no">5732</span><span id="line.5732">    }</span>
<span class="source-line-no">5733</span><span id="line.5733">    public int[] asEncoded()</span>
<span class="source-line-no">5734</span><span id="line.5734">    {</span>
<span class="source-line-no">5735</span><span id="line.5735">        int ct = size(), idx = 0;</span>
<span class="source-line-no">5736</span><span id="line.5736">        int[] points = new int[ct];</span>
<span class="source-line-no">5737</span><span id="line.5737">        long t, w;</span>
<span class="source-line-no">5738</span><span id="line.5738">        for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">5739</span><span id="line.5739">            for (int s = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">5740</span><span id="line.5740">                if((t = data[x * ySections + s]) != 0)</span>
<span class="source-line-no">5741</span><span id="line.5741">                {</span>
<span class="source-line-no">5742</span><span id="line.5742">                    w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">5743</span><span id="line.5743">                    while (w != 0) {</span>
<span class="source-line-no">5744</span><span id="line.5744">                        points[idx++] = Coord.pureEncode(x, (s &lt;&lt; 6) | Long.numberOfTrailingZeros(w));</span>
<span class="source-line-no">5745</span><span id="line.5745">                        t ^= w;</span>
<span class="source-line-no">5746</span><span id="line.5746">                        w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">5747</span><span id="line.5747">                    }</span>
<span class="source-line-no">5748</span><span id="line.5748">                }</span>
<span class="source-line-no">5749</span><span id="line.5749">            }</span>
<span class="source-line-no">5750</span><span id="line.5750">        }</span>
<span class="source-line-no">5751</span><span id="line.5751">        return points;</span>
<span class="source-line-no">5752</span><span id="line.5752">    }</span>
<span class="source-line-no">5753</span><span id="line.5753">    public int[] asTightEncoded()</span>
<span class="source-line-no">5754</span><span id="line.5754">    {</span>
<span class="source-line-no">5755</span><span id="line.5755">        int ct = size(), idx = 0;</span>
<span class="source-line-no">5756</span><span id="line.5756">        int[] points = new int[ct];</span>
<span class="source-line-no">5757</span><span id="line.5757">        long t, w;</span>
<span class="source-line-no">5758</span><span id="line.5758">        for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">5759</span><span id="line.5759">            for (int s = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">5760</span><span id="line.5760">                if((t = data[x * ySections + s]) != 0)</span>
<span class="source-line-no">5761</span><span id="line.5761">                {</span>
<span class="source-line-no">5762</span><span id="line.5762">                    w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">5763</span><span id="line.5763">                    while (w != 0) {</span>
<span class="source-line-no">5764</span><span id="line.5764">                        points[idx++] =  ((s &lt;&lt; 6) | Long.numberOfTrailingZeros(w)) * width + x;</span>
<span class="source-line-no">5765</span><span id="line.5765">                        t ^= w;</span>
<span class="source-line-no">5766</span><span id="line.5766">                        w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">5767</span><span id="line.5767">                    }</span>
<span class="source-line-no">5768</span><span id="line.5768">                }</span>
<span class="source-line-no">5769</span><span id="line.5769">            }</span>
<span class="source-line-no">5770</span><span id="line.5770">        }</span>
<span class="source-line-no">5771</span><span id="line.5771">        return points;</span>
<span class="source-line-no">5772</span><span id="line.5772">    }</span>
<span class="source-line-no">5773</span><span id="line.5773"></span>
<span class="source-line-no">5774</span><span id="line.5774">    /**</span>
<span class="source-line-no">5775</span><span id="line.5775">     * @return All cells in this zone.</span>
<span class="source-line-no">5776</span><span id="line.5776">     */</span>
<span class="source-line-no">5777</span><span id="line.5777">    @Override</span>
<span class="source-line-no">5778</span><span id="line.5778">    public List&lt;Coord&gt; getAll() {</span>
<span class="source-line-no">5779</span><span id="line.5779">        ArrayList&lt;Coord&gt; points = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">5780</span><span id="line.5780">        long t, w;</span>
<span class="source-line-no">5781</span><span id="line.5781">        for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">5782</span><span id="line.5782">            for (int s = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">5783</span><span id="line.5783">                if((t = data[x * ySections + s]) != 0)</span>
<span class="source-line-no">5784</span><span id="line.5784">                {</span>
<span class="source-line-no">5785</span><span id="line.5785">                    w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">5786</span><span id="line.5786">                    while (w != 0) {</span>
<span class="source-line-no">5787</span><span id="line.5787">                        points.add(Coord.get(x, (s &lt;&lt; 6) | Long.numberOfTrailingZeros(w)));</span>
<span class="source-line-no">5788</span><span id="line.5788">                        t ^= w;</span>
<span class="source-line-no">5789</span><span id="line.5789">                        w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">5790</span><span id="line.5790">                    }</span>
<span class="source-line-no">5791</span><span id="line.5791">                }</span>
<span class="source-line-no">5792</span><span id="line.5792">            }</span>
<span class="source-line-no">5793</span><span id="line.5793">        }</span>
<span class="source-line-no">5794</span><span id="line.5794">        return points;</span>
<span class="source-line-no">5795</span><span id="line.5795"></span>
<span class="source-line-no">5796</span><span id="line.5796">    }</span>
<span class="source-line-no">5797</span><span id="line.5797"></span>
<span class="source-line-no">5798</span><span id="line.5798">    /**</span>
<span class="source-line-no">5799</span><span id="line.5799">     * Gets the first Coord in the iteration order, or (-1,-1) if this GreasedRegion is empty.</span>
<span class="source-line-no">5800</span><span id="line.5800">     * @return the first Coord in the iteration order, or (-1,-1) if this GreasedRegion is empty</span>
<span class="source-line-no">5801</span><span id="line.5801">     */</span>
<span class="source-line-no">5802</span><span id="line.5802">    public Coord first()</span>
<span class="source-line-no">5803</span><span id="line.5803">    {</span>
<span class="source-line-no">5804</span><span id="line.5804">        long w;</span>
<span class="source-line-no">5805</span><span id="line.5805">        for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">5806</span><span id="line.5806">            for (int s = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">5807</span><span id="line.5807">                if ((w = (data[x * ySections + s])) != 0) {</span>
<span class="source-line-no">5808</span><span id="line.5808">                    return Coord.get(x, (s &lt;&lt; 6) | Long.numberOfTrailingZeros(w));</span>
<span class="source-line-no">5809</span><span id="line.5809">                }</span>
<span class="source-line-no">5810</span><span id="line.5810">            }</span>
<span class="source-line-no">5811</span><span id="line.5811">        }</span>
<span class="source-line-no">5812</span><span id="line.5812">        return Coord.get(-1, -1);</span>
<span class="source-line-no">5813</span><span id="line.5813">    }</span>
<span class="source-line-no">5814</span><span id="line.5814"></span>
<span class="source-line-no">5815</span><span id="line.5815">    public int firstTight()</span>
<span class="source-line-no">5816</span><span id="line.5816">    {</span>
<span class="source-line-no">5817</span><span id="line.5817">        long w;</span>
<span class="source-line-no">5818</span><span id="line.5818">        for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">5819</span><span id="line.5819">            for (int s = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">5820</span><span id="line.5820">                if ((w = (data[x * ySections + s])) != 0) {</span>
<span class="source-line-no">5821</span><span id="line.5821">                    return ((s &lt;&lt; 6) | Long.numberOfTrailingZeros(w)) * width + x;</span>
<span class="source-line-no">5822</span><span id="line.5822">                }</span>
<span class="source-line-no">5823</span><span id="line.5823">            }</span>
<span class="source-line-no">5824</span><span id="line.5824">        }</span>
<span class="source-line-no">5825</span><span id="line.5825">        return -1;</span>
<span class="source-line-no">5826</span><span id="line.5826">    }</span>
<span class="source-line-no">5827</span><span id="line.5827"></span>
<span class="source-line-no">5828</span><span id="line.5828">    /**</span>
<span class="source-line-no">5829</span><span id="line.5829">     * Gets the last Coord in the iteration order, or (-1,-1) if this GreasedRegion is empty.</span>
<span class="source-line-no">5830</span><span id="line.5830">     * @return the last Coord in the iteration order, or (-1,-1) if this GreasedRegion is empty</span>
<span class="source-line-no">5831</span><span id="line.5831">     */</span>
<span class="source-line-no">5832</span><span id="line.5832">    public Coord last()</span>
<span class="source-line-no">5833</span><span id="line.5833">    {</span>
<span class="source-line-no">5834</span><span id="line.5834">        long w;</span>
<span class="source-line-no">5835</span><span id="line.5835">        for (int x = width - 1; x &gt;= 0; x--) {</span>
<span class="source-line-no">5836</span><span id="line.5836">            for (int s = ySections - 1; s &gt;= 0; s--) {</span>
<span class="source-line-no">5837</span><span id="line.5837">                if ((w = (data[x * ySections + s])) != 0) {</span>
<span class="source-line-no">5838</span><span id="line.5838">                    return Coord.get(x, (s &lt;&lt; 6) | 63 - Long.numberOfLeadingZeros(w));</span>
<span class="source-line-no">5839</span><span id="line.5839">                }</span>
<span class="source-line-no">5840</span><span id="line.5840">            }</span>
<span class="source-line-no">5841</span><span id="line.5841">        }</span>
<span class="source-line-no">5842</span><span id="line.5842">        return Coord.get(-1, -1);</span>
<span class="source-line-no">5843</span><span id="line.5843">    }</span>
<span class="source-line-no">5844</span><span id="line.5844"></span>
<span class="source-line-no">5845</span><span id="line.5845">    public int lastTight()</span>
<span class="source-line-no">5846</span><span id="line.5846">    {</span>
<span class="source-line-no">5847</span><span id="line.5847">        long w;</span>
<span class="source-line-no">5848</span><span id="line.5848">        for (int x = width - 1; x &gt;= 0; x--) {</span>
<span class="source-line-no">5849</span><span id="line.5849">            for (int s = ySections - 1; s &gt;= 0; s--) {</span>
<span class="source-line-no">5850</span><span id="line.5850">                if ((w = (data[x * ySections + s])) != 0) {</span>
<span class="source-line-no">5851</span><span id="line.5851">                    return ((s &lt;&lt; 6) | 63 - Long.numberOfLeadingZeros(w)) * width + x;</span>
<span class="source-line-no">5852</span><span id="line.5852">                }</span>
<span class="source-line-no">5853</span><span id="line.5853">            }</span>
<span class="source-line-no">5854</span><span id="line.5854">        }</span>
<span class="source-line-no">5855</span><span id="line.5855">        return -1;</span>
<span class="source-line-no">5856</span><span id="line.5856">    }</span>
<span class="source-line-no">5857</span><span id="line.5857"></span>
<span class="source-line-no">5858</span><span id="line.5858">    public Coord nth(final int index)</span>
<span class="source-line-no">5859</span><span id="line.5859">    {</span>
<span class="source-line-no">5860</span><span id="line.5860">        if(index &lt; 0)</span>
<span class="source-line-no">5861</span><span id="line.5861">            return Coord.get(-1, -1);</span>
<span class="source-line-no">5862</span><span id="line.5862">        int ct = size(), tmp;</span>
<span class="source-line-no">5863</span><span id="line.5863">        if(index &gt;= ct)</span>
<span class="source-line-no">5864</span><span id="line.5864">            return Coord.get(-1, -1);</span>
<span class="source-line-no">5865</span><span id="line.5865">        long t, w;</span>
<span class="source-line-no">5866</span><span id="line.5866">        for (int s = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">5867</span><span id="line.5867">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">5868</span><span id="line.5868">                if ((ct = counts[x * ySections + s]) &gt; index) {</span>
<span class="source-line-no">5869</span><span id="line.5869">                    t = data[x * ySections + s];</span>
<span class="source-line-no">5870</span><span id="line.5870">                    w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">5871</span><span id="line.5871">                    for (--ct; w != 0; ct--) {</span>
<span class="source-line-no">5872</span><span id="line.5872">                        if (ct == index)</span>
<span class="source-line-no">5873</span><span id="line.5873">                            return Coord.get(x, (s &lt;&lt; 6) | Long.numberOfTrailingZeros(w));</span>
<span class="source-line-no">5874</span><span id="line.5874">                        t ^= w;</span>
<span class="source-line-no">5875</span><span id="line.5875">                        w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">5876</span><span id="line.5876">                    }</span>
<span class="source-line-no">5877</span><span id="line.5877">                }</span>
<span class="source-line-no">5878</span><span id="line.5878">            }</span>
<span class="source-line-no">5879</span><span id="line.5879">        }</span>
<span class="source-line-no">5880</span><span id="line.5880">        return Coord.get(-1, -1);</span>
<span class="source-line-no">5881</span><span id="line.5881">    }</span>
<span class="source-line-no">5882</span><span id="line.5882"></span>
<span class="source-line-no">5883</span><span id="line.5883">    public Coord atFraction(final double fraction)</span>
<span class="source-line-no">5884</span><span id="line.5884">    {</span>
<span class="source-line-no">5885</span><span id="line.5885">        int ct = size(), tmp;</span>
<span class="source-line-no">5886</span><span id="line.5886">        if(ct &lt;= 0) return Coord.get(-1, -1);</span>
<span class="source-line-no">5887</span><span id="line.5887">        tmp = Math.abs((int)(fraction * ct) % ct);</span>
<span class="source-line-no">5888</span><span id="line.5888">        long t, w;</span>
<span class="source-line-no">5889</span><span id="line.5889">        for (int s = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">5890</span><span id="line.5890">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">5891</span><span id="line.5891">                if ((ct = counts[x * ySections + s]) &gt; tmp) {</span>
<span class="source-line-no">5892</span><span id="line.5892">                    t = data[x * ySections + s];</span>
<span class="source-line-no">5893</span><span id="line.5893">                    w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">5894</span><span id="line.5894">                    for (--ct; w != 0; ct--) {</span>
<span class="source-line-no">5895</span><span id="line.5895">                        if (ct == tmp)</span>
<span class="source-line-no">5896</span><span id="line.5896">                            return Coord.get(x, (s &lt;&lt; 6) | Long.numberOfTrailingZeros(w));</span>
<span class="source-line-no">5897</span><span id="line.5897">                        t ^= w;</span>
<span class="source-line-no">5898</span><span id="line.5898">                        w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">5899</span><span id="line.5899">                    }</span>
<span class="source-line-no">5900</span><span id="line.5900">                }</span>
<span class="source-line-no">5901</span><span id="line.5901">            }</span>
<span class="source-line-no">5902</span><span id="line.5902">        }</span>
<span class="source-line-no">5903</span><span id="line.5903">        return Coord.get(-1, -1);</span>
<span class="source-line-no">5904</span><span id="line.5904">    }</span>
<span class="source-line-no">5905</span><span id="line.5905"></span>
<span class="source-line-no">5906</span><span id="line.5906">    public int atFractionTight(final double fraction)</span>
<span class="source-line-no">5907</span><span id="line.5907">    {</span>
<span class="source-line-no">5908</span><span id="line.5908">        int ct = size(), tmp;</span>
<span class="source-line-no">5909</span><span id="line.5909">        if(ct &lt;= 0) return -1;</span>
<span class="source-line-no">5910</span><span id="line.5910">        tmp = Math.abs((int)(fraction * ct) % ct);</span>
<span class="source-line-no">5911</span><span id="line.5911">        long t, w;</span>
<span class="source-line-no">5912</span><span id="line.5912"></span>
<span class="source-line-no">5913</span><span id="line.5913">        for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">5914</span><span id="line.5914">            for (int s = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">5915</span><span id="line.5915">                if ((ct = counts[x * ySections + s]) &gt; tmp) {</span>
<span class="source-line-no">5916</span><span id="line.5916">                    t = data[x * ySections + s];</span>
<span class="source-line-no">5917</span><span id="line.5917">                    w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">5918</span><span id="line.5918">                    for (--ct; w != 0; ct--) {</span>
<span class="source-line-no">5919</span><span id="line.5919">                        if (ct == tmp)</span>
<span class="source-line-no">5920</span><span id="line.5920">                            return ((s &lt;&lt; 6) | Long.numberOfTrailingZeros(w)) * width + x;</span>
<span class="source-line-no">5921</span><span id="line.5921">                        t ^= w;</span>
<span class="source-line-no">5922</span><span id="line.5922">                        w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">5923</span><span id="line.5923">                    }</span>
<span class="source-line-no">5924</span><span id="line.5924">                }</span>
<span class="source-line-no">5925</span><span id="line.5925">            }</span>
<span class="source-line-no">5926</span><span id="line.5926">        }</span>
<span class="source-line-no">5927</span><span id="line.5927">        return -1;</span>
<span class="source-line-no">5928</span><span id="line.5928">    }</span>
<span class="source-line-no">5929</span><span id="line.5929"></span>
<span class="source-line-no">5930</span><span id="line.5930">    /**</span>
<span class="source-line-no">5931</span><span id="line.5931">     * Gets a single random Coord from the "on" positions in this GreasedRegion, or the Coord (-1,-1) if this is empty.</span>
<span class="source-line-no">5932</span><span id="line.5932">     * Uses the given IRNG to generate one random int, which is used as an index. The technique this uses to iterate</span>
<span class="source-line-no">5933</span><span id="line.5933">     * over bits can be credited to Erling Ellingsen and Daniel Lemire, found</span>
<span class="source-line-no">5934</span><span id="line.5934">     * &lt;a href="https://lemire.me/blog/2013/12/23/even-faster-bitmap-decoding/"&gt;here&lt;/a&gt;, and seems to be a little</span>
<span class="source-line-no">5935</span><span id="line.5935">     * faster than the previous method. The fastest way to get a random Coord from a GreasedRegion is to avoid iterating</span>
<span class="source-line-no">5936</span><span id="line.5936">     * over the bits at all, so if your region data doesn't change you should get it as a Coord array with</span>
<span class="source-line-no">5937</span><span id="line.5937">     * {@link #asCoords()} and call {@link IRNG#getRandomElement(Object[])} with that array as the parameter. If you</span>
<span class="source-line-no">5938</span><span id="line.5938">     * take the asCoords() call out of consideration, getting random elements out of an array (especially a large one)</span>
<span class="source-line-no">5939</span><span id="line.5939">     * can be hundreds of times faster.</span>
<span class="source-line-no">5940</span><span id="line.5940">     * @param rng an IRNG such as an {@link RNG} or {@link GWTRNG}</span>
<span class="source-line-no">5941</span><span id="line.5941">     * @return a single randomly-chosen Coord from the "on" positions in this GreasedRegion, or (-1,-1) if empty</span>
<span class="source-line-no">5942</span><span id="line.5942">     */</span>
<span class="source-line-no">5943</span><span id="line.5943">    public Coord singleRandom(IRNG rng)</span>
<span class="source-line-no">5944</span><span id="line.5944">    {</span>
<span class="source-line-no">5945</span><span id="line.5945">        int ct = size(), tmp = rng.nextInt(ct);</span>
<span class="source-line-no">5946</span><span id="line.5946">        long t, w;</span>
<span class="source-line-no">5947</span><span id="line.5947">        for (int s = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">5948</span><span id="line.5948">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">5949</span><span id="line.5949">                if ((ct = counts[x * ySections + s]) &gt; tmp) {</span>
<span class="source-line-no">5950</span><span id="line.5950">                    t = data[x * ySections + s] | 0L;</span>
<span class="source-line-no">5951</span><span id="line.5951">                    for (--ct; t != 0; ct--) {</span>
<span class="source-line-no">5952</span><span id="line.5952">                        w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">5953</span><span id="line.5953">                        if (ct == tmp)</span>
<span class="source-line-no">5954</span><span id="line.5954">                            return Coord.get(x, (s &lt;&lt; 6) | Long.bitCount(w-1));</span>
<span class="source-line-no">5955</span><span id="line.5955">                        t ^= w;</span>
<span class="source-line-no">5956</span><span id="line.5956">                    }</span>
<span class="source-line-no">5957</span><span id="line.5957">                }</span>
<span class="source-line-no">5958</span><span id="line.5958">            }</span>
<span class="source-line-no">5959</span><span id="line.5959">        }</span>
<span class="source-line-no">5960</span><span id="line.5960">        return Coord.get(-1, -1);</span>
<span class="source-line-no">5961</span><span id="line.5961">    }</span>
<span class="source-line-no">5962</span><span id="line.5962"></span>
<span class="source-line-no">5963</span><span id="line.5963">    public int singleRandomTight(IRNG rng)</span>
<span class="source-line-no">5964</span><span id="line.5964">    {</span>
<span class="source-line-no">5965</span><span id="line.5965">        int ct = size(), tmp = rng.nextInt(ct);</span>
<span class="source-line-no">5966</span><span id="line.5966">        long t, w;</span>
<span class="source-line-no">5967</span><span id="line.5967">        for (int s = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">5968</span><span id="line.5968">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">5969</span><span id="line.5969">                if ((ct = counts[x * ySections + s]) &gt; tmp) {</span>
<span class="source-line-no">5970</span><span id="line.5970">                    t = data[x * ySections + s];</span>
<span class="source-line-no">5971</span><span id="line.5971">                    w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">5972</span><span id="line.5972">                    for (--ct; w != 0; ct--) {</span>
<span class="source-line-no">5973</span><span id="line.5973">                        if (ct == tmp)</span>
<span class="source-line-no">5974</span><span id="line.5974">                            return ((s &lt;&lt; 6) | Long.numberOfTrailingZeros(w)) * width + x;</span>
<span class="source-line-no">5975</span><span id="line.5975">                        t ^= w;</span>
<span class="source-line-no">5976</span><span id="line.5976">                        w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">5977</span><span id="line.5977">                    }</span>
<span class="source-line-no">5978</span><span id="line.5978">                }</span>
<span class="source-line-no">5979</span><span id="line.5979">            }</span>
<span class="source-line-no">5980</span><span id="line.5980">        }</span>
<span class="source-line-no">5981</span><span id="line.5981"></span>
<span class="source-line-no">5982</span><span id="line.5982">        return -1;</span>
<span class="source-line-no">5983</span><span id="line.5983">    }</span>
<span class="source-line-no">5984</span><span id="line.5984"></span>
<span class="source-line-no">5985</span><span id="line.5985">    /**</span>
<span class="source-line-no">5986</span><span id="line.5986">     * Narrow-purpose; takes an x and a y value, each between 0 and 65535 inclusive, and interleaves their bits so the</span>
<span class="source-line-no">5987</span><span id="line.5987">     * least significant bit and every other bit after it are filled with the bits of x, while the</span>
<span class="source-line-no">5988</span><span id="line.5988">     * second-least-significant bit and every other bit after that are filled with the bits of y. Essentially, this</span>
<span class="source-line-no">5989</span><span id="line.5989">     * takes two numbers with bits labeled like {@code a b c} for x and {@code R S T} for y and makes a number with</span>
<span class="source-line-no">5990</span><span id="line.5990">     * those bits arranged like {@code R a S b T c}.</span>
<span class="source-line-no">5991</span><span id="line.5991">     * @param x an int between 0 and 65535, inclusive</span>
<span class="source-line-no">5992</span><span id="line.5992">     * @param y an int between 0 and 65535, inclusive</span>
<span class="source-line-no">5993</span><span id="line.5993">     * @return an int that interleaves x and y, with x in the least significant bit position</span>
<span class="source-line-no">5994</span><span id="line.5994">     */</span>
<span class="source-line-no">5995</span><span id="line.5995">    public static int interleaveBits(int x, int y)</span>
<span class="source-line-no">5996</span><span id="line.5996">    {</span>
<span class="source-line-no">5997</span><span id="line.5997">        x |= y &lt;&lt; 16;</span>
<span class="source-line-no">5998</span><span id="line.5998">        x =    ((x &amp; 0x0000ff00) &lt;&lt; 8) | ((x &gt;&gt;&gt; 8) &amp; 0x0000ff00) | (x &amp; 0xff0000ff);</span>
<span class="source-line-no">5999</span><span id="line.5999">        x =    ((x &amp; 0x00f000f0) &lt;&lt; 4) | ((x &gt;&gt;&gt; 4) &amp; 0x00f000f0) | (x &amp; 0xf00ff00f);</span>
<span class="source-line-no">6000</span><span id="line.6000">        x =    ((x &amp; 0x0c0c0c0c) &lt;&lt; 2) | ((x &gt;&gt;&gt; 2) &amp; 0x0c0c0c0c) | (x &amp; 0xc3c3c3c3);</span>
<span class="source-line-no">6001</span><span id="line.6001">        return ((x &amp; 0x22222222) &lt;&lt; 1) | ((x &gt;&gt;&gt; 1) &amp; 0x22222222) | (x &amp; 0x99999999);</span>
<span class="source-line-no">6002</span><span id="line.6002">    }</span>
<span class="source-line-no">6003</span><span id="line.6003"></span>
<span class="source-line-no">6004</span><span id="line.6004">    /**</span>
<span class="source-line-no">6005</span><span id="line.6005">     * Narrow-purpose; takes an int that represents a distance down the Z-order curve and moves its bits around so that</span>
<span class="source-line-no">6006</span><span id="line.6006">     * its x component is stored in the bottom 16 bits (use {@code (n &amp; 0xffff)} to obtain) and its y component is</span>
<span class="source-line-no">6007</span><span id="line.6007">     * stored in the upper 16 bits (use {@code (n &gt;&gt;&gt; 16)} to obtain). This may be useful for ordering traversals of all</span>
<span class="source-line-no">6008</span><span id="line.6008">     * points in a GreasedRegion less predictably.</span>
<span class="source-line-no">6009</span><span id="line.6009">     * @param n an int that has already been interleaved, though this can really be any int</span>
<span class="source-line-no">6010</span><span id="line.6010">     * @return an int with x in its lower bits ({@code x = n &amp; 0xffff;}) and y in its upper bits ({@code y = n &gt;&gt;&gt; 16;})</span>
<span class="source-line-no">6011</span><span id="line.6011">     */</span>
<span class="source-line-no">6012</span><span id="line.6012">    public static int disperseBits(int n)</span>
<span class="source-line-no">6013</span><span id="line.6013">    {</span>
<span class="source-line-no">6014</span><span id="line.6014">        n =    ((n &amp; 0x22222222) &lt;&lt; 1) | ((n &gt;&gt;&gt; 1) &amp; 0x22222222) | (n &amp; 0x99999999);</span>
<span class="source-line-no">6015</span><span id="line.6015">        n =    ((n &amp; 0x0c0c0c0c) &lt;&lt; 2) | ((n &gt;&gt;&gt; 2) &amp; 0x0c0c0c0c) | (n &amp; 0xc3c3c3c3);</span>
<span class="source-line-no">6016</span><span id="line.6016">        n =    ((n &amp; 0x00f000f0) &lt;&lt; 4) | ((n &gt;&gt;&gt; 4) &amp; 0x00f000f0) | (n &amp; 0xf00ff00f);</span>
<span class="source-line-no">6017</span><span id="line.6017">        return ((n &amp; 0x0000ff00) &lt;&lt; 8) | ((n &gt;&gt;&gt; 8) &amp; 0x0000ff00) | (n &amp; 0xff0000ff);</span>
<span class="source-line-no">6018</span><span id="line.6018">    }</span>
<span class="source-line-no">6019</span><span id="line.6019">    private static int nextPowerOfTwo(int n)</span>
<span class="source-line-no">6020</span><span id="line.6020">    {</span>
<span class="source-line-no">6021</span><span id="line.6021">        final int highest = Integer.highestOneBit(n);</span>
<span class="source-line-no">6022</span><span id="line.6022">        return  (highest == NumberTools.lowestOneBit(n)) ? highest : highest &lt;&lt; 1;</span>
<span class="source-line-no">6023</span><span id="line.6023">    }</span>
<span class="source-line-no">6024</span><span id="line.6024"></span>
<span class="source-line-no">6025</span><span id="line.6025">    /**</span>
<span class="source-line-no">6026</span><span id="line.6026">     * Like {@link #nth(int)}, this gets the Coord at a given index along a path through the GreasedRegion, but unlike</span>
<span class="source-line-no">6027</span><span id="line.6027">     * nth(), this traverses the path in a zig-zag pattern called the Z-Order Curve. This method is often not very fast</span>
<span class="source-line-no">6028</span><span id="line.6028">     * compared to nth(), but this different path can help if iteration needs to seem less regular while still covering</span>
<span class="source-line-no">6029</span><span id="line.6029">     * all "on" cells in the GresedRegion eventually.</span>
<span class="source-line-no">6030</span><span id="line.6030">     * @param index the distance along the Z-order curve to travel, only counting "on" cells in this GreasedRegion.</span>
<span class="source-line-no">6031</span><span id="line.6031">     * @return the Coord at the given distance, or the Coord with x and y both -1 if index is too high or low</span>
<span class="source-line-no">6032</span><span id="line.6032">     */</span>
<span class="source-line-no">6033</span><span id="line.6033">    public Coord nthZCurve(final int index)</span>
<span class="source-line-no">6034</span><span id="line.6034">    {</span>
<span class="source-line-no">6035</span><span id="line.6035">        int ct = -1, x, y, s, d, max = nextPowerOfTwo(width) * nextPowerOfTwo(height);</span>
<span class="source-line-no">6036</span><span id="line.6036">        long t, w;</span>
<span class="source-line-no">6037</span><span id="line.6037">        for (int o = 0; o &lt; max; o++) {</span>
<span class="source-line-no">6038</span><span id="line.6038">            d = disperseBits(o);</span>
<span class="source-line-no">6039</span><span id="line.6039">            x = d &amp; 0xffff;</span>
<span class="source-line-no">6040</span><span id="line.6040">            y = d &gt;&gt;&gt; 16;</span>
<span class="source-line-no">6041</span><span id="line.6041">            if(x &gt;= width &amp;&amp; y &gt;= height)</span>
<span class="source-line-no">6042</span><span id="line.6042">                break;</span>
<span class="source-line-no">6043</span><span id="line.6043">            if(x &gt;= width)</span>
<span class="source-line-no">6044</span><span id="line.6044">                continue;</span>
<span class="source-line-no">6045</span><span id="line.6045">            if(y &gt;= height)</span>
<span class="source-line-no">6046</span><span id="line.6046">                continue;</span>
<span class="source-line-no">6047</span><span id="line.6047">            s = d &gt;&gt;&gt; 22;</span>
<span class="source-line-no">6048</span><span id="line.6048">            t = data[x * ySections + s];</span>
<span class="source-line-no">6049</span><span id="line.6049">            if((ct += (t &gt;&gt;&gt; (y &amp; 63) &amp; 1L)) == index)</span>
<span class="source-line-no">6050</span><span id="line.6050">                return Coord.get(x, y);</span>
<span class="source-line-no">6051</span><span id="line.6051">        }</span>
<span class="source-line-no">6052</span><span id="line.6052">        return Coord.get(-1, -1);</span>
<span class="source-line-no">6053</span><span id="line.6053">    }</span>
<span class="source-line-no">6054</span><span id="line.6054">    /**</span>
<span class="source-line-no">6055</span><span id="line.6055">     * Like {@link #nth(int)}, this finds a given index along a path through the GreasedRegion, but unlike nth(), this</span>
<span class="source-line-no">6056</span><span id="line.6056">     * traverses the path in a zig-zag pattern called the Z-Order Curve, and unlike {@link #nthZCurve(int)}, this does</span>
<span class="source-line-no">6057</span><span id="line.6057">     * not return a Coord and instead produces a "tight"-encoded int. This method is often not very fast compared to</span>
<span class="source-line-no">6058</span><span id="line.6058">     * nth(), but this different path can help if iteration needs to seem less regular while still covering all "on"</span>
<span class="source-line-no">6059</span><span id="line.6059">     * cells in the GreasedRegion eventually, and the tight encoding may be handy if you need to use ints.</span>
<span class="source-line-no">6060</span><span id="line.6060">     * @param index the distance along the Z-order curve to travel, only counting "on" cells in this GreasedRegion.</span>
<span class="source-line-no">6061</span><span id="line.6061">     * @return the "tight" encoded point at the given distance, or -1 if index is too high or low</span>
<span class="source-line-no">6062</span><span id="line.6062">     */</span>
<span class="source-line-no">6063</span><span id="line.6063"></span>
<span class="source-line-no">6064</span><span id="line.6064">    public int nthZCurveTight(final int index)</span>
<span class="source-line-no">6065</span><span id="line.6065">    {</span>
<span class="source-line-no">6066</span><span id="line.6066">        int ct = -1, x, y, s, d, max = nextPowerOfTwo(width) * nextPowerOfTwo(height);</span>
<span class="source-line-no">6067</span><span id="line.6067">        long t;</span>
<span class="source-line-no">6068</span><span id="line.6068">        for (int o = 0; o &lt; max; o++) {</span>
<span class="source-line-no">6069</span><span id="line.6069">            d = disperseBits(o);</span>
<span class="source-line-no">6070</span><span id="line.6070">            x = d &amp; 0xffff;</span>
<span class="source-line-no">6071</span><span id="line.6071">            y = d &gt;&gt;&gt; 16;</span>
<span class="source-line-no">6072</span><span id="line.6072">            if(x &gt;= width &amp;&amp; y &gt;= height)</span>
<span class="source-line-no">6073</span><span id="line.6073">                break;</span>
<span class="source-line-no">6074</span><span id="line.6074">            if(x &gt;= width)</span>
<span class="source-line-no">6075</span><span id="line.6075">                continue;</span>
<span class="source-line-no">6076</span><span id="line.6076">            if(y &gt;= height)</span>
<span class="source-line-no">6077</span><span id="line.6077">                continue;</span>
<span class="source-line-no">6078</span><span id="line.6078">            s = d &gt;&gt;&gt; 22;</span>
<span class="source-line-no">6079</span><span id="line.6079">            t = data[x * ySections + s];</span>
<span class="source-line-no">6080</span><span id="line.6080">            if((ct += (t &gt;&gt;&gt; (y &amp; 63) &amp; 1L)) == index)</span>
<span class="source-line-no">6081</span><span id="line.6081">                return y * width + x;</span>
<span class="source-line-no">6082</span><span id="line.6082">        }</span>
<span class="source-line-no">6083</span><span id="line.6083">        return -1;</span>
<span class="source-line-no">6084</span><span id="line.6084">    }</span>
<span class="source-line-no">6085</span><span id="line.6085"></span>
<span class="source-line-no">6086</span><span id="line.6086">    /**</span>
<span class="source-line-no">6087</span><span id="line.6087">     * Gets a Coord array from the "on" contents of this GreasedRegion, using a quasi-random scattering of chosen cells</span>
<span class="source-line-no">6088</span><span id="line.6088">     * with a count that matches the given {@code fraction} of the total amount of "on" cells in this. This is quasi-</span>
<span class="source-line-no">6089</span><span id="line.6089">     * random instead of pseudo-random because it is somewhat less likely to produce nearby cells in the result. If you</span>
<span class="source-line-no">6090</span><span id="line.6090">     * request too many cells (too high of a value for fraction), it will start to overlap, however. Contrast with</span>
<span class="source-line-no">6091</span><span id="line.6091">     * {@link #mixedRandomSeparated(double, int)}, which tends to overlap more frequently. This method seems to work</span>
<span class="source-line-no">6092</span><span id="line.6092">     * well because it chooses quasi-random points by their index in the Z-Order Curve as opposed to the simpler</span>
<span class="source-line-no">6093</span><span id="line.6093">     * approach mixedRandomSeparated uses to traverse points (which just runs through the "on" cells a column at a time,</span>
<span class="source-line-no">6094</span><span id="line.6094">     * not caring if two points are in adjacent cells as long as they are in different columns). Testing with a dungeon</span>
<span class="source-line-no">6095</span><span id="line.6095">     * layout of mostly-on cells, this method has no overlap with a fraction of 0.4, while mixedRandomSeparated has</span>
<span class="source-line-no">6096</span><span id="line.6096">     * overlap as early as 0.15 for fraction, and it only gets worse at higher values. A change to the algorithm used by</span>
<span class="source-line-no">6097</span><span id="line.6097">     * {@link #quasiRandomSeparated(double)} has it overlapping at the same rate as this method, though it should be</span>
<span class="source-line-no">6098</span><span id="line.6098">     * much faster. This method can be especially slow, since each Z-Order traversal may need to try many cells that are</span>
<span class="source-line-no">6099</span><span id="line.6099">     * outside the GreasedRegion but are on the Z-Order Curve.</span>
<span class="source-line-no">6100</span><span id="line.6100">     * Does not restrict the size of the returned array other than only using up to {@code fraction * size()} cells.</span>
<span class="source-line-no">6101</span><span id="line.6101">     * @param fraction the fraction of "on" cells to randomly select, between 0.0 and 1.0</span>
<span class="source-line-no">6102</span><span id="line.6102">     * @return a freshly-allocated Coord array containing the quasi-random cells</span>
<span class="source-line-no">6103</span><span id="line.6103">     */</span>
<span class="source-line-no">6104</span><span id="line.6104">    public Coord[] separatedZCurve(double fraction)</span>
<span class="source-line-no">6105</span><span id="line.6105">    {</span>
<span class="source-line-no">6106</span><span id="line.6106">        return separatedZCurve(fraction, -1);</span>
<span class="source-line-no">6107</span><span id="line.6107">    }</span>
<span class="source-line-no">6108</span><span id="line.6108"></span>
<span class="source-line-no">6109</span><span id="line.6109">    /**</span>
<span class="source-line-no">6110</span><span id="line.6110">     * Gets a Coord array from the "on" contents of this GreasedRegion, using a quasi-random scattering of chosen cells</span>
<span class="source-line-no">6111</span><span id="line.6111">     * with a count that matches the given {@code fraction} of the total amount of "on" cells in this. This is quasi-</span>
<span class="source-line-no">6112</span><span id="line.6112">     * random instead of pseudo-random because it is somewhat less likely to produce nearby cells in the result. If you</span>
<span class="source-line-no">6113</span><span id="line.6113">     * request too many cells (too high of a value for fraction), it will start to overlap, however. Contrast with</span>
<span class="source-line-no">6114</span><span id="line.6114">     * {@link #mixedRandomSeparated(double, int)}, which tends to overlap more frequently. This method seems to work</span>
<span class="source-line-no">6115</span><span id="line.6115">     * well because it chooses quasi-random points by their index in the Z-Order Curve as opposed to the simpler</span>
<span class="source-line-no">6116</span><span id="line.6116">     * approach mixedRandomSeparated uses to traverse points (which just runs through the "on" cells a column at a time,</span>
<span class="source-line-no">6117</span><span id="line.6117">     * not caring if two points are in adjacent cells as long as they are in different columns). Testing with a dungeon</span>
<span class="source-line-no">6118</span><span id="line.6118">     * layout of mostly-on cells, this method has no overlap with a fraction of 0.4, while mixedRandomSeparated has</span>
<span class="source-line-no">6119</span><span id="line.6119">     * overlap as early as 0.15 for fraction, and it only gets worse at higher values. A change to the algorithm used by</span>
<span class="source-line-no">6120</span><span id="line.6120">     * {@link #quasiRandomSeparated(double, int)} has it overlapping at the same rate as this method, though it should</span>
<span class="source-line-no">6121</span><span id="line.6121">     * be much faster. This method can be especially slow, since each Z-Order traversal may need to try many cells that</span>
<span class="source-line-no">6122</span><span id="line.6122">     * are outside the GreasedRegion but are on the Z-Order Curve.</span>
<span class="source-line-no">6123</span><span id="line.6123">     * Restricts the total size of the returned array to a maximum of {@code limit} (minimum is 0 if no cells are "on").</span>
<span class="source-line-no">6124</span><span id="line.6124">     * If limit is negative, this will not restrict the size.</span>
<span class="source-line-no">6125</span><span id="line.6125">     * @param fraction the fraction of "on" cells to randomly select, between 0.0 and 1.0</span>
<span class="source-line-no">6126</span><span id="line.6126">     * @param limit the maximum size of the array to return</span>
<span class="source-line-no">6127</span><span id="line.6127">     * @return a freshly-allocated Coord array containing the quasi-random cells</span>
<span class="source-line-no">6128</span><span id="line.6128">     */</span>
<span class="source-line-no">6129</span><span id="line.6129">    public Coord[] separatedZCurve(double fraction, int limit)</span>
<span class="source-line-no">6130</span><span id="line.6130">    {</span>
<span class="source-line-no">6131</span><span id="line.6131">        if(fraction &lt; 0)</span>
<span class="source-line-no">6132</span><span id="line.6132">            return new Coord[0];</span>
<span class="source-line-no">6133</span><span id="line.6133">        if(fraction &gt; 1)</span>
<span class="source-line-no">6134</span><span id="line.6134">            fraction = 1;</span>
<span class="source-line-no">6135</span><span id="line.6135">        int ct = size(), total;</span>
<span class="source-line-no">6136</span><span id="line.6136">        total = ct;</span>
<span class="source-line-no">6137</span><span id="line.6137">        ct *= fraction;</span>
<span class="source-line-no">6138</span><span id="line.6138">        if(limit &gt;= 0 &amp;&amp; limit &lt; ct)</span>
<span class="source-line-no">6139</span><span id="line.6139">            ct = limit;</span>
<span class="source-line-no">6140</span><span id="line.6140">        Coord[] vl = new Coord[ct];</span>
<span class="source-line-no">6141</span><span id="line.6141">        for (int i = 0; i &lt; ct; i++)</span>
<span class="source-line-no">6142</span><span id="line.6142">        {</span>
<span class="source-line-no">6143</span><span id="line.6143">            vl[i] = nthZCurve((int) (VanDerCorputQRNG.determine2(i ^ i &gt;&gt;&gt; 1) * total));</span>
<span class="source-line-no">6144</span><span id="line.6144">        }</span>
<span class="source-line-no">6145</span><span id="line.6145">        return vl;</span>
<span class="source-line-no">6146</span><span id="line.6146">    }</span>
<span class="source-line-no">6147</span><span id="line.6147">    /**</span>
<span class="source-line-no">6148</span><span id="line.6148">     * Modifies this GreasedRegion so it contains a quasi-random subset of its previous contents, choosing cells so that</span>
<span class="source-line-no">6149</span><span id="line.6149">     * the {@link #size()} matches the given {@code fraction} of the total amount of "on" cells in this. This is quasi-</span>
<span class="source-line-no">6150</span><span id="line.6150">     * random instead of pseudo-random because it is somewhat less likely to produce nearby cells in the result. If you</span>
<span class="source-line-no">6151</span><span id="line.6151">     * request too many cells (too high of a value for fraction), it will start to overlap, however. Contrast with</span>
<span class="source-line-no">6152</span><span id="line.6152">     * {@link #mixedRandomRegion(double)}, which tends to overlap more frequently. This method seems to work</span>
<span class="source-line-no">6153</span><span id="line.6153">     * well because it chooses quasi-random points by their index in the Z-Order Curve as opposed to the simpler</span>
<span class="source-line-no">6154</span><span id="line.6154">     * approach mixedRandomRegion uses to traverse points (which just runs through the "on" cells a column at a time,</span>
<span class="source-line-no">6155</span><span id="line.6155">     * not caring if two points are in adjacent cells as long as they are in different columns). Testing with a dungeon</span>
<span class="source-line-no">6156</span><span id="line.6156">     * layout of mostly-on cells, this method has no overlap with a fraction of 0.4, while mixedRandomRegion has</span>
<span class="source-line-no">6157</span><span id="line.6157">     * overlap as early as 0.15 for fraction, and it only gets worse at higher values. A change to the algorithm used by</span>
<span class="source-line-no">6158</span><span id="line.6158">     * {@link #quasiRandomRegion(double)} has it overlapping at the same rate as this method, though it should be much</span>
<span class="source-line-no">6159</span><span id="line.6159">     * faster. This method can be especially slow, since each Z-Order traversal may need to try many cells that are</span>
<span class="source-line-no">6160</span><span id="line.6160">     * outside the GreasedRegion but are on the Z-Order Curve.</span>
<span class="source-line-no">6161</span><span id="line.6161">     * Does not restrict the size of the returned array other than only using up to {@code fraction * size()} cells.</span>
<span class="source-line-no">6162</span><span id="line.6162">     * @param fraction the fraction of "on" cells to randomly select, between 0.0 and 1.0</span>
<span class="source-line-no">6163</span><span id="line.6163">     * @return this, after modifications, for chaining</span>
<span class="source-line-no">6164</span><span id="line.6164">     */</span>
<span class="source-line-no">6165</span><span id="line.6165">    public GreasedRegion separatedRegionZCurve(double fraction)</span>
<span class="source-line-no">6166</span><span id="line.6166">    {</span>
<span class="source-line-no">6167</span><span id="line.6167">        return separatedRegionZCurve(fraction, -1);</span>
<span class="source-line-no">6168</span><span id="line.6168">    }</span>
<span class="source-line-no">6169</span><span id="line.6169"></span>
<span class="source-line-no">6170</span><span id="line.6170">    /**</span>
<span class="source-line-no">6171</span><span id="line.6171">     * Modifies this GreasedRegion so it contains a quasi-random subset of its previous contents, choosing cells so that</span>
<span class="source-line-no">6172</span><span id="line.6172">     * the {@link #size()} matches the given {@code fraction} of the total amount of "on" cells in this. This is quasi-</span>
<span class="source-line-no">6173</span><span id="line.6173">     * random instead of pseudo-random because it is somewhat less likely to produce nearby cells in the result. If you</span>
<span class="source-line-no">6174</span><span id="line.6174">     * request too many cells (too high of a value for fraction), it will start to overlap, however. Contrast with</span>
<span class="source-line-no">6175</span><span id="line.6175">     * {@link #mixedRandomRegion(double, int)}, which tends to overlap more frequently. This method seems to work</span>
<span class="source-line-no">6176</span><span id="line.6176">     * well because it chooses quasi-random points by their index in the Z-Order Curve as opposed to the simpler</span>
<span class="source-line-no">6177</span><span id="line.6177">     * approach mixedRandomRegion uses to traverse points (which just runs through the "on" cells a column at a time,</span>
<span class="source-line-no">6178</span><span id="line.6178">     * not caring if two points are in adjacent cells as long as they are in different columns). Testing with a dungeon</span>
<span class="source-line-no">6179</span><span id="line.6179">     * layout of mostly-on cells, this method has no overlap with a fraction of 0.4, while mixedRandomRegion has</span>
<span class="source-line-no">6180</span><span id="line.6180">     * overlap as early as 0.15 for fraction, and it only gets worse at higher values. A change to the algorithm used by</span>
<span class="source-line-no">6181</span><span id="line.6181">     * {@link #quasiRandomRegion(double, int)} has it overlapping at the same rate as this method, though it should be</span>
<span class="source-line-no">6182</span><span id="line.6182">     * much faster. This method can be especially slow, since each Z-Order traversal may need to try many cells that</span>
<span class="source-line-no">6183</span><span id="line.6183">     * are outside the GreasedRegion but are on the Z-Order Curve.</span>
<span class="source-line-no">6184</span><span id="line.6184">     * Restricts the total size of the returned array to a maximum of {@code limit} (minimum is 0 if no cells are "on").</span>
<span class="source-line-no">6185</span><span id="line.6185">     * If limit is negative, this will not restrict the size.</span>
<span class="source-line-no">6186</span><span id="line.6186">     * @param fraction the fraction of "on" cells to randomly select, between 0.0 and 1.0</span>
<span class="source-line-no">6187</span><span id="line.6187">     * @param limit the maximum size of the array to return</span>
<span class="source-line-no">6188</span><span id="line.6188">     * @return this, after modifications, for chaining</span>
<span class="source-line-no">6189</span><span id="line.6189">     */</span>
<span class="source-line-no">6190</span><span id="line.6190">    public GreasedRegion separatedRegionZCurve(double fraction, int limit)</span>
<span class="source-line-no">6191</span><span id="line.6191">    {</span>
<span class="source-line-no">6192</span><span id="line.6192">        if(fraction &lt;= 0)</span>
<span class="source-line-no">6193</span><span id="line.6193">            return empty();</span>
<span class="source-line-no">6194</span><span id="line.6194">        if(fraction &gt;= 1)</span>
<span class="source-line-no">6195</span><span id="line.6195">            return this;</span>
<span class="source-line-no">6196</span><span id="line.6196">        int ct = size(), total;</span>
<span class="source-line-no">6197</span><span id="line.6197">        if(limit &gt;= ct)</span>
<span class="source-line-no">6198</span><span id="line.6198">            return this;</span>
<span class="source-line-no">6199</span><span id="line.6199">        total = ct;</span>
<span class="source-line-no">6200</span><span id="line.6200">        ct *= fraction;</span>
<span class="source-line-no">6201</span><span id="line.6201">        if(limit &gt;= 0 &amp;&amp; limit &lt; ct)</span>
<span class="source-line-no">6202</span><span id="line.6202">            ct = limit;</span>
<span class="source-line-no">6203</span><span id="line.6203">        int[] vl = new int[ct];</span>
<span class="source-line-no">6204</span><span id="line.6204">        for (int i = 0; i &lt; ct; i++)</span>
<span class="source-line-no">6205</span><span id="line.6205">        {</span>
<span class="source-line-no">6206</span><span id="line.6206">            vl[i] = nthZCurveTight((int) (VanDerCorputQRNG.determine2(i ^ i &gt;&gt;&gt; 1) * total));</span>
<span class="source-line-no">6207</span><span id="line.6207">        }</span>
<span class="source-line-no">6208</span><span id="line.6208">        return empty().insertSeveral(vl);</span>
<span class="source-line-no">6209</span><span id="line.6209">    }</span>
<span class="source-line-no">6210</span><span id="line.6210"></span>
<span class="source-line-no">6211</span><span id="line.6211">    /**</span>
<span class="source-line-no">6212</span><span id="line.6212">     * Gets a Coord array from the "on" contents of this GreasedRegion, using a quasi-random scattering of chosen cells</span>
<span class="source-line-no">6213</span><span id="line.6213">     * with a count that matches the given {@code fraction} of the total amount of "on" cells in this. This is quasi-</span>
<span class="source-line-no">6214</span><span id="line.6214">     * random instead of pseudo-random because it uses blue noise to sharply limit the likelihood of nearby points being</span>
<span class="source-line-no">6215</span><span id="line.6215">     * chosen when fraction is small. If you request too many cells (too high of a value for fraction), it will start to</span>
<span class="source-line-no">6216</span><span id="line.6216">     * have nearby cells, however. Does not restrict the size of the returned array other than only using up to</span>
<span class="source-line-no">6217</span><span id="line.6217">     * {@code fraction * size()} cells.</span>
<span class="source-line-no">6218</span><span id="line.6218">     * &lt;br&gt;</span>
<span class="source-line-no">6219</span><span id="line.6219">     * Also take a look at {@link #separatedZCurve(double, int)}, {@link #quasiRandomSeparated(double, int)},</span>
<span class="source-line-no">6220</span><span id="line.6220">     * {@link #mixedRandomSeparated(double, int, long)}, and {@link #separatedRegionBlue(double, int)}. Internally, this</span>
<span class="source-line-no">6221</span><span id="line.6221">     * is a thin wrapper around {@link #separatedRegionBlue(double, int)}, and won't be more efficient than that method.</span>
<span class="source-line-no">6222</span><span id="line.6222">     * @param fraction the fraction of "on" cells to randomly select, between 0.0 and 1.0</span>
<span class="source-line-no">6223</span><span id="line.6223">     * @return a freshly-allocated Coord array containing the quasi-random cells</span>
<span class="source-line-no">6224</span><span id="line.6224">     */</span>
<span class="source-line-no">6225</span><span id="line.6225">    public Coord[] separatedBlue(double fraction)</span>
<span class="source-line-no">6226</span><span id="line.6226">    {</span>
<span class="source-line-no">6227</span><span id="line.6227">        return separatedBlue(fraction, -1);</span>
<span class="source-line-no">6228</span><span id="line.6228">    }</span>
<span class="source-line-no">6229</span><span id="line.6229"></span>
<span class="source-line-no">6230</span><span id="line.6230">    /**</span>
<span class="source-line-no">6231</span><span id="line.6231">     * Gets a Coord array from the "on" contents of this GreasedRegion, using a quasi-random scattering of chosen cells</span>
<span class="source-line-no">6232</span><span id="line.6232">     * with a count that matches the given {@code fraction} of the total amount of "on" cells in this. This is quasi-</span>
<span class="source-line-no">6233</span><span id="line.6233">     * random instead of pseudo-random because it uses blue noise to sharply limit the likelihood of nearby points being</span>
<span class="source-line-no">6234</span><span id="line.6234">     * chosen when fraction is small. If you request too many cells (too high of a value for fraction), it will start to</span>
<span class="source-line-no">6235</span><span id="line.6235">     * have nearby cells, however. Restricts the total size of the returned array to a maximum of {@code limit} (minimum</span>
<span class="source-line-no">6236</span><span id="line.6236">     * is 0 if no cells are "on"). If limit is negative, this will not restrict the size.</span>
<span class="source-line-no">6237</span><span id="line.6237">     * &lt;br&gt;</span>
<span class="source-line-no">6238</span><span id="line.6238">     * Also take a look at {@link #separatedZCurve(double, int)}, {@link #quasiRandomSeparated(double, int)},</span>
<span class="source-line-no">6239</span><span id="line.6239">     * {@link #mixedRandomSeparated(double, int, long)}, and {@link #separatedRegionBlue(double, int)}. Internally, this</span>
<span class="source-line-no">6240</span><span id="line.6240">     * is a thin wrapper around {@link #separatedRegionBlue(double, int)}, and won't be more efficient than that method.</span>
<span class="source-line-no">6241</span><span id="line.6241">     * @param fraction the fraction of "on" cells to randomly select, between 0.0 and 1.0</span>
<span class="source-line-no">6242</span><span id="line.6242">     * @param limit the maximum size of the array to return; may return less</span>
<span class="source-line-no">6243</span><span id="line.6243">     * @return a freshly-allocated Coord array containing the quasi-random cells</span>
<span class="source-line-no">6244</span><span id="line.6244">     */</span>
<span class="source-line-no">6245</span><span id="line.6245">    public Coord[] separatedBlue(double fraction, int limit)</span>
<span class="source-line-no">6246</span><span id="line.6246">    {</span>
<span class="source-line-no">6247</span><span id="line.6247">        if(fraction &lt;= 0)</span>
<span class="source-line-no">6248</span><span id="line.6248">            return new Coord[0];</span>
<span class="source-line-no">6249</span><span id="line.6249">        if(fraction &gt; 0xFFp-8)</span>
<span class="source-line-no">6250</span><span id="line.6250">            fraction = 0xFFp-8;</span>
<span class="source-line-no">6251</span><span id="line.6251">        int ct = size();</span>
<span class="source-line-no">6252</span><span id="line.6252">        if(limit &gt;= ct)</span>
<span class="source-line-no">6253</span><span id="line.6253">            return asCoords();</span>
<span class="source-line-no">6254</span><span id="line.6254">        return copy().separatedRegionBlue(fraction, limit).asCoords();</span>
<span class="source-line-no">6255</span><span id="line.6255">    }</span>
<span class="source-line-no">6256</span><span id="line.6256">    /**</span>
<span class="source-line-no">6257</span><span id="line.6257">     * Modifies this GreasedRegion so it contains a quasi-random subset of its previous contents, choosing cells so that</span>
<span class="source-line-no">6258</span><span id="line.6258">     * the {@link #size()} matches the given {@code fraction} of the total amount of "on" cells in this. This is quasi-</span>
<span class="source-line-no">6259</span><span id="line.6259">     * random instead of pseudo-random because it uses blue noise to sharply limit the likelihood of nearby points being</span>
<span class="source-line-no">6260</span><span id="line.6260">     * chosen when fraction is small. If you request too many cells (too high of a value for fraction), it will start to</span>
<span class="source-line-no">6261</span><span id="line.6261">     * have nearby cells, however. Does not restrict the size of the returned GreasedRegion other than only using up to</span>
<span class="source-line-no">6262</span><span id="line.6262">     * {@code fraction * size()} cells.</span>
<span class="source-line-no">6263</span><span id="line.6263">     * &lt;br&gt;</span>
<span class="source-line-no">6264</span><span id="line.6264">     * Also take a look at {@link #separatedRegionZCurve(double, int)}, {@link #quasiRandomRegion(double, int)},</span>
<span class="source-line-no">6265</span><span id="line.6265">     * {@link #mixedRandomRegion(double, int, long)}, and {@link #separatedBlue(double, int)}.</span>
<span class="source-line-no">6266</span><span id="line.6266">     * @param fraction the fraction of "on" cells to randomly select, between 0.0 and 1.0</span>
<span class="source-line-no">6267</span><span id="line.6267">     * @return this, after modifications, for chaining</span>
<span class="source-line-no">6268</span><span id="line.6268">     */</span>
<span class="source-line-no">6269</span><span id="line.6269">    public GreasedRegion separatedRegionBlue(double fraction)</span>
<span class="source-line-no">6270</span><span id="line.6270">    {</span>
<span class="source-line-no">6271</span><span id="line.6271">        return separatedRegionBlue(fraction, -1);</span>
<span class="source-line-no">6272</span><span id="line.6272">    }</span>
<span class="source-line-no">6273</span><span id="line.6273"></span>
<span class="source-line-no">6274</span><span id="line.6274">    /**</span>
<span class="source-line-no">6275</span><span id="line.6275">     * Modifies this GreasedRegion so it contains a quasi-random subset of its previous contents, choosing cells so that</span>
<span class="source-line-no">6276</span><span id="line.6276">     * the {@link #size()} matches the given {@code fraction} of the total amount of "on" cells in this. This is quasi-</span>
<span class="source-line-no">6277</span><span id="line.6277">     * random instead of pseudo-random because it uses blue noise to sharply limit the likelihood of nearby points being</span>
<span class="source-line-no">6278</span><span id="line.6278">     * chosen when fraction is small. If you request too many cells (too high of a value for fraction), it will start to</span>
<span class="source-line-no">6279</span><span id="line.6279">     * have nearby cells, however. Restricts the total size of the returned GreasedRegion to a maximum of {@code limit}</span>
<span class="source-line-no">6280</span><span id="line.6280">     * (minimum is 0 if no cells are "on"). If limit is negative, this will not restrict the size.</span>
<span class="source-line-no">6281</span><span id="line.6281">     * &lt;br&gt;</span>
<span class="source-line-no">6282</span><span id="line.6282">     * Also take a look at {@link #separatedRegionZCurve(double, int)}, {@link #quasiRandomRegion(double, int)},</span>
<span class="source-line-no">6283</span><span id="line.6283">     * {@link #mixedRandomRegion(double, int, long)}, and {@link #separatedBlue(double, int)}.</span>
<span class="source-line-no">6284</span><span id="line.6284">     * @param fraction the fraction of "on" cells to quasi-randomly select, between 0.0 and 1.0</span>
<span class="source-line-no">6285</span><span id="line.6285">     * @param limit the maximum size of the array to return; may return less</span>
<span class="source-line-no">6286</span><span id="line.6286">     * @return this, after modifications, for chaining</span>
<span class="source-line-no">6287</span><span id="line.6287">     */</span>
<span class="source-line-no">6288</span><span id="line.6288">    public GreasedRegion separatedRegionBlue(double fraction, int limit)</span>
<span class="source-line-no">6289</span><span id="line.6289">    {</span>
<span class="source-line-no">6290</span><span id="line.6290">        if(fraction &lt;= 0)</span>
<span class="source-line-no">6291</span><span id="line.6291">            return empty();</span>
<span class="source-line-no">6292</span><span id="line.6292">        if(fraction &gt; 0xFFp-8)</span>
<span class="source-line-no">6293</span><span id="line.6293">            fraction = 0xFFp-8;</span>
<span class="source-line-no">6294</span><span id="line.6294">        int ct = size();</span>
<span class="source-line-no">6295</span><span id="line.6295">        if(limit &gt;= ct)</span>
<span class="source-line-no">6296</span><span id="line.6296">            return this;</span>
<span class="source-line-no">6297</span><span id="line.6297">        ct *= fraction;</span>
<span class="source-line-no">6298</span><span id="line.6298">        if(limit &gt;= 0 &amp;&amp; limit &lt; ct)</span>
<span class="source-line-no">6299</span><span id="line.6299">            ct = limit;</span>
<span class="source-line-no">6300</span><span id="line.6300">        for (int i = 255; i &gt;= 0; i--) {</span>
<span class="source-line-no">6301</span><span id="line.6301">            if(ct &gt;= andWrapping64(BlueNoise.LEVELS[i]).size())</span>
<span class="source-line-no">6302</span><span id="line.6302">                return this;</span>
<span class="source-line-no">6303</span><span id="line.6303">        }</span>
<span class="source-line-no">6304</span><span id="line.6304">        return this;</span>
<span class="source-line-no">6305</span><span id="line.6305">    }</span>
<span class="source-line-no">6306</span><span id="line.6306"></span>
<span class="source-line-no">6307</span><span id="line.6307">    public Coord[] randomPortion(IRNG rng, int size)</span>
<span class="source-line-no">6308</span><span id="line.6308">    {</span>
<span class="source-line-no">6309</span><span id="line.6309">        int ct = size(), idx = 0, run = 0;</span>
<span class="source-line-no">6310</span><span id="line.6310">        if(ct &lt;= 0 || size &lt;= 0)</span>
<span class="source-line-no">6311</span><span id="line.6311">            return new Coord[0];</span>
<span class="source-line-no">6312</span><span id="line.6312">        if(ct &lt;= size)</span>
<span class="source-line-no">6313</span><span id="line.6313">            return asCoords();</span>
<span class="source-line-no">6314</span><span id="line.6314">        Coord[] points = new Coord[size];</span>
<span class="source-line-no">6315</span><span id="line.6315">        int[] order = rng.randomOrdering(ct);</span>
<span class="source-line-no">6316</span><span id="line.6316">        Arrays.sort(order, 0, size);</span>
<span class="source-line-no">6317</span><span id="line.6317">        long t, w;</span>
<span class="source-line-no">6318</span><span id="line.6318">        ALL:</span>
<span class="source-line-no">6319</span><span id="line.6319">        for (int s = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">6320</span><span id="line.6320">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">6321</span><span id="line.6321">                if((t = data[x * ySections + s]) != 0)</span>
<span class="source-line-no">6322</span><span id="line.6322">                {</span>
<span class="source-line-no">6323</span><span id="line.6323">                    w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">6324</span><span id="line.6324">                    while (w != 0) {</span>
<span class="source-line-no">6325</span><span id="line.6325">                        if (run++ == order[idx]) {</span>
<span class="source-line-no">6326</span><span id="line.6326">                            points[idx++] = Coord.get(x, (s &lt;&lt; 6) | Long.numberOfTrailingZeros(w));</span>
<span class="source-line-no">6327</span><span id="line.6327">                            if (idx &gt;= size) break ALL;</span>
<span class="source-line-no">6328</span><span id="line.6328">                        }</span>
<span class="source-line-no">6329</span><span id="line.6329">                        t ^= w;</span>
<span class="source-line-no">6330</span><span id="line.6330">                        w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">6331</span><span id="line.6331">                    }</span>
<span class="source-line-no">6332</span><span id="line.6332">                }</span>
<span class="source-line-no">6333</span><span id="line.6333">            }</span>
<span class="source-line-no">6334</span><span id="line.6334">        }</span>
<span class="source-line-no">6335</span><span id="line.6335">        return points;</span>
<span class="source-line-no">6336</span><span id="line.6336">    }</span>
<span class="source-line-no">6337</span><span id="line.6337"></span>
<span class="source-line-no">6338</span><span id="line.6338">    public GreasedRegion randomRegion(IRNG rng, int size)</span>
<span class="source-line-no">6339</span><span id="line.6339">    {</span>
<span class="source-line-no">6340</span><span id="line.6340">        int ct = size(), idx = 0, run = 0;</span>
<span class="source-line-no">6341</span><span id="line.6341">        if(ct &lt;= 0 || size &lt;= 0)</span>
<span class="source-line-no">6342</span><span id="line.6342">            return empty();</span>
<span class="source-line-no">6343</span><span id="line.6343">        if(ct &lt;= size)</span>
<span class="source-line-no">6344</span><span id="line.6344">            return this;</span>
<span class="source-line-no">6345</span><span id="line.6345">        int[] order = rng.randomOrdering(ct);</span>
<span class="source-line-no">6346</span><span id="line.6346">        Arrays.sort(order, 0, size);</span>
<span class="source-line-no">6347</span><span id="line.6347">        long t, w;</span>
<span class="source-line-no">6348</span><span id="line.6348">        ALL:</span>
<span class="source-line-no">6349</span><span id="line.6349">        for (int s = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">6350</span><span id="line.6350">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">6351</span><span id="line.6351">                if((t = data[x * ySections + s]) != 0)</span>
<span class="source-line-no">6352</span><span id="line.6352">                {</span>
<span class="source-line-no">6353</span><span id="line.6353">                    w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">6354</span><span id="line.6354">                    while (w != 0) {</span>
<span class="source-line-no">6355</span><span id="line.6355">                        if (run++ == order[idx]) {</span>
<span class="source-line-no">6356</span><span id="line.6356">                            if(++idx &gt;= size) break ALL;</span>
<span class="source-line-no">6357</span><span id="line.6357">                        }</span>
<span class="source-line-no">6358</span><span id="line.6358">                        else</span>
<span class="source-line-no">6359</span><span id="line.6359">                        {</span>
<span class="source-line-no">6360</span><span id="line.6360">                            data[x * ySections + s] &amp;= ~(1L &lt;&lt; Long.numberOfTrailingZeros(w));</span>
<span class="source-line-no">6361</span><span id="line.6361">                        }</span>
<span class="source-line-no">6362</span><span id="line.6362">                        t ^= w;</span>
<span class="source-line-no">6363</span><span id="line.6363">                        w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">6364</span><span id="line.6364">                    }</span>
<span class="source-line-no">6365</span><span id="line.6365">                }</span>
<span class="source-line-no">6366</span><span id="line.6366">            }</span>
<span class="source-line-no">6367</span><span id="line.6367">        }</span>
<span class="source-line-no">6368</span><span id="line.6368">        tallied = false;</span>
<span class="source-line-no">6369</span><span id="line.6369">        return this;</span>
<span class="source-line-no">6370</span><span id="line.6370">    }</span>
<span class="source-line-no">6371</span><span id="line.6371"></span>
<span class="source-line-no">6372</span><span id="line.6372">    @Override</span>
<span class="source-line-no">6373</span><span id="line.6373">    public boolean contains(int x, int y)</span>
<span class="source-line-no">6374</span><span id="line.6374">    {</span>
<span class="source-line-no">6375</span><span id="line.6375">        return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; width &amp;&amp; y &lt; height &amp;&amp; ySections &gt; 0 &amp;&amp;</span>
<span class="source-line-no">6376</span><span id="line.6376">                ((data[x * ySections + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0);</span>
<span class="source-line-no">6377</span><span id="line.6377">    }</span>
<span class="source-line-no">6378</span><span id="line.6378"></span>
<span class="source-line-no">6379</span><span id="line.6379"></span>
<span class="source-line-no">6380</span><span id="line.6380">    /**</span>
<span class="source-line-no">6381</span><span id="line.6381">     * @return Whether this zone is empty.</span>
<span class="source-line-no">6382</span><span id="line.6382">     */</span>
<span class="source-line-no">6383</span><span id="line.6383">    @Override</span>
<span class="source-line-no">6384</span><span id="line.6384">    public boolean isEmpty() {</span>
<span class="source-line-no">6385</span><span id="line.6385">        if(tallied) return ct &gt; 0;</span>
<span class="source-line-no">6386</span><span id="line.6386">        for (int i = 0; i &lt; data.length; i++) {</span>
<span class="source-line-no">6387</span><span id="line.6387">            if(data[i] != 0L) return false;</span>
<span class="source-line-no">6388</span><span id="line.6388">        }</span>
<span class="source-line-no">6389</span><span id="line.6389">        return true;</span>
<span class="source-line-no">6390</span><span id="line.6390">    }</span>
<span class="source-line-no">6391</span><span id="line.6391"></span>
<span class="source-line-no">6392</span><span id="line.6392">    /**</span>
<span class="source-line-no">6393</span><span id="line.6393">     * Generates a 2D int array from an array or vararg of GreasedRegions, starting at all 0 and adding 1 to the int at</span>
<span class="source-line-no">6394</span><span id="line.6394">     * a position once for every GreasedRegion that has that cell as "on." This means if you give 8 GreasedRegions to</span>
<span class="source-line-no">6395</span><span id="line.6395">     * this method, it can produce any number between 0 and 8 in a cell; if you give 16 GreasedRegions, then it can</span>
<span class="source-line-no">6396</span><span id="line.6396">     * produce any number between 0 and 16 in a cell.</span>
<span class="source-line-no">6397</span><span id="line.6397">     * @param regions an array or vararg of GreasedRegions; must all have the same width and height</span>
<span class="source-line-no">6398</span><span id="line.6398">     * @return a 2D int array with the same width and height as the regions, where an int cell equals the number of given GreasedRegions that had an "on" cell at that position</span>
<span class="source-line-no">6399</span><span id="line.6399">     */</span>
<span class="source-line-no">6400</span><span id="line.6400">    public static int[][] sum(GreasedRegion... regions)</span>
<span class="source-line-no">6401</span><span id="line.6401">    {</span>
<span class="source-line-no">6402</span><span id="line.6402">        if(regions == null || regions.length &lt;= 0)</span>
<span class="source-line-no">6403</span><span id="line.6403">            return new int[0][0];</span>
<span class="source-line-no">6404</span><span id="line.6404">        int w = regions[0].width, h = regions[0].height, l = regions.length, ys = regions[0].ySections;</span>
<span class="source-line-no">6405</span><span id="line.6405">        int[][] numbers = new int[w][h];</span>
<span class="source-line-no">6406</span><span id="line.6406">        for (int x = 0; x &lt; w; x++) {</span>
<span class="source-line-no">6407</span><span id="line.6407">            for (int y = 0; y &lt; h; y++) {</span>
<span class="source-line-no">6408</span><span id="line.6408">                for (int i = 0; i &lt; l; i++) {</span>
<span class="source-line-no">6409</span><span id="line.6409">                    numbers[x][y] += (regions[i].data[x * ys + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0 ? 1 : 0;</span>
<span class="source-line-no">6410</span><span id="line.6410">                }</span>
<span class="source-line-no">6411</span><span id="line.6411">            }</span>
<span class="source-line-no">6412</span><span id="line.6412">        }</span>
<span class="source-line-no">6413</span><span id="line.6413">        return numbers;</span>
<span class="source-line-no">6414</span><span id="line.6414">    }</span>
<span class="source-line-no">6415</span><span id="line.6415"></span>
<span class="source-line-no">6416</span><span id="line.6416">    /**</span>
<span class="source-line-no">6417</span><span id="line.6417">     * Generates a 2D int array from a List of GreasedRegions, starting at all 0 and adding 1 to the int at</span>
<span class="source-line-no">6418</span><span id="line.6418">     * a position once for every GreasedRegion that has that cell as "on." This means if you give 8 GreasedRegions to</span>
<span class="source-line-no">6419</span><span id="line.6419">     * this method, it can produce any number between 0 and 8 in a cell; if you give 16 GreasedRegions, then it can</span>
<span class="source-line-no">6420</span><span id="line.6420">     * produce any number between 0 and 16 in a cell.</span>
<span class="source-line-no">6421</span><span id="line.6421">     * @param regions a List of GreasedRegions; must all have the same width and height</span>
<span class="source-line-no">6422</span><span id="line.6422">     * @return a 2D int array with the same width and height as the regions, where an int cell equals the number of given GreasedRegions that had an "on" cell at that position</span>
<span class="source-line-no">6423</span><span id="line.6423">     */</span>
<span class="source-line-no">6424</span><span id="line.6424">    public static int[][] sum(List&lt;GreasedRegion&gt; regions)</span>
<span class="source-line-no">6425</span><span id="line.6425">    {</span>
<span class="source-line-no">6426</span><span id="line.6426">        if(regions == null || regions.isEmpty())</span>
<span class="source-line-no">6427</span><span id="line.6427">            return new int[0][0];</span>
<span class="source-line-no">6428</span><span id="line.6428">        GreasedRegion t = regions.get(0);</span>
<span class="source-line-no">6429</span><span id="line.6429">        int w = t.width, h = t.height, l = regions.size(), ys = t.ySections;</span>
<span class="source-line-no">6430</span><span id="line.6430">        int[][] numbers = new int[w][h];</span>
<span class="source-line-no">6431</span><span id="line.6431">        for (int x = 0; x &lt; w; x++) {</span>
<span class="source-line-no">6432</span><span id="line.6432">            for (int y = 0; y &lt; h; y++) {</span>
<span class="source-line-no">6433</span><span id="line.6433">                for (int i = 0; i &lt; l; i++) {</span>
<span class="source-line-no">6434</span><span id="line.6434">                    numbers[x][y] += (regions.get(i).data[x * ys + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0 ? 1 : 0;</span>
<span class="source-line-no">6435</span><span id="line.6435">                }</span>
<span class="source-line-no">6436</span><span id="line.6436">            }</span>
<span class="source-line-no">6437</span><span id="line.6437">        }</span>
<span class="source-line-no">6438</span><span id="line.6438">        return numbers;</span>
<span class="source-line-no">6439</span><span id="line.6439">    }</span>
<span class="source-line-no">6440</span><span id="line.6440"></span>
<span class="source-line-no">6441</span><span id="line.6441">    /**</span>
<span class="source-line-no">6442</span><span id="line.6442">     * Generates a 2D double array from an array or vararg of GreasedRegions, starting at all 0 and adding 1 to the double at</span>
<span class="source-line-no">6443</span><span id="line.6443">     * a position once for every GreasedRegion that has that cell as "on." This means if you give 8 GreasedRegions to</span>
<span class="source-line-no">6444</span><span id="line.6444">     * this method, it can produce any number between 0 and 8 in a cell; if you give 16 GreasedRegions, then it can</span>
<span class="source-line-no">6445</span><span id="line.6445">     * produce any number between 0 and 16 in a cell.</span>
<span class="source-line-no">6446</span><span id="line.6446">     * @param regions an array or vararg of GreasedRegions; must all have the same width and height</span>
<span class="source-line-no">6447</span><span id="line.6447">     * @return a 2D double array with the same width and height as the regions, where an double cell equals the number of given GreasedRegions that had an "on" cell at that position</span>
<span class="source-line-no">6448</span><span id="line.6448">     */</span>
<span class="source-line-no">6449</span><span id="line.6449">    public static double[][] sumDouble(GreasedRegion... regions)</span>
<span class="source-line-no">6450</span><span id="line.6450">    {</span>
<span class="source-line-no">6451</span><span id="line.6451">        if(regions == null || regions.length &lt;= 0)</span>
<span class="source-line-no">6452</span><span id="line.6452">            return new double[0][0];</span>
<span class="source-line-no">6453</span><span id="line.6453">        int w = regions[0].width, h = regions[0].height, l = regions.length, ys = regions[0].ySections;</span>
<span class="source-line-no">6454</span><span id="line.6454">        double[][] numbers = new double[w][h];</span>
<span class="source-line-no">6455</span><span id="line.6455">        for (int x = 0; x &lt; w; x++) {</span>
<span class="source-line-no">6456</span><span id="line.6456">            for (int y = 0; y &lt; h; y++) {</span>
<span class="source-line-no">6457</span><span id="line.6457">                for (int i = 0; i &lt; l; i++) {</span>
<span class="source-line-no">6458</span><span id="line.6458">                    numbers[x][y] += (regions[i].data[x * ys + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0 ? 1.0 : 0.0;</span>
<span class="source-line-no">6459</span><span id="line.6459">                }</span>
<span class="source-line-no">6460</span><span id="line.6460">            }</span>
<span class="source-line-no">6461</span><span id="line.6461">        }</span>
<span class="source-line-no">6462</span><span id="line.6462">        return numbers;</span>
<span class="source-line-no">6463</span><span id="line.6463">    }</span>
<span class="source-line-no">6464</span><span id="line.6464"></span>
<span class="source-line-no">6465</span><span id="line.6465">    /**</span>
<span class="source-line-no">6466</span><span id="line.6466">     * Generates a 2D double array from a List of GreasedRegions, starting at all 0 and adding 1 to the double at</span>
<span class="source-line-no">6467</span><span id="line.6467">     * a position once for every GreasedRegion that has that cell as "on." This means if you give 8 GreasedRegions to</span>
<span class="source-line-no">6468</span><span id="line.6468">     * this method, it can produce any number between 0 and 8 in a cell; if you give 16 GreasedRegions, then it can</span>
<span class="source-line-no">6469</span><span id="line.6469">     * produce any number between 0 and 16 in a cell.</span>
<span class="source-line-no">6470</span><span id="line.6470">     * @param regions a List of GreasedRegions; must all have the same width and height</span>
<span class="source-line-no">6471</span><span id="line.6471">     * @return a 2D double array with the same width and height as the regions, where an double cell equals the number of given GreasedRegions that had an "on" cell at that position</span>
<span class="source-line-no">6472</span><span id="line.6472">     */</span>
<span class="source-line-no">6473</span><span id="line.6473">    public static double[][] sumDouble(List&lt;GreasedRegion&gt; regions)</span>
<span class="source-line-no">6474</span><span id="line.6474">    {</span>
<span class="source-line-no">6475</span><span id="line.6475">        if(regions == null || regions.isEmpty())</span>
<span class="source-line-no">6476</span><span id="line.6476">            return new double[0][0];</span>
<span class="source-line-no">6477</span><span id="line.6477">        GreasedRegion t = regions.get(0);</span>
<span class="source-line-no">6478</span><span id="line.6478">        int w = t.width, h = t.height, l = regions.size(), ys = t.ySections;</span>
<span class="source-line-no">6479</span><span id="line.6479">        double[][] numbers = new double[w][h];</span>
<span class="source-line-no">6480</span><span id="line.6480">        for (int x = 0; x &lt; w; x++) {</span>
<span class="source-line-no">6481</span><span id="line.6481">            for (int y = 0; y &lt; h; y++) {</span>
<span class="source-line-no">6482</span><span id="line.6482">                for (int i = 0; i &lt; l; i++) {</span>
<span class="source-line-no">6483</span><span id="line.6483">                    numbers[x][y] += (regions.get(i).data[x * ys + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0 ? 1.0 : 0.0;</span>
<span class="source-line-no">6484</span><span id="line.6484">                }</span>
<span class="source-line-no">6485</span><span id="line.6485">            }</span>
<span class="source-line-no">6486</span><span id="line.6486">        }</span>
<span class="source-line-no">6487</span><span id="line.6487">        return numbers;</span>
<span class="source-line-no">6488</span><span id="line.6488">    }</span>
<span class="source-line-no">6489</span><span id="line.6489"></span>
<span class="source-line-no">6490</span><span id="line.6490">    /**</span>
<span class="source-line-no">6491</span><span id="line.6491">     * Generates a 2D int array from an array of GreasedRegions and an array of weights, starting the 2D result at all 0</span>
<span class="source-line-no">6492</span><span id="line.6492">     * and, for every GreasedRegion that has that cell as "on," adding the int in the corresponding weights array at</span>
<span class="source-line-no">6493</span><span id="line.6493">     * the position of that cell. This means if you give an array of 4 GreasedRegions to this method along with the</span>
<span class="source-line-no">6494</span><span id="line.6494">     * weights {@code 1, 2, 3, 4}, it can produce a number between 0 and 10 in a cell (where 10 is used when all 4</span>
<span class="source-line-no">6495</span><span id="line.6495">     * GreasedRegions have a cell "on," since {@code 1 + 2 + 3 + 4 == 10}); if the weights are instead</span>
<span class="source-line-no">6496</span><span id="line.6496">     * {@code 1, 10, 100, 1000}, then the results can vary between 0 and 1111, where 1111 is only if all GreasedRegions</span>
<span class="source-line-no">6497</span><span id="line.6497">     * have a cell as "on." The weights array must have a length at least equal to the length of the regions array.</span>
<span class="source-line-no">6498</span><span id="line.6498">     * @param regions an array of GreasedRegions; must all have the same width and height</span>
<span class="source-line-no">6499</span><span id="line.6499">     * @param weights an array of ints; must have length at least equal to regions' length</span>
<span class="source-line-no">6500</span><span id="line.6500">     * @return a 2D int array with the same width and height as the regions, where an int cell equals the sum of the weights corresponding to GreasedRegions that had an "on" cell at that position</span>
<span class="source-line-no">6501</span><span id="line.6501">     */</span>
<span class="source-line-no">6502</span><span id="line.6502">    public static int[][] sumWeighted(GreasedRegion[] regions, int[] weights)</span>
<span class="source-line-no">6503</span><span id="line.6503">    {</span>
<span class="source-line-no">6504</span><span id="line.6504">        if(regions == null || regions.length &lt;= 0 || weights == null || weights.length &lt; regions.length)</span>
<span class="source-line-no">6505</span><span id="line.6505">            return new int[0][0];</span>
<span class="source-line-no">6506</span><span id="line.6506">        int w = regions[0].width, h = regions[0].height, l = regions.length, ys = regions[0].ySections;</span>
<span class="source-line-no">6507</span><span id="line.6507">        int[][] numbers = new int[w][h];</span>
<span class="source-line-no">6508</span><span id="line.6508">        for (int x = 0; x &lt; w; x++) {</span>
<span class="source-line-no">6509</span><span id="line.6509">            for (int y = 0; y &lt; h; y++) {</span>
<span class="source-line-no">6510</span><span id="line.6510">                for (int i = 0; i &lt; l; i++) {</span>
<span class="source-line-no">6511</span><span id="line.6511">                    numbers[x][y] += (regions[i].data[x * ys + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0 ? weights[i] : 0;</span>
<span class="source-line-no">6512</span><span id="line.6512">                }</span>
<span class="source-line-no">6513</span><span id="line.6513">            }</span>
<span class="source-line-no">6514</span><span id="line.6514">        }</span>
<span class="source-line-no">6515</span><span id="line.6515">        return numbers;</span>
<span class="source-line-no">6516</span><span id="line.6516">    }</span>
<span class="source-line-no">6517</span><span id="line.6517"></span>
<span class="source-line-no">6518</span><span id="line.6518">    /**</span>
<span class="source-line-no">6519</span><span id="line.6519">     * Generates a 2D double array from an array of GreasedRegions and an array of weights, starting the 2D result at</span>
<span class="source-line-no">6520</span><span id="line.6520">     * all 0 and, for every GreasedRegion that has that cell as "on," adding the double in the corresponding weights</span>
<span class="source-line-no">6521</span><span id="line.6521">     * array at the position of that cell. This means if you give an array of 4 GreasedRegions to this method along with</span>
<span class="source-line-no">6522</span><span id="line.6522">     * the weights {@code 1, 2, 3, 4}, it can produce a number between 0 and 10 in a cell (where 10 is used when all 4</span>
<span class="source-line-no">6523</span><span id="line.6523">     * GreasedRegions have a cell "on," since {@code 1 + 2 + 3 + 4 == 10}); if the weights are instead</span>
<span class="source-line-no">6524</span><span id="line.6524">     * {@code 1, 10, 100, 1000}, then the results can vary between 0 and 1111, where 1111 is only if all GreasedRegions</span>
<span class="source-line-no">6525</span><span id="line.6525">     * have a cell as "on." The weights array must have a length at least equal to the length of the regions array.</span>
<span class="source-line-no">6526</span><span id="line.6526">     * @param regions an array of GreasedRegions; must all have the same width and height</span>
<span class="source-line-no">6527</span><span id="line.6527">     * @param weights an array of doubles; must have length at least equal to regions' length</span>
<span class="source-line-no">6528</span><span id="line.6528">     * @return a 2D double array with the same width and height as the regions, where an double cell equals the sum of the weights corresponding to GreasedRegions that had an "on" cell at that position</span>
<span class="source-line-no">6529</span><span id="line.6529">     */</span>
<span class="source-line-no">6530</span><span id="line.6530">    public static double[][] sumWeightedDouble(GreasedRegion[] regions, double[] weights)</span>
<span class="source-line-no">6531</span><span id="line.6531">    {</span>
<span class="source-line-no">6532</span><span id="line.6532">        if(regions == null || regions.length &lt;= 0 || weights == null || weights.length &lt; regions.length)</span>
<span class="source-line-no">6533</span><span id="line.6533">            return new double[0][0];</span>
<span class="source-line-no">6534</span><span id="line.6534">        int w = regions[0].width, h = regions[0].height, l = regions.length, ys = regions[0].ySections;</span>
<span class="source-line-no">6535</span><span id="line.6535">        double[][] numbers = new double[w][h];</span>
<span class="source-line-no">6536</span><span id="line.6536">        for (int x = 0; x &lt; w; x++) {</span>
<span class="source-line-no">6537</span><span id="line.6537">            for (int y = 0; y &lt; h; y++) {</span>
<span class="source-line-no">6538</span><span id="line.6538">                for (int i = 0; i &lt; l; i++) {</span>
<span class="source-line-no">6539</span><span id="line.6539">                    numbers[x][y] += (regions[i].data[x * ys + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0 ? weights[i] : 0.0;</span>
<span class="source-line-no">6540</span><span id="line.6540">                }</span>
<span class="source-line-no">6541</span><span id="line.6541">            }</span>
<span class="source-line-no">6542</span><span id="line.6542">        }</span>
<span class="source-line-no">6543</span><span id="line.6543">        return numbers;</span>
<span class="source-line-no">6544</span><span id="line.6544">    }</span>
<span class="source-line-no">6545</span><span id="line.6545"></span>
<span class="source-line-no">6546</span><span id="line.6546">    /**</span>
<span class="source-line-no">6547</span><span id="line.6547">     * Adds to an existing 2D int array with an array or vararg of GreasedRegions, adding 1 to the int in existing at</span>
<span class="source-line-no">6548</span><span id="line.6548">     * a position once for every GreasedRegion that has that cell as "on." This means if you give 8 GreasedRegions to</span>
<span class="source-line-no">6549</span><span id="line.6549">     * this method, it can increment by any number between 0 and 8 in a cell; if you give 16 GreasedRegions, then it can</span>
<span class="source-line-no">6550</span><span id="line.6550">     * increase the value in existing by any number between 0 and 16 in a cell.</span>
<span class="source-line-no">6551</span><span id="line.6551">     * @param existing a non-null 2D int array that will have each cell incremented by the sum of the GreasedRegions</span>
<span class="source-line-no">6552</span><span id="line.6552">     * @param regions an array or vararg of GreasedRegions; must all have the same width and height</span>
<span class="source-line-no">6553</span><span id="line.6553">     * @return existing, after modification, where an int cell will be changed by the number of given GreasedRegions that had an "on" cell at that position</span>
<span class="source-line-no">6554</span><span id="line.6554">     */</span>
<span class="source-line-no">6555</span><span id="line.6555">    public static int[][] sumInto(int[][] existing, GreasedRegion... regions)</span>
<span class="source-line-no">6556</span><span id="line.6556">    {</span>
<span class="source-line-no">6557</span><span id="line.6557">        if(regions == null || regions.length &lt;= 0 || existing == null || existing.length == 0 || existing[0].length == 0)</span>
<span class="source-line-no">6558</span><span id="line.6558">            return existing;</span>
<span class="source-line-no">6559</span><span id="line.6559">        int w = existing.length, h = existing[0].length, l = regions.length, ys;</span>
<span class="source-line-no">6560</span><span id="line.6560">        for (int i = 0; i &lt; l; i++) {</span>
<span class="source-line-no">6561</span><span id="line.6561">            GreasedRegion region = regions[i];</span>
<span class="source-line-no">6562</span><span id="line.6562">            ys = region.ySections;</span>
<span class="source-line-no">6563</span><span id="line.6563">            for (int x = 0; x &lt; w &amp;&amp; x &lt; region.width; x++) {</span>
<span class="source-line-no">6564</span><span id="line.6564">                for (int y = 0; y &lt; h &amp;&amp; y &lt; region.height; y++) {</span>
<span class="source-line-no">6565</span><span id="line.6565">                    existing[x][y] += (region.data[x * ys + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0 ? 1 : 0;</span>
<span class="source-line-no">6566</span><span id="line.6566">                }</span>
<span class="source-line-no">6567</span><span id="line.6567">            }</span>
<span class="source-line-no">6568</span><span id="line.6568">        }</span>
<span class="source-line-no">6569</span><span id="line.6569">        return existing;</span>
<span class="source-line-no">6570</span><span id="line.6570">    }</span>
<span class="source-line-no">6571</span><span id="line.6571"></span>
<span class="source-line-no">6572</span><span id="line.6572"></span>
<span class="source-line-no">6573</span><span id="line.6573">    /**</span>
<span class="source-line-no">6574</span><span id="line.6574">     * Adds to an existing 2D double array with an array or vararg of GreasedRegions, adding 1 to the double in existing</span>
<span class="source-line-no">6575</span><span id="line.6575">     * at a position once for every GreasedRegion that has that cell as "on." This means if you give 8 GreasedRegions to</span>
<span class="source-line-no">6576</span><span id="line.6576">     * this method, it can increment by any number between 0 and 8 in a cell; if you give 16 GreasedRegions, then it can</span>
<span class="source-line-no">6577</span><span id="line.6577">     * increase the value in existing by any number between 0 and 16 in a cell.</span>
<span class="source-line-no">6578</span><span id="line.6578">     * @param existing a non-null 2D double array that will have each cell incremented by the sum of the GreasedRegions</span>
<span class="source-line-no">6579</span><span id="line.6579">     * @param regions an array or vararg of GreasedRegions; must all have the same width and height</span>
<span class="source-line-no">6580</span><span id="line.6580">     * @return existing, after modification, where a double cell will be changed by the number of given GreasedRegions that had an "on" cell at that position</span>
<span class="source-line-no">6581</span><span id="line.6581">     */</span>
<span class="source-line-no">6582</span><span id="line.6582">    public static double[][] sumIntoDouble(double[][] existing, GreasedRegion... regions)</span>
<span class="source-line-no">6583</span><span id="line.6583">    {</span>
<span class="source-line-no">6584</span><span id="line.6584">        if(regions == null || regions.length &lt;= 0 || existing == null || existing.length == 0 || existing[0].length == 0)</span>
<span class="source-line-no">6585</span><span id="line.6585">            return existing;</span>
<span class="source-line-no">6586</span><span id="line.6586">        int w = existing.length, h = existing[0].length, l = regions.length, ys = regions[0].ySections;</span>
<span class="source-line-no">6587</span><span id="line.6587">        for (int i = 0; i &lt; l; i++) {</span>
<span class="source-line-no">6588</span><span id="line.6588">            for (int x = 0; x &lt; w &amp;&amp; x &lt; regions[i].width; x++) {</span>
<span class="source-line-no">6589</span><span id="line.6589">                for (int y = 0; y &lt; h &amp;&amp; y &lt; regions[i].height; y++) {</span>
<span class="source-line-no">6590</span><span id="line.6590">                    existing[x][y] += (regions[i].data[x * ys + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0 ? 1.0 : 0.0;</span>
<span class="source-line-no">6591</span><span id="line.6591">                }</span>
<span class="source-line-no">6592</span><span id="line.6592">            }</span>
<span class="source-line-no">6593</span><span id="line.6593">        }</span>
<span class="source-line-no">6594</span><span id="line.6594">        return existing;</span>
<span class="source-line-no">6595</span><span id="line.6595">    }</span>
<span class="source-line-no">6596</span><span id="line.6596"></span>
<span class="source-line-no">6597</span><span id="line.6597">    /**</span>
<span class="source-line-no">6598</span><span id="line.6598">     * Discouraged from active use; slower than {@link squidpony.squidai.DijkstraMap} and has less features.</span>
<span class="source-line-no">6599</span><span id="line.6599">     * @param map a 2D char array where '#' is a wall</span>
<span class="source-line-no">6600</span><span id="line.6600">     * @param goals an array or vararg of Coord to get the distances toward</span>
<span class="source-line-no">6601</span><span id="line.6601">     * @return a 2D double array of distances from a cell to the nearest goal</span>
<span class="source-line-no">6602</span><span id="line.6602">     */</span>
<span class="source-line-no">6603</span><span id="line.6603">    public static double[][] dijkstraScan(char[][] map, Coord... goals)</span>
<span class="source-line-no">6604</span><span id="line.6604">    {</span>
<span class="source-line-no">6605</span><span id="line.6605">        if(map == null || map.length &lt;= 0 || map[0].length &lt;= 0 || goals == null || goals.length &lt;= 0)</span>
<span class="source-line-no">6606</span><span id="line.6606">            return new double[0][0];</span>
<span class="source-line-no">6607</span><span id="line.6607">        int w = map.length, h = map[0].length, ys = (h + 63) &gt;&gt;&gt; 6;</span>
<span class="source-line-no">6608</span><span id="line.6608">        double[][] numbers = new double[w][h];</span>
<span class="source-line-no">6609</span><span id="line.6609">        GreasedRegion walls = new GreasedRegion(map, '#'), floors = new GreasedRegion(walls).not(),</span>
<span class="source-line-no">6610</span><span id="line.6610">                middle = new GreasedRegion(w, h, goals).and(floors);</span>
<span class="source-line-no">6611</span><span id="line.6611">        ArrayList&lt;GreasedRegion&gt; regions = middle.floodSeriesToLimit(floors);</span>
<span class="source-line-no">6612</span><span id="line.6612">        int l = regions.size();</span>
<span class="source-line-no">6613</span><span id="line.6613">        for (int x = 0; x &lt; w; x++) {</span>
<span class="source-line-no">6614</span><span id="line.6614">            for (int y = 0; y &lt; h; y++) {</span>
<span class="source-line-no">6615</span><span id="line.6615">                for (int i = 0; i &lt; l; i++) {</span>
<span class="source-line-no">6616</span><span id="line.6616">                    numbers[x][y] += (regions.get(i).data[x * ys + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0 ? 1 : 0;</span>
<span class="source-line-no">6617</span><span id="line.6617">                }</span>
<span class="source-line-no">6618</span><span id="line.6618">            }</span>
<span class="source-line-no">6619</span><span id="line.6619">        }</span>
<span class="source-line-no">6620</span><span id="line.6620">        return numbers;</span>
<span class="source-line-no">6621</span><span id="line.6621">    }</span>
<span class="source-line-no">6622</span><span id="line.6622">    /**</span>
<span class="source-line-no">6623</span><span id="line.6623">     * Discouraged from active use; slower than {@link squidpony.squidai.DijkstraMap} and has less features.</span>
<span class="source-line-no">6624</span><span id="line.6624">     * @param map a 2D char array where '#' is a wall</span>
<span class="source-line-no">6625</span><span id="line.6625">     * @param goals an array or vararg of Coord to get the distances toward</span>
<span class="source-line-no">6626</span><span id="line.6626">     * @return a 2D double array of distances from a cell to the nearest goal</span>
<span class="source-line-no">6627</span><span id="line.6627">     */</span>
<span class="source-line-no">6628</span><span id="line.6628">    public static double[][] dijkstraScan8way(char[][] map, Coord... goals)</span>
<span class="source-line-no">6629</span><span id="line.6629">    {</span>
<span class="source-line-no">6630</span><span id="line.6630">        if(map == null || map.length &lt;= 0 || map[0].length &lt;= 0 || goals == null || goals.length &lt;= 0)</span>
<span class="source-line-no">6631</span><span id="line.6631">            return new double[0][0];</span>
<span class="source-line-no">6632</span><span id="line.6632">        int w = map.length, h = map[0].length, ys = (h + 63) &gt;&gt;&gt; 6;</span>
<span class="source-line-no">6633</span><span id="line.6633">        double[][] numbers = new double[w][h];</span>
<span class="source-line-no">6634</span><span id="line.6634">        GreasedRegion walls = new GreasedRegion(map, '#'), floors = new GreasedRegion(walls).not(),</span>
<span class="source-line-no">6635</span><span id="line.6635">                middle = new GreasedRegion(w, h, goals).and(floors);</span>
<span class="source-line-no">6636</span><span id="line.6636">        ArrayList&lt;GreasedRegion&gt; regions = middle.floodSeriesToLimit8way(floors);</span>
<span class="source-line-no">6637</span><span id="line.6637">        int l = regions.size();</span>
<span class="source-line-no">6638</span><span id="line.6638">        for (int x = 0; x &lt; w; x++) {</span>
<span class="source-line-no">6639</span><span id="line.6639">            for (int y = 0; y &lt; h; y++) {</span>
<span class="source-line-no">6640</span><span id="line.6640">                for (int i = 0; i &lt; l; i++) {</span>
<span class="source-line-no">6641</span><span id="line.6641">                    numbers[x][y] += (regions.get(i).data[x * ys + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0 ? 1 : 0;</span>
<span class="source-line-no">6642</span><span id="line.6642">                }</span>
<span class="source-line-no">6643</span><span id="line.6643">            }</span>
<span class="source-line-no">6644</span><span id="line.6644">        }</span>
<span class="source-line-no">6645</span><span id="line.6645">        return numbers;</span>
<span class="source-line-no">6646</span><span id="line.6646">    }</span>
<span class="source-line-no">6647</span><span id="line.6647"></span>
<span class="source-line-no">6648</span><span id="line.6648">    /**</span>
<span class="source-line-no">6649</span><span id="line.6649">     * Generates a 2D int array from an array or vararg of GreasedRegions, treating each cell in the nth region as the</span>
<span class="source-line-no">6650</span><span id="line.6650">     * nth bit of the int at the corresponding x,y cell in the int array. This means if you give 8 GreasedRegions to</span>
<span class="source-line-no">6651</span><span id="line.6651">     * this method, it can produce any 8-bit number in a cell (0-255); if you give 16 GreasedRegions, then it can</span>
<span class="source-line-no">6652</span><span id="line.6652">     * produce any 16-bit number (0-65535).</span>
<span class="source-line-no">6653</span><span id="line.6653">     * @param regions an array or vararg of GreasedRegions; must all have the same width and height</span>
<span class="source-line-no">6654</span><span id="line.6654">     * @return a 2D int array with the same width and height as the regions, with bits per int taken from the regions</span>
<span class="source-line-no">6655</span><span id="line.6655">     */</span>
<span class="source-line-no">6656</span><span id="line.6656">    public static int[][] bitSum(GreasedRegion... regions)</span>
<span class="source-line-no">6657</span><span id="line.6657">    {</span>
<span class="source-line-no">6658</span><span id="line.6658">        if(regions == null || regions.length &lt;= 0)</span>
<span class="source-line-no">6659</span><span id="line.6659">            return new int[0][0];</span>
<span class="source-line-no">6660</span><span id="line.6660">        int w = regions[0].width, h = regions[0].height, l = Math.min(32, regions.length), ys = regions[0].ySections;</span>
<span class="source-line-no">6661</span><span id="line.6661">        int[][] numbers = new int[w][h];</span>
<span class="source-line-no">6662</span><span id="line.6662">        for (int x = 0; x &lt; w; x++) {</span>
<span class="source-line-no">6663</span><span id="line.6663">            for (int y = 0; y &lt; h; y++) {</span>
<span class="source-line-no">6664</span><span id="line.6664">                for (int i = 0; i &lt; l; i++) {</span>
<span class="source-line-no">6665</span><span id="line.6665">                    numbers[x][y] |= (regions[i].data[x * ys + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0 ? 1 &lt;&lt; i : 0;</span>
<span class="source-line-no">6666</span><span id="line.6666">                }</span>
<span class="source-line-no">6667</span><span id="line.6667">            }</span>
<span class="source-line-no">6668</span><span id="line.6668">        }</span>
<span class="source-line-no">6669</span><span id="line.6669">        return numbers;</span>
<span class="source-line-no">6670</span><span id="line.6670">    }</span>
<span class="source-line-no">6671</span><span id="line.6671"></span>
<span class="source-line-no">6672</span><span id="line.6672">    /*</span>
<span class="source-line-no">6673</span><span id="line.6673">    public static int[][] selectiveNegate(int[][] numbers, GreasedRegion region, int mask)</span>
<span class="source-line-no">6674</span><span id="line.6674">    {</span>
<span class="source-line-no">6675</span><span id="line.6675">        if(region == null)</span>
<span class="source-line-no">6676</span><span id="line.6676">            return numbers;</span>
<span class="source-line-no">6677</span><span id="line.6677">        int w = region.width, h = region.height, ys = region.ySections;</span>
<span class="source-line-no">6678</span><span id="line.6678">        for (int x = 0; x &lt; w; x++) {</span>
<span class="source-line-no">6679</span><span id="line.6679">            for (int y = 0; y &lt; h; y++) {</span>
<span class="source-line-no">6680</span><span id="line.6680">                if((region.data[x * ys + (y &gt;&gt; 6)] &amp; (1L &lt;&lt; (y &amp; 63))) != 0) numbers[x][y] = (~numbers[x][y] &amp; mask);</span>
<span class="source-line-no">6681</span><span id="line.6681">            }</span>
<span class="source-line-no">6682</span><span id="line.6682">        }</span>
<span class="source-line-no">6683</span><span id="line.6683">        return numbers;</span>
<span class="source-line-no">6684</span><span id="line.6684">    }</span>
<span class="source-line-no">6685</span><span id="line.6685">    */</span>
<span class="source-line-no">6686</span><span id="line.6686"></span>
<span class="source-line-no">6687</span><span id="line.6687">    @Override</span>
<span class="source-line-no">6688</span><span id="line.6688">    public boolean equals(Object o) {</span>
<span class="source-line-no">6689</span><span id="line.6689">        if (this == o) return true;</span>
<span class="source-line-no">6690</span><span id="line.6690">        if (o == null || getClass() != o.getClass()) return false;</span>
<span class="source-line-no">6691</span><span id="line.6691"></span>
<span class="source-line-no">6692</span><span id="line.6692">        GreasedRegion that = (GreasedRegion) o;</span>
<span class="source-line-no">6693</span><span id="line.6693"></span>
<span class="source-line-no">6694</span><span id="line.6694">        if (height != that.height) return false;</span>
<span class="source-line-no">6695</span><span id="line.6695">        if (width != that.width) return false;</span>
<span class="source-line-no">6696</span><span id="line.6696">        if (ySections != that.ySections) return false;</span>
<span class="source-line-no">6697</span><span id="line.6697">        if (yEndMask != that.yEndMask) return false;</span>
<span class="source-line-no">6698</span><span id="line.6698">        return Arrays.equals(data, that.data);</span>
<span class="source-line-no">6699</span><span id="line.6699">    }</span>
<span class="source-line-no">6700</span><span id="line.6700"></span>
<span class="source-line-no">6701</span><span id="line.6701">    @Override</span>
<span class="source-line-no">6702</span><span id="line.6702">    public int hashCode() {</span>
<span class="source-line-no">6703</span><span id="line.6703">        return CrossHash.hash(data) ^ GWTRNG.determineInt(GWTRNG.determineInt(height) + width);</span>
<span class="source-line-no">6704</span><span id="line.6704">//        long result = 0x1A976FDF6BF60B8EL, z = 0x60642E2A34326F15L;</span>
<span class="source-line-no">6705</span><span id="line.6705">//        final int len = data.length;</span>
<span class="source-line-no">6706</span><span id="line.6706">//        for (int i = 0; i &lt; len; i++) {</span>
<span class="source-line-no">6707</span><span id="line.6707">//            result ^= (z += (data[i] ^ 0xC6BC279692B5CC85L) * 0x6C8E9CF570932BABL);</span>
<span class="source-line-no">6708</span><span id="line.6708">//            result = (result &lt;&lt; 54 | result &gt;&gt;&gt; 10);</span>
<span class="source-line-no">6709</span><span id="line.6709">//        }</span>
<span class="source-line-no">6710</span><span id="line.6710">//        result ^= (z += (height ^ 0xC6BC279692B5CC85L) * 0x6C8E9CF570932BABL);</span>
<span class="source-line-no">6711</span><span id="line.6711">//        result = (result &lt;&lt; 54 | result &gt;&gt;&gt; 10);</span>
<span class="source-line-no">6712</span><span id="line.6712">//        result ^= (z += (width ^ 0xC6BC279692B5CC85L) * 0x6C8E9CF570932BABL);</span>
<span class="source-line-no">6713</span><span id="line.6713">//        result = (result &lt;&lt; 54 | result &gt;&gt;&gt; 10);</span>
<span class="source-line-no">6714</span><span id="line.6714">//</span>
<span class="source-line-no">6715</span><span id="line.6715">//        result += (z ^ z &gt;&gt;&gt; 26) * 0x632BE59BD9B4E019L;</span>
<span class="source-line-no">6716</span><span id="line.6716">//        result = (result ^ result &gt;&gt;&gt; 33) * 0xFF51AFD7ED558CCDL;</span>
<span class="source-line-no">6717</span><span id="line.6717">//        return (int)((result ^ result &gt;&gt;&gt; 33) * 0xC4CEB9FE1A85EC53L);</span>
<span class="source-line-no">6718</span><span id="line.6718">    }</span>
<span class="source-line-no">6719</span><span id="line.6719">    public long hash64() {</span>
<span class="source-line-no">6720</span><span id="line.6720">        return CrossHash.hash64(data) ^ DiverRNG.randomize(DiverRNG.randomize(height) + width);</span>
<span class="source-line-no">6721</span><span id="line.6721">//</span>
<span class="source-line-no">6722</span><span id="line.6722">//        long result = 0x1A976FDF6BF60B8EL, z = 0x60642E2A34326F15L;</span>
<span class="source-line-no">6723</span><span id="line.6723">//        final int len = data.length;</span>
<span class="source-line-no">6724</span><span id="line.6724">//        for (int i = 0; i &lt; len; i++) {</span>
<span class="source-line-no">6725</span><span id="line.6725">//            result ^= (z += (data[i] ^ 0xC6BC279692B5CC85L) * 0x6C8E9CF570932BABL);</span>
<span class="source-line-no">6726</span><span id="line.6726">//            result = (result &lt;&lt; 54 | result &gt;&gt;&gt; 10);</span>
<span class="source-line-no">6727</span><span id="line.6727">//        }</span>
<span class="source-line-no">6728</span><span id="line.6728">//        result ^= (z += (height ^ 0xC6BC279692B5CC85L) * 0x6C8E9CF570932BABL);</span>
<span class="source-line-no">6729</span><span id="line.6729">//        result = (result &lt;&lt; 54 | result &gt;&gt;&gt; 10);</span>
<span class="source-line-no">6730</span><span id="line.6730">//        result ^= (z += (width ^ 0xC6BC279692B5CC85L) * 0x6C8E9CF570932BABL);</span>
<span class="source-line-no">6731</span><span id="line.6731">//        result = (result &lt;&lt; 54 | result &gt;&gt;&gt; 10);</span>
<span class="source-line-no">6732</span><span id="line.6732">//        </span>
<span class="source-line-no">6733</span><span id="line.6733">//        result += (z ^ z &gt;&gt;&gt; 26) * 0x632BE59BD9B4E019L;</span>
<span class="source-line-no">6734</span><span id="line.6734">//        result = (result ^ result &gt;&gt;&gt; 33) * 0xFF51AFD7ED558CCDL;</span>
<span class="source-line-no">6735</span><span id="line.6735">//        return ((result ^ result &gt;&gt;&gt; 33) * 0xC4CEB9FE1A85EC53L);</span>
<span class="source-line-no">6736</span><span id="line.6736">    }</span>
<span class="source-line-no">6737</span><span id="line.6737"></span>
<span class="source-line-no">6738</span><span id="line.6738">    /**</span>
<span class="source-line-no">6739</span><span id="line.6739">     * Computes a 64-bit hash code of this GreasedRegion given a 64-bit seed; even if given two very similar seeds,</span>
<span class="source-line-no">6740</span><span id="line.6740">     * this should produce very different hash codes for the same GreasedRegion.</span>
<span class="source-line-no">6741</span><span id="line.6741">     * &lt;br&gt;</span>
<span class="source-line-no">6742</span><span id="line.6742">     * Meant for potential use in Bloom filters. Uses {@link CrossHash.Yolk}'s algorithm(s).</span>
<span class="source-line-no">6743</span><span id="line.6743">     * @param seed a seed that will determine how the hashing algorithm works; all 64 bits are used.</span>
<span class="source-line-no">6744</span><span id="line.6744">     * @return a 64-bit hash code for this GreasedRegion</span>
<span class="source-line-no">6745</span><span id="line.6745">     */</span>
<span class="source-line-no">6746</span><span id="line.6746">    public long hash64(long seed)</span>
<span class="source-line-no">6747</span><span id="line.6747">    {</span>
<span class="source-line-no">6748</span><span id="line.6748">        seed += b1;</span>
<span class="source-line-no">6749</span><span id="line.6749">        seed ^= seed &gt;&gt;&gt; 23 ^ seed &gt;&gt;&gt; 48 ^ seed &lt;&lt; 7 ^ seed &lt;&lt; 53;</span>
<span class="source-line-no">6750</span><span id="line.6750">        long a = seed + b4, b = seed + b3, c = seed + b2, d = seed + b1;</span>
<span class="source-line-no">6751</span><span id="line.6751">        final int len = data.length;</span>
<span class="source-line-no">6752</span><span id="line.6752">        for (int i = 3; i &lt; len; i+=4) {</span>
<span class="source-line-no">6753</span><span id="line.6753">            a ^= data[i-3] * b1; a = (a &lt;&lt; 23 | a &gt;&gt;&gt; 41) * b3;</span>
<span class="source-line-no">6754</span><span id="line.6754">            b ^= data[i-2] * b2; b = (b &lt;&lt; 25 | b &gt;&gt;&gt; 39) * b4;</span>
<span class="source-line-no">6755</span><span id="line.6755">            c ^= data[i-1] * b3; c = (c &lt;&lt; 29 | c &gt;&gt;&gt; 35) * b5;</span>
<span class="source-line-no">6756</span><span id="line.6756">            d ^= data[i  ] * b4; d = (d &lt;&lt; 31 | d &gt;&gt;&gt; 33) * b1;</span>
<span class="source-line-no">6757</span><span id="line.6757">            seed += a + b + c + d;</span>
<span class="source-line-no">6758</span><span id="line.6758">        }</span>
<span class="source-line-no">6759</span><span id="line.6759">        seed += b5;</span>
<span class="source-line-no">6760</span><span id="line.6760">        switch (len &amp; 3) {</span>
<span class="source-line-no">6761</span><span id="line.6761">            case 1: seed = wow(seed, b1 ^ data[len-1]); break;</span>
<span class="source-line-no">6762</span><span id="line.6762">            case 2: seed = wow(seed + data[len-2], b2 + data[len-1]); break;</span>
<span class="source-line-no">6763</span><span id="line.6763">            case 3: seed = wow(seed + data[len-3], b2 + data[len-2]) ^ wow(seed + data[len-1], seed ^ b3); break;</span>
<span class="source-line-no">6764</span><span id="line.6764">        }</span>
<span class="source-line-no">6765</span><span id="line.6765">        seed = wow(seed + height, b4 + width);</span>
<span class="source-line-no">6766</span><span id="line.6766">        seed = (seed ^ seed &lt;&lt; 16) * (len ^ b0 ^ seed &gt;&gt;&gt; 32);</span>
<span class="source-line-no">6767</span><span id="line.6767">        return seed - (seed &gt;&gt;&gt; 31) + (seed &lt;&lt; 33);</span>
<span class="source-line-no">6768</span><span id="line.6768"></span>
<span class="source-line-no">6769</span><span id="line.6769">    }</span>
<span class="source-line-no">6770</span><span id="line.6770"></span>
<span class="source-line-no">6771</span><span id="line.6771">    public String serializeToString()</span>
<span class="source-line-no">6772</span><span id="line.6772">    {</span>
<span class="source-line-no">6773</span><span id="line.6773">        return width +</span>
<span class="source-line-no">6774</span><span id="line.6774">                "," + height +</span>
<span class="source-line-no">6775</span><span id="line.6775">                "," + StringKit.joinAlt(",",data);</span>
<span class="source-line-no">6776</span><span id="line.6776">    }</span>
<span class="source-line-no">6777</span><span id="line.6777">    public static GreasedRegion deserializeFromString(String s)</span>
<span class="source-line-no">6778</span><span id="line.6778">    {</span>
<span class="source-line-no">6779</span><span id="line.6779">        if(s == null || s.isEmpty())</span>
<span class="source-line-no">6780</span><span id="line.6780">            return null;</span>
<span class="source-line-no">6781</span><span id="line.6781">        int gap = s.indexOf(','), w = Integer.parseInt(s.substring(0, gap)),</span>
<span class="source-line-no">6782</span><span id="line.6782">                gap2 = s.indexOf(',', gap+1), h = Integer.parseInt(s.substring(gap+1, gap2));</span>
<span class="source-line-no">6783</span><span id="line.6783">        String[] splits = StringKit.split(s.substring(gap2+1), ",");</span>
<span class="source-line-no">6784</span><span id="line.6784">        long[] data = new long[splits.length];</span>
<span class="source-line-no">6785</span><span id="line.6785">        for (int i = 0; i &lt; splits.length; i++) {</span>
<span class="source-line-no">6786</span><span id="line.6786">            data[i] = StringKit.longFromDec(splits[i]);</span>
<span class="source-line-no">6787</span><span id="line.6787">        }</span>
<span class="source-line-no">6788</span><span id="line.6788">        return new GreasedRegion(data, w, h);</span>
<span class="source-line-no">6789</span><span id="line.6789">    }</span>
<span class="source-line-no">6790</span><span id="line.6790"></span>
<span class="source-line-no">6791</span><span id="line.6791">    /**</span>
<span class="source-line-no">6792</span><span id="line.6792">     * Constructs a GreasedRegion using a vararg for data. Primarily meant for generated code, since</span>
<span class="source-line-no">6793</span><span id="line.6793">     * {@link #serializeToString()} produces a String that happens to be a valid parameter list for this method.</span>
<span class="source-line-no">6794</span><span id="line.6794">     * @param width width of the GreasedRegion to produce</span>
<span class="source-line-no">6795</span><span id="line.6795">     * @param height height of the GreasedRegion to produce</span>
<span class="source-line-no">6796</span><span id="line.6796">     * @param data array or vararg of long containing the exact data, probably from an existing GreasedRegion</span>
<span class="source-line-no">6797</span><span id="line.6797">     * @return a new GreasedRegion with the given width, height, and data</span>
<span class="source-line-no">6798</span><span id="line.6798">     */</span>
<span class="source-line-no">6799</span><span id="line.6799">    public static GreasedRegion of(final int width, final int height, final long... data)</span>
<span class="source-line-no">6800</span><span id="line.6800">    {</span>
<span class="source-line-no">6801</span><span id="line.6801">        return new GreasedRegion(data, width, height);</span>
<span class="source-line-no">6802</span><span id="line.6802">    }</span>
<span class="source-line-no">6803</span><span id="line.6803">    </span>
<span class="source-line-no">6804</span><span id="line.6804">    /**</span>
<span class="source-line-no">6805</span><span id="line.6805">     * Compresses this GreasedRegion into a UTF-16 String and returns the String without modifying this GreasedRegion.</span>
<span class="source-line-no">6806</span><span id="line.6806">     * Uses {@link CoordPacker}'s algorithm and data to compress this GreasedRegion in 256x128 blocks, storing the</span>
<span class="source-line-no">6807</span><span id="line.6807">     * CoordPacker-like data as chars with values from 256 to 33023 (a concept also used in {@link LZSEncoding}),</span>
<span class="source-line-no">6808</span><span id="line.6808">     * and using ASCII semicolons to separate them or store other info (just width and height, which are given first as</span>
<span class="source-line-no">6809</span><span id="line.6809">     * 16 hex digits). This finishes by running the result through {@link LZSEncoding}, a combination which typically</span>
<span class="source-line-no">6810</span><span id="line.6810">     * gets very good compression.</span>
<span class="source-line-no">6811</span><span id="line.6811">     * @return a String that could be used to reconstruct this GreasedRegion using {@link #decompress(String)}</span>
<span class="source-line-no">6812</span><span id="line.6812">     */</span>
<span class="source-line-no">6813</span><span id="line.6813">    public String toCompressedString()</span>
<span class="source-line-no">6814</span><span id="line.6814">    {</span>
<span class="source-line-no">6815</span><span id="line.6815">        CoordPacker.init();</span>
<span class="source-line-no">6816</span><span id="line.6816">        StringBuilder packing = new StringBuilder(width * height &gt;&gt; 3);</span>
<span class="source-line-no">6817</span><span id="line.6817">        StringKit.appendHex(packing, width);</span>
<span class="source-line-no">6818</span><span id="line.6818">        StringKit.appendHex(packing, height);</span>
<span class="source-line-no">6819</span><span id="line.6819">        final int chunksX = width + 255 &gt;&gt; 8, chunksY = height + 127 &gt;&gt; 7;</span>
<span class="source-line-no">6820</span><span id="line.6820">        for (int bigX = 0, baseX = 0; bigX &lt; chunksX; bigX++, baseX += 256) {</span>
<span class="source-line-no">6821</span><span id="line.6821">            for (int bigY = 0, baseY = 0; bigY &lt; chunksY; bigY++, baseY += 128) {</span>
<span class="source-line-no">6822</span><span id="line.6822">                packing.append(';');</span>
<span class="source-line-no">6823</span><span id="line.6823">                boolean on = false, current;</span>
<span class="source-line-no">6824</span><span id="line.6824">                short skip = 0, hx, hy;</span>
<span class="source-line-no">6825</span><span id="line.6825">                int xSize = Math.min(256, width - baseX), ySize = Math.min(128, height - baseY),</span>
<span class="source-line-no">6826</span><span id="line.6826">                        limit = 0x8000, mapLimit = xSize * ySize;</span>
<span class="source-line-no">6827</span><span id="line.6827">                if (xSize &lt;= 128) {</span>
<span class="source-line-no">6828</span><span id="line.6828">                    limit &gt;&gt;= 1;</span>
<span class="source-line-no">6829</span><span id="line.6829">                    if (xSize &lt;= 64) {</span>
<span class="source-line-no">6830</span><span id="line.6830">                        limit &gt;&gt;= 1;</span>
<span class="source-line-no">6831</span><span id="line.6831">                        if (ySize &lt;= 64) {</span>
<span class="source-line-no">6832</span><span id="line.6832">                            limit &gt;&gt;= 1;</span>
<span class="source-line-no">6833</span><span id="line.6833">                            if (ySize &lt;= 32) {</span>
<span class="source-line-no">6834</span><span id="line.6834">                                limit &gt;&gt;= 1;</span>
<span class="source-line-no">6835</span><span id="line.6835">                                if (xSize &lt;= 32) {</span>
<span class="source-line-no">6836</span><span id="line.6836">                                    limit &gt;&gt;= 1;</span>
<span class="source-line-no">6837</span><span id="line.6837">                                }</span>
<span class="source-line-no">6838</span><span id="line.6838">                            }</span>
<span class="source-line-no">6839</span><span id="line.6839">                        }</span>
<span class="source-line-no">6840</span><span id="line.6840">                    }</span>
<span class="source-line-no">6841</span><span id="line.6841">                }</span>
<span class="source-line-no">6842</span><span id="line.6842">                for (int i = 0, ml = 0; i &lt; limit &amp;&amp; ml &lt; mapLimit; i++, skip++) {</span>
<span class="source-line-no">6843</span><span id="line.6843">                    hx = CoordPacker.hilbertX[i];</span>
<span class="source-line-no">6844</span><span id="line.6844">                    hy = CoordPacker.hilbertY[i];</span>
<span class="source-line-no">6845</span><span id="line.6845">                    if (hx &gt;= xSize || hy &gt;= ySize) {</span>
<span class="source-line-no">6846</span><span id="line.6846">                        if (on) {</span>
<span class="source-line-no">6847</span><span id="line.6847">                            on = false;</span>
<span class="source-line-no">6848</span><span id="line.6848">                            packing.append((char) (skip + 256));</span>
<span class="source-line-no">6849</span><span id="line.6849">                            skip = 0;</span>
<span class="source-line-no">6850</span><span id="line.6850">                        }</span>
<span class="source-line-no">6851</span><span id="line.6851">                        continue;</span>
<span class="source-line-no">6852</span><span id="line.6852">                    }</span>
<span class="source-line-no">6853</span><span id="line.6853">                    ml++;</span>
<span class="source-line-no">6854</span><span id="line.6854">                    current = ((data[(baseX + hx) * ySections + (baseY + hy &gt;&gt; 6)] &amp; (1L &lt;&lt; hy)) != 0);</span>
<span class="source-line-no">6855</span><span id="line.6855">                    if (current != on) {</span>
<span class="source-line-no">6856</span><span id="line.6856">                        packing.append((char) (skip + 256));</span>
<span class="source-line-no">6857</span><span id="line.6857">                        skip = 0;</span>
<span class="source-line-no">6858</span><span id="line.6858">                        on = current;</span>
<span class="source-line-no">6859</span><span id="line.6859">                    }</span>
<span class="source-line-no">6860</span><span id="line.6860">                }</span>
<span class="source-line-no">6861</span><span id="line.6861">                if (on)</span>
<span class="source-line-no">6862</span><span id="line.6862">                    packing.append((char) (skip + 256));</span>
<span class="source-line-no">6863</span><span id="line.6863">            }</span>
<span class="source-line-no">6864</span><span id="line.6864">        }</span>
<span class="source-line-no">6865</span><span id="line.6865">        return LZSEncoding.compressToUTF16(packing.toString());</span>
<span class="source-line-no">6866</span><span id="line.6866">    }</span>
<span class="source-line-no">6867</span><span id="line.6867"></span>
<span class="source-line-no">6868</span><span id="line.6868">    /**</span>
<span class="source-line-no">6869</span><span id="line.6869">     * Decompresses a String returned by {@link #toCompressedString()}, returning a new GreasedRegion with identical</span>
<span class="source-line-no">6870</span><span id="line.6870">     * width, height, and contents to the GreasedRegion before compression. This decompresses the {@link LZSEncoding}</span>
<span class="source-line-no">6871</span><span id="line.6871">     * applied to the data, then decompresses the {@link CoordPacker}-type Hilbert Curve RLE data to get the original</span>
<span class="source-line-no">6872</span><span id="line.6872">     * GreasedRegion back.</span>
<span class="source-line-no">6873</span><span id="line.6873">     * @param compressed a String that was compressed by {@link #toCompressedString()}, without changes</span>
<span class="source-line-no">6874</span><span id="line.6874">     * @return a new copy of the GreasedRegion that was previously compressed</span>
<span class="source-line-no">6875</span><span id="line.6875">     */</span>
<span class="source-line-no">6876</span><span id="line.6876">    public static GreasedRegion decompress(String compressed)</span>
<span class="source-line-no">6877</span><span id="line.6877">    {</span>
<span class="source-line-no">6878</span><span id="line.6878">        CoordPacker.init();</span>
<span class="source-line-no">6879</span><span id="line.6879">        GreasedRegion target;</span>
<span class="source-line-no">6880</span><span id="line.6880">        compressed = LZSEncoding.decompressFromUTF16(compressed);</span>
<span class="source-line-no">6881</span><span id="line.6881">        final int width = StringKit.intFromHex(compressed), height = StringKit.intFromHex(compressed, 8, 16);</span>
<span class="source-line-no">6882</span><span id="line.6882">        target = new GreasedRegion(width, height);</span>
<span class="source-line-no">6883</span><span id="line.6883">        final int chunksX = width + 255 &gt;&gt; 8, chunksY = height + 127 &gt;&gt; 7;</span>
<span class="source-line-no">6884</span><span id="line.6884">        int startPack = 16, endPack, idx;//, hy;</span>
<span class="source-line-no">6885</span><span id="line.6885">        boolean on;</span>
<span class="source-line-no">6886</span><span id="line.6886">        for (int bigX = 0, baseX = 0; bigX &lt; chunksX; bigX++, baseX += 256) {</span>
<span class="source-line-no">6887</span><span id="line.6887">            for (int bigY = 0, baseY = 0; bigY &lt; chunksY; bigY++, baseY += 128) {</span>
<span class="source-line-no">6888</span><span id="line.6888">                ++startPack;</span>
<span class="source-line-no">6889</span><span id="line.6889">                endPack = compressed.indexOf(';', startPack);</span>
<span class="source-line-no">6890</span><span id="line.6890">                if(endPack &lt; 0) endPack = compressed.length();</span>
<span class="source-line-no">6891</span><span id="line.6891">                on = false;</span>
<span class="source-line-no">6892</span><span id="line.6892">                idx = 0;</span>
<span class="source-line-no">6893</span><span id="line.6893">                for(int p = startPack; p &lt; endPack; p++, on = !on) {</span>
<span class="source-line-no">6894</span><span id="line.6894">                    if (on) {</span>
<span class="source-line-no">6895</span><span id="line.6895">                        for (int toSkip = idx + (compressed.charAt(p) - 256); idx &lt; toSkip &amp;&amp; idx &lt; 0x8000; idx++) {</span>
<span class="source-line-no">6896</span><span id="line.6896">                            target.insert(CoordPacker.hilbertX[idx] + baseX, CoordPacker.hilbertY[idx] + baseY);</span>
<span class="source-line-no">6897</span><span id="line.6897">                            //hy = CoordPacker.hilbertY[idx] + baseY;</span>
<span class="source-line-no">6898</span><span id="line.6898">                            //target.data[(CoordPacker.hilbertX[idx] + baseX) * target.ySections + (hy &gt;&gt; 6)] |= 1L &lt;&lt; (hy &amp; 63);</span>
<span class="source-line-no">6899</span><span id="line.6899">                        }</span>
<span class="source-line-no">6900</span><span id="line.6900">                    } else {</span>
<span class="source-line-no">6901</span><span id="line.6901">                        idx += compressed.charAt(p) - 256;</span>
<span class="source-line-no">6902</span><span id="line.6902">                    }</span>
<span class="source-line-no">6903</span><span id="line.6903">                }</span>
<span class="source-line-no">6904</span><span id="line.6904">                startPack = endPack;</span>
<span class="source-line-no">6905</span><span id="line.6905">            }</span>
<span class="source-line-no">6906</span><span id="line.6906">        }</span>
<span class="source-line-no">6907</span><span id="line.6907">//        target.tallied = false;</span>
<span class="source-line-no">6908</span><span id="line.6908">        return target;</span>
<span class="source-line-no">6909</span><span id="line.6909">    }</span>
<span class="source-line-no">6910</span><span id="line.6910"></span>
<span class="source-line-no">6911</span><span id="line.6911">    @Override</span>
<span class="source-line-no">6912</span><span id="line.6912">    public boolean contains(Object o) {</span>
<span class="source-line-no">6913</span><span id="line.6913">        if(o instanceof Coord)</span>
<span class="source-line-no">6914</span><span id="line.6914">            return contains((Coord)o);</span>
<span class="source-line-no">6915</span><span id="line.6915">        return false;</span>
<span class="source-line-no">6916</span><span id="line.6916">    }</span>
<span class="source-line-no">6917</span><span id="line.6917"></span>
<span class="source-line-no">6918</span><span id="line.6918">    @Override</span>
<span class="source-line-no">6919</span><span id="line.6919">    public Iterator&lt;Coord&gt; iterator() {</span>
<span class="source-line-no">6920</span><span id="line.6920">        return new GRIterator();</span>
<span class="source-line-no">6921</span><span id="line.6921">    }</span>
<span class="source-line-no">6922</span><span id="line.6922"></span>
<span class="source-line-no">6923</span><span id="line.6923">    @Override</span>
<span class="source-line-no">6924</span><span id="line.6924">    public Object[] toArray() {</span>
<span class="source-line-no">6925</span><span id="line.6925">        return asCoords();</span>
<span class="source-line-no">6926</span><span id="line.6926">    }</span>
<span class="source-line-no">6927</span><span id="line.6927"></span>
<span class="source-line-no">6928</span><span id="line.6928">    @SuppressWarnings("unchecked")</span>
<span class="source-line-no">6929</span><span id="line.6929">    @Override</span>
<span class="source-line-no">6930</span><span id="line.6930">    public &lt;T&gt; T[] toArray(T[] a) {</span>
<span class="source-line-no">6931</span><span id="line.6931">        if(a instanceof Coord[])</span>
<span class="source-line-no">6932</span><span id="line.6932">            return (T[])asCoords((Coord[])a);</span>
<span class="source-line-no">6933</span><span id="line.6933">        return a;</span>
<span class="source-line-no">6934</span><span id="line.6934">    }</span>
<span class="source-line-no">6935</span><span id="line.6935"></span>
<span class="source-line-no">6936</span><span id="line.6936">    @Override</span>
<span class="source-line-no">6937</span><span id="line.6937">    public boolean add(Coord coord) {</span>
<span class="source-line-no">6938</span><span id="line.6938">        if(contains(coord))</span>
<span class="source-line-no">6939</span><span id="line.6939">            return false;</span>
<span class="source-line-no">6940</span><span id="line.6940">        insert(coord);</span>
<span class="source-line-no">6941</span><span id="line.6941">        return true;</span>
<span class="source-line-no">6942</span><span id="line.6942">    }</span>
<span class="source-line-no">6943</span><span id="line.6943">    @Override</span>
<span class="source-line-no">6944</span><span id="line.6944">    public void clear()</span>
<span class="source-line-no">6945</span><span id="line.6945">    {</span>
<span class="source-line-no">6946</span><span id="line.6946">        Arrays.fill(data, 0L);</span>
<span class="source-line-no">6947</span><span id="line.6947">    }</span>
<span class="source-line-no">6948</span><span id="line.6948"></span>
<span class="source-line-no">6949</span><span id="line.6949">    @Override</span>
<span class="source-line-no">6950</span><span id="line.6950">    public boolean remove(Object o) {</span>
<span class="source-line-no">6951</span><span id="line.6951">        if(o instanceof Coord)</span>
<span class="source-line-no">6952</span><span id="line.6952">        {</span>
<span class="source-line-no">6953</span><span id="line.6953">            if(contains((Coord)o))</span>
<span class="source-line-no">6954</span><span id="line.6954">            {</span>
<span class="source-line-no">6955</span><span id="line.6955">                remove((Coord)o);</span>
<span class="source-line-no">6956</span><span id="line.6956">                return true;</span>
<span class="source-line-no">6957</span><span id="line.6957">            }</span>
<span class="source-line-no">6958</span><span id="line.6958">            return false;</span>
<span class="source-line-no">6959</span><span id="line.6959">        }</span>
<span class="source-line-no">6960</span><span id="line.6960">        return false;</span>
<span class="source-line-no">6961</span><span id="line.6961">    }</span>
<span class="source-line-no">6962</span><span id="line.6962"></span>
<span class="source-line-no">6963</span><span id="line.6963">    @Override</span>
<span class="source-line-no">6964</span><span id="line.6964">    public boolean containsAll(Collection&lt;?&gt; c) {</span>
<span class="source-line-no">6965</span><span id="line.6965">        for(Object o : c)</span>
<span class="source-line-no">6966</span><span id="line.6966">        {</span>
<span class="source-line-no">6967</span><span id="line.6967">            if(!contains(o))</span>
<span class="source-line-no">6968</span><span id="line.6968">                return false;</span>
<span class="source-line-no">6969</span><span id="line.6969">        }</span>
<span class="source-line-no">6970</span><span id="line.6970">        return true;</span>
<span class="source-line-no">6971</span><span id="line.6971">    }</span>
<span class="source-line-no">6972</span><span id="line.6972"></span>
<span class="source-line-no">6973</span><span id="line.6973">    @Override</span>
<span class="source-line-no">6974</span><span id="line.6974">    public boolean addAll(Collection&lt;? extends Coord&gt; c) {</span>
<span class="source-line-no">6975</span><span id="line.6975">        boolean changed = false;</span>
<span class="source-line-no">6976</span><span id="line.6976">        for(Coord co : c)</span>
<span class="source-line-no">6977</span><span id="line.6977">        {</span>
<span class="source-line-no">6978</span><span id="line.6978">            changed |= add(co);</span>
<span class="source-line-no">6979</span><span id="line.6979">        }</span>
<span class="source-line-no">6980</span><span id="line.6980">        return changed;</span>
<span class="source-line-no">6981</span><span id="line.6981">    }</span>
<span class="source-line-no">6982</span><span id="line.6982"></span>
<span class="source-line-no">6983</span><span id="line.6983">    @Override</span>
<span class="source-line-no">6984</span><span id="line.6984">    public boolean removeAll(Collection&lt;?&gt; c) {</span>
<span class="source-line-no">6985</span><span id="line.6985">        boolean changed = false;</span>
<span class="source-line-no">6986</span><span id="line.6986">        for(Object o : c)</span>
<span class="source-line-no">6987</span><span id="line.6987">        {</span>
<span class="source-line-no">6988</span><span id="line.6988">            changed |= remove(o);</span>
<span class="source-line-no">6989</span><span id="line.6989">        }</span>
<span class="source-line-no">6990</span><span id="line.6990">        return changed;</span>
<span class="source-line-no">6991</span><span id="line.6991">    }</span>
<span class="source-line-no">6992</span><span id="line.6992"></span>
<span class="source-line-no">6993</span><span id="line.6993">    @Override</span>
<span class="source-line-no">6994</span><span id="line.6994">    public boolean retainAll(Collection&lt;?&gt; c) {</span>
<span class="source-line-no">6995</span><span id="line.6995">        GreasedRegion g2 = new GreasedRegion(width, height);</span>
<span class="source-line-no">6996</span><span id="line.6996">        for(Object o : c)</span>
<span class="source-line-no">6997</span><span id="line.6997">        {</span>
<span class="source-line-no">6998</span><span id="line.6998">            if(contains(o) &amp;&amp; o instanceof Coord)</span>
<span class="source-line-no">6999</span><span id="line.6999">            {</span>
<span class="source-line-no">7000</span><span id="line.7000">                g2.add((Coord)o);</span>
<span class="source-line-no">7001</span><span id="line.7001">            }</span>
<span class="source-line-no">7002</span><span id="line.7002">        }</span>
<span class="source-line-no">7003</span><span id="line.7003">        boolean changed = equals(g2);</span>
<span class="source-line-no">7004</span><span id="line.7004">        remake(g2);</span>
<span class="source-line-no">7005</span><span id="line.7005">        return changed;</span>
<span class="source-line-no">7006</span><span id="line.7006">    }</span>
<span class="source-line-no">7007</span><span id="line.7007"></span>
<span class="source-line-no">7008</span><span id="line.7008">    /**</span>
<span class="source-line-no">7009</span><span id="line.7009">     * Randomly removes points from a GreasedRegion, with larger values for preservation keeping more of the existing</span>
<span class="source-line-no">7010</span><span id="line.7010">     * shape intact. If preservation is 1, roughly 1/2 of all points will be removed; if 2, roughly 1/4, if 3, roughly</span>
<span class="source-line-no">7011</span><span id="line.7011">     * 1/8, and so on, so that preservation can be thought of as a negative exponent of 2.</span>
<span class="source-line-no">7012</span><span id="line.7012">     * @param rng used to determine random factors</span>
<span class="source-line-no">7013</span><span id="line.7013">     * @param preservation roughly what degree of points to remove (higher keeps more); removes about {@code 1/(2^preservation)} points</span>
<span class="source-line-no">7014</span><span id="line.7014">     * @return a randomly modified change to this GreasedRegion</span>
<span class="source-line-no">7015</span><span id="line.7015">     */</span>
<span class="source-line-no">7016</span><span id="line.7016">    public GreasedRegion deteriorate(RandomnessSource rng, int preservation) {</span>
<span class="source-line-no">7017</span><span id="line.7017">        if(rng == null || width &lt;= 2 || ySections &lt;= 0 || preservation &lt;= 0)</span>
<span class="source-line-no">7018</span><span id="line.7018">            return this;</span>
<span class="source-line-no">7019</span><span id="line.7019">        long mash;</span>
<span class="source-line-no">7020</span><span id="line.7020">        for (int i = 0; i &lt; width * ySections; i++) {</span>
<span class="source-line-no">7021</span><span id="line.7021">            mash = rng.nextLong();</span>
<span class="source-line-no">7022</span><span id="line.7022">            for (int j = i; j &lt; preservation; j++) {</span>
<span class="source-line-no">7023</span><span id="line.7023">                mash |= rng.nextLong();</span>
<span class="source-line-no">7024</span><span id="line.7024">            }</span>
<span class="source-line-no">7025</span><span id="line.7025">            data[i] &amp;= mash;</span>
<span class="source-line-no">7026</span><span id="line.7026">        }</span>
<span class="source-line-no">7027</span><span id="line.7027">        tallied = false;</span>
<span class="source-line-no">7028</span><span id="line.7028">        return this;</span>
<span class="source-line-no">7029</span><span id="line.7029">    }</span>
<span class="source-line-no">7030</span><span id="line.7030"></span>
<span class="source-line-no">7031</span><span id="line.7031">    /**</span>
<span class="source-line-no">7032</span><span id="line.7032">     * Randomly removes points from a GreasedRegion, with preservation as a fraction between 1.0 (keep all) and 0.0</span>
<span class="source-line-no">7033</span><span id="line.7033">     * (remove all). If preservation is 0.5, roughly 1/2 of all points will be removed; if 0.25, roughly 3/4 will be</span>
<span class="source-line-no">7034</span><span id="line.7034">     * removed (roughly 0.25 will be _kept_), if 0.8, roughly 1/5 will be removed (and about 0.8 will be kept), and so</span>
<span class="source-line-no">7035</span><span id="line.7035">     * on. Preservation must be between 0.0 and 1.0 for this to have the intended behavior; 1.0 or higher will keep all</span>
<span class="source-line-no">7036</span><span id="line.7036">     * points without change (returning this GreasedRegion), while anything less than 0.015625 (1.0/64) will empty this</span>
<span class="source-line-no">7037</span><span id="line.7037">     * GreasedRegion (using {@link #empty()}) and then return it. The parameter {@code random} can be an object like a</span>
<span class="source-line-no">7038</span><span id="line.7038">     * {@link DiverRNG}, an {@link RNG} backed by a well-distributed RandomnessSource like its default, DiverRNG, a</span>
<span class="source-line-no">7039</span><span id="line.7039">     * {@link GWTRNG} (especially if you target GWT, where it will perform much better than most alternatives), or any</span>
<span class="source-line-no">7040</span><span id="line.7040">     * of various other RandomnessSource implementations that distribute bits well for</span>
<span class="source-line-no">7041</span><span id="line.7041">     * {@link RandomnessSource#nextLong()}, but should not be intentionally-biased RNGs like {@link DharmaRNG} or </span>
<span class="source-line-no">7042</span><span id="line.7042">     * {@link EditRNG}, nor double-based QRNGs like {@link VanDerCorputQRNG} or {@link SobolQRNG}.</span>
<span class="source-line-no">7043</span><span id="line.7043">     * @param random used to determine random factors; likely to be an {@link RNG}, {@link DiverRNG}, or {@link GWTRNG}</span>
<span class="source-line-no">7044</span><span id="line.7044">     * @param preservation the rough fraction of points to keep, between 0.0 and 1.0</span>
<span class="source-line-no">7045</span><span id="line.7045">     * @return a randomly modified change to this GreasedRegion</span>
<span class="source-line-no">7046</span><span id="line.7046">     */</span>
<span class="source-line-no">7047</span><span id="line.7047">    public GreasedRegion deteriorate(final RandomnessSource random, final double preservation) {</span>
<span class="source-line-no">7048</span><span id="line.7048">        if(random == null || width &lt;= 2 || ySections &lt;= 0 || preservation &gt;= 1)</span>
<span class="source-line-no">7049</span><span id="line.7049">            return this;</span>
<span class="source-line-no">7050</span><span id="line.7050">        if(preservation &lt;= 0)</span>
<span class="source-line-no">7051</span><span id="line.7051">            return empty();</span>
<span class="source-line-no">7052</span><span id="line.7052">        int bitCount = (int) (preservation * 64);</span>
<span class="source-line-no">7053</span><span id="line.7053">        for (int i = 0; i &lt; width * ySections; i++) {</span>
<span class="source-line-no">7054</span><span id="line.7054">            data[i] &amp;= approximateBits(random, bitCount);</span>
<span class="source-line-no">7055</span><span id="line.7055">        }</span>
<span class="source-line-no">7056</span><span id="line.7056">        tallied = false;</span>
<span class="source-line-no">7057</span><span id="line.7057">        return this;</span>
<span class="source-line-no">7058</span><span id="line.7058">    }</span>
<span class="source-line-no">7059</span><span id="line.7059"></span>
<span class="source-line-no">7060</span><span id="line.7060">    /**</span>
<span class="source-line-no">7061</span><span id="line.7061">     * Changes the on/off state of the cell with the given x and y, making an on cell into an off cell, or an off cell</span>
<span class="source-line-no">7062</span><span id="line.7062">     * into an on cell.</span>
<span class="source-line-no">7063</span><span id="line.7063">     * &lt;br&gt;</span>
<span class="source-line-no">7064</span><span id="line.7064">     * This was called flip(), but that name would be confusing since flipping a rectangular area usually means</span>
<span class="source-line-no">7065</span><span id="line.7065">     * reversing an axis.</span>
<span class="source-line-no">7066</span><span id="line.7066">     * @param x the x position of the cell to flip</span>
<span class="source-line-no">7067</span><span id="line.7067">     * @param y the y position of the cell to flip</span>
<span class="source-line-no">7068</span><span id="line.7068">     * @return this for chaining, modified</span>
<span class="source-line-no">7069</span><span id="line.7069">     */</span>
<span class="source-line-no">7070</span><span id="line.7070">    public GreasedRegion toggle(int x, int y) {</span>
<span class="source-line-no">7071</span><span id="line.7071">        if(x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; width &amp;&amp; y &lt; height &amp;&amp; ySections &gt; 0)</span>
<span class="source-line-no">7072</span><span id="line.7072">        {</span>
<span class="source-line-no">7073</span><span id="line.7073">            data[x * ySections + (y &gt;&gt; 6)] ^= (1L &lt;&lt; (y &amp; 63));</span>
<span class="source-line-no">7074</span><span id="line.7074">            tallied = false;</span>
<span class="source-line-no">7075</span><span id="line.7075">        }</span>
<span class="source-line-no">7076</span><span id="line.7076">        return this;</span>
<span class="source-line-no">7077</span><span id="line.7077"></span>
<span class="source-line-no">7078</span><span id="line.7078">    }</span>
<span class="source-line-no">7079</span><span id="line.7079"></span>
<span class="source-line-no">7080</span><span id="line.7080">    /**</span>
<span class="source-line-no">7081</span><span id="line.7081">     * Returns a new GreasedRegion that has been mirrored along the rightmost edge, parallel to the y-axis. The new</span>
<span class="source-line-no">7082</span><span id="line.7082">     * GreasedRegion will have exactly twice the width, the additional width will have the contents of the original</span>
<span class="source-line-no">7083</span><span id="line.7083">     * GreasesRegion in reversed order. The positions shared by both GreasedRegions will be the same, that is, any area</span>
<span class="source-line-no">7084</span><span id="line.7084">     * not added to the original will be equal to the original.</span>
<span class="source-line-no">7085</span><span id="line.7085">     * @return a new GreasedRegion with twice the width of {@code this}, that is mirrored along the rightmost edge</span>
<span class="source-line-no">7086</span><span id="line.7086">     */</span>
<span class="source-line-no">7087</span><span id="line.7087">    public GreasedRegion mirrorY()</span>
<span class="source-line-no">7088</span><span id="line.7088">    {</span>
<span class="source-line-no">7089</span><span id="line.7089">        GreasedRegion next = new GreasedRegion(data, width, height, width * 2, height);</span>
<span class="source-line-no">7090</span><span id="line.7090">        for (int i = 0, o = width * 2 - 1; i &lt; width; i++, o--) {</span>
<span class="source-line-no">7091</span><span id="line.7091">            System.arraycopy(data, ySections * i, next.data, ySections * o, ySections);</span>
<span class="source-line-no">7092</span><span id="line.7092">        }</span>
<span class="source-line-no">7093</span><span id="line.7093">        return next;</span>
<span class="source-line-no">7094</span><span id="line.7094">    }</span>
<span class="source-line-no">7095</span><span id="line.7095"></span>
<span class="source-line-no">7096</span><span id="line.7096">    @Override</span>
<span class="source-line-no">7097</span><span id="line.7097">    public boolean intersectsWith(Zone other) {</span>
<span class="source-line-no">7098</span><span id="line.7098">        if (other instanceof GreasedRegion)</span>
<span class="source-line-no">7099</span><span id="line.7099">            return intersects((GreasedRegion) other);</span>
<span class="source-line-no">7100</span><span id="line.7100">        long t, w;</span>
<span class="source-line-no">7101</span><span id="line.7101">        for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">7102</span><span id="line.7102">            for (int s = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">7103</span><span id="line.7103">                if ((t = data[x * ySections + s]) != 0) {</span>
<span class="source-line-no">7104</span><span id="line.7104">                    w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">7105</span><span id="line.7105">                    while (w != 0) {</span>
<span class="source-line-no">7106</span><span id="line.7106">                        if (other.contains(x, (s &lt;&lt; 6) | Long.numberOfTrailingZeros(w)))</span>
<span class="source-line-no">7107</span><span id="line.7107">                            return true;</span>
<span class="source-line-no">7108</span><span id="line.7108">                        t ^= w;</span>
<span class="source-line-no">7109</span><span id="line.7109">                        w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">7110</span><span id="line.7110">                    }</span>
<span class="source-line-no">7111</span><span id="line.7111">                }</span>
<span class="source-line-no">7112</span><span id="line.7112">            }</span>
<span class="source-line-no">7113</span><span id="line.7113">        }</span>
<span class="source-line-no">7114</span><span id="line.7114">        return false;</span>
<span class="source-line-no">7115</span><span id="line.7115">    }</span>
<span class="source-line-no">7116</span><span id="line.7116">    /**</span>
<span class="source-line-no">7117</span><span id="line.7117">     * Translates a copy of {@code this} by the x,y values in {@code c}.</span>
<span class="source-line-no">7118</span><span id="line.7118">     * Implemented with {@code return copy().translate(c.x, c.y);}</span>
<span class="source-line-no">7119</span><span id="line.7119">     * @return {@code this} copied and shifted by {@code (c.x,c.y)}</span>
<span class="source-line-no">7120</span><span id="line.7120">     */</span>
<span class="source-line-no">7121</span><span id="line.7121">    @Override</span>
<span class="source-line-no">7122</span><span id="line.7122">    public GreasedRegion translate(Coord c) {</span>
<span class="source-line-no">7123</span><span id="line.7123">        return copy().translate(c.x, c.y);</span>
<span class="source-line-no">7124</span><span id="line.7124">    }</span>
<span class="source-line-no">7125</span><span id="line.7125">    /**</span>
<span class="source-line-no">7126</span><span id="line.7126">     * Gets a Collection of Coord values that are not in this GreasedRegion, but are</span>
<span class="source-line-no">7127</span><span id="line.7127">     * adjacent to it, either orthogonally or diagonally. Related to the fringe()</span>
<span class="source-line-no">7128</span><span id="line.7128">     * methods in CoordPacker and GreasedRegion, but guaranteed to use 8-way</span>
<span class="source-line-no">7129</span><span id="line.7129">     * adjacency and to return a new Collection of Coord. This implementation returns</span>
<span class="source-line-no">7130</span><span id="line.7130">     * a GreasedRegion produced simply by {@code return copy().fringe8way();} .</span>
<span class="source-line-no">7131</span><span id="line.7131">     * @return Cells adjacent to {@code this} (orthogonally or diagonally) that</span>
<span class="source-line-no">7132</span><span id="line.7132">     * aren't in {@code this}</span>
<span class="source-line-no">7133</span><span id="line.7133">     */</span>
<span class="source-line-no">7134</span><span id="line.7134">    @Override</span>
<span class="source-line-no">7135</span><span id="line.7135">    public GreasedRegion getExternalBorder() {</span>
<span class="source-line-no">7136</span><span id="line.7136">        return copy().fringe8way();</span>
<span class="source-line-no">7137</span><span id="line.7137">    }</span>
<span class="source-line-no">7138</span><span id="line.7138"></span>
<span class="source-line-no">7139</span><span id="line.7139">    /**</span>
<span class="source-line-no">7140</span><span id="line.7140">     * Gets a new Zone that contains all the Coords in {@code this} plus all</span>
<span class="source-line-no">7141</span><span id="line.7141">     * neighboring Coords, which can be orthogonally or diagonally adjacent</span>
<span class="source-line-no">7142</span><span id="line.7142">     * to any Coord this has in it. Related to the expand() methods in</span>
<span class="source-line-no">7143</span><span id="line.7143">     * CoordPacker and GreasedRegion, but guaranteed to use 8-way adjacency</span>
<span class="source-line-no">7144</span><span id="line.7144">     * and to return a new Zone. This implementation returns a GreasedRegion</span>
<span class="source-line-no">7145</span><span id="line.7145">     * produced simply by {@code return copy().expand8way();} .</span>
<span class="source-line-no">7146</span><span id="line.7146">     * @return A new GreasedRegion where "off" cells adjacent to {@code this}</span>
<span class="source-line-no">7147</span><span id="line.7147">     *         (orthogonally or diagonally) have been added to the "on" cells</span>
<span class="source-line-no">7148</span><span id="line.7148">     *         in {@code this}</span>
<span class="source-line-no">7149</span><span id="line.7149">     */</span>
<span class="source-line-no">7150</span><span id="line.7150">    @Override</span>
<span class="source-line-no">7151</span><span id="line.7151">    public GreasedRegion extend() {</span>
<span class="source-line-no">7152</span><span id="line.7152">        return copy().expand8way();</span>
<span class="source-line-no">7153</span><span id="line.7153">    }</span>
<span class="source-line-no">7154</span><span id="line.7154"></span>
<span class="source-line-no">7155</span><span id="line.7155">    /**</span>
<span class="source-line-no">7156</span><span id="line.7156">     * Checks if {@code c} is present in this GreasedRegion. Returns true if and only if c is present in this</span>
<span class="source-line-no">7157</span><span id="line.7157">     * GreasedRegion as an "on" cell. This will never be true if c is null, has negative x or y, has a value for x that</span>
<span class="source-line-no">7158</span><span id="line.7158">     * is equal to or greater than {@link #width}, or has a value for y that is equal to or greater than</span>
<span class="source-line-no">7159</span><span id="line.7159">     * {@link #height}, but none of those conditions will cause Exceptions to be thrown.</span>
<span class="source-line-no">7160</span><span id="line.7160">     * @param c a Coord to try to find in this GreasedRegion; if null this will always return false</span>
<span class="source-line-no">7161</span><span id="line.7161">     * @return true if {@code c} is an "on" cell in this GreasedRegion, or false otherwise, including if c is null</span>
<span class="source-line-no">7162</span><span id="line.7162">     */</span>
<span class="source-line-no">7163</span><span id="line.7163">    @Override</span>
<span class="source-line-no">7164</span><span id="line.7164">    public boolean contains(Coord c) {</span>
<span class="source-line-no">7165</span><span id="line.7165">        return c != null &amp;&amp; contains(c.x, c.y);</span>
<span class="source-line-no">7166</span><span id="line.7166">    }</span>
<span class="source-line-no">7167</span><span id="line.7167"></span>
<span class="source-line-no">7168</span><span id="line.7168">    /**</span>
<span class="source-line-no">7169</span><span id="line.7169">     * Checks whether all Coords in {@code other} are also present in {@code this}.</span>
<span class="source-line-no">7170</span><span id="line.7170">     * Requires that {@code other} won't give a null Coord while this method iterates over it.</span>
<span class="source-line-no">7171</span><span id="line.7171">     * @param other another Zone, such as a GreasedRegion or a {@link squidpony.squidgrid.zone.CoordPackerZone}</span>
<span class="source-line-no">7172</span><span id="line.7172">     * @return true if all Coords in other are "on" in this GreasedRegion, or false otherwise</span>
<span class="source-line-no">7173</span><span id="line.7173">     */</span>
<span class="source-line-no">7174</span><span id="line.7174">    @Override</span>
<span class="source-line-no">7175</span><span id="line.7175">    public boolean contains(Zone other) {</span>
<span class="source-line-no">7176</span><span id="line.7176">        if(other instanceof Collection)</span>
<span class="source-line-no">7177</span><span id="line.7177">            return containsAll((Collection) other);</span>
<span class="source-line-no">7178</span><span id="line.7178">        for(Coord c : other)</span>
<span class="source-line-no">7179</span><span id="line.7179">        {</span>
<span class="source-line-no">7180</span><span id="line.7180">            if(!contains(c.x, c.y))</span>
<span class="source-line-no">7181</span><span id="line.7181">                return false;</span>
<span class="source-line-no">7182</span><span id="line.7182">        }</span>
<span class="source-line-no">7183</span><span id="line.7183">        return true;</span>
<span class="source-line-no">7184</span><span id="line.7184">    }</span>
<span class="source-line-no">7185</span><span id="line.7185"></span>
<span class="source-line-no">7186</span><span id="line.7186">    /**</span>
<span class="source-line-no">7187</span><span id="line.7187">     * @param smallestBound if true, finds the smallest x-coordinate value;</span>
<span class="source-line-no">7188</span><span id="line.7188">     *                          if false, finds the biggest.</span>
<span class="source-line-no">7189</span><span id="line.7189">     * @return The x-coordinate of the Coord within {@code this} that has the</span>
<span class="source-line-no">7190</span><span id="line.7190">     * smallest (or biggest) x-coordinate. Or -1 if the zone is empty.</span>
<span class="source-line-no">7191</span><span id="line.7191">     */</span>
<span class="source-line-no">7192</span><span id="line.7192">    @Override</span>
<span class="source-line-no">7193</span><span id="line.7193">    public int xBound(boolean smallestBound) {</span>
<span class="source-line-no">7194</span><span id="line.7194">        if(smallestBound)</span>
<span class="source-line-no">7195</span><span id="line.7195">            return first().x;</span>
<span class="source-line-no">7196</span><span id="line.7196">        else</span>
<span class="source-line-no">7197</span><span id="line.7197">            return last().x;</span>
<span class="source-line-no">7198</span><span id="line.7198">    }</span>
<span class="source-line-no">7199</span><span id="line.7199"></span>
<span class="source-line-no">7200</span><span id="line.7200">    /**</span>
<span class="source-line-no">7201</span><span id="line.7201">     * @param smallestBound if true, finds the smallest y-coordinate value;</span>
<span class="source-line-no">7202</span><span id="line.7202">     *                          if false, finds the biggest.</span>
<span class="source-line-no">7203</span><span id="line.7203">     * @return The y-coordinate of the Coord within {@code this} that has the</span>
<span class="source-line-no">7204</span><span id="line.7204">     * smallest (or biggest) y-coordinate. Or -1 if the zone is empty.</span>
<span class="source-line-no">7205</span><span id="line.7205">     */</span>
<span class="source-line-no">7206</span><span id="line.7206">    @Override</span>
<span class="source-line-no">7207</span><span id="line.7207">    public int yBound(boolean smallestBound) {</span>
<span class="source-line-no">7208</span><span id="line.7208">        long t = 0L;</span>
<span class="source-line-no">7209</span><span id="line.7209">        if(smallestBound) {</span>
<span class="source-line-no">7210</span><span id="line.7210">            for (int s = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">7211</span><span id="line.7211">                for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">7212</span><span id="line.7212">                    t |= data[x * ySections + s];</span>
<span class="source-line-no">7213</span><span id="line.7213">                }</span>
<span class="source-line-no">7214</span><span id="line.7214">                if(t != 0L)</span>
<span class="source-line-no">7215</span><span id="line.7215">                    return s &lt;&lt; 6 | Long.numberOfTrailingZeros(t);</span>
<span class="source-line-no">7216</span><span id="line.7216">            }</span>
<span class="source-line-no">7217</span><span id="line.7217">            return -1;</span>
<span class="source-line-no">7218</span><span id="line.7218">        }</span>
<span class="source-line-no">7219</span><span id="line.7219">        else</span>
<span class="source-line-no">7220</span><span id="line.7220">        {</span>
<span class="source-line-no">7221</span><span id="line.7221">            for (int s = ySections - 1; s &gt;= 0; s--) {</span>
<span class="source-line-no">7222</span><span id="line.7222">                for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">7223</span><span id="line.7223">                    t |= data[x * ySections + s];</span>
<span class="source-line-no">7224</span><span id="line.7224">                }</span>
<span class="source-line-no">7225</span><span id="line.7225">                if(t != 0L)</span>
<span class="source-line-no">7226</span><span id="line.7226">                    return s &lt;&lt; 6 | 63 - Long.numberOfLeadingZeros(t);</span>
<span class="source-line-no">7227</span><span id="line.7227">            }</span>
<span class="source-line-no">7228</span><span id="line.7228">            return -1;</span>
<span class="source-line-no">7229</span><span id="line.7229">        }</span>
<span class="source-line-no">7230</span><span id="line.7230">    }</span>
<span class="source-line-no">7231</span><span id="line.7231"></span>
<span class="source-line-no">7232</span><span id="line.7232">    /**</span>
<span class="source-line-no">7233</span><span id="line.7233">     * Gets the distance between the minimum x-value contained in this GreasedRegion and the maximum x-value in it.</span>
<span class="source-line-no">7234</span><span id="line.7234">     * Not the same as accessing the field {@link #width} on a GreasedRegion! The field will get the span of the space</span>
<span class="source-line-no">7235</span><span id="line.7235">     * that the GreasedRegion can use, including "on" and "off" cells. This method will only get the distance between</span>
<span class="source-line-no">7236</span><span id="line.7236">     * the furthest-separated "on" cells on the x-axis, and won't consider "off" cells. This method can return -1 if the</span>
<span class="source-line-no">7237</span><span id="line.7237">     * GreasedRegion is empty, 0 if the "on" cells are all in a vertical line (that is, when the minimum x is equal to</span>
<span class="source-line-no">7238</span><span id="line.7238">     * the maximum x), or a positive int in other cases with multiple x-values.</span>
<span class="source-line-no">7239</span><span id="line.7239">     * @return the distance on the x-axis between the "on" cell with the lowest x-value and the one with the highest</span>
<span class="source-line-no">7240</span><span id="line.7240">     */</span>
<span class="source-line-no">7241</span><span id="line.7241">    @Override</span>
<span class="source-line-no">7242</span><span id="line.7242">    public int getWidth() {</span>
<span class="source-line-no">7243</span><span id="line.7243">        if (super.width == -2)</span>
<span class="source-line-no">7244</span><span id="line.7244">            super.width = isEmpty() ? -1 : xBound(false) - xBound(true);</span>
<span class="source-line-no">7245</span><span id="line.7245">        return super.width;</span>
<span class="source-line-no">7246</span><span id="line.7246">    }</span>
<span class="source-line-no">7247</span><span id="line.7247">    /**</span>
<span class="source-line-no">7248</span><span id="line.7248">     * Gets the distance between the minimum y-value contained in this GreasedRegion and the maximum y-value in it.</span>
<span class="source-line-no">7249</span><span id="line.7249">     * Not the same as accessing the field {@link #height} on a GreasedRegion! The field will get the span of the space</span>
<span class="source-line-no">7250</span><span id="line.7250">     * that the GreasedRegion can use, including "on" and "off" cells. This method will only get the distance between</span>
<span class="source-line-no">7251</span><span id="line.7251">     * the furthest-separated "on" cells on the y-axis, and won't consider "off" cells. This method can return -1 if the</span>
<span class="source-line-no">7252</span><span id="line.7252">     * GreasedRegion is empty, 0 if the "on" cells are all in a horizontal line (that is, when the minimum y is equal to</span>
<span class="source-line-no">7253</span><span id="line.7253">     * the maximum y), or a positive int in other cases with multiple y-values.</span>
<span class="source-line-no">7254</span><span id="line.7254">     * @return the distance on the y-axis between the "on" cell with the lowest y-value and the one with the highest</span>
<span class="source-line-no">7255</span><span id="line.7255">     */</span>
<span class="source-line-no">7256</span><span id="line.7256">    @Override</span>
<span class="source-line-no">7257</span><span id="line.7257">    public int getHeight() {</span>
<span class="source-line-no">7258</span><span id="line.7258">        if (super.height == -2)</span>
<span class="source-line-no">7259</span><span id="line.7259">            super.height = isEmpty() ? -1 : yBound(false) - yBound(true);</span>
<span class="source-line-no">7260</span><span id="line.7260">        return super.height;</span>
<span class="source-line-no">7261</span><span id="line.7261">    }</span>
<span class="source-line-no">7262</span><span id="line.7262"></span>
<span class="source-line-no">7263</span><span id="line.7263">    /**</span>
<span class="source-line-no">7264</span><span id="line.7264">     * Gets the diagonal distance from the point combining the lowest x-value present in this GreasedRegion with the</span>
<span class="source-line-no">7265</span><span id="line.7265">     * lowest y-value in this, to the point combining the highest x-value and the highest y-value. These minimum and</span>
<span class="source-line-no">7266</span><span id="line.7266">     * maximum values don't necessarily match a single "on" cell for each min and max corner, and can take their x and y</span>
<span class="source-line-no">7267</span><span id="line.7267">     * values from two different points. The diagonal distance uses Euclidean measurement (basic Pythagorean Theorem</span>
<span class="source-line-no">7268</span><span id="line.7268">     * math here), and will be a double.</span>
<span class="source-line-no">7269</span><span id="line.7269">     * @return the diagonal distance from (min x, min y) to (max x, max y), as a double</span>
<span class="source-line-no">7270</span><span id="line.7270">     */</span>
<span class="source-line-no">7271</span><span id="line.7271">    @Override</span>
<span class="source-line-no">7272</span><span id="line.7272">    public double getDiagonal() {</span>
<span class="source-line-no">7273</span><span id="line.7273">        final int w = getWidth();</span>
<span class="source-line-no">7274</span><span id="line.7274">        final int h = getHeight();</span>
<span class="source-line-no">7275</span><span id="line.7275">        return Math.sqrt((w * w) + (h * h));</span>
<span class="source-line-no">7276</span><span id="line.7276">    }</span>
<span class="source-line-no">7277</span><span id="line.7277">//////Not duplicated because the superclass does this just fine.</span>
<span class="source-line-no">7278</span><span id="line.7278">//    @Override</span>
<span class="source-line-no">7279</span><span id="line.7279">//    public Coord getCenter() {</span>
<span class="source-line-no">7280</span><span id="line.7280">//        return super.getCenter();</span>
<span class="source-line-no">7281</span><span id="line.7281">//    }</span>
<span class="source-line-no">7282</span><span id="line.7282"></span>
<span class="source-line-no">7283</span><span id="line.7283">    @Override</span>
<span class="source-line-no">7284</span><span id="line.7284">    public GreasedRegion getInternalBorder() {</span>
<span class="source-line-no">7285</span><span id="line.7285">        return copy().surface8way();</span>
<span class="source-line-no">7286</span><span id="line.7286">    }</span>
<span class="source-line-no">7287</span><span id="line.7287"></span>
<span class="source-line-no">7288</span><span id="line.7288">    /**</span>
<span class="source-line-no">7289</span><span id="line.7289">     * Gets a Coord array from the "on" contents of this GreasedRegion, using a deterministic but random-seeming</span>
<span class="source-line-no">7290</span><span id="line.7290">     * scattering of chosen cells with a count that matches the given {@code fraction} of the total amount of "on" cells</span>
<span class="source-line-no">7291</span><span id="line.7291">     * in this. This is pseudo-random with the given seed (which will be made into an odd number if it is not one</span>
<span class="source-line-no">7292</span><span id="line.7292">     * already), and is very good at avoiding overlap (just as good as {@link #separatedZCurve(double, int)}, and</span>
<span class="source-line-no">7293</span><span id="line.7293">     * much faster). If you request too many cells (too high of a value for fraction), it will start to overlap, but</span>
<span class="source-line-no">7294</span><span id="line.7294">     * a fraction value of 0.4 reliably has had no overlap in testing. Restricts the total size of the returned array to</span>
<span class="source-line-no">7295</span><span id="line.7295">     * a maximum of {@code limit} (minimum is 0 if no cells are "on"). If limit is negative, this will not restrict the</span>
<span class="source-line-no">7296</span><span id="line.7296">     * size.</span>
<span class="source-line-no">7297</span><span id="line.7297">     * @param fraction the fraction of "on" cells to randomly select, between 0.0 and 1.0</span>
<span class="source-line-no">7298</span><span id="line.7298">     * @param limit the maximum size of the array to return</span>
<span class="source-line-no">7299</span><span id="line.7299">     * @param seed a long seed to change the points; the most significant 21 bits (except the sign bit) and least significant bit are ignored</span>
<span class="source-line-no">7300</span><span id="line.7300">     * @return a freshly-allocated Coord array containing the pseudo-random cells</span>
<span class="source-line-no">7301</span><span id="line.7301">     */</span>
<span class="source-line-no">7302</span><span id="line.7302">    public Coord[] mixedRandomSeparatedAlt(double fraction, int limit, long seed)</span>
<span class="source-line-no">7303</span><span id="line.7303">    {</span>
<span class="source-line-no">7304</span><span id="line.7304">        if(fraction &lt; 0)</span>
<span class="source-line-no">7305</span><span id="line.7305">            return new Coord[0];</span>
<span class="source-line-no">7306</span><span id="line.7306">        if(fraction &gt; 1)</span>
<span class="source-line-no">7307</span><span id="line.7307">            fraction = 1;</span>
<span class="source-line-no">7308</span><span id="line.7308">        int tmp, ic;</span>
<span class="source-line-no">7309</span><span id="line.7309">        long t, w;</span>
<span class="source-line-no">7310</span><span id="line.7310">        seed |= 1L;</span>
<span class="source-line-no">7311</span><span id="line.7311">        final int total = size();</span>
<span class="source-line-no">7312</span><span id="line.7312">        int ct = (int)(total * fraction);</span>
<span class="source-line-no">7313</span><span id="line.7313">        if(limit &gt;= 0 &amp;&amp; limit &lt; ct)</span>
<span class="source-line-no">7314</span><span id="line.7314">            ct = limit;</span>
<span class="source-line-no">7315</span><span id="line.7315">        Coord[] vl = new Coord[ct];</span>
<span class="source-line-no">7316</span><span id="line.7316">        EACH_QUASI:</span>
<span class="source-line-no">7317</span><span id="line.7317">        for (int i = 0; i &lt; ct; i++)</span>
<span class="source-line-no">7318</span><span id="line.7318">        {</span>
<span class="source-line-no">7319</span><span id="line.7319">            tmp = (int)(VanDerCorputQRNG.altDetermine(seed, i+1) * total);</span>
<span class="source-line-no">7320</span><span id="line.7320"></span>
<span class="source-line-no">7321</span><span id="line.7321">            for (int s = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">7322</span><span id="line.7322">                for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">7323</span><span id="line.7323">                    if ((ic = counts[x * ySections + s]) &gt; tmp) {</span>
<span class="source-line-no">7324</span><span id="line.7324">                        t = data[x * ySections + s];</span>
<span class="source-line-no">7325</span><span id="line.7325">                        for (--ic; t != 0; ic--) {</span>
<span class="source-line-no">7326</span><span id="line.7326">                            w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">7327</span><span id="line.7327">                            if (ic == tmp)</span>
<span class="source-line-no">7328</span><span id="line.7328">                            {</span>
<span class="source-line-no">7329</span><span id="line.7329">                                vl[i] = Coord.get(x, (s &lt;&lt; 6) | Long.bitCount(w-1));</span>
<span class="source-line-no">7330</span><span id="line.7330">                                continue EACH_QUASI;</span>
<span class="source-line-no">7331</span><span id="line.7331">                            }</span>
<span class="source-line-no">7332</span><span id="line.7332">                            t ^= w;</span>
<span class="source-line-no">7333</span><span id="line.7333">                        }</span>
<span class="source-line-no">7334</span><span id="line.7334">                    }</span>
<span class="source-line-no">7335</span><span id="line.7335">                }</span>
<span class="source-line-no">7336</span><span id="line.7336">            }</span>
<span class="source-line-no">7337</span><span id="line.7337">        }</span>
<span class="source-line-no">7338</span><span id="line.7338">        return vl;</span>
<span class="source-line-no">7339</span><span id="line.7339">    }</span>
<span class="source-line-no">7340</span><span id="line.7340"></span>
<span class="source-line-no">7341</span><span id="line.7341"></span>
<span class="source-line-no">7342</span><span id="line.7342">    public class GRIterator implements Iterator&lt;Coord&gt;</span>
<span class="source-line-no">7343</span><span id="line.7343">    {</span>
<span class="source-line-no">7344</span><span id="line.7344">        public int index;</span>
<span class="source-line-no">7345</span><span id="line.7345">        private long t, w;</span>
<span class="source-line-no">7346</span><span id="line.7346">        public GRIterator()</span>
<span class="source-line-no">7347</span><span id="line.7347">        {</span>
<span class="source-line-no">7348</span><span id="line.7348">            if(!tallied)</span>
<span class="source-line-no">7349</span><span id="line.7349">                tally();</span>
<span class="source-line-no">7350</span><span id="line.7350">        }</span>
<span class="source-line-no">7351</span><span id="line.7351">        @Override</span>
<span class="source-line-no">7352</span><span id="line.7352">        public boolean hasNext() {</span>
<span class="source-line-no">7353</span><span id="line.7353">            return index &lt; ct;</span>
<span class="source-line-no">7354</span><span id="line.7354">        }</span>
<span class="source-line-no">7355</span><span id="line.7355"></span>
<span class="source-line-no">7356</span><span id="line.7356">        @Override</span>
<span class="source-line-no">7357</span><span id="line.7357">        public Coord next() {</span>
<span class="source-line-no">7358</span><span id="line.7358">            int c;</span>
<span class="source-line-no">7359</span><span id="line.7359">            if(index &gt;= ct)</span>
<span class="source-line-no">7360</span><span id="line.7360">                return null;</span>
<span class="source-line-no">7361</span><span id="line.7361">            for (int s = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">7362</span><span id="line.7362">                for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">7363</span><span id="line.7363">                    if ((c = counts[x * ySections + s]) &gt; index) {</span>
<span class="source-line-no">7364</span><span id="line.7364">                        t = data[x * ySections + s] | 0L;</span>
<span class="source-line-no">7365</span><span id="line.7365">                        for (--c; t != 0; c--) {</span>
<span class="source-line-no">7366</span><span id="line.7366">                            w = NumberTools.lowestOneBit(t);</span>
<span class="source-line-no">7367</span><span id="line.7367">                            if (c == index)</span>
<span class="source-line-no">7368</span><span id="line.7368">                            {</span>
<span class="source-line-no">7369</span><span id="line.7369">                                index++;</span>
<span class="source-line-no">7370</span><span id="line.7370">                                return Coord.get(x, (s &lt;&lt; 6) | Long.bitCount(w-1));</span>
<span class="source-line-no">7371</span><span id="line.7371">                            }</span>
<span class="source-line-no">7372</span><span id="line.7372">                            t ^= w;</span>
<span class="source-line-no">7373</span><span id="line.7373">                        }</span>
<span class="source-line-no">7374</span><span id="line.7374">                    }</span>
<span class="source-line-no">7375</span><span id="line.7375">                }</span>
<span class="source-line-no">7376</span><span id="line.7376">            }</span>
<span class="source-line-no">7377</span><span id="line.7377">            return null;</span>
<span class="source-line-no">7378</span><span id="line.7378"></span>
<span class="source-line-no">7379</span><span id="line.7379">            /*</span>
<span class="source-line-no">7380</span><span id="line.7380">            for (int x = 0; x &lt; width; x++) {</span>
<span class="source-line-no">7381</span><span id="line.7381">                for (int s = 0; s &lt; ySections; s++) {</span>
<span class="source-line-no">7382</span><span id="line.7382">                    if ((w = NumberTools.lowestOneBit(data[x * ySections + s])) != 0 &amp;&amp; i++ &gt;= index) {</span>
<span class="source-line-no">7383</span><span id="line.7383">                        if(index++ &lt; limit)</span>
<span class="source-line-no">7384</span><span id="line.7384">                            return Coord.get(x, (s &lt;&lt; 6) | Long.numberOfTrailingZeros(w));</span>
<span class="source-line-no">7385</span><span id="line.7385">                        else</span>
<span class="source-line-no">7386</span><span id="line.7386">                            return null;</span>
<span class="source-line-no">7387</span><span id="line.7387">                    }</span>
<span class="source-line-no">7388</span><span id="line.7388">                }</span>
<span class="source-line-no">7389</span><span id="line.7389">            }</span>
<span class="source-line-no">7390</span><span id="line.7390">            */</span>
<span class="source-line-no">7391</span><span id="line.7391">        }</span>
<span class="source-line-no">7392</span><span id="line.7392"></span>
<span class="source-line-no">7393</span><span id="line.7393">        @Override</span>
<span class="source-line-no">7394</span><span id="line.7394">        public void remove() {</span>
<span class="source-line-no">7395</span><span id="line.7395">            throw new UnsupportedOperationException("remove() is not supported on this Iterator.");</span>
<span class="source-line-no">7396</span><span id="line.7396">        }</span>
<span class="source-line-no">7397</span><span id="line.7397">    }</span>
<span class="source-line-no">7398</span><span id="line.7398">}</span>




























































</pre>
</div>
</main>
</body>
</html>
