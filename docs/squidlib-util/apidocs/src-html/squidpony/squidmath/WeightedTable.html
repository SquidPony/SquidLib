<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (16) -->
<title>Source code</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="source: package: squidpony.squidmath, class: WeightedTable">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body class="source-page">
<main role="main">
<div class="source-container">
<pre><span class="source-line-no">001</span><span id="line.1">package squidpony.squidmath;</span>
<span class="source-line-no">002</span><span id="line.2"></span>
<span class="source-line-no">003</span><span id="line.3">import squidpony.StringKit;</span>
<span class="source-line-no">004</span><span id="line.4"></span>
<span class="source-line-no">005</span><span id="line.5">import java.io.Serializable;</span>
<span class="source-line-no">006</span><span id="line.6"></span>
<span class="source-line-no">007</span><span id="line.7">/**</span>
<span class="source-line-no">008</span><span id="line.8"> * A different approach to the same task {@link ProbabilityTable} solves, though this only looks up an appropriate index</span>
<span class="source-line-no">009</span><span id="line.9"> * instead of also storing items it can choose; allows positive doubles for weights but does not allow nested tables for</span>
<span class="source-line-no">010</span><span id="line.10"> * simplicity. This doesn't store an RNG (or RandomnessSource) in this class, and instead expects a long to be given for</span>
<span class="source-line-no">011</span><span id="line.11"> * each random draw from the table (these long parameters can be random, sequential, or in some other way different</span>
<span class="source-line-no">012</span><span id="line.12"> * every time). Uses &lt;a href="http://www.keithschwarz.com/darts-dice-coins/"&gt;Vose's Alias Method&lt;/a&gt;, and is based</span>
<span class="source-line-no">013</span><span id="line.13"> * fairly-closely on the code given by Keith Schwarz at that link. Because Vose's Alias Method is remarkably fast (O(1)</span>
<span class="source-line-no">014</span><span id="line.14"> * generation time in use, and O(n) time to construct a WeightedTable instance), this may be useful to consider if you</span>
<span class="source-line-no">015</span><span id="line.15"> * don't need all the features of ProbabilityTable or if you want deeper control over the random aspects of it.</span>
<span class="source-line-no">016</span><span id="line.16"> * &lt;br&gt;</span>
<span class="source-line-no">017</span><span id="line.17"> * Internally, this uses DiverRNG's algorithm (without considering negative bounds) as found in</span>
<span class="source-line-no">018</span><span id="line.18"> * {@link DiverRNG#determineBounded(long, int)} and {@link DiverRNG#determine(long)} to generate two ints, one used for</span>
<span class="source-line-no">019</span><span id="line.19"> * probability and treated as a 31-bit integer and the other used to determine the chosen column, which is bounded to an</span>
<span class="source-line-no">020</span><span id="line.20"> * arbitrary positive int. It does this with just one randomized 64-bit value, allowing the state given to</span>
<span class="source-line-no">021</span><span id="line.21"> * {@link #random(long)} to be just one long.</span>
<span class="source-line-no">022</span><span id="line.22"> * &lt;br&gt;</span>
<span class="source-line-no">023</span><span id="line.23"> * Created by Tommy Ettinger on 1/5/2018.</span>
<span class="source-line-no">024</span><span id="line.24"> */</span>
<span class="source-line-no">025</span><span id="line.25">public class WeightedTable implements Serializable {</span>
<span class="source-line-no">026</span><span id="line.26">    private static final long serialVersionUID = 101L;</span>
<span class="source-line-no">027</span><span id="line.27">//    protected final int[] alias;</span>
<span class="source-line-no">028</span><span id="line.28">//    protected final int[] probability;</span>
<span class="source-line-no">029</span><span id="line.29">    protected final int[] mixed;</span>
<span class="source-line-no">030</span><span id="line.30">    public final int size;</span>
<span class="source-line-no">031</span><span id="line.31"></span>
<span class="source-line-no">032</span><span id="line.32">    /**</span>
<span class="source-line-no">033</span><span id="line.33">     * Constructs a useless WeightedTable that always returns the index 0.</span>
<span class="source-line-no">034</span><span id="line.34">     */</span>
<span class="source-line-no">035</span><span id="line.35">    public WeightedTable()</span>
<span class="source-line-no">036</span><span id="line.36">    {</span>
<span class="source-line-no">037</span><span id="line.37">        this(1);</span>
<span class="source-line-no">038</span><span id="line.38">    }</span>
<span class="source-line-no">039</span><span id="line.39"></span>
<span class="source-line-no">040</span><span id="line.40">    /**</span>
<span class="source-line-no">041</span><span id="line.41">     * Constructs a WeightedTable with the given array of weights for each index. The array can also be a varargs for</span>
<span class="source-line-no">042</span><span id="line.42">     * convenience. The weights can be any positive non-zero doubles, but should usually not be so large or small that</span>
<span class="source-line-no">043</span><span id="line.43">     * precision loss is risked. Each weight will be used to determine the likelihood of that weight's index being</span>
<span class="source-line-no">044</span><span id="line.44">     * returned by {@link #random(long)}.</span>
<span class="source-line-no">045</span><span id="line.45">     * @param probabilities an array or varargs of positive doubles representing the weights for their own indices</span>
<span class="source-line-no">046</span><span id="line.46">     */</span>
<span class="source-line-no">047</span><span id="line.47">    public WeightedTable(double... probabilities) {</span>
<span class="source-line-no">048</span><span id="line.48">        /* Begin by doing basic structural checks on the inputs. */</span>
<span class="source-line-no">049</span><span id="line.49">        if (probabilities == null)</span>
<span class="source-line-no">050</span><span id="line.50">            throw new NullPointerException("Array 'probabilities' given to WeightedTable cannot be null");</span>
<span class="source-line-no">051</span><span id="line.51">        if ((size = probabilities.length) == 0)</span>
<span class="source-line-no">052</span><span id="line.52">            throw new IllegalArgumentException("Array 'probabilities' given to WeightedTable must be nonempty.");</span>
<span class="source-line-no">053</span><span id="line.53"></span>
<span class="source-line-no">054</span><span id="line.54">        mixed = new int[size&lt;&lt;1];</span>
<span class="source-line-no">055</span><span id="line.55"></span>
<span class="source-line-no">056</span><span id="line.56">        double sum = 0.0;</span>
<span class="source-line-no">057</span><span id="line.57"></span>
<span class="source-line-no">058</span><span id="line.58">        /* Make a copy of the probabilities array, since we will be making</span>
<span class="source-line-no">059</span><span id="line.59">         * changes to it.</span>
<span class="source-line-no">060</span><span id="line.60">         */</span>
<span class="source-line-no">061</span><span id="line.61">        double[] probs = new double[size];</span>
<span class="source-line-no">062</span><span id="line.62">        for (int i = 0; i &lt; size; ++i) {</span>
<span class="source-line-no">063</span><span id="line.63">            if(probabilities[i] &lt;= 0) continue;</span>
<span class="source-line-no">064</span><span id="line.64">            sum += (probs[i] = probabilities[i]);</span>
<span class="source-line-no">065</span><span id="line.65">        }</span>
<span class="source-line-no">066</span><span id="line.66">        if(sum &lt;= 0)</span>
<span class="source-line-no">067</span><span id="line.67">            throw new IllegalArgumentException("At least one probability must be positive");</span>
<span class="source-line-no">068</span><span id="line.68">        final double average = sum / size, invAverage = 1.0 / average;</span>
<span class="source-line-no">069</span><span id="line.69"></span>
<span class="source-line-no">070</span><span id="line.70">        /* Create two stacks to act as worklists as we populate the tables. */</span>
<span class="source-line-no">071</span><span id="line.71">        IntVLA small = new IntVLA(size);</span>
<span class="source-line-no">072</span><span id="line.72">        IntVLA large = new IntVLA(size);</span>
<span class="source-line-no">073</span><span id="line.73"></span>
<span class="source-line-no">074</span><span id="line.74">        /* Populate the stacks with the input probabilities. */</span>
<span class="source-line-no">075</span><span id="line.75">        for (int i = 0; i &lt; size; ++i) {</span>
<span class="source-line-no">076</span><span id="line.76">            /* If the probability is below the average probability, then we add</span>
<span class="source-line-no">077</span><span id="line.77">             * it to the small list; otherwise we add it to the large list.</span>
<span class="source-line-no">078</span><span id="line.78">             */</span>
<span class="source-line-no">079</span><span id="line.79">            if (probs[i] &gt;= average)</span>
<span class="source-line-no">080</span><span id="line.80">                large.add(i);</span>
<span class="source-line-no">081</span><span id="line.81">            else</span>
<span class="source-line-no">082</span><span id="line.82">                small.add(i);</span>
<span class="source-line-no">083</span><span id="line.83">        }</span>
<span class="source-line-no">084</span><span id="line.84"></span>
<span class="source-line-no">085</span><span id="line.85">        /* As a note: in the mathematical specification of the algorithm, we</span>
<span class="source-line-no">086</span><span id="line.86">         * will always exhaust the small list before the big list.  However,</span>
<span class="source-line-no">087</span><span id="line.87">         * due to floating point inaccuracies, this is not necessarily true.</span>
<span class="source-line-no">088</span><span id="line.88">         * Consequently, this inner loop (which tries to pair small and large</span>
<span class="source-line-no">089</span><span id="line.89">         * elements) will have to check that both lists aren't empty.</span>
<span class="source-line-no">090</span><span id="line.90">         */</span>
<span class="source-line-no">091</span><span id="line.91">        while (!small.isEmpty() &amp;&amp; !large.isEmpty()) {</span>
<span class="source-line-no">092</span><span id="line.92">            /* Get the index of the small and the large probabilities. */</span>
<span class="source-line-no">093</span><span id="line.93">            int less = small.pop(), less2 = less &lt;&lt; 1;</span>
<span class="source-line-no">094</span><span id="line.94">            int more = large.pop();</span>
<span class="source-line-no">095</span><span id="line.95"></span>
<span class="source-line-no">096</span><span id="line.96">            /* These probabilities have not yet been scaled up to be such that</span>
<span class="source-line-no">097</span><span id="line.97">             * sum/n is given weight 1.0.  We do this here instead.</span>
<span class="source-line-no">098</span><span id="line.98">             */</span>
<span class="source-line-no">099</span><span id="line.99">            mixed[less2] = (int)(0x7FFFFFFF * (probs[less] * invAverage));</span>
<span class="source-line-no">100</span><span id="line.100">            mixed[less2|1] = more;</span>
<span class="source-line-no">101</span><span id="line.101"></span>
<span class="source-line-no">102</span><span id="line.102">            probs[more] += probs[less] - average;</span>
<span class="source-line-no">103</span><span id="line.103"></span>
<span class="source-line-no">104</span><span id="line.104">            if (probs[more] &gt;= average)</span>
<span class="source-line-no">105</span><span id="line.105">                large.add(more);</span>
<span class="source-line-no">106</span><span id="line.106">            else</span>
<span class="source-line-no">107</span><span id="line.107">                small.add(more);</span>
<span class="source-line-no">108</span><span id="line.108">        }</span>
<span class="source-line-no">109</span><span id="line.109"></span>
<span class="source-line-no">110</span><span id="line.110">        while (!small.isEmpty())</span>
<span class="source-line-no">111</span><span id="line.111">            mixed[small.pop()&lt;&lt;1] = 0x7FFFFFFF;</span>
<span class="source-line-no">112</span><span id="line.112">        while (!large.isEmpty())</span>
<span class="source-line-no">113</span><span id="line.113">            mixed[large.pop()&lt;&lt;1] = 0x7FFFFFFF;</span>
<span class="source-line-no">114</span><span id="line.114">    }</span>
<span class="source-line-no">115</span><span id="line.115"></span>
<span class="source-line-no">116</span><span id="line.116">    private WeightedTable(int[] mixed, boolean ignored)</span>
<span class="source-line-no">117</span><span id="line.117">    {</span>
<span class="source-line-no">118</span><span id="line.118">        size = mixed.length &gt;&gt; 1;</span>
<span class="source-line-no">119</span><span id="line.119">        this.mixed = mixed;</span>
<span class="source-line-no">120</span><span id="line.120">    }</span>
<span class="source-line-no">121</span><span id="line.121">    /**</span>
<span class="source-line-no">122</span><span id="line.122">     * Gets an index of one of the weights in this WeightedTable, with the choice determined deterministically by the</span>
<span class="source-line-no">123</span><span id="line.123">     * given long, but higher weights will be returned by more possible inputs than lower weights. The state parameter</span>
<span class="source-line-no">124</span><span id="line.124">     * can be from a random source, but this will randomize it again anyway, so it is also fine to just give sequential</span>
<span class="source-line-no">125</span><span id="line.125">     * longs. The important thing is that each state input this is given will produce the same result for this</span>
<span class="source-line-no">126</span><span id="line.126">     * WeightedTable every time, so you should give different state values when you want random-seeming results. You may</span>
<span class="source-line-no">127</span><span id="line.127">     * want to call this like {@code weightedTable.random(++state)}, where state is a long, to ensure the inputs change.</span>
<span class="source-line-no">128</span><span id="line.128">     * This will always return an int between 0 (inclusive) and {@link #size} (exclusive).</span>
<span class="source-line-no">129</span><span id="line.129">     * @param state a long that should be different every time; consider calling with {@code ++state}</span>
<span class="source-line-no">130</span><span id="line.130">     * @return a random-seeming index from 0 to {@link #size} - 1, determined by weights and the given state</span>
<span class="source-line-no">131</span><span id="line.131">     */</span>
<span class="source-line-no">132</span><span id="line.132">    public int random(long state)</span>
<span class="source-line-no">133</span><span id="line.133">    {</span>
<span class="source-line-no">134</span><span id="line.134">        // This is DiverRNG's algorithm to generate a random long given sequential states</span>
<span class="source-line-no">135</span><span id="line.135">        state = (state = ((state = (((state * 0x632BE59BD9B4E019L) ^ 0x9E3779B97F4A7C15L) * 0xC6BC279692B5CC83L)) ^ </span>
<span class="source-line-no">136</span><span id="line.136">                state &gt;&gt;&gt; 27) * 0xAEF17502108EF2D9L) ^ state &gt;&gt;&gt; 25;</span>
<span class="source-line-no">137</span><span id="line.137">        // get a random int (using half the bits of our previously-calculated state) that is less than size</span>
<span class="source-line-no">138</span><span id="line.138">        int column = (int)((size * (state &amp; 0xFFFFFFFFL)) &gt;&gt; 32);</span>
<span class="source-line-no">139</span><span id="line.139">        // use the other half of the bits of state to get a 31-bit int, compare to probability and choose either the</span>
<span class="source-line-no">140</span><span id="line.140">        // current column or the alias for that column based on that probability</span>
<span class="source-line-no">141</span><span id="line.141">        return ((state &gt;&gt;&gt; 33) &lt;= mixed[column &lt;&lt; 1]) ? column : mixed[column &lt;&lt; 1 | 1];</span>
<span class="source-line-no">142</span><span id="line.142">    }</span>
<span class="source-line-no">143</span><span id="line.143">    </span>
<span class="source-line-no">144</span><span id="line.144">    public String serializeToString()</span>
<span class="source-line-no">145</span><span id="line.145">    {</span>
<span class="source-line-no">146</span><span id="line.146">        return StringKit.join(",", mixed);</span>
<span class="source-line-no">147</span><span id="line.147">    }</span>
<span class="source-line-no">148</span><span id="line.148">    public static WeightedTable deserializeFromString(String data)</span>
<span class="source-line-no">149</span><span id="line.149">    {</span>
<span class="source-line-no">150</span><span id="line.150">        if(data == null || data.isEmpty())</span>
<span class="source-line-no">151</span><span id="line.151">            return null;</span>
<span class="source-line-no">152</span><span id="line.152">        int pos = -1;//data.indexOf(':');</span>
<span class="source-line-no">153</span><span id="line.153">        //int size = StringKit.intFromDec(data, 0, pos);</span>
<span class="source-line-no">154</span><span id="line.154">        int count = StringKit.count(data, ',') + 1;</span>
<span class="source-line-no">155</span><span id="line.155">        int[] mixed = new int[count];</span>
<span class="source-line-no">156</span><span id="line.156">        for (int i = 0; i &lt; count; i++) {</span>
<span class="source-line-no">157</span><span id="line.157">            mixed[i] = StringKit.intFromDec(data, pos+1, pos = data.indexOf(',', pos+1));</span>
<span class="source-line-no">158</span><span id="line.158">        }</span>
<span class="source-line-no">159</span><span id="line.159">        return new WeightedTable(mixed, true);</span>
<span class="source-line-no">160</span><span id="line.160">    }</span>
<span class="source-line-no">161</span><span id="line.161"></span>
<span class="source-line-no">162</span><span id="line.162">}</span>




























































</pre>
</div>
</main>
</body>
</html>
