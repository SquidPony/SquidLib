<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>Source code</title>
<meta name="description" content="source: package: squidpony.squidmath, class: OrderedSet">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body class="source-page">
<main role="main">
<div class="source-container">
<pre><span class="source-line-no">001</span><span id="line.1">/*</span>
<span class="source-line-no">002</span><span id="line.2"> * Copyright (C) 2002-2015 Sebastiano Vigna</span>
<span class="source-line-no">003</span><span id="line.3"> *</span>
<span class="source-line-no">004</span><span id="line.4"> * Licensed under the Apache License, Version 2.0 (the "License");</span>
<span class="source-line-no">005</span><span id="line.5"> * you may not use this file except in compliance with the License.</span>
<span class="source-line-no">006</span><span id="line.6"> * You may obtain a copy of the License at</span>
<span class="source-line-no">007</span><span id="line.7"> *</span>
<span class="source-line-no">008</span><span id="line.8"> *     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="source-line-no">009</span><span id="line.9"> *</span>
<span class="source-line-no">010</span><span id="line.10"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="source-line-no">011</span><span id="line.11"> * distributed under the License is distributed on an "AS IS" BASIS,</span>
<span class="source-line-no">012</span><span id="line.12"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="source-line-no">013</span><span id="line.13"> * See the License for the specific language governing permissions and</span>
<span class="source-line-no">014</span><span id="line.14"> * limitations under the License. </span>
<span class="source-line-no">015</span><span id="line.15"> */</span>
<span class="source-line-no">016</span><span id="line.16">package squidpony.squidmath;</span>
<span class="source-line-no">017</span><span id="line.17"></span>
<span class="source-line-no">018</span><span id="line.18">import squidpony.annotation.GwtIncompatible;</span>
<span class="source-line-no">019</span><span id="line.19"></span>
<span class="source-line-no">020</span><span id="line.20">import java.util.*;</span>
<span class="source-line-no">021</span><span id="line.21"></span>
<span class="source-line-no">022</span><span id="line.22">import static squidpony.squidmath.CrossHash.Water.*;</span>
<span class="source-line-no">023</span><span id="line.23"></span>
<span class="source-line-no">024</span><span id="line.24">/**</span>
<span class="source-line-no">025</span><span id="line.25"> * A generic linked hash set with with a fast implementation, originally from fastutil as ObjectLinkedOpenHashSet but</span>
<span class="source-line-no">026</span><span id="line.26"> * modified to support indexed access of items, reordering, and optional hash strategies for array keys (which fastutil</span>
<span class="source-line-no">027</span><span id="line.27"> * does differently).</span>
<span class="source-line-no">028</span><span id="line.28"> * &lt;p&gt;</span>
<span class="source-line-no">029</span><span id="line.29"> * Instances of this class use a hash table to represent a set. The table is</span>
<span class="source-line-no">030</span><span id="line.30"> * filled up to a specified &lt;em&gt;load factor&lt;/em&gt;, and then doubled in size to</span>
<span class="source-line-no">031</span><span id="line.31"> * accommodate new entries. If the table is emptied below &lt;em&gt;one fourth&lt;/em&gt; of</span>
<span class="source-line-no">032</span><span id="line.32"> * the load factor, it is halved in size. However, halving is not performed when</span>
<span class="source-line-no">033</span><span id="line.33"> * deleting entries from an iterator, as it would interfere with the iteration</span>
<span class="source-line-no">034</span><span id="line.34"> * process.</span>
<span class="source-line-no">035</span><span id="line.35"> * &lt;/p&gt;</span>
<span class="source-line-no">036</span><span id="line.36"> * &lt;p&gt;</span>
<span class="source-line-no">037</span><span id="line.37"> * Note that {@link #clear()} does not modify the hash table size. Rather, a</span>
<span class="source-line-no">038</span><span id="line.38"> * family of {@linkplain #trim() trimming methods} lets you control the size of</span>
<span class="source-line-no">039</span><span id="line.39"> * the table; this is particularly useful if you reuse instances of this class.</span>
<span class="source-line-no">040</span><span id="line.40"> * &lt;/p&gt;</span>
<span class="source-line-no">041</span><span id="line.41"> * &lt;p&gt;</span>
<span class="source-line-no">042</span><span id="line.42"> * Iterators generated by this set will enumerate elements in the same order in</span>
<span class="source-line-no">043</span><span id="line.43"> * which they have been added to the set (addition of elements already present</span>
<span class="source-line-no">044</span><span id="line.44"> * in the set does not change the iteration order). Note that this order has</span>
<span class="source-line-no">045</span><span id="line.45"> * nothing in common with the natural order of the keys. The order is kept by</span>
<span class="source-line-no">046</span><span id="line.46"> * means of an array list, represented &lt;i&gt;via&lt;/i&gt; an IntVLA parallel to the</span>
<span class="source-line-no">047</span><span id="line.47"> * table that can be modified with methods like {@link #shuffle(IRNG)}.</span>
<span class="source-line-no">048</span><span id="line.48"> * &lt;/p&gt;</span>
<span class="source-line-no">049</span><span id="line.49"> * &lt;p&gt;</span>
<span class="source-line-no">050</span><span id="line.50"> * This class implements the interface of a sorted set, so to allow easy access</span>
<span class="source-line-no">051</span><span id="line.51"> * of the iteration order: for instance, you can get the first element in</span>
<span class="source-line-no">052</span><span id="line.52"> * iteration order with {@code first()} without having to create an iterator;</span>
<span class="source-line-no">053</span><span id="line.53"> * however, this class partially violates the {@link java.util.SortedSet}</span>
<span class="source-line-no">054</span><span id="line.54"> * contract because all subset methods throw an exception and</span>
<span class="source-line-no">055</span><span id="line.55"> * {@link #comparator()} returns always &lt;code&gt;null&lt;/code&gt;.</span>
<span class="source-line-no">056</span><span id="line.56"> * &lt;p&gt;</span>
<span class="source-line-no">057</span><span id="line.57"> * &lt;p&gt;</span>
<span class="source-line-no">058</span><span id="line.58"> * Additional methods, such as &lt;code&gt;addAndMoveToFirst()&lt;/code&gt;, make it easy to</span>
<span class="source-line-no">059</span><span id="line.59"> * use instances of this class as a cache (e.g., with LRU policy).</span>
<span class="source-line-no">060</span><span id="line.60"> * &lt;/p&gt;</span>
<span class="source-line-no">061</span><span id="line.61"> * &lt;p&gt;</span>
<span class="source-line-no">062</span><span id="line.62"> * This class allows approximately constant-time lookup of keys or values by their index in the ordering, which can</span>
<span class="source-line-no">063</span><span id="line.63"> * allow some novel usage of the data structure. OrderedSet can be used like a list of unique elements, keeping order</span>
<span class="source-line-no">064</span><span id="line.64"> * like a list does but also allowing rapid checks for whether an item exists in the OrderedSet, and {@link OrderedMap}</span>
<span class="source-line-no">065</span><span id="line.65"> * can be used like that but with values associated as well (where OrderedSet uses contains(), OrderedMap uses</span>
<span class="source-line-no">066</span><span id="line.66"> * containsKey()). You can also set the item at a position with {@link #addAt(Object, int)}, or alter an item while</span>
<span class="source-line-no">067</span><span id="line.67"> * keeping index the same with {@link #alter(Object, Object)}. Reordering works here too, both with completely random</span>
<span class="source-line-no">068</span><span id="line.68"> * orders from {@link #shuffle(IRNG)} or with a previously-generated ordering from {@link #reorder(int...)} (you can</span>
<span class="source-line-no">069</span><span id="line.69"> * produce such an ordering for a given size and reuse it across multiple Ordered data structures with</span>
<span class="source-line-no">070</span><span id="line.70"> * {@link IRNG#randomOrdering(int)}).</span>
<span class="source-line-no">071</span><span id="line.71"> * &lt;/p&gt;</span>
<span class="source-line-no">072</span><span id="line.72"> * &lt;p&gt;</span>
<span class="source-line-no">073</span><span id="line.73"> * You can pass an {@link CrossHash.IHasher} instance such as {@link CrossHash#generalHasher} as an extra parameter to</span>
<span class="source-line-no">074</span><span id="line.74"> * most of this class' constructors, which allows the OrderedSet to use arrays (usually primitive arrays) as items. If</span>
<span class="source-line-no">075</span><span id="line.75"> * you expect only one type of array, you can use an instance like {@link CrossHash#intHasher} to hash int arrays, or</span>
<span class="source-line-no">076</span><span id="line.76"> * the aforementioned generalHasher to hash most kinds of arrays (it can't handle most multi-dimensional arrays well).</span>
<span class="source-line-no">077</span><span id="line.77"> * If you aren't using array items, you don't need to give an IHasher to the constructor and can ignore this feature.</span>
<span class="source-line-no">078</span><span id="line.78"> * &lt;/p&gt;</span>
<span class="source-line-no">079</span><span id="line.79"> * &lt;br&gt;</span>
<span class="source-line-no">080</span><span id="line.80"> * Thank you, Sebastiano Vigna, for making FastUtil available to the public with such high quality.</span>
<span class="source-line-no">081</span><span id="line.81"> * &lt;br&gt;</span>
<span class="source-line-no">082</span><span id="line.82"> * See https://github.com/vigna/fastutil for the original library.</span>
<span class="source-line-no">083</span><span id="line.83"> *</span>
<span class="source-line-no">084</span><span id="line.84"> * @author Sebastiano Vigna (responsible for all the hard parts)</span>
<span class="source-line-no">085</span><span id="line.85"> * @author Tommy Ettinger (mostly responsible for squashing several layers of parent classes into one monster class)</span>
<span class="source-line-no">086</span><span id="line.86"> */</span>
<span class="source-line-no">087</span><span id="line.87">public class OrderedSet&lt;K&gt; implements SortedSet&lt;K&gt;, java.io.Serializable, Cloneable {</span>
<span class="source-line-no">088</span><span id="line.88">    private static final long serialVersionUID = 0L;</span>
<span class="source-line-no">089</span><span id="line.89">    /**</span>
<span class="source-line-no">090</span><span id="line.90">     * The array of keys.</span>
<span class="source-line-no">091</span><span id="line.91">     */</span>
<span class="source-line-no">092</span><span id="line.92">    protected K[] key;</span>
<span class="source-line-no">093</span><span id="line.93">    /**</span>
<span class="source-line-no">094</span><span id="line.94">     * The mask for wrapping a position counter.</span>
<span class="source-line-no">095</span><span id="line.95">     */</span>
<span class="source-line-no">096</span><span id="line.96">    protected int mask;</span>
<span class="source-line-no">097</span><span id="line.97">    /**</span>
<span class="source-line-no">098</span><span id="line.98">     * Whether this set contains the key zero.</span>
<span class="source-line-no">099</span><span id="line.99">     */</span>
<span class="source-line-no">100</span><span id="line.100">    protected boolean containsNull;</span>
<span class="source-line-no">101</span><span id="line.101">    /**</span>
<span class="source-line-no">102</span><span id="line.102">     * An IntVLA (variable-length int sequence) that stores the positions in the key array of specific keys, with the</span>
<span class="source-line-no">103</span><span id="line.103">     * positions in insertion order. The order can be changed with {@link #reorder(int...)} and other methods.</span>
<span class="source-line-no">104</span><span id="line.104">     */</span>
<span class="source-line-no">105</span><span id="line.105">    protected IntVLA order;</span>
<span class="source-line-no">106</span><span id="line.106">    /**</span>
<span class="source-line-no">107</span><span id="line.107">     * The current table size.</span>
<span class="source-line-no">108</span><span id="line.108">     */</span>
<span class="source-line-no">109</span><span id="line.109">    protected int n;</span>
<span class="source-line-no">110</span><span id="line.110">    /**</span>
<span class="source-line-no">111</span><span id="line.111">     * Threshold after which we rehash. It must be the table size times {@link #f}.</span>
<span class="source-line-no">112</span><span id="line.112">     */</span>
<span class="source-line-no">113</span><span id="line.113">    protected int maxFill;</span>
<span class="source-line-no">114</span><span id="line.114">    /**</span>
<span class="source-line-no">115</span><span id="line.115">     * Number of entries in the set (including the key zero, if present).</span>
<span class="source-line-no">116</span><span id="line.116">     */</span>
<span class="source-line-no">117</span><span id="line.117">    protected int size;</span>
<span class="source-line-no">118</span><span id="line.118">    /**</span>
<span class="source-line-no">119</span><span id="line.119">     * The acceptable load factor.</span>
<span class="source-line-no">120</span><span id="line.120">     */</span>
<span class="source-line-no">121</span><span id="line.121">    public final float f;</span>
<span class="source-line-no">122</span><span id="line.122"></span>
<span class="source-line-no">123</span><span id="line.123">    /**</span>
<span class="source-line-no">124</span><span id="line.124">     * The initial default size of a hash table.</span>
<span class="source-line-no">125</span><span id="line.125">     */</span>
<span class="source-line-no">126</span><span id="line.126">    public static final int DEFAULT_INITIAL_SIZE = 16;</span>
<span class="source-line-no">127</span><span id="line.127">    /**</span>
<span class="source-line-no">128</span><span id="line.128">     * The default load factor of a hash table.</span>
<span class="source-line-no">129</span><span id="line.129">     */</span>
<span class="source-line-no">130</span><span id="line.130">    public static final float DEFAULT_LOAD_FACTOR = .375f; // .1875f; // .75f;</span>
<span class="source-line-no">131</span><span id="line.131">    /**</span>
<span class="source-line-no">132</span><span id="line.132">     * The load factor for a (usually small) table that is meant to be particularly fast.</span>
<span class="source-line-no">133</span><span id="line.133">     */</span>
<span class="source-line-no">134</span><span id="line.134">    public static final float FAST_LOAD_FACTOR = .5f;</span>
<span class="source-line-no">135</span><span id="line.135">    /**</span>
<span class="source-line-no">136</span><span id="line.136">     * The load factor for a (usually very small) table that is meant to be extremely fast.</span>
<span class="source-line-no">137</span><span id="line.137">     */</span>
<span class="source-line-no">138</span><span id="line.138">    public static final float VERY_FAST_LOAD_FACTOR = .25f;</span>
<span class="source-line-no">139</span><span id="line.139"></span>
<span class="source-line-no">140</span><span id="line.140">    protected final CrossHash.IHasher hasher;</span>
<span class="source-line-no">141</span><span id="line.141"></span>
<span class="source-line-no">142</span><span id="line.142">    /**</span>
<span class="source-line-no">143</span><span id="line.143">     * Creates a new hash map.</span>
<span class="source-line-no">144</span><span id="line.144">     * &lt;p&gt;</span>
<span class="source-line-no">145</span><span id="line.145">     * &lt;p&gt;The actual table size will be the least power of two greater than &lt;code&gt;expected&lt;/code&gt;/&lt;code&gt;f&lt;/code&gt;.</span>
<span class="source-line-no">146</span><span id="line.146">     *</span>
<span class="source-line-no">147</span><span id="line.147">     * @param expected the expected number of elements in the hash set.</span>
<span class="source-line-no">148</span><span id="line.148">     * @param f        the load factor.</span>
<span class="source-line-no">149</span><span id="line.149">     */</span>
<span class="source-line-no">150</span><span id="line.150"></span>
<span class="source-line-no">151</span><span id="line.151">    @SuppressWarnings("unchecked")</span>
<span class="source-line-no">152</span><span id="line.152">    public OrderedSet(final int expected, final float f) {</span>
<span class="source-line-no">153</span><span id="line.153">        if (f &lt;= 0 || f &gt; 1)</span>
<span class="source-line-no">154</span><span id="line.154">            throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than or equal to 1");</span>
<span class="source-line-no">155</span><span id="line.155">        if (expected &lt; 0) throw new IllegalArgumentException("The expected number of elements must be nonnegative");</span>
<span class="source-line-no">156</span><span id="line.156">        this.f = f;</span>
<span class="source-line-no">157</span><span id="line.157">        n = arraySize(expected, f);</span>
<span class="source-line-no">158</span><span id="line.158">        mask = n - 1;</span>
<span class="source-line-no">159</span><span id="line.159">        maxFill = maxFill(n, f);</span>
<span class="source-line-no">160</span><span id="line.160">        key = (K[]) new Object[n + 1];</span>
<span class="source-line-no">161</span><span id="line.161">        //link = new long[n + 1];</span>
<span class="source-line-no">162</span><span id="line.162">        order = new IntVLA(expected);</span>
<span class="source-line-no">163</span><span id="line.163">        hasher = CrossHash.mildHasher;</span>
<span class="source-line-no">164</span><span id="line.164">    }</span>
<span class="source-line-no">165</span><span id="line.165"></span>
<span class="source-line-no">166</span><span id="line.166">    /**</span>
<span class="source-line-no">167</span><span id="line.167">     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load</span>
<span class="source-line-no">168</span><span id="line.168">     * factor.</span>
<span class="source-line-no">169</span><span id="line.169">     *</span>
<span class="source-line-no">170</span><span id="line.170">     * @param expected the expected number of elements in the hash set.</span>
<span class="source-line-no">171</span><span id="line.171">     */</span>
<span class="source-line-no">172</span><span id="line.172">    public OrderedSet(final int expected) {</span>
<span class="source-line-no">173</span><span id="line.173">        this(expected, DEFAULT_LOAD_FACTOR);</span>
<span class="source-line-no">174</span><span id="line.174">    }</span>
<span class="source-line-no">175</span><span id="line.175"></span>
<span class="source-line-no">176</span><span id="line.176">    /**</span>
<span class="source-line-no">177</span><span id="line.177">     * Creates a new hash set with initial expected</span>
<span class="source-line-no">178</span><span id="line.178">     * {@link #DEFAULT_INITIAL_SIZE} elements and</span>
<span class="source-line-no">179</span><span id="line.179">     * {@link #DEFAULT_LOAD_FACTOR} as load factor.</span>
<span class="source-line-no">180</span><span id="line.180">     */</span>
<span class="source-line-no">181</span><span id="line.181">    public OrderedSet() {</span>
<span class="source-line-no">182</span><span id="line.182">        this(DEFAULT_INITIAL_SIZE, DEFAULT_LOAD_FACTOR);</span>
<span class="source-line-no">183</span><span id="line.183">    }</span>
<span class="source-line-no">184</span><span id="line.184"></span>
<span class="source-line-no">185</span><span id="line.185">    /**</span>
<span class="source-line-no">186</span><span id="line.186">     * Creates a new hash set copying a given collection.</span>
<span class="source-line-no">187</span><span id="line.187">     *</span>
<span class="source-line-no">188</span><span id="line.188">     * @param c a {@link Collection} to be copied into the new hash set.</span>
<span class="source-line-no">189</span><span id="line.189">     * @param f the load factor.</span>
<span class="source-line-no">190</span><span id="line.190">     */</span>
<span class="source-line-no">191</span><span id="line.191">    public OrderedSet(final Collection&lt;? extends K&gt; c,</span>
<span class="source-line-no">192</span><span id="line.192">                      final float f) {</span>
<span class="source-line-no">193</span><span id="line.193">        this(c.size(), f, (c instanceof OrderedSet) ? ((OrderedSet) c).hasher : CrossHash.mildHasher);</span>
<span class="source-line-no">194</span><span id="line.194">        addAll(c);</span>
<span class="source-line-no">195</span><span id="line.195">    }</span>
<span class="source-line-no">196</span><span id="line.196"></span>
<span class="source-line-no">197</span><span id="line.197">    /**</span>
<span class="source-line-no">198</span><span id="line.198">     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load</span>
<span class="source-line-no">199</span><span id="line.199">     * factor copying a given collection.</span>
<span class="source-line-no">200</span><span id="line.200">     *</span>
<span class="source-line-no">201</span><span id="line.201">     * @param c a {@link Collection} to be copied into the new hash set.</span>
<span class="source-line-no">202</span><span id="line.202">     */</span>
<span class="source-line-no">203</span><span id="line.203">    public OrderedSet(final Collection&lt;? extends K&gt; c) {</span>
<span class="source-line-no">204</span><span id="line.204">        this(c, (c instanceof OrderedSet) ? ((OrderedSet) c).f : DEFAULT_LOAD_FACTOR, (c instanceof OrderedSet) ? ((OrderedSet) c).hasher : CrossHash.mildHasher);</span>
<span class="source-line-no">205</span><span id="line.205">    }</span>
<span class="source-line-no">206</span><span id="line.206"></span>
<span class="source-line-no">207</span><span id="line.207">    /**</span>
<span class="source-line-no">208</span><span id="line.208">     * Creates a new hash set using elements provided by a type-specific</span>
<span class="source-line-no">209</span><span id="line.209">     * iterator.</span>
<span class="source-line-no">210</span><span id="line.210">     *</span>
<span class="source-line-no">211</span><span id="line.211">     * @param i a type-specific iterator whose elements will fill the set.</span>
<span class="source-line-no">212</span><span id="line.212">     * @param f the load factor.</span>
<span class="source-line-no">213</span><span id="line.213">     */</span>
<span class="source-line-no">214</span><span id="line.214">    public OrderedSet(final Iterator&lt;? extends K&gt; i, final float f) {</span>
<span class="source-line-no">215</span><span id="line.215">        this(DEFAULT_INITIAL_SIZE, f);</span>
<span class="source-line-no">216</span><span id="line.216">        while (i.hasNext())</span>
<span class="source-line-no">217</span><span id="line.217">            add(i.next());</span>
<span class="source-line-no">218</span><span id="line.218">    }</span>
<span class="source-line-no">219</span><span id="line.219"></span>
<span class="source-line-no">220</span><span id="line.220">    /**</span>
<span class="source-line-no">221</span><span id="line.221">     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load</span>
<span class="source-line-no">222</span><span id="line.222">     * factor using elements provided by a type-specific iterator.</span>
<span class="source-line-no">223</span><span id="line.223">     *</span>
<span class="source-line-no">224</span><span id="line.224">     * @param i a type-specific iterator whose elements will fill the set.</span>
<span class="source-line-no">225</span><span id="line.225">     */</span>
<span class="source-line-no">226</span><span id="line.226">    public OrderedSet(final Iterator&lt;? extends K&gt; i) {</span>
<span class="source-line-no">227</span><span id="line.227">        this(i, DEFAULT_LOAD_FACTOR);</span>
<span class="source-line-no">228</span><span id="line.228">    }</span>
<span class="source-line-no">229</span><span id="line.229"></span>
<span class="source-line-no">230</span><span id="line.230">    /**</span>
<span class="source-line-no">231</span><span id="line.231">     * Creates a new hash set and fills it with the elements of a given array.</span>
<span class="source-line-no">232</span><span id="line.232">     *</span>
<span class="source-line-no">233</span><span id="line.233">     * @param a      an array whose elements will be used to fill the set.</span>
<span class="source-line-no">234</span><span id="line.234">     * @param offset the first element to use.</span>
<span class="source-line-no">235</span><span id="line.235">     * @param length the number of elements to use.</span>
<span class="source-line-no">236</span><span id="line.236">     * @param f      the load factor.</span>
<span class="source-line-no">237</span><span id="line.237">     */</span>
<span class="source-line-no">238</span><span id="line.238">    public OrderedSet(final K[] a, final int offset,</span>
<span class="source-line-no">239</span><span id="line.239">                      final int length, final float f) {</span>
<span class="source-line-no">240</span><span id="line.240">        this(Math.max(length, 0), f);</span>
<span class="source-line-no">241</span><span id="line.241">        if (a == null) throw new NullPointerException("Array passed to OrderedSet constructor cannot be null");</span>
<span class="source-line-no">242</span><span id="line.242">        if (offset &lt; 0) throw new ArrayIndexOutOfBoundsException("Offset (" + offset + ") is negative");</span>
<span class="source-line-no">243</span><span id="line.243">        if (length &lt; 0) throw new IllegalArgumentException("Length (" + length + ") is negative");</span>
<span class="source-line-no">244</span><span id="line.244">        if (offset + length &gt; a.length) {</span>
<span class="source-line-no">245</span><span id="line.245">            throw new ArrayIndexOutOfBoundsException(</span>
<span class="source-line-no">246</span><span id="line.246">                    "Last index (" + (offset + length) + ") is greater than array length (" + a.length + ")");</span>
<span class="source-line-no">247</span><span id="line.247">        }</span>
<span class="source-line-no">248</span><span id="line.248">        for (int i = 0; i &lt; length; i++)</span>
<span class="source-line-no">249</span><span id="line.249">            add(a[offset + i]);</span>
<span class="source-line-no">250</span><span id="line.250">    }</span>
<span class="source-line-no">251</span><span id="line.251"></span>
<span class="source-line-no">252</span><span id="line.252">    /**</span>
<span class="source-line-no">253</span><span id="line.253">     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load</span>
<span class="source-line-no">254</span><span id="line.254">     * factor and fills it with the elements of a given array.</span>
<span class="source-line-no">255</span><span id="line.255">     *</span>
<span class="source-line-no">256</span><span id="line.256">     * @param a      an array whose elements will be used to fill the set.</span>
<span class="source-line-no">257</span><span id="line.257">     * @param offset the first element to use.</span>
<span class="source-line-no">258</span><span id="line.258">     * @param length the number of elements to use.</span>
<span class="source-line-no">259</span><span id="line.259">     */</span>
<span class="source-line-no">260</span><span id="line.260">    public OrderedSet(final K[] a, final int offset,</span>
<span class="source-line-no">261</span><span id="line.261">                      final int length) {</span>
<span class="source-line-no">262</span><span id="line.262">        this(a, offset, length, DEFAULT_LOAD_FACTOR);</span>
<span class="source-line-no">263</span><span id="line.263">    }</span>
<span class="source-line-no">264</span><span id="line.264"></span>
<span class="source-line-no">265</span><span id="line.265">    /**</span>
<span class="source-line-no">266</span><span id="line.266">     * Creates a new hash set copying the elements of an array.</span>
<span class="source-line-no">267</span><span id="line.267">     *</span>
<span class="source-line-no">268</span><span id="line.268">     * @param a an array to be copied into the new hash set.</span>
<span class="source-line-no">269</span><span id="line.269">     * @param f the load factor.</span>
<span class="source-line-no">270</span><span id="line.270">     */</span>
<span class="source-line-no">271</span><span id="line.271">    public OrderedSet(final K[] a, final float f) {</span>
<span class="source-line-no">272</span><span id="line.272">        this(a, 0, a.length, f);</span>
<span class="source-line-no">273</span><span id="line.273">    }</span>
<span class="source-line-no">274</span><span id="line.274"></span>
<span class="source-line-no">275</span><span id="line.275">    /**</span>
<span class="source-line-no">276</span><span id="line.276">     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load</span>
<span class="source-line-no">277</span><span id="line.277">     * factor copying the elements of an array.</span>
<span class="source-line-no">278</span><span id="line.278">     *</span>
<span class="source-line-no">279</span><span id="line.279">     * @param a an array to be copied into the new hash set.</span>
<span class="source-line-no">280</span><span id="line.280">     */</span>
<span class="source-line-no">281</span><span id="line.281">    public OrderedSet(final K[] a) {</span>
<span class="source-line-no">282</span><span id="line.282">        this(a, DEFAULT_LOAD_FACTOR);</span>
<span class="source-line-no">283</span><span id="line.283">    }</span>
<span class="source-line-no">284</span><span id="line.284"></span>
<span class="source-line-no">285</span><span id="line.285">    /**</span>
<span class="source-line-no">286</span><span id="line.286">     * Creates a new hash map.</span>
<span class="source-line-no">287</span><span id="line.287">     * &lt;p&gt;</span>
<span class="source-line-no">288</span><span id="line.288">     * &lt;p&gt;The actual table size will be the least power of two greater than &lt;code&gt;expected&lt;/code&gt;/&lt;code&gt;f&lt;/code&gt;.</span>
<span class="source-line-no">289</span><span id="line.289">     *</span>
<span class="source-line-no">290</span><span id="line.290">     * @param expected the expected number of elements in the hash set.</span>
<span class="source-line-no">291</span><span id="line.291">     * @param f        the load factor.</span>
<span class="source-line-no">292</span><span id="line.292">     * @param hasher   used to hash items; typically only needed when K is an array, where CrossHash has implementations</span>
<span class="source-line-no">293</span><span id="line.293">     */</span>
<span class="source-line-no">294</span><span id="line.294">    @SuppressWarnings("unchecked")</span>
<span class="source-line-no">295</span><span id="line.295">    public OrderedSet(final int expected, final float f, CrossHash.IHasher hasher) {</span>
<span class="source-line-no">296</span><span id="line.296">        if (f &lt;= 0 || f &gt; 1)</span>
<span class="source-line-no">297</span><span id="line.297">            throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than or equal to 1");</span>
<span class="source-line-no">298</span><span id="line.298">        if (expected &lt; 0) throw new IllegalArgumentException("The expected number of elements must be nonnegative");</span>
<span class="source-line-no">299</span><span id="line.299">        this.f = f;</span>
<span class="source-line-no">300</span><span id="line.300">        n = arraySize(expected, f);</span>
<span class="source-line-no">301</span><span id="line.301">        mask = n - 1;</span>
<span class="source-line-no">302</span><span id="line.302">        maxFill = maxFill(n, f);</span>
<span class="source-line-no">303</span><span id="line.303">        key = (K[]) new Object[n + 1];</span>
<span class="source-line-no">304</span><span id="line.304">        //link = new long[n + 1];</span>
<span class="source-line-no">305</span><span id="line.305">        order = new IntVLA(expected);</span>
<span class="source-line-no">306</span><span id="line.306">        this.hasher = hasher == null ? CrossHash.mildHasher : hasher;</span>
<span class="source-line-no">307</span><span id="line.307">    }</span>
<span class="source-line-no">308</span><span id="line.308"></span>
<span class="source-line-no">309</span><span id="line.309">    /**</span>
<span class="source-line-no">310</span><span id="line.310">     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load</span>
<span class="source-line-no">311</span><span id="line.311">     * factor.</span>
<span class="source-line-no">312</span><span id="line.312">     *</span>
<span class="source-line-no">313</span><span id="line.313">     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations</span>
<span class="source-line-no">314</span><span id="line.314">     */</span>
<span class="source-line-no">315</span><span id="line.315">    public OrderedSet(CrossHash.IHasher hasher) {</span>
<span class="source-line-no">316</span><span id="line.316">        this(DEFAULT_INITIAL_SIZE, DEFAULT_LOAD_FACTOR, hasher);</span>
<span class="source-line-no">317</span><span id="line.317">    }</span>
<span class="source-line-no">318</span><span id="line.318"></span>
<span class="source-line-no">319</span><span id="line.319">    /**</span>
<span class="source-line-no">320</span><span id="line.320">     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load</span>
<span class="source-line-no">321</span><span id="line.321">     * factor.</span>
<span class="source-line-no">322</span><span id="line.322">     *</span>
<span class="source-line-no">323</span><span id="line.323">     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations</span>
<span class="source-line-no">324</span><span id="line.324">     */</span>
<span class="source-line-no">325</span><span id="line.325">    public OrderedSet(final int expected, CrossHash.IHasher hasher) {</span>
<span class="source-line-no">326</span><span id="line.326">        this(expected, DEFAULT_LOAD_FACTOR, hasher);</span>
<span class="source-line-no">327</span><span id="line.327">    }</span>
<span class="source-line-no">328</span><span id="line.328"></span>
<span class="source-line-no">329</span><span id="line.329">    /**</span>
<span class="source-line-no">330</span><span id="line.330">     * Creates a new hash set copying a given collection.</span>
<span class="source-line-no">331</span><span id="line.331">     *</span>
<span class="source-line-no">332</span><span id="line.332">     * @param c      a {@link Collection} to be copied into the new hash set.</span>
<span class="source-line-no">333</span><span id="line.333">     * @param f      the load factor.</span>
<span class="source-line-no">334</span><span id="line.334">     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations</span>
<span class="source-line-no">335</span><span id="line.335">     */</span>
<span class="source-line-no">336</span><span id="line.336">    public OrderedSet(final Collection&lt;? extends K&gt; c,</span>
<span class="source-line-no">337</span><span id="line.337">                      final float f, CrossHash.IHasher hasher) {</span>
<span class="source-line-no">338</span><span id="line.338">        this(c.size(), f, hasher);</span>
<span class="source-line-no">339</span><span id="line.339">        addAll(c);</span>
<span class="source-line-no">340</span><span id="line.340">    }</span>
<span class="source-line-no">341</span><span id="line.341"></span>
<span class="source-line-no">342</span><span id="line.342">    /**</span>
<span class="source-line-no">343</span><span id="line.343">     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load</span>
<span class="source-line-no">344</span><span id="line.344">     * factor copying a given collection.</span>
<span class="source-line-no">345</span><span id="line.345">     *</span>
<span class="source-line-no">346</span><span id="line.346">     * @param c      a {@link Collection} to be copied into the new hash set.</span>
<span class="source-line-no">347</span><span id="line.347">     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations</span>
<span class="source-line-no">348</span><span id="line.348">     */</span>
<span class="source-line-no">349</span><span id="line.349">    public OrderedSet(final Collection&lt;? extends K&gt; c, CrossHash.IHasher hasher) {</span>
<span class="source-line-no">350</span><span id="line.350">        this(c, DEFAULT_LOAD_FACTOR, hasher);</span>
<span class="source-line-no">351</span><span id="line.351">    }</span>
<span class="source-line-no">352</span><span id="line.352"></span>
<span class="source-line-no">353</span><span id="line.353">    /**</span>
<span class="source-line-no">354</span><span id="line.354">     * Creates a new hash set and fills it with the elements of a given array.</span>
<span class="source-line-no">355</span><span id="line.355">     *</span>
<span class="source-line-no">356</span><span id="line.356">     * @param a      an array whose elements will be used to fill the set.</span>
<span class="source-line-no">357</span><span id="line.357">     * @param offset the first element to use.</span>
<span class="source-line-no">358</span><span id="line.358">     * @param length the number of elements to use.</span>
<span class="source-line-no">359</span><span id="line.359">     * @param f      the load factor.</span>
<span class="source-line-no">360</span><span id="line.360">     */</span>
<span class="source-line-no">361</span><span id="line.361">    public OrderedSet(final K[] a, final int offset,</span>
<span class="source-line-no">362</span><span id="line.362">                      final int length, final float f, CrossHash.IHasher hasher) {</span>
<span class="source-line-no">363</span><span id="line.363">        this(Math.max(length, 0), f, hasher);</span>
<span class="source-line-no">364</span><span id="line.364">        if (a == null) throw new NullPointerException("Array passed to OrderedSet constructor cannot be null");</span>
<span class="source-line-no">365</span><span id="line.365">        if (offset &lt; 0) throw new ArrayIndexOutOfBoundsException("Offset (" + offset + ") is negative");</span>
<span class="source-line-no">366</span><span id="line.366">        if (length &lt; 0) throw new IllegalArgumentException("Length (" + length + ") is negative");</span>
<span class="source-line-no">367</span><span id="line.367">        if (offset + length &gt; a.length) {</span>
<span class="source-line-no">368</span><span id="line.368">            throw new ArrayIndexOutOfBoundsException(</span>
<span class="source-line-no">369</span><span id="line.369">                    "Last index (" + (offset + length) + ") is greater than array length (" + a.length + ")");</span>
<span class="source-line-no">370</span><span id="line.370">        }</span>
<span class="source-line-no">371</span><span id="line.371">        for (int i = 0; i &lt; length; i++)</span>
<span class="source-line-no">372</span><span id="line.372">            add(a[offset + i]);</span>
<span class="source-line-no">373</span><span id="line.373">    }</span>
<span class="source-line-no">374</span><span id="line.374"></span>
<span class="source-line-no">375</span><span id="line.375">    /**</span>
<span class="source-line-no">376</span><span id="line.376">     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load</span>
<span class="source-line-no">377</span><span id="line.377">     * factor and fills it with the elements of a given array.</span>
<span class="source-line-no">378</span><span id="line.378">     *</span>
<span class="source-line-no">379</span><span id="line.379">     * @param a      an array whose elements will be used to fill the set.</span>
<span class="source-line-no">380</span><span id="line.380">     * @param offset the first element to use.</span>
<span class="source-line-no">381</span><span id="line.381">     * @param length the number of elements to use.</span>
<span class="source-line-no">382</span><span id="line.382">     */</span>
<span class="source-line-no">383</span><span id="line.383">    public OrderedSet(final K[] a, final int offset,</span>
<span class="source-line-no">384</span><span id="line.384">                      final int length, CrossHash.IHasher hasher) {</span>
<span class="source-line-no">385</span><span id="line.385">        this(a, offset, length, DEFAULT_LOAD_FACTOR, hasher);</span>
<span class="source-line-no">386</span><span id="line.386">    }</span>
<span class="source-line-no">387</span><span id="line.387"></span>
<span class="source-line-no">388</span><span id="line.388">    /**</span>
<span class="source-line-no">389</span><span id="line.389">     * Creates a new hash set copying the elements of an array.</span>
<span class="source-line-no">390</span><span id="line.390">     *</span>
<span class="source-line-no">391</span><span id="line.391">     * @param a an array to be copied into the new hash set.</span>
<span class="source-line-no">392</span><span id="line.392">     * @param f the load factor.</span>
<span class="source-line-no">393</span><span id="line.393">     */</span>
<span class="source-line-no">394</span><span id="line.394">    public OrderedSet(final K[] a, final float f, CrossHash.IHasher hasher) {</span>
<span class="source-line-no">395</span><span id="line.395">        this(a, 0, a.length, f, hasher);</span>
<span class="source-line-no">396</span><span id="line.396">    }</span>
<span class="source-line-no">397</span><span id="line.397"></span>
<span class="source-line-no">398</span><span id="line.398">    /**</span>
<span class="source-line-no">399</span><span id="line.399">     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load</span>
<span class="source-line-no">400</span><span id="line.400">     * factor copying the elements of an array.</span>
<span class="source-line-no">401</span><span id="line.401">     *</span>
<span class="source-line-no">402</span><span id="line.402">     * @param a an array to be copied into the new hash set.</span>
<span class="source-line-no">403</span><span id="line.403">     */</span>
<span class="source-line-no">404</span><span id="line.404">    public OrderedSet(final K[] a, CrossHash.IHasher hasher) {</span>
<span class="source-line-no">405</span><span id="line.405">        this(a, DEFAULT_LOAD_FACTOR, hasher);</span>
<span class="source-line-no">406</span><span id="line.406">    }</span>
<span class="source-line-no">407</span><span id="line.407"></span>
<span class="source-line-no">408</span><span id="line.408">    private int realSize() {</span>
<span class="source-line-no">409</span><span id="line.409">        return containsNull ? size - 1 : size;</span>
<span class="source-line-no">410</span><span id="line.410">    }</span>
<span class="source-line-no">411</span><span id="line.411"></span>
<span class="source-line-no">412</span><span id="line.412">    private void ensureCapacity(final int capacity) {</span>
<span class="source-line-no">413</span><span id="line.413">        final int needed = arraySize(capacity, f);</span>
<span class="source-line-no">414</span><span id="line.414">        if (needed &gt; n)</span>
<span class="source-line-no">415</span><span id="line.415">            rehash(needed);</span>
<span class="source-line-no">416</span><span id="line.416">    }</span>
<span class="source-line-no">417</span><span id="line.417"></span>
<span class="source-line-no">418</span><span id="line.418">    private void tryCapacity(final long capacity) {</span>
<span class="source-line-no">419</span><span id="line.419">        final int needed = (int) Math.min(</span>
<span class="source-line-no">420</span><span id="line.420">                1 &lt;&lt; 30,</span>
<span class="source-line-no">421</span><span id="line.421">                Math.max(2, HashCommon.nextPowerOfTwo((long) Math.ceil(capacity</span>
<span class="source-line-no">422</span><span id="line.422">                        / f))));</span>
<span class="source-line-no">423</span><span id="line.423">        if (needed &gt; n)</span>
<span class="source-line-no">424</span><span id="line.424">            rehash(needed);</span>
<span class="source-line-no">425</span><span id="line.425">    }</span>
<span class="source-line-no">426</span><span id="line.426"></span>
<span class="source-line-no">427</span><span id="line.427">    public boolean addAll(Collection&lt;? extends K&gt; c) {</span>
<span class="source-line-no">428</span><span id="line.428">        int n = c.size();</span>
<span class="source-line-no">429</span><span id="line.429">        // The resulting collection will be at least c.size() big</span>
<span class="source-line-no">430</span><span id="line.430">        if (f &lt;= .5)</span>
<span class="source-line-no">431</span><span id="line.431">            ensureCapacity(n); // The resulting collection will be sized</span>
<span class="source-line-no">432</span><span id="line.432">            // for c.size() elements</span>
<span class="source-line-no">433</span><span id="line.433">        else</span>
<span class="source-line-no">434</span><span id="line.434">            tryCapacity(size() + n); // The resulting collection will be</span>
<span class="source-line-no">435</span><span id="line.435">        // tentatively sized for size() + c.size() elements</span>
<span class="source-line-no">436</span><span id="line.436">        boolean retVal = false;</span>
<span class="source-line-no">437</span><span id="line.437">        final Iterator&lt;? extends K&gt; i = c.iterator();</span>
<span class="source-line-no">438</span><span id="line.438">        while (n-- != 0)</span>
<span class="source-line-no">439</span><span id="line.439">            if (add(i.next()))</span>
<span class="source-line-no">440</span><span id="line.440">                retVal = true;</span>
<span class="source-line-no">441</span><span id="line.441">        return retVal;</span>
<span class="source-line-no">442</span><span id="line.442">    }</span>
<span class="source-line-no">443</span><span id="line.443"></span>
<span class="source-line-no">444</span><span id="line.444">    public boolean addAll(K[] a) {</span>
<span class="source-line-no">445</span><span id="line.445">        if(a == null)</span>
<span class="source-line-no">446</span><span id="line.446">            return false;</span>
<span class="source-line-no">447</span><span id="line.447">        int n = a.length;</span>
<span class="source-line-no">448</span><span id="line.448">        // The resulting collection will be at least a.length big</span>
<span class="source-line-no">449</span><span id="line.449">        if (f &lt;= .5)</span>
<span class="source-line-no">450</span><span id="line.450">            ensureCapacity(n); // The resulting collection will be sized</span>
<span class="source-line-no">451</span><span id="line.451">            // for a.length elements</span>
<span class="source-line-no">452</span><span id="line.452">        else</span>
<span class="source-line-no">453</span><span id="line.453">            tryCapacity(size() + n); // The resulting collection will be</span>
<span class="source-line-no">454</span><span id="line.454">        // tentatively sized for size() + a.length elements</span>
<span class="source-line-no">455</span><span id="line.455">        boolean retVal = false;</span>
<span class="source-line-no">456</span><span id="line.456">        for (int i = 0; i &lt; n; i++) {</span>
<span class="source-line-no">457</span><span id="line.457">            if(add(a[i]))</span>
<span class="source-line-no">458</span><span id="line.458">                retVal = true;</span>
<span class="source-line-no">459</span><span id="line.459">        }</span>
<span class="source-line-no">460</span><span id="line.460">        return retVal;</span>
<span class="source-line-no">461</span><span id="line.461">    }</span>
<span class="source-line-no">462</span><span id="line.462"></span>
<span class="source-line-no">463</span><span id="line.463"></span>
<span class="source-line-no">464</span><span id="line.464">    public boolean add(final K k) {</span>
<span class="source-line-no">465</span><span id="line.465">        int pos;</span>
<span class="source-line-no">466</span><span id="line.466">        if (k == null) {</span>
<span class="source-line-no">467</span><span id="line.467">            if (containsNull)</span>
<span class="source-line-no">468</span><span id="line.468">                return false;</span>
<span class="source-line-no">469</span><span id="line.469">            pos = n;</span>
<span class="source-line-no">470</span><span id="line.470">            containsNull = true;</span>
<span class="source-line-no">471</span><span id="line.471">        } else {</span>
<span class="source-line-no">472</span><span id="line.472">            K curr;</span>
<span class="source-line-no">473</span><span id="line.473">            final K[] key = this.key;</span>
<span class="source-line-no">474</span><span id="line.474">            // The starting point.</span>
<span class="source-line-no">475</span><span id="line.475">            if (!((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)) {</span>
<span class="source-line-no">476</span><span id="line.476">                if (hasher.areEqual(curr, k))</span>
<span class="source-line-no">477</span><span id="line.477">                    return false;</span>
<span class="source-line-no">478</span><span id="line.478">                while (!((curr = key[pos = pos + 1 &amp; mask]) == null))</span>
<span class="source-line-no">479</span><span id="line.479">                    if (hasher.areEqual(curr, k))</span>
<span class="source-line-no">480</span><span id="line.480">                        return false;</span>
<span class="source-line-no">481</span><span id="line.481">            }</span>
<span class="source-line-no">482</span><span id="line.482">            key[pos] = k;</span>
<span class="source-line-no">483</span><span id="line.483">        }</span>
<span class="source-line-no">484</span><span id="line.484">        order.add(pos);</span>
<span class="source-line-no">485</span><span id="line.485">        if (size++ &gt;= maxFill)</span>
<span class="source-line-no">486</span><span id="line.486">            rehash(arraySize(size + 1, f));</span>
<span class="source-line-no">487</span><span id="line.487">        return true;</span>
<span class="source-line-no">488</span><span id="line.488">    }</span>
<span class="source-line-no">489</span><span id="line.489"></span>
<span class="source-line-no">490</span><span id="line.490">    public boolean addAt(final K k, final int idx) {</span>
<span class="source-line-no">491</span><span id="line.491">//        if (idx &lt;= 0)</span>
<span class="source-line-no">492</span><span id="line.492">//            return addAndMoveToFirst(k);</span>
<span class="source-line-no">493</span><span id="line.493">//        else if (idx &gt;= size)</span>
<span class="source-line-no">494</span><span id="line.494">//            return addAndMoveToLast(k);</span>
<span class="source-line-no">495</span><span id="line.495"></span>
<span class="source-line-no">496</span><span id="line.496">        int pos;</span>
<span class="source-line-no">497</span><span id="line.497">        if (k == null) {</span>
<span class="source-line-no">498</span><span id="line.498">            if (containsNull)</span>
<span class="source-line-no">499</span><span id="line.499">                return false;</span>
<span class="source-line-no">500</span><span id="line.500">            pos = n;</span>
<span class="source-line-no">501</span><span id="line.501">            containsNull = true;</span>
<span class="source-line-no">502</span><span id="line.502">        } else {</span>
<span class="source-line-no">503</span><span id="line.503">            K curr;</span>
<span class="source-line-no">504</span><span id="line.504">            final K[] key = this.key;</span>
<span class="source-line-no">505</span><span id="line.505">            // The starting point.</span>
<span class="source-line-no">506</span><span id="line.506">            if (!((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)) {</span>
<span class="source-line-no">507</span><span id="line.507">                if (hasher.areEqual(curr, k))</span>
<span class="source-line-no">508</span><span id="line.508">                    return false;</span>
<span class="source-line-no">509</span><span id="line.509">                while (!((curr = key[pos = pos + 1 &amp; mask]) == null))</span>
<span class="source-line-no">510</span><span id="line.510">                    if (hasher.areEqual(curr, k))</span>
<span class="source-line-no">511</span><span id="line.511">                        return false;</span>
<span class="source-line-no">512</span><span id="line.512">            }</span>
<span class="source-line-no">513</span><span id="line.513">            key[pos] = k;</span>
<span class="source-line-no">514</span><span id="line.514">        }</span>
<span class="source-line-no">515</span><span id="line.515">        order.insert(idx, pos);</span>
<span class="source-line-no">516</span><span id="line.516">        if (size++ &gt;= maxFill)</span>
<span class="source-line-no">517</span><span id="line.517">            rehash(arraySize(size + 1, f));</span>
<span class="source-line-no">518</span><span id="line.518">        return true;</span>
<span class="source-line-no">519</span><span id="line.519">    }</span>
<span class="source-line-no">520</span><span id="line.520"></span>
<span class="source-line-no">521</span><span id="line.521">    /**</span>
<span class="source-line-no">522</span><span id="line.522">     * Add a random element if not present, get the existing value if already</span>
<span class="source-line-no">523</span><span id="line.523">     * present.</span>
<span class="source-line-no">524</span><span id="line.524">     * &lt;p&gt;</span>
<span class="source-line-no">525</span><span id="line.525">     * This is equivalent to (but faster than) doing a:</span>
<span class="source-line-no">526</span><span id="line.526">     * &lt;p&gt;</span>
<span class="source-line-no">527</span><span id="line.527">     * &lt;pre&gt;</span>
<span class="source-line-no">528</span><span id="line.528">     * K exist = set.get(k);</span>
<span class="source-line-no">529</span><span id="line.529">     * if (exist == null) {</span>
<span class="source-line-no">530</span><span id="line.530">     *  set.add(k);</span>
<span class="source-line-no">531</span><span id="line.531">     *  exist = k;</span>
<span class="source-line-no">532</span><span id="line.532">     * }</span>
<span class="source-line-no">533</span><span id="line.533">     * &lt;/pre&gt;</span>
<span class="source-line-no">534</span><span id="line.534">     */</span>
<span class="source-line-no">535</span><span id="line.535">    public K addOrGet(final K k) {</span>
<span class="source-line-no">536</span><span id="line.536">        int pos;</span>
<span class="source-line-no">537</span><span id="line.537">        if (k == null) {</span>
<span class="source-line-no">538</span><span id="line.538">            if (containsNull)</span>
<span class="source-line-no">539</span><span id="line.539">                return key[n];</span>
<span class="source-line-no">540</span><span id="line.540">            pos = n;</span>
<span class="source-line-no">541</span><span id="line.541">            containsNull = true;</span>
<span class="source-line-no">542</span><span id="line.542">        } else {</span>
<span class="source-line-no">543</span><span id="line.543">            K curr;</span>
<span class="source-line-no">544</span><span id="line.544">            final K[] key = this.key;</span>
<span class="source-line-no">545</span><span id="line.545">            // The starting point.</span>
<span class="source-line-no">546</span><span id="line.546">            if (!((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)) {</span>
<span class="source-line-no">547</span><span id="line.547">                if (hasher.areEqual(curr, k))</span>
<span class="source-line-no">548</span><span id="line.548">                    return curr;</span>
<span class="source-line-no">549</span><span id="line.549">                while (!((curr = key[pos = pos + 1 &amp; mask]) == null))</span>
<span class="source-line-no">550</span><span id="line.550">                    if (hasher.areEqual(curr, k))</span>
<span class="source-line-no">551</span><span id="line.551">                        return curr;</span>
<span class="source-line-no">552</span><span id="line.552">            }</span>
<span class="source-line-no">553</span><span id="line.553">            key[pos] = k;</span>
<span class="source-line-no">554</span><span id="line.554">        }</span>
<span class="source-line-no">555</span><span id="line.555">        order.add(pos);</span>
<span class="source-line-no">556</span><span id="line.556">        if (size++ &gt;= maxFill)</span>
<span class="source-line-no">557</span><span id="line.557">            rehash(arraySize(size + 1, f));</span>
<span class="source-line-no">558</span><span id="line.558">        return k;</span>
<span class="source-line-no">559</span><span id="line.559">    }</span>
<span class="source-line-no">560</span><span id="line.560"></span>
<span class="source-line-no">561</span><span id="line.561">    /**</span>
<span class="source-line-no">562</span><span id="line.562">     * Shifts left entries with the specified hash code, starting at the</span>
<span class="source-line-no">563</span><span id="line.563">     * specified position, and empties the resulting free entry.</span>
<span class="source-line-no">564</span><span id="line.564">     *</span>
<span class="source-line-no">565</span><span id="line.565">     * @param pos a starting position.</span>
<span class="source-line-no">566</span><span id="line.566">     */</span>
<span class="source-line-no">567</span><span id="line.567">    protected final void shiftKeys(int pos) {</span>
<span class="source-line-no">568</span><span id="line.568">        // Shift entries with the same hash.</span>
<span class="source-line-no">569</span><span id="line.569">        int last, slot;</span>
<span class="source-line-no">570</span><span id="line.570">        K curr;</span>
<span class="source-line-no">571</span><span id="line.571">        final K[] key = this.key;</span>
<span class="source-line-no">572</span><span id="line.572">        for (; ; ) {</span>
<span class="source-line-no">573</span><span id="line.573">            pos = (last = pos) + 1 &amp; mask;</span>
<span class="source-line-no">574</span><span id="line.574">            for (; ; ) {</span>
<span class="source-line-no">575</span><span id="line.575">                if ((curr = key[pos]) == null) {</span>
<span class="source-line-no">576</span><span id="line.576">                    key[last] = null;</span>
<span class="source-line-no">577</span><span id="line.577">                    return;</span>
<span class="source-line-no">578</span><span id="line.578">                }</span>
<span class="source-line-no">579</span><span id="line.579">                slot = (hasher.hash(curr))</span>
<span class="source-line-no">580</span><span id="line.580">                        &amp; mask;</span>
<span class="source-line-no">581</span><span id="line.581">                if (last &lt;= pos ? last &gt;= slot || slot &gt; pos : last &gt;= slot</span>
<span class="source-line-no">582</span><span id="line.582">                        &amp;&amp; slot &gt; pos)</span>
<span class="source-line-no">583</span><span id="line.583">                    break;</span>
<span class="source-line-no">584</span><span id="line.584">                pos = pos + 1 &amp; mask;</span>
<span class="source-line-no">585</span><span id="line.585">            }</span>
<span class="source-line-no">586</span><span id="line.586">            key[last] = curr;</span>
<span class="source-line-no">587</span><span id="line.587">            fixOrder(pos, last);</span>
<span class="source-line-no">588</span><span id="line.588">        }</span>
<span class="source-line-no">589</span><span id="line.589">    }</span>
<span class="source-line-no">590</span><span id="line.590"></span>
<span class="source-line-no">591</span><span id="line.591">    private boolean removeEntry(final int pos) {</span>
<span class="source-line-no">592</span><span id="line.592">        size--;</span>
<span class="source-line-no">593</span><span id="line.593">        fixOrder(pos);</span>
<span class="source-line-no">594</span><span id="line.594">        shiftKeys(pos);</span>
<span class="source-line-no">595</span><span id="line.595">        if (size &lt; maxFill / 4 &amp;&amp; n &gt; DEFAULT_INITIAL_SIZE)</span>
<span class="source-line-no">596</span><span id="line.596">            rehash(n / 2);</span>
<span class="source-line-no">597</span><span id="line.597">        return true;</span>
<span class="source-line-no">598</span><span id="line.598">    }</span>
<span class="source-line-no">599</span><span id="line.599"></span>
<span class="source-line-no">600</span><span id="line.600">    private boolean removeNullEntry() {</span>
<span class="source-line-no">601</span><span id="line.601">        containsNull = false;</span>
<span class="source-line-no">602</span><span id="line.602">        key[n] = null;</span>
<span class="source-line-no">603</span><span id="line.603">        size--;</span>
<span class="source-line-no">604</span><span id="line.604">        fixOrder(n);</span>
<span class="source-line-no">605</span><span id="line.605">        if (size &lt; maxFill / 4 &amp;&amp; n &gt; DEFAULT_INITIAL_SIZE)</span>
<span class="source-line-no">606</span><span id="line.606">            rehash(n / 2);</span>
<span class="source-line-no">607</span><span id="line.607">        return true;</span>
<span class="source-line-no">608</span><span id="line.608">    }</span>
<span class="source-line-no">609</span><span id="line.609"></span>
<span class="source-line-no">610</span><span id="line.610">    protected boolean rem(final Object k) {</span>
<span class="source-line-no">611</span><span id="line.611">        if (k == null)</span>
<span class="source-line-no">612</span><span id="line.612">            return containsNull &amp;&amp; removeNullEntry();</span>
<span class="source-line-no">613</span><span id="line.613">        K curr;</span>
<span class="source-line-no">614</span><span id="line.614">        final K[] key = this.key;</span>
<span class="source-line-no">615</span><span id="line.615">        int pos;</span>
<span class="source-line-no">616</span><span id="line.616">        // The starting point.</span>
<span class="source-line-no">617</span><span id="line.617">        if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)</span>
<span class="source-line-no">618</span><span id="line.618">            return false;</span>
<span class="source-line-no">619</span><span id="line.619">        if (hasher.areEqual(k, curr))</span>
<span class="source-line-no">620</span><span id="line.620">            return removeEntry(pos);</span>
<span class="source-line-no">621</span><span id="line.621">        while (true) {</span>
<span class="source-line-no">622</span><span id="line.622">            if ((curr = key[pos = pos + 1 &amp; mask]) == null)</span>
<span class="source-line-no">623</span><span id="line.623">                return false;</span>
<span class="source-line-no">624</span><span id="line.624">            if (hasher.areEqual(k, curr))</span>
<span class="source-line-no">625</span><span id="line.625">                return removeEntry(pos);</span>
<span class="source-line-no">626</span><span id="line.626">        }</span>
<span class="source-line-no">627</span><span id="line.627">    }</span>
<span class="source-line-no">628</span><span id="line.628"></span>
<span class="source-line-no">629</span><span id="line.629">    @Override</span>
<span class="source-line-no">630</span><span id="line.630">    public boolean remove(final Object o) {</span>
<span class="source-line-no">631</span><span id="line.631">        return rem(o);</span>
<span class="source-line-no">632</span><span id="line.632">    }</span>
<span class="source-line-no">633</span><span id="line.633"></span>
<span class="source-line-no">634</span><span id="line.634">    /**</span>
<span class="source-line-no">635</span><span id="line.635">     * Removes the first key in iteration order.</span>
<span class="source-line-no">636</span><span id="line.636">     *</span>
<span class="source-line-no">637</span><span id="line.637">     * @return the first key.</span>
<span class="source-line-no">638</span><span id="line.638">     * @throws NoSuchElementException is this set is empty.</span>
<span class="source-line-no">639</span><span id="line.639">     */</span>
<span class="source-line-no">640</span><span id="line.640">    public K removeFirst() {</span>
<span class="source-line-no">641</span><span id="line.641">        if (size == 0)</span>
<span class="source-line-no">642</span><span id="line.642">            throw new NoSuchElementException();</span>
<span class="source-line-no">643</span><span id="line.643">        final int pos = order.removeIndex(0);</span>
<span class="source-line-no">644</span><span id="line.644">        final K k = key[pos];</span>
<span class="source-line-no">645</span><span id="line.645">        size--;</span>
<span class="source-line-no">646</span><span id="line.646">        if (k == null) {</span>
<span class="source-line-no">647</span><span id="line.647">            containsNull = false;</span>
<span class="source-line-no">648</span><span id="line.648">            key[n] = null;</span>
<span class="source-line-no">649</span><span id="line.649">        } else</span>
<span class="source-line-no">650</span><span id="line.650">            shiftKeys(pos);</span>
<span class="source-line-no">651</span><span id="line.651">        if (size &lt; maxFill / 4 &amp;&amp; n &gt; DEFAULT_INITIAL_SIZE)</span>
<span class="source-line-no">652</span><span id="line.652">            rehash(n / 2);</span>
<span class="source-line-no">653</span><span id="line.653">        return k;</span>
<span class="source-line-no">654</span><span id="line.654">    }</span>
<span class="source-line-no">655</span><span id="line.655"></span>
<span class="source-line-no">656</span><span id="line.656">    /**</span>
<span class="source-line-no">657</span><span id="line.657">     * Removes the the last key in iteration order.</span>
<span class="source-line-no">658</span><span id="line.658">     *</span>
<span class="source-line-no">659</span><span id="line.659">     * @return the last key.</span>
<span class="source-line-no">660</span><span id="line.660">     * @throws NoSuchElementException is this set is empty.</span>
<span class="source-line-no">661</span><span id="line.661">     */</span>
<span class="source-line-no">662</span><span id="line.662">    public K removeLast() {</span>
<span class="source-line-no">663</span><span id="line.663">        if (size == 0)</span>
<span class="source-line-no">664</span><span id="line.664">            throw new NoSuchElementException();</span>
<span class="source-line-no">665</span><span id="line.665">        final int pos = order.pop();</span>
<span class="source-line-no">666</span><span id="line.666"></span>
<span class="source-line-no">667</span><span id="line.667">        // Abbreviated version of fixOrder(pos)</span>
<span class="source-line-no">668</span><span id="line.668">        /*</span>
<span class="source-line-no">669</span><span id="line.669">        last = (int) (link[pos] &gt;&gt;&gt; 32);</span>
<span class="source-line-no">670</span><span id="line.670">        if (0 &lt;= last) {</span>
<span class="source-line-no">671</span><span id="line.671">            // Special case of SET_NEXT( link[ last ], -1 )</span>
<span class="source-line-no">672</span><span id="line.672">            link[last] |= -1 &amp; 0xFFFFFFFFL;</span>
<span class="source-line-no">673</span><span id="line.673">        }*/</span>
<span class="source-line-no">674</span><span id="line.674">        final K k = key[pos];</span>
<span class="source-line-no">675</span><span id="line.675">        size--;</span>
<span class="source-line-no">676</span><span id="line.676">        if (k == null) {</span>
<span class="source-line-no">677</span><span id="line.677">            containsNull = false;</span>
<span class="source-line-no">678</span><span id="line.678">            key[n] = null;</span>
<span class="source-line-no">679</span><span id="line.679">        } else</span>
<span class="source-line-no">680</span><span id="line.680">            shiftKeys(pos);</span>
<span class="source-line-no">681</span><span id="line.681">        if (size &lt; maxFill / 4 &amp;&amp; n &gt; DEFAULT_INITIAL_SIZE)</span>
<span class="source-line-no">682</span><span id="line.682">            rehash(n / 2);</span>
<span class="source-line-no">683</span><span id="line.683">        return k;</span>
<span class="source-line-no">684</span><span id="line.684"></span>
<span class="source-line-no">685</span><span id="line.685">    }</span>
<span class="source-line-no">686</span><span id="line.686"></span>
<span class="source-line-no">687</span><span id="line.687">    private void moveIndexToFirst(final int i) {</span>
<span class="source-line-no">688</span><span id="line.688">        if (size &lt;= 1 || order.items[0] == i)</span>
<span class="source-line-no">689</span><span id="line.689">            return;</span>
<span class="source-line-no">690</span><span id="line.690">        order.moveToFirst(i);</span>
<span class="source-line-no">691</span><span id="line.691">    }</span>
<span class="source-line-no">692</span><span id="line.692"></span>
<span class="source-line-no">693</span><span id="line.693">    private void moveIndexToLast(final int i) {</span>
<span class="source-line-no">694</span><span id="line.694">        if (size &lt;= 1 || order.items[order.size-1] == i)</span>
<span class="source-line-no">695</span><span id="line.695">            return;</span>
<span class="source-line-no">696</span><span id="line.696">        order.moveToLast(i);</span>
<span class="source-line-no">697</span><span id="line.697">    }</span>
<span class="source-line-no">698</span><span id="line.698"></span>
<span class="source-line-no">699</span><span id="line.699">    /**</span>
<span class="source-line-no">700</span><span id="line.700">     * Adds a key to the set; if the key is already present, it is moved to the</span>
<span class="source-line-no">701</span><span id="line.701">     * first position of the iteration order.</span>
<span class="source-line-no">702</span><span id="line.702">     *</span>
<span class="source-line-no">703</span><span id="line.703">     * @param k the key.</span>
<span class="source-line-no">704</span><span id="line.704">     * @return true if the key was not present.</span>
<span class="source-line-no">705</span><span id="line.705">     */</span>
<span class="source-line-no">706</span><span id="line.706">    public boolean addAndMoveToFirst(final K k) {</span>
<span class="source-line-no">707</span><span id="line.707">        int pos;</span>
<span class="source-line-no">708</span><span id="line.708">        if (k == null) {</span>
<span class="source-line-no">709</span><span id="line.709">            if (containsNull) {</span>
<span class="source-line-no">710</span><span id="line.710">                moveIndexToFirst(n);</span>
<span class="source-line-no">711</span><span id="line.711">                return false;</span>
<span class="source-line-no">712</span><span id="line.712">            }</span>
<span class="source-line-no">713</span><span id="line.713">            containsNull = true;</span>
<span class="source-line-no">714</span><span id="line.714">            pos = n;</span>
<span class="source-line-no">715</span><span id="line.715">        } else {</span>
<span class="source-line-no">716</span><span id="line.716">            // The starting point.</span>
<span class="source-line-no">717</span><span id="line.717">            final K[] key = this.key;</span>
<span class="source-line-no">718</span><span id="line.718">            pos = (hasher.hash(k)) &amp; mask;</span>
<span class="source-line-no">719</span><span id="line.719">            while (!(key[pos] == null)) {</span>
<span class="source-line-no">720</span><span id="line.720">                if (hasher.areEqual(k, key[pos])) {</span>
<span class="source-line-no">721</span><span id="line.721">                    moveIndexToFirst(pos);</span>
<span class="source-line-no">722</span><span id="line.722">                    return false;</span>
<span class="source-line-no">723</span><span id="line.723">                }</span>
<span class="source-line-no">724</span><span id="line.724">                pos = pos + 1 &amp; mask;</span>
<span class="source-line-no">725</span><span id="line.725">            }</span>
<span class="source-line-no">726</span><span id="line.726">        }</span>
<span class="source-line-no">727</span><span id="line.727">        key[pos] = k;</span>
<span class="source-line-no">728</span><span id="line.728">        order.insert(0, pos);</span>
<span class="source-line-no">729</span><span id="line.729">        if (size++ &gt;= maxFill)</span>
<span class="source-line-no">730</span><span id="line.730">            rehash(arraySize(size, f));</span>
<span class="source-line-no">731</span><span id="line.731">        return true;</span>
<span class="source-line-no">732</span><span id="line.732">    }</span>
<span class="source-line-no">733</span><span id="line.733"></span>
<span class="source-line-no">734</span><span id="line.734">    /**</span>
<span class="source-line-no">735</span><span id="line.735">     * Adds a key to the set; if the key is already present, it is moved to the</span>
<span class="source-line-no">736</span><span id="line.736">     * last position of the iteration order.</span>
<span class="source-line-no">737</span><span id="line.737">     *</span>
<span class="source-line-no">738</span><span id="line.738">     * @param k the key.</span>
<span class="source-line-no">739</span><span id="line.739">     * @return true if the key was not present.</span>
<span class="source-line-no">740</span><span id="line.740">     */</span>
<span class="source-line-no">741</span><span id="line.741">    public boolean addAndMoveToLast(final K k) {</span>
<span class="source-line-no">742</span><span id="line.742">        int pos;</span>
<span class="source-line-no">743</span><span id="line.743">        if (k == null) {</span>
<span class="source-line-no">744</span><span id="line.744">            if (containsNull) {</span>
<span class="source-line-no">745</span><span id="line.745">                moveIndexToLast(n);</span>
<span class="source-line-no">746</span><span id="line.746">                return false;</span>
<span class="source-line-no">747</span><span id="line.747">            }</span>
<span class="source-line-no">748</span><span id="line.748">            containsNull = true;</span>
<span class="source-line-no">749</span><span id="line.749">            pos = n;</span>
<span class="source-line-no">750</span><span id="line.750">        } else {</span>
<span class="source-line-no">751</span><span id="line.751">            // The starting point.</span>
<span class="source-line-no">752</span><span id="line.752">            final K[] key = this.key;</span>
<span class="source-line-no">753</span><span id="line.753">            pos = (hasher.hash(k)) &amp; mask;</span>
<span class="source-line-no">754</span><span id="line.754">            // There's always an unused entry.</span>
<span class="source-line-no">755</span><span id="line.755">            while (!(key[pos] == null)) {</span>
<span class="source-line-no">756</span><span id="line.756">                if (hasher.areEqual(k, key[pos])) {</span>
<span class="source-line-no">757</span><span id="line.757">                    moveIndexToLast(pos);</span>
<span class="source-line-no">758</span><span id="line.758">                    return false;</span>
<span class="source-line-no">759</span><span id="line.759">                }</span>
<span class="source-line-no">760</span><span id="line.760">                pos = pos + 1 &amp; mask;</span>
<span class="source-line-no">761</span><span id="line.761">            }</span>
<span class="source-line-no">762</span><span id="line.762">        }</span>
<span class="source-line-no">763</span><span id="line.763">        key[pos] = k;</span>
<span class="source-line-no">764</span><span id="line.764">        order.add(pos);</span>
<span class="source-line-no">765</span><span id="line.765">        if (size++ &gt;= maxFill)</span>
<span class="source-line-no">766</span><span id="line.766">            rehash(arraySize(size, f));</span>
<span class="source-line-no">767</span><span id="line.767">        return true;</span>
<span class="source-line-no">768</span><span id="line.768">    }</span>
<span class="source-line-no">769</span><span id="line.769"></span>
<span class="source-line-no">770</span><span id="line.770">    /**</span>
<span class="source-line-no">771</span><span id="line.771">     * Returns the element of this set that is equal to the given key, or</span>
<span class="source-line-no">772</span><span id="line.772">     * &lt;code&gt;null&lt;/code&gt;.</span>
<span class="source-line-no">773</span><span id="line.773">     *</span>
<span class="source-line-no">774</span><span id="line.774">     * @return the element of this set that is equal to the given key, or</span>
<span class="source-line-no">775</span><span id="line.775">     * &lt;code&gt;null&lt;/code&gt;.</span>
<span class="source-line-no">776</span><span id="line.776">     */</span>
<span class="source-line-no">777</span><span id="line.777">    public K get(final Object k) {</span>
<span class="source-line-no">778</span><span id="line.778">        if (k == null)</span>
<span class="source-line-no">779</span><span id="line.779">            return key[n]; // This is correct independently of the value of</span>
<span class="source-line-no">780</span><span id="line.780">        // containsNull and of the map being custom</span>
<span class="source-line-no">781</span><span id="line.781">        K curr;</span>
<span class="source-line-no">782</span><span id="line.782">        final K[] key = this.key;</span>
<span class="source-line-no">783</span><span id="line.783">        int pos;</span>
<span class="source-line-no">784</span><span id="line.784">        // The starting point.</span>
<span class="source-line-no">785</span><span id="line.785">        if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)</span>
<span class="source-line-no">786</span><span id="line.786">            return null;</span>
<span class="source-line-no">787</span><span id="line.787">        if (hasher.areEqual(k, curr))</span>
<span class="source-line-no">788</span><span id="line.788">            return curr;</span>
<span class="source-line-no">789</span><span id="line.789">        // There's always an unused entry.</span>
<span class="source-line-no">790</span><span id="line.790">        while (true) {</span>
<span class="source-line-no">791</span><span id="line.791">            if ((curr = key[pos = pos + 1 &amp; mask]) == null)</span>
<span class="source-line-no">792</span><span id="line.792">                return null;</span>
<span class="source-line-no">793</span><span id="line.793">            if (hasher.areEqual(k, curr))</span>
<span class="source-line-no">794</span><span id="line.794">                return curr;</span>
<span class="source-line-no">795</span><span id="line.795">        }</span>
<span class="source-line-no">796</span><span id="line.796">    }</span>
<span class="source-line-no">797</span><span id="line.797"></span>
<span class="source-line-no">798</span><span id="line.798">    public boolean contains(final Object k) {</span>
<span class="source-line-no">799</span><span id="line.799">        if (k == null)</span>
<span class="source-line-no">800</span><span id="line.800">            return containsNull;</span>
<span class="source-line-no">801</span><span id="line.801">        K curr;</span>
<span class="source-line-no">802</span><span id="line.802">        final K[] key = this.key;</span>
<span class="source-line-no">803</span><span id="line.803">        int pos;</span>
<span class="source-line-no">804</span><span id="line.804">        // The starting point.</span>
<span class="source-line-no">805</span><span id="line.805">        if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)</span>
<span class="source-line-no">806</span><span id="line.806">            return false;</span>
<span class="source-line-no">807</span><span id="line.807">        if (hasher.areEqual(k, curr))</span>
<span class="source-line-no">808</span><span id="line.808">            return true;</span>
<span class="source-line-no">809</span><span id="line.809">        // There's always an unused entry.</span>
<span class="source-line-no">810</span><span id="line.810">        while (true) {</span>
<span class="source-line-no">811</span><span id="line.811">            if ((curr = key[pos = pos + 1 &amp; mask]) == null)</span>
<span class="source-line-no">812</span><span id="line.812">                return false;</span>
<span class="source-line-no">813</span><span id="line.813">            if (hasher.areEqual(k, curr))</span>
<span class="source-line-no">814</span><span id="line.814">                return true;</span>
<span class="source-line-no">815</span><span id="line.815">        }</span>
<span class="source-line-no">816</span><span id="line.816">    }</span>
<span class="source-line-no">817</span><span id="line.817"></span>
<span class="source-line-no">818</span><span id="line.818">    protected int positionOf(final Object k) {</span>
<span class="source-line-no">819</span><span id="line.819">        if (k == null)</span>
<span class="source-line-no">820</span><span id="line.820">        {</span>
<span class="source-line-no">821</span><span id="line.821">            if(containsNull)</span>
<span class="source-line-no">822</span><span id="line.822">                return n;</span>
<span class="source-line-no">823</span><span id="line.823">            else</span>
<span class="source-line-no">824</span><span id="line.824">                return -1;</span>
<span class="source-line-no">825</span><span id="line.825">        }</span>
<span class="source-line-no">826</span><span id="line.826">        K curr;</span>
<span class="source-line-no">827</span><span id="line.827">        final K[] key = this.key;</span>
<span class="source-line-no">828</span><span id="line.828">        int pos;</span>
<span class="source-line-no">829</span><span id="line.829">        // The starting point.</span>
<span class="source-line-no">830</span><span id="line.830">        if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)</span>
<span class="source-line-no">831</span><span id="line.831">            return -1;</span>
<span class="source-line-no">832</span><span id="line.832">        if (hasher.areEqual(k, curr))</span>
<span class="source-line-no">833</span><span id="line.833">            return pos;</span>
<span class="source-line-no">834</span><span id="line.834">        // There's always an unused entry.</span>
<span class="source-line-no">835</span><span id="line.835">        while (true) {</span>
<span class="source-line-no">836</span><span id="line.836">            if ((curr = key[pos = pos + 1 &amp; mask]) == null)</span>
<span class="source-line-no">837</span><span id="line.837">                return -1;</span>
<span class="source-line-no">838</span><span id="line.838">            if (hasher.areEqual(k, curr))</span>
<span class="source-line-no">839</span><span id="line.839">                return pos;</span>
<span class="source-line-no">840</span><span id="line.840">        }</span>
<span class="source-line-no">841</span><span id="line.841">    }</span>
<span class="source-line-no">842</span><span id="line.842">    /**</span>
<span class="source-line-no">843</span><span id="line.843">     * Gets the position in the ordering of the given key, though not as efficiently as some data structures can do it</span>
<span class="source-line-no">844</span><span id="line.844">     * (e.g. {@link Arrangement} can access ordering position very quickly but doesn't store other values on its own).</span>
<span class="source-line-no">845</span><span id="line.845">     * Returns a value that is at least 0 if it found k, or -1 if k was not present.</span>
<span class="source-line-no">846</span><span id="line.846">     * @param k a key or possible key that this should find the index of</span>
<span class="source-line-no">847</span><span id="line.847">     * @return the index of k, if present, or -1 if it is not present in this OrderedSet</span>
<span class="source-line-no">848</span><span id="line.848">     */</span>
<span class="source-line-no">849</span><span id="line.849">    public int indexOf(final Object k)</span>
<span class="source-line-no">850</span><span id="line.850">    {</span>
<span class="source-line-no">851</span><span id="line.851">        int pos = positionOf(k);</span>
<span class="source-line-no">852</span><span id="line.852">        return (pos &lt; 0) ? -1 : order.indexOf(pos);</span>
<span class="source-line-no">853</span><span id="line.853">    }</span>
<span class="source-line-no">854</span><span id="line.854"></span>
<span class="source-line-no">855</span><span id="line.855">    /**</span>
<span class="source-line-no">856</span><span id="line.856">     * Swaps the positions in the ordering for the given items, if they are both present. Returns true if the ordering</span>
<span class="source-line-no">857</span><span id="line.857">     * changed as a result of this call, or false if it stayed the same (which can be because left or right was not</span>
<span class="source-line-no">858</span><span id="line.858">     * present, or because left and right are the same reference (so swapping would do nothing)).</span>
<span class="source-line-no">859</span><span id="line.859">     * @param left an item that should be present in this OrderedSet</span>
<span class="source-line-no">860</span><span id="line.860">     * @param right an item that should be present in this OrderedSet</span>
<span class="source-line-no">861</span><span id="line.861">     * @return true if this OrderedSet changed in ordering as a result of this call, or false otherwise</span>
<span class="source-line-no">862</span><span id="line.862">     */</span>
<span class="source-line-no">863</span><span id="line.863">    public boolean swap(final K left, final K right)</span>
<span class="source-line-no">864</span><span id="line.864">    {</span>
<span class="source-line-no">865</span><span id="line.865">        if(left == right) return false;</span>
<span class="source-line-no">866</span><span id="line.866">        int l = indexOf(left);</span>
<span class="source-line-no">867</span><span id="line.867">        if(l &lt; 0) return false;</span>
<span class="source-line-no">868</span><span id="line.868">        int r = indexOf(right);</span>
<span class="source-line-no">869</span><span id="line.869">        if(r &lt; 0) return false;</span>
<span class="source-line-no">870</span><span id="line.870">        order.swap(l, r);</span>
<span class="source-line-no">871</span><span id="line.871">        return true;</span>
<span class="source-line-no">872</span><span id="line.872">    }</span>
<span class="source-line-no">873</span><span id="line.873">    /**</span>
<span class="source-line-no">874</span><span id="line.874">     * Swaps the given indices in the ordering, if they are both ints between 0 and size. Returns true if the ordering</span>
<span class="source-line-no">875</span><span id="line.875">     * changed as a result of this call, or false if it stayed the same (which can be because left or right referred to</span>
<span class="source-line-no">876</span><span id="line.876">     * an out-of-bounds index, or because left and right are equal (so swapping would do nothing)).</span>
<span class="source-line-no">877</span><span id="line.877">     * @param left an index of an item in this OrderedSet, at least 0 and less than {@link #size()}</span>
<span class="source-line-no">878</span><span id="line.878">     * @param right an index of an item in this OrderedSet, at least 0 and less than {@link #size()}</span>
<span class="source-line-no">879</span><span id="line.879">     * @return true if this OrderedSet changed in ordering as a result of this call, or false otherwise</span>
<span class="source-line-no">880</span><span id="line.880">     */</span>
<span class="source-line-no">881</span><span id="line.881">    public boolean swapIndices(final int left, final int right)</span>
<span class="source-line-no">882</span><span id="line.882">    {</span>
<span class="source-line-no">883</span><span id="line.883">        if(left &lt; 0 || right &lt; 0 || left &gt;= order.size || right &gt;= order.size || left == right) return false;</span>
<span class="source-line-no">884</span><span id="line.884">        order.swap(left, right);</span>
<span class="source-line-no">885</span><span id="line.885">        return true;</span>
<span class="source-line-no">886</span><span id="line.886">    }</span>
<span class="source-line-no">887</span><span id="line.887"></span>
<span class="source-line-no">888</span><span id="line.888">    /*</span>
<span class="source-line-no">889</span><span id="line.889">     * Removes all elements from this set.</span>
<span class="source-line-no">890</span><span id="line.890">     *</span>
<span class="source-line-no">891</span><span id="line.891">     * &lt;P&gt;To increase object reuse, this method does not change the table size.</span>
<span class="source-line-no">892</span><span id="line.892">     * If you want to reduce the table size, you must use {@link #trim()}.</span>
<span class="source-line-no">893</span><span id="line.893">     */</span>
<span class="source-line-no">894</span><span id="line.894">    public void clear() {</span>
<span class="source-line-no">895</span><span id="line.895">        if (size == 0)</span>
<span class="source-line-no">896</span><span id="line.896">            return;</span>
<span class="source-line-no">897</span><span id="line.897">        size = 0;</span>
<span class="source-line-no">898</span><span id="line.898">        containsNull = false;</span>
<span class="source-line-no">899</span><span id="line.899">        Arrays.fill(key, null);</span>
<span class="source-line-no">900</span><span id="line.900">        order.clear();</span>
<span class="source-line-no">901</span><span id="line.901">    }</span>
<span class="source-line-no">902</span><span id="line.902"></span>
<span class="source-line-no">903</span><span id="line.903">    public int size() {</span>
<span class="source-line-no">904</span><span id="line.904">        return size;</span>
<span class="source-line-no">905</span><span id="line.905">    }</span>
<span class="source-line-no">906</span><span id="line.906"></span>
<span class="source-line-no">907</span><span id="line.907">    /**</span>
<span class="source-line-no">908</span><span id="line.908">     * Checks whether this collection contains all elements from the given</span>
<span class="source-line-no">909</span><span id="line.909">     * collection.</span>
<span class="source-line-no">910</span><span id="line.910">     *</span>
<span class="source-line-no">911</span><span id="line.911">     * @param c a collection.</span>
<span class="source-line-no">912</span><span id="line.912">     * @return &lt;code&gt;true&lt;/code&gt; if this collection contains all elements of the</span>
<span class="source-line-no">913</span><span id="line.913">     * argument.</span>
<span class="source-line-no">914</span><span id="line.914">     */</span>
<span class="source-line-no">915</span><span id="line.915">    public boolean containsAll(Collection&lt;?&gt; c) {</span>
<span class="source-line-no">916</span><span id="line.916">        int n = c.size();</span>
<span class="source-line-no">917</span><span id="line.917">        final Iterator&lt;?&gt; i = c.iterator();</span>
<span class="source-line-no">918</span><span id="line.918">        while (n-- != 0)</span>
<span class="source-line-no">919</span><span id="line.919">            if (!contains(i.next()))</span>
<span class="source-line-no">920</span><span id="line.920">                return false;</span>
<span class="source-line-no">921</span><span id="line.921">        return true;</span>
<span class="source-line-no">922</span><span id="line.922">    }</span>
<span class="source-line-no">923</span><span id="line.923"></span>
<span class="source-line-no">924</span><span id="line.924">    /**</span>
<span class="source-line-no">925</span><span id="line.925">     * Retains in this collection only elements from the given collection.</span>
<span class="source-line-no">926</span><span id="line.926">     *</span>
<span class="source-line-no">927</span><span id="line.927">     * @param c a collection.</span>
<span class="source-line-no">928</span><span id="line.928">     * @return &lt;code&gt;true&lt;/code&gt; if this collection changed as a result of the</span>
<span class="source-line-no">929</span><span id="line.929">     * call.</span>
<span class="source-line-no">930</span><span id="line.930">     */</span>
<span class="source-line-no">931</span><span id="line.931">    public boolean retainAll(Collection&lt;?&gt; c) {</span>
<span class="source-line-no">932</span><span id="line.932">        boolean retVal = false;</span>
<span class="source-line-no">933</span><span id="line.933">        int n = size();</span>
<span class="source-line-no">934</span><span id="line.934">        final Iterator&lt;?&gt; i = iterator();</span>
<span class="source-line-no">935</span><span id="line.935">        while (n-- != 0) {</span>
<span class="source-line-no">936</span><span id="line.936">            if (!c.contains(i.next())) {</span>
<span class="source-line-no">937</span><span id="line.937">                i.remove();</span>
<span class="source-line-no">938</span><span id="line.938">                retVal = true;</span>
<span class="source-line-no">939</span><span id="line.939">            }</span>
<span class="source-line-no">940</span><span id="line.940">        }</span>
<span class="source-line-no">941</span><span id="line.941">        return retVal;</span>
<span class="source-line-no">942</span><span id="line.942">    }</span>
<span class="source-line-no">943</span><span id="line.943"></span>
<span class="source-line-no">944</span><span id="line.944">    /**</span>
<span class="source-line-no">945</span><span id="line.945">     * Remove from this collection all elements in the given collection. If the</span>
<span class="source-line-no">946</span><span id="line.946">     * collection is an instance of this class, it uses faster iterators.</span>
<span class="source-line-no">947</span><span id="line.947">     *</span>
<span class="source-line-no">948</span><span id="line.948">     * @param c a collection.</span>
<span class="source-line-no">949</span><span id="line.949">     * @return &lt;code&gt;true&lt;/code&gt; if this collection changed as a result of the</span>
<span class="source-line-no">950</span><span id="line.950">     * call.</span>
<span class="source-line-no">951</span><span id="line.951">     */</span>
<span class="source-line-no">952</span><span id="line.952">    public boolean removeAll(Collection&lt;?&gt; c) {</span>
<span class="source-line-no">953</span><span id="line.953">        boolean retVal = false;</span>
<span class="source-line-no">954</span><span id="line.954">        int n = c.size();</span>
<span class="source-line-no">955</span><span id="line.955">        final Iterator&lt;?&gt; i = c.iterator();</span>
<span class="source-line-no">956</span><span id="line.956">        while (n-- != 0)</span>
<span class="source-line-no">957</span><span id="line.957">            if (remove(i.next()))</span>
<span class="source-line-no">958</span><span id="line.958">                retVal = true;</span>
<span class="source-line-no">959</span><span id="line.959">        return retVal;</span>
<span class="source-line-no">960</span><span id="line.960">    }</span>
<span class="source-line-no">961</span><span id="line.961"></span>
<span class="source-line-no">962</span><span id="line.962">    public boolean isEmpty() {</span>
<span class="source-line-no">963</span><span id="line.963">        return size() == 0;</span>
<span class="source-line-no">964</span><span id="line.964">    }</span>
<span class="source-line-no">965</span><span id="line.965"></span>
<span class="source-line-no">966</span><span id="line.966"></span>
<span class="source-line-no">967</span><span id="line.967">    /**</span>
<span class="source-line-no">968</span><span id="line.968">     * Modifies the link vector so that the given entry is removed. This method will complete in linear time.</span>
<span class="source-line-no">969</span><span id="line.969">     *</span>
<span class="source-line-no">970</span><span id="line.970">     * @param i the index of an entry.</span>
<span class="source-line-no">971</span><span id="line.971">     */</span>
<span class="source-line-no">972</span><span id="line.972">    protected int fixOrder(final int i) {</span>
<span class="source-line-no">973</span><span id="line.973">        if (size == 0) {</span>
<span class="source-line-no">974</span><span id="line.974">            order.clear();</span>
<span class="source-line-no">975</span><span id="line.975">            return 0;</span>
<span class="source-line-no">976</span><span id="line.976">        }</span>
<span class="source-line-no">977</span><span id="line.977">        return order.removeValue(i);</span>
<span class="source-line-no">978</span><span id="line.978">    }</span>
<span class="source-line-no">979</span><span id="line.979"></span>
<span class="source-line-no">980</span><span id="line.980">    /**</span>
<span class="source-line-no">981</span><span id="line.981">     * Modifies the ordering for a shift from s to d.</span>
<span class="source-line-no">982</span><span id="line.982">     * &lt;br&gt;</span>
<span class="source-line-no">983</span><span id="line.983">     * This method will complete in linear time or better.</span>
<span class="source-line-no">984</span><span id="line.984">     *</span>
<span class="source-line-no">985</span><span id="line.985">     * @param s the source position.</span>
<span class="source-line-no">986</span><span id="line.986">     * @param d the destination position.</span>
<span class="source-line-no">987</span><span id="line.987">     */</span>
<span class="source-line-no">988</span><span id="line.988">    protected void fixOrder(int s, int d) {</span>
<span class="source-line-no">989</span><span id="line.989">        if(size == 0)</span>
<span class="source-line-no">990</span><span id="line.990">            return;</span>
<span class="source-line-no">991</span><span id="line.991">        if (size == 1 || order.items[0] == s) {</span>
<span class="source-line-no">992</span><span id="line.992">            order.set(0, d);</span>
<span class="source-line-no">993</span><span id="line.993">        } else if (order.items[order.size-1] == s) {</span>
<span class="source-line-no">994</span><span id="line.994">            order.set(order.size - 1, d);</span>
<span class="source-line-no">995</span><span id="line.995">        } else {</span>
<span class="source-line-no">996</span><span id="line.996">            order.set(order.indexOf(s), d);</span>
<span class="source-line-no">997</span><span id="line.997">        }</span>
<span class="source-line-no">998</span><span id="line.998">    }</span>
<span class="source-line-no">999</span><span id="line.999"></span>
<span class="source-line-no">1000</span><span id="line.1000">    /**</span>
<span class="source-line-no">1001</span><span id="line.1001">     * Returns the first element of this set in iteration order.</span>
<span class="source-line-no">1002</span><span id="line.1002">     *</span>
<span class="source-line-no">1003</span><span id="line.1003">     * @return the first element in iteration order.</span>
<span class="source-line-no">1004</span><span id="line.1004">     */</span>
<span class="source-line-no">1005</span><span id="line.1005">    public K first() {</span>
<span class="source-line-no">1006</span><span id="line.1006">        if (size == 0)</span>
<span class="source-line-no">1007</span><span id="line.1007">            throw new NoSuchElementException();</span>
<span class="source-line-no">1008</span><span id="line.1008">        return key[order.items[0]];</span>
<span class="source-line-no">1009</span><span id="line.1009">    }</span>
<span class="source-line-no">1010</span><span id="line.1010"></span>
<span class="source-line-no">1011</span><span id="line.1011">    /**</span>
<span class="source-line-no">1012</span><span id="line.1012">     * Returns the last element of this set in iteration order.</span>
<span class="source-line-no">1013</span><span id="line.1013">     *</span>
<span class="source-line-no">1014</span><span id="line.1014">     * @return the last element in iteration order.</span>
<span class="source-line-no">1015</span><span id="line.1015">     */</span>
<span class="source-line-no">1016</span><span id="line.1016">    public K last() {</span>
<span class="source-line-no">1017</span><span id="line.1017">        if (size == 0)</span>
<span class="source-line-no">1018</span><span id="line.1018">            throw new NoSuchElementException();</span>
<span class="source-line-no">1019</span><span id="line.1019">        return key[order.items[order.size-1]];</span>
<span class="source-line-no">1020</span><span id="line.1020">    }</span>
<span class="source-line-no">1021</span><span id="line.1021"></span>
<span class="source-line-no">1022</span><span id="line.1022">    public SortedSet&lt;K&gt; tailSet(K from) {</span>
<span class="source-line-no">1023</span><span id="line.1023">        throw new UnsupportedOperationException();</span>
<span class="source-line-no">1024</span><span id="line.1024">    }</span>
<span class="source-line-no">1025</span><span id="line.1025"></span>
<span class="source-line-no">1026</span><span id="line.1026">    public SortedSet&lt;K&gt; headSet(K to) {</span>
<span class="source-line-no">1027</span><span id="line.1027">        throw new UnsupportedOperationException();</span>
<span class="source-line-no">1028</span><span id="line.1028">    }</span>
<span class="source-line-no">1029</span><span id="line.1029"></span>
<span class="source-line-no">1030</span><span id="line.1030">    public SortedSet&lt;K&gt; subSet(K from, K to) {</span>
<span class="source-line-no">1031</span><span id="line.1031">        throw new UnsupportedOperationException();</span>
<span class="source-line-no">1032</span><span id="line.1032">    }</span>
<span class="source-line-no">1033</span><span id="line.1033"></span>
<span class="source-line-no">1034</span><span id="line.1034">    public Comparator&lt;? super K&gt; comparator() {</span>
<span class="source-line-no">1035</span><span id="line.1035">        return null;</span>
<span class="source-line-no">1036</span><span id="line.1036">    }</span>
<span class="source-line-no">1037</span><span id="line.1037"></span>
<span class="source-line-no">1038</span><span id="line.1038">    /**</span>
<span class="source-line-no">1039</span><span id="line.1039">     * A list iterator over a linked set.</span>
<span class="source-line-no">1040</span><span id="line.1040">     * &lt;p&gt;</span>
<span class="source-line-no">1041</span><span id="line.1041">     * &lt;p&gt;</span>
<span class="source-line-no">1042</span><span id="line.1042">     * This class provides a list iterator over a linked hash set. The</span>
<span class="source-line-no">1043</span><span id="line.1043">     * constructor runs in constant time.</span>
<span class="source-line-no">1044</span><span id="line.1044">     */</span>
<span class="source-line-no">1045</span><span id="line.1045">    private class SetIterator implements ListIterator&lt;K&gt; {</span>
<span class="source-line-no">1046</span><span id="line.1046">        /**</span>
<span class="source-line-no">1047</span><span id="line.1047">         * The entry that will be returned by the next call to</span>
<span class="source-line-no">1048</span><span id="line.1048">         * {@link java.util.ListIterator#previous()} (or &lt;code&gt;null&lt;/code&gt; if no</span>
<span class="source-line-no">1049</span><span id="line.1049">         * previous entry exists).</span>
<span class="source-line-no">1050</span><span id="line.1050">         */</span>
<span class="source-line-no">1051</span><span id="line.1051">        int prev = -1;</span>
<span class="source-line-no">1052</span><span id="line.1052">        /**</span>
<span class="source-line-no">1053</span><span id="line.1053">         * The entry that will be returned by the next call to</span>
<span class="source-line-no">1054</span><span id="line.1054">         * {@link java.util.ListIterator#next()} (or &lt;code&gt;null&lt;/code&gt; if no</span>
<span class="source-line-no">1055</span><span id="line.1055">         * next entry exists).</span>
<span class="source-line-no">1056</span><span id="line.1056">         */</span>
<span class="source-line-no">1057</span><span id="line.1057">        int next;</span>
<span class="source-line-no">1058</span><span id="line.1058">        /**</span>
<span class="source-line-no">1059</span><span id="line.1059">         * The last entry that was returned (or -1 if we did not iterate or used</span>
<span class="source-line-no">1060</span><span id="line.1060">         * {@link #remove()}).</span>
<span class="source-line-no">1061</span><span id="line.1061">         */</span>
<span class="source-line-no">1062</span><span id="line.1062">        int curr = -1;</span>
<span class="source-line-no">1063</span><span id="line.1063">        /**</span>
<span class="source-line-no">1064</span><span id="line.1064">         * The current index (in the sense of a {@link java.util.ListIterator}).</span>
<span class="source-line-no">1065</span><span id="line.1065">         * When -1, we do not know the current index.</span>
<span class="source-line-no">1066</span><span id="line.1066">         */</span>
<span class="source-line-no">1067</span><span id="line.1067">        int index;</span>
<span class="source-line-no">1068</span><span id="line.1068"></span>
<span class="source-line-no">1069</span><span id="line.1069">        SetIterator() {</span>
<span class="source-line-no">1070</span><span id="line.1070">            next = size == 0 ? -1 : order.items[0];</span>
<span class="source-line-no">1071</span><span id="line.1071">            index = 0;</span>
<span class="source-line-no">1072</span><span id="line.1072">        }</span>
<span class="source-line-no">1073</span><span id="line.1073"></span>
<span class="source-line-no">1074</span><span id="line.1074">        public boolean hasNext() {</span>
<span class="source-line-no">1075</span><span id="line.1075">            return next != -1;</span>
<span class="source-line-no">1076</span><span id="line.1076">        }</span>
<span class="source-line-no">1077</span><span id="line.1077"></span>
<span class="source-line-no">1078</span><span id="line.1078">        public boolean hasPrevious() {</span>
<span class="source-line-no">1079</span><span id="line.1079">            return prev != -1;</span>
<span class="source-line-no">1080</span><span id="line.1080">        }</span>
<span class="source-line-no">1081</span><span id="line.1081"></span>
<span class="source-line-no">1082</span><span id="line.1082">        public K next() {</span>
<span class="source-line-no">1083</span><span id="line.1083">            if (!hasNext())</span>
<span class="source-line-no">1084</span><span id="line.1084">                throw new NoSuchElementException();</span>
<span class="source-line-no">1085</span><span id="line.1085">            curr = next;</span>
<span class="source-line-no">1086</span><span id="line.1086">            if (++index &gt;= order.size)</span>
<span class="source-line-no">1087</span><span id="line.1087">                next = -1;</span>
<span class="source-line-no">1088</span><span id="line.1088">            else</span>
<span class="source-line-no">1089</span><span id="line.1089">                next = order.get(index);//(int) link[curr];</span>
<span class="source-line-no">1090</span><span id="line.1090">            prev = curr;</span>
<span class="source-line-no">1091</span><span id="line.1091">            return key[curr];</span>
<span class="source-line-no">1092</span><span id="line.1092">        }</span>
<span class="source-line-no">1093</span><span id="line.1093"></span>
<span class="source-line-no">1094</span><span id="line.1094">        public K previous() {</span>
<span class="source-line-no">1095</span><span id="line.1095">            if (!hasPrevious())</span>
<span class="source-line-no">1096</span><span id="line.1096">                throw new NoSuchElementException();</span>
<span class="source-line-no">1097</span><span id="line.1097">            curr = prev;</span>
<span class="source-line-no">1098</span><span id="line.1098">            if (--index &lt; 1)</span>
<span class="source-line-no">1099</span><span id="line.1099">                prev = -1;</span>
<span class="source-line-no">1100</span><span id="line.1100">            else</span>
<span class="source-line-no">1101</span><span id="line.1101">                prev = order.get(index - 1);</span>
<span class="source-line-no">1102</span><span id="line.1102">            next = curr;</span>
<span class="source-line-no">1103</span><span id="line.1103">            return key[curr];</span>
<span class="source-line-no">1104</span><span id="line.1104">        }</span>
<span class="source-line-no">1105</span><span id="line.1105"></span>
<span class="source-line-no">1106</span><span id="line.1106">        private void ensureIndexKnown() {</span>
<span class="source-line-no">1107</span><span id="line.1107">            if (index &gt;= 0)</span>
<span class="source-line-no">1108</span><span id="line.1108">                return;</span>
<span class="source-line-no">1109</span><span id="line.1109">            if (prev == -1) {</span>
<span class="source-line-no">1110</span><span id="line.1110">                index = 0;</span>
<span class="source-line-no">1111</span><span id="line.1111">                return;</span>
<span class="source-line-no">1112</span><span id="line.1112">            }</span>
<span class="source-line-no">1113</span><span id="line.1113">            if (next == -1) {</span>
<span class="source-line-no">1114</span><span id="line.1114">                index = size;</span>
<span class="source-line-no">1115</span><span id="line.1115">                return;</span>
<span class="source-line-no">1116</span><span id="line.1116">            }</span>
<span class="source-line-no">1117</span><span id="line.1117">            index = 0;</span>
<span class="source-line-no">1118</span><span id="line.1118">        }</span>
<span class="source-line-no">1119</span><span id="line.1119"></span>
<span class="source-line-no">1120</span><span id="line.1120">        public int nextIndex() {</span>
<span class="source-line-no">1121</span><span id="line.1121">            ensureIndexKnown();</span>
<span class="source-line-no">1122</span><span id="line.1122">            return index + 1;</span>
<span class="source-line-no">1123</span><span id="line.1123">        }</span>
<span class="source-line-no">1124</span><span id="line.1124"></span>
<span class="source-line-no">1125</span><span id="line.1125">        public int previousIndex() {</span>
<span class="source-line-no">1126</span><span id="line.1126">            ensureIndexKnown();</span>
<span class="source-line-no">1127</span><span id="line.1127">            return index - 1;</span>
<span class="source-line-no">1128</span><span id="line.1128">        }</span>
<span class="source-line-no">1129</span><span id="line.1129"></span>
<span class="source-line-no">1130</span><span id="line.1130">        public void remove() {</span>
<span class="source-line-no">1131</span><span id="line.1131">            ensureIndexKnown();</span>
<span class="source-line-no">1132</span><span id="line.1132">            if (curr == -1)</span>
<span class="source-line-no">1133</span><span id="line.1133">                throw new IllegalStateException();</span>
<span class="source-line-no">1134</span><span id="line.1134">            if (curr == prev) {</span>
<span class="source-line-no">1135</span><span id="line.1135">                /*</span>
<span class="source-line-no">1136</span><span id="line.1136">                 * If the last operation was a next(), we are removing an entry</span>
<span class="source-line-no">1137</span><span id="line.1137">                                 * that precedes the current index, and thus we must decrement</span>
<span class="source-line-no">1138</span><span id="line.1138">                                 * it.</span>
<span class="source-line-no">1139</span><span id="line.1139">                                 */</span>
<span class="source-line-no">1140</span><span id="line.1140">                if (--index &gt;= 1)</span>
<span class="source-line-no">1141</span><span id="line.1141">                    prev = order.get(index - 1); //(int) (link[curr] &gt;&gt;&gt; 32);</span>
<span class="source-line-no">1142</span><span id="line.1142">                else</span>
<span class="source-line-no">1143</span><span id="line.1143">                    prev = -1;</span>
<span class="source-line-no">1144</span><span id="line.1144">            } else {</span>
<span class="source-line-no">1145</span><span id="line.1145">                if (index &lt; order.size - 1)</span>
<span class="source-line-no">1146</span><span id="line.1146">                    next = order.get(index + 1);</span>
<span class="source-line-no">1147</span><span id="line.1147">                else</span>
<span class="source-line-no">1148</span><span id="line.1148">                    next = -1;</span>
<span class="source-line-no">1149</span><span id="line.1149">            }</span>
<span class="source-line-no">1150</span><span id="line.1150">            order.removeIndex(index);</span>
<span class="source-line-no">1151</span><span id="line.1151">            size--;</span>
<span class="source-line-no">1152</span><span id="line.1152">            int last, slot, pos = curr;</span>
<span class="source-line-no">1153</span><span id="line.1153">            curr = -1;</span>
<span class="source-line-no">1154</span><span id="line.1154">            if (pos == n) {</span>
<span class="source-line-no">1155</span><span id="line.1155">                containsNull = false;</span>
<span class="source-line-no">1156</span><span id="line.1156">                key[n] = null;</span>
<span class="source-line-no">1157</span><span id="line.1157">                //order.removeValue(pos);</span>
<span class="source-line-no">1158</span><span id="line.1158">            } else {</span>
<span class="source-line-no">1159</span><span id="line.1159">                K curr;</span>
<span class="source-line-no">1160</span><span id="line.1160">                final K[] key = OrderedSet.this.key;</span>
<span class="source-line-no">1161</span><span id="line.1161">                // We have to horribly duplicate the shiftKeys() code because we</span>
<span class="source-line-no">1162</span><span id="line.1162">                // need to update next/prev.</span>
<span class="source-line-no">1163</span><span id="line.1163">                for (; ; ) {</span>
<span class="source-line-no">1164</span><span id="line.1164">                    pos = (last = pos) + 1 &amp; mask;</span>
<span class="source-line-no">1165</span><span id="line.1165">                    for (; ; ) {</span>
<span class="source-line-no">1166</span><span id="line.1166">                        if ((curr = key[pos]) == null) {</span>
<span class="source-line-no">1167</span><span id="line.1167">                            key[last] = null;</span>
<span class="source-line-no">1168</span><span id="line.1168">                            return;</span>
<span class="source-line-no">1169</span><span id="line.1169">                        }</span>
<span class="source-line-no">1170</span><span id="line.1170">                        slot = (hasher.hash(curr)) &amp; mask;</span>
<span class="source-line-no">1171</span><span id="line.1171">                        if (last &lt;= pos</span>
<span class="source-line-no">1172</span><span id="line.1172">                                ? last &gt;= slot || slot &gt; pos</span>
<span class="source-line-no">1173</span><span id="line.1173">                                : last &gt;= slot &amp;&amp; slot &gt; pos)</span>
<span class="source-line-no">1174</span><span id="line.1174">                            break;</span>
<span class="source-line-no">1175</span><span id="line.1175">                        pos = pos + 1 &amp; mask;</span>
<span class="source-line-no">1176</span><span id="line.1176">                    }</span>
<span class="source-line-no">1177</span><span id="line.1177">                    key[last] = curr;</span>
<span class="source-line-no">1178</span><span id="line.1178">                    if (next == pos)</span>
<span class="source-line-no">1179</span><span id="line.1179">                        next = last;</span>
<span class="source-line-no">1180</span><span id="line.1180">                    if (prev == pos)</span>
<span class="source-line-no">1181</span><span id="line.1181">                        prev = last;</span>
<span class="source-line-no">1182</span><span id="line.1182">                    fixOrder(pos, last);</span>
<span class="source-line-no">1183</span><span id="line.1183">                }</span>
<span class="source-line-no">1184</span><span id="line.1184">            }</span>
<span class="source-line-no">1185</span><span id="line.1185"></span>
<span class="source-line-no">1186</span><span id="line.1186">        }</span>
<span class="source-line-no">1187</span><span id="line.1187"></span>
<span class="source-line-no">1188</span><span id="line.1188">        /**</span>
<span class="source-line-no">1189</span><span id="line.1189">         * Replaces the last element returned by {@link #next} or</span>
<span class="source-line-no">1190</span><span id="line.1190">         * {@link #previous} with the specified element (optional operation).</span>
<span class="source-line-no">1191</span><span id="line.1191">         * This call can be made only if neither {@link #remove} nor {@link</span>
<span class="source-line-no">1192</span><span id="line.1192">         * #add} have been called after the last call to {@code next} or</span>
<span class="source-line-no">1193</span><span id="line.1193">         * {@code previous}.</span>
<span class="source-line-no">1194</span><span id="line.1194">         *</span>
<span class="source-line-no">1195</span><span id="line.1195">         * @param k the element with which to replace the last element returned by</span>
<span class="source-line-no">1196</span><span id="line.1196">         *          {@code next} or {@code previous}</span>
<span class="source-line-no">1197</span><span id="line.1197">         * @throws UnsupportedOperationException if the {@code set} operation</span>
<span class="source-line-no">1198</span><span id="line.1198">         *                                       is not supported by this list iterator</span>
<span class="source-line-no">1199</span><span id="line.1199">         * @throws ClassCastException            if the class of the specified element</span>
<span class="source-line-no">1200</span><span id="line.1200">         *                                       prevents it from being added to this list</span>
<span class="source-line-no">1201</span><span id="line.1201">         * @throws IllegalArgumentException      if some aspect of the specified</span>
<span class="source-line-no">1202</span><span id="line.1202">         *                                       element prevents it from being added to this list</span>
<span class="source-line-no">1203</span><span id="line.1203">         * @throws IllegalStateException         if neither {@code next} nor</span>
<span class="source-line-no">1204</span><span id="line.1204">         *                                       {@code previous} have been called, or {@code remove} or</span>
<span class="source-line-no">1205</span><span id="line.1205">         *                                       {@code add} have been called after the last call to</span>
<span class="source-line-no">1206</span><span id="line.1206">         *                                       {@code next} or {@code previous}</span>
<span class="source-line-no">1207</span><span id="line.1207">         */</span>
<span class="source-line-no">1208</span><span id="line.1208">        @Override</span>
<span class="source-line-no">1209</span><span id="line.1209">        public void set(K k) {</span>
<span class="source-line-no">1210</span><span id="line.1210">            throw new UnsupportedOperationException("set() not supported on OrderedSet iterator");</span>
<span class="source-line-no">1211</span><span id="line.1211">        }</span>
<span class="source-line-no">1212</span><span id="line.1212"></span>
<span class="source-line-no">1213</span><span id="line.1213">        /**</span>
<span class="source-line-no">1214</span><span id="line.1214">         * Inserts the specified element into the list (optional operation).</span>
<span class="source-line-no">1215</span><span id="line.1215">         * The element is inserted immediately before the element that</span>
<span class="source-line-no">1216</span><span id="line.1216">         * would be returned by {@link #next}, if any, and after the element</span>
<span class="source-line-no">1217</span><span id="line.1217">         * that would be returned by {@link #previous}, if any.  (If the</span>
<span class="source-line-no">1218</span><span id="line.1218">         * list contains no elements, the new element becomes the sole element</span>
<span class="source-line-no">1219</span><span id="line.1219">         * on the list.)  The new element is inserted before the implicit</span>
<span class="source-line-no">1220</span><span id="line.1220">         * cursor: a subsequent call to {@code next} would be unaffected, and a</span>
<span class="source-line-no">1221</span><span id="line.1221">         * subsequent call to {@code previous} would return the new element.</span>
<span class="source-line-no">1222</span><span id="line.1222">         * (This call increases by one the value that would be returned by a</span>
<span class="source-line-no">1223</span><span id="line.1223">         * call to {@code nextIndex} or {@code previousIndex}.)</span>
<span class="source-line-no">1224</span><span id="line.1224">         *</span>
<span class="source-line-no">1225</span><span id="line.1225">         * @param k the element to insert</span>
<span class="source-line-no">1226</span><span id="line.1226">         * @throws UnsupportedOperationException if the {@code add} method is</span>
<span class="source-line-no">1227</span><span id="line.1227">         *                                       not supported by this list iterator</span>
<span class="source-line-no">1228</span><span id="line.1228">         * @throws ClassCastException            if the class of the specified element</span>
<span class="source-line-no">1229</span><span id="line.1229">         *                                       prevents it from being added to this list</span>
<span class="source-line-no">1230</span><span id="line.1230">         * @throws IllegalArgumentException      if some aspect of this element</span>
<span class="source-line-no">1231</span><span id="line.1231">         *                                       prevents it from being added to this list</span>
<span class="source-line-no">1232</span><span id="line.1232">         */</span>
<span class="source-line-no">1233</span><span id="line.1233">        @Override</span>
<span class="source-line-no">1234</span><span id="line.1234">        public void add(K k) {</span>
<span class="source-line-no">1235</span><span id="line.1235">            throw new UnsupportedOperationException("add() not supported on OrderedSet iterator");</span>
<span class="source-line-no">1236</span><span id="line.1236">        }</span>
<span class="source-line-no">1237</span><span id="line.1237">    }</span>
<span class="source-line-no">1238</span><span id="line.1238"></span>
<span class="source-line-no">1239</span><span id="line.1239">    public ListIterator&lt;K&gt; iterator() {</span>
<span class="source-line-no">1240</span><span id="line.1240">        return new SetIterator();</span>
<span class="source-line-no">1241</span><span id="line.1241">    }</span>
<span class="source-line-no">1242</span><span id="line.1242"></span>
<span class="source-line-no">1243</span><span id="line.1243">    /**</span>
<span class="source-line-no">1244</span><span id="line.1244">     * Rehashes the map, making the table as small as possible.</span>
<span class="source-line-no">1245</span><span id="line.1245">     * &lt;p&gt;</span>
<span class="source-line-no">1246</span><span id="line.1246">     * &lt;P&gt;This method rehashes the table to the smallest size satisfying the load factor. It can be used when the set will not be changed anymore, so to optimize access speed and size.</span>
<span class="source-line-no">1247</span><span id="line.1247">     * &lt;p&gt;</span>
<span class="source-line-no">1248</span><span id="line.1248">     * &lt;P&gt;If the table size is already the minimum possible, this method does nothing.</span>
<span class="source-line-no">1249</span><span id="line.1249">     *</span>
<span class="source-line-no">1250</span><span id="line.1250">     * @return true if there was enough memory to trim the map.</span>
<span class="source-line-no">1251</span><span id="line.1251">     * @see #trim(int)</span>
<span class="source-line-no">1252</span><span id="line.1252">     */</span>
<span class="source-line-no">1253</span><span id="line.1253">    public boolean trim() {</span>
<span class="source-line-no">1254</span><span id="line.1254">        final int l = arraySize(size, f);</span>
<span class="source-line-no">1255</span><span id="line.1255">        if (l &gt;= n || size &gt; maxFill(l, f)) return true;</span>
<span class="source-line-no">1256</span><span id="line.1256">        try {</span>
<span class="source-line-no">1257</span><span id="line.1257">            rehash(l);</span>
<span class="source-line-no">1258</span><span id="line.1258">        } catch (Exception cantDoIt) {</span>
<span class="source-line-no">1259</span><span id="line.1259">            return false;</span>
<span class="source-line-no">1260</span><span id="line.1260">        }</span>
<span class="source-line-no">1261</span><span id="line.1261">        return true;</span>
<span class="source-line-no">1262</span><span id="line.1262">    }</span>
<span class="source-line-no">1263</span><span id="line.1263"></span>
<span class="source-line-no">1264</span><span id="line.1264">    /**</span>
<span class="source-line-no">1265</span><span id="line.1265">     * Rehashes this map if the table is too large.</span>
<span class="source-line-no">1266</span><span id="line.1266">     * &lt;p&gt;</span>
<span class="source-line-no">1267</span><span id="line.1267">     * &lt;P&gt;Let &lt;var&gt;N&lt;/var&gt; be the smallest table size that can hold &lt;code&gt;max(n,{@link #size()})&lt;/code&gt; entries, still satisfying the load factor. If the current table size is smaller than or equal to</span>
<span class="source-line-no">1268</span><span id="line.1268">     * &lt;var&gt;N&lt;/var&gt;, this method does nothing. Otherwise, it rehashes this map in a table of size &lt;var&gt;N&lt;/var&gt;.</span>
<span class="source-line-no">1269</span><span id="line.1269">     * &lt;p&gt;</span>
<span class="source-line-no">1270</span><span id="line.1270">     * &lt;P&gt;This method is useful when reusing maps. {@linkplain #clear() Clearing a map} leaves the table size untouched. If you are reusing a map many times, you can call this method with a typical</span>
<span class="source-line-no">1271</span><span id="line.1271">     * size to avoid keeping around a very large table just because of a few large transient maps.</span>
<span class="source-line-no">1272</span><span id="line.1272">     *</span>
<span class="source-line-no">1273</span><span id="line.1273">     * @param n the threshold for the trimming.</span>
<span class="source-line-no">1274</span><span id="line.1274">     * @return true if there was enough memory to trim the map.</span>
<span class="source-line-no">1275</span><span id="line.1275">     * @see #trim()</span>
<span class="source-line-no">1276</span><span id="line.1276">     */</span>
<span class="source-line-no">1277</span><span id="line.1277">    public boolean trim(final int n) {</span>
<span class="source-line-no">1278</span><span id="line.1278">        final int l = HashCommon.nextPowerOfTwo((int) Math.ceil(n / f));</span>
<span class="source-line-no">1279</span><span id="line.1279">        if (l &gt;= n || size &gt; maxFill(l, f)) return true;</span>
<span class="source-line-no">1280</span><span id="line.1280">        try {</span>
<span class="source-line-no">1281</span><span id="line.1281">            rehash(l);</span>
<span class="source-line-no">1282</span><span id="line.1282">        } catch (Exception cantDoIt) {</span>
<span class="source-line-no">1283</span><span id="line.1283">            return false;</span>
<span class="source-line-no">1284</span><span id="line.1284">        }</span>
<span class="source-line-no">1285</span><span id="line.1285">        return true;</span>
<span class="source-line-no">1286</span><span id="line.1286">    }</span>
<span class="source-line-no">1287</span><span id="line.1287"></span>
<span class="source-line-no">1288</span><span id="line.1288">    /**</span>
<span class="source-line-no">1289</span><span id="line.1289">     * Rehashes the map.</span>
<span class="source-line-no">1290</span><span id="line.1290">     * &lt;p&gt;</span>
<span class="source-line-no">1291</span><span id="line.1291">     * &lt;p&gt;</span>
<span class="source-line-no">1292</span><span id="line.1292">     * This method implements the basic rehashing strategy, and may be overriden</span>
<span class="source-line-no">1293</span><span id="line.1293">     * by subclasses implementing different rehashing strategies (e.g.,</span>
<span class="source-line-no">1294</span><span id="line.1294">     * disk-based rehashing). However, you should not override this method</span>
<span class="source-line-no">1295</span><span id="line.1295">     * unless you understand the internal workings of this class.</span>
<span class="source-line-no">1296</span><span id="line.1296">     *</span>
<span class="source-line-no">1297</span><span id="line.1297">     * @param newN the new size</span>
<span class="source-line-no">1298</span><span id="line.1298">     */</span>
<span class="source-line-no">1299</span><span id="line.1299"></span>
<span class="source-line-no">1300</span><span id="line.1300">    @SuppressWarnings("unchecked")</span>
<span class="source-line-no">1301</span><span id="line.1301">    protected void rehash(final int newN) {</span>
<span class="source-line-no">1302</span><span id="line.1302">        final K[] key = this.key;</span>
<span class="source-line-no">1303</span><span id="line.1303">        final int mask = newN - 1; // Note that this is used by the hashing</span>
<span class="source-line-no">1304</span><span id="line.1304">        // macro</span>
<span class="source-line-no">1305</span><span id="line.1305">        final K[] newKey = (K[]) new Object[newN + 1];</span>
<span class="source-line-no">1306</span><span id="line.1306">        K k;</span>
<span class="source-line-no">1307</span><span id="line.1307">        int i, pos, sz = order.size;</span>
<span class="source-line-no">1308</span><span id="line.1308">        final int[] oi = order.items;</span>
<span class="source-line-no">1309</span><span id="line.1309">        for (int q = 0; q &lt; sz; q++) {</span>
<span class="source-line-no">1310</span><span id="line.1310">            i = oi[q];</span>
<span class="source-line-no">1311</span><span id="line.1311">            if ((k = key[i]) == null)</span>
<span class="source-line-no">1312</span><span id="line.1312">                pos = newN;</span>
<span class="source-line-no">1313</span><span id="line.1313">            else {</span>
<span class="source-line-no">1314</span><span id="line.1314">                pos = (hasher.hash(k)) &amp; mask;</span>
<span class="source-line-no">1315</span><span id="line.1315">                while (!(newKey[pos] == null))</span>
<span class="source-line-no">1316</span><span id="line.1316">                    pos = pos + 1 &amp; mask;</span>
<span class="source-line-no">1317</span><span id="line.1317">            }</span>
<span class="source-line-no">1318</span><span id="line.1318">            newKey[pos] = k;</span>
<span class="source-line-no">1319</span><span id="line.1319">            oi[q] = pos;</span>
<span class="source-line-no">1320</span><span id="line.1320">        }</span>
<span class="source-line-no">1321</span><span id="line.1321">        n = newN;</span>
<span class="source-line-no">1322</span><span id="line.1322">        this.mask = mask;</span>
<span class="source-line-no">1323</span><span id="line.1323">        maxFill = maxFill(n, f);</span>
<span class="source-line-no">1324</span><span id="line.1324">        this.key = newKey;</span>
<span class="source-line-no">1325</span><span id="line.1325">    }</span>
<span class="source-line-no">1326</span><span id="line.1326">    /*</span>
<span class="source-line-no">1327</span><span id="line.1327">    @SuppressWarnings("unchecked")</span>
<span class="source-line-no">1328</span><span id="line.1328">    protected void rehash(final int newN) {</span>
<span class="source-line-no">1329</span><span id="line.1329">        final K key[] = this.key;</span>
<span class="source-line-no">1330</span><span id="line.1330">        final V value[] = this.value;</span>
<span class="source-line-no">1331</span><span id="line.1331">        final int mask = newN - 1; // Note that this is used by the hashing</span>
<span class="source-line-no">1332</span><span id="line.1332">        // macro</span>
<span class="source-line-no">1333</span><span id="line.1333">        final K newKey[] = (K[]) new Object[newN + 1];</span>
<span class="source-line-no">1334</span><span id="line.1334">        final V newValue[] = (V[]) new Object[newN + 1];</span>
<span class="source-line-no">1335</span><span id="line.1335">        int i = first, prev = -1, newPrev = -1, t, pos;</span>
<span class="source-line-no">1336</span><span id="line.1336">        final long link[] = this.link;</span>
<span class="source-line-no">1337</span><span id="line.1337">        final long newLink[] = new long[newN + 1];</span>
<span class="source-line-no">1338</span><span id="line.1338">        first = -1;</span>
<span class="source-line-no">1339</span><span id="line.1339">        for (int j = size; j-- != 0;) {</span>
<span class="source-line-no">1340</span><span id="line.1340">            if (((key[i]) == null))</span>
<span class="source-line-no">1341</span><span id="line.1341">                pos = newN;</span>
<span class="source-line-no">1342</span><span id="line.1342">            else {</span>
<span class="source-line-no">1343</span><span id="line.1343">                pos = (((key[i]).hashCode())) &amp; mask;</span>
<span class="source-line-no">1344</span><span id="line.1344">                while (!((newKey[pos]) == null))</span>
<span class="source-line-no">1345</span><span id="line.1345">                    pos = (pos + 1) &amp; mask;</span>
<span class="source-line-no">1346</span><span id="line.1346">            }</span>
<span class="source-line-no">1347</span><span id="line.1347">            newKey[pos] = key[i];</span>
<span class="source-line-no">1348</span><span id="line.1348">            newValue[pos] = value[i];</span>
<span class="source-line-no">1349</span><span id="line.1349">            if (prev != -1) {</span>
<span class="source-line-no">1350</span><span id="line.1350">                newLink[newPrev] ^= ((newLink[newPrev] ^ (pos &amp; 0xFFFFFFFFL)) &amp; 0xFFFFFFFFL);</span>
<span class="source-line-no">1351</span><span id="line.1351">                newLink[pos] ^= ((newLink[pos] ^ ((newPrev &amp; 0xFFFFFFFFL) &lt;&lt; 32)) &amp; 0xFFFFFFFF00000000L);</span>
<span class="source-line-no">1352</span><span id="line.1352">                newPrev = pos;</span>
<span class="source-line-no">1353</span><span id="line.1353">            } else {</span>
<span class="source-line-no">1354</span><span id="line.1354">                newPrev = first = pos;</span>
<span class="source-line-no">1355</span><span id="line.1355">                // Special case of SET(newLink[ pos ], -1, -1);</span>
<span class="source-line-no">1356</span><span id="line.1356">                newLink[pos] = -1L;</span>
<span class="source-line-no">1357</span><span id="line.1357">            }</span>
<span class="source-line-no">1358</span><span id="line.1358">            t = i;</span>
<span class="source-line-no">1359</span><span id="line.1359">            i = (int) link[i];</span>
<span class="source-line-no">1360</span><span id="line.1360">            prev = t;</span>
<span class="source-line-no">1361</span><span id="line.1361">        }</span>
<span class="source-line-no">1362</span><span id="line.1362">        this.link = newLink;</span>
<span class="source-line-no">1363</span><span id="line.1363">        this.last = newPrev;</span>
<span class="source-line-no">1364</span><span id="line.1364">        if (newPrev != -1)</span>
<span class="source-line-no">1365</span><span id="line.1365">            // Special case of SET_NEXT( newLink[ newPrev ], -1 );</span>
<span class="source-line-no">1366</span><span id="line.1366">            newLink[newPrev] |= -1 &amp; 0xFFFFFFFFL;</span>
<span class="source-line-no">1367</span><span id="line.1367">        n = newN;</span>
<span class="source-line-no">1368</span><span id="line.1368">        this.mask = mask;</span>
<span class="source-line-no">1369</span><span id="line.1369">        maxFill = maxFill(n, f);</span>
<span class="source-line-no">1370</span><span id="line.1370">        this.key = newKey;</span>
<span class="source-line-no">1371</span><span id="line.1371">        this.value = newValue;</span>
<span class="source-line-no">1372</span><span id="line.1372">    }</span>
<span class="source-line-no">1373</span><span id="line.1373">    */</span>
<span class="source-line-no">1374</span><span id="line.1374"></span>
<span class="source-line-no">1375</span><span id="line.1375">    /**</span>
<span class="source-line-no">1376</span><span id="line.1376">     * Returns a deep copy of this map.</span>
<span class="source-line-no">1377</span><span id="line.1377">     * &lt;p&gt;</span>
<span class="source-line-no">1378</span><span id="line.1378">     * &lt;p&gt;</span>
<span class="source-line-no">1379</span><span id="line.1379">     * This method performs a deep copy of this hash map; the data stored in the</span>
<span class="source-line-no">1380</span><span id="line.1380">     * map, however, is not cloned. Note that this makes a difference only for</span>
<span class="source-line-no">1381</span><span id="line.1381">     * object keys.</span>
<span class="source-line-no">1382</span><span id="line.1382">     *</span>
<span class="source-line-no">1383</span><span id="line.1383">     * @return a deep copy of this map.</span>
<span class="source-line-no">1384</span><span id="line.1384">     */</span>
<span class="source-line-no">1385</span><span id="line.1385">    @SuppressWarnings("unchecked")</span>
<span class="source-line-no">1386</span><span id="line.1386">    @GwtIncompatible</span>
<span class="source-line-no">1387</span><span id="line.1387">    public Object clone() {</span>
<span class="source-line-no">1388</span><span id="line.1388">        OrderedSet&lt;K&gt; c;</span>
<span class="source-line-no">1389</span><span id="line.1389">        try {</span>
<span class="source-line-no">1390</span><span id="line.1390">            c = new OrderedSet&lt;&gt;(hasher);</span>
<span class="source-line-no">1391</span><span id="line.1391">            c.key = (K[]) new Object[n + 1];</span>
<span class="source-line-no">1392</span><span id="line.1392">            System.arraycopy(key, 0, c.key, 0, n + 1);</span>
<span class="source-line-no">1393</span><span id="line.1393">            c.order = (IntVLA) order.clone();</span>
<span class="source-line-no">1394</span><span id="line.1394">            return c;</span>
<span class="source-line-no">1395</span><span id="line.1395">        } catch (Exception cantHappen) {</span>
<span class="source-line-no">1396</span><span id="line.1396">            throw new UnsupportedOperationException(cantHappen + (cantHappen.getMessage() != null ?</span>
<span class="source-line-no">1397</span><span id="line.1397">                    "; " + cantHappen.getMessage() : ""));</span>
<span class="source-line-no">1398</span><span id="line.1398">        }</span>
<span class="source-line-no">1399</span><span id="line.1399">    }</span>
<span class="source-line-no">1400</span><span id="line.1400"></span>
<span class="source-line-no">1401</span><span id="line.1401">    /**</span>
<span class="source-line-no">1402</span><span id="line.1402">     * Returns a hash code for this set.</span>
<span class="source-line-no">1403</span><span id="line.1403">     * &lt;p&gt;</span>
<span class="source-line-no">1404</span><span id="line.1404">     * This method overrides the generic method provided by the superclass.</span>
<span class="source-line-no">1405</span><span id="line.1405">     * Since &lt;code&gt;equals()&lt;/code&gt; is not overriden, it is important that the</span>
<span class="source-line-no">1406</span><span id="line.1406">     * value returned by this method is the same value as the one returned by</span>
<span class="source-line-no">1407</span><span id="line.1407">     * the overriden method.</span>
<span class="source-line-no">1408</span><span id="line.1408">     *</span>
<span class="source-line-no">1409</span><span id="line.1409">     * @return a hash code for this set.</span>
<span class="source-line-no">1410</span><span id="line.1410">     */</span>
<span class="source-line-no">1411</span><span id="line.1411">    public int hashCode() {</span>
<span class="source-line-no">1412</span><span id="line.1412">        int h = 0;</span>
<span class="source-line-no">1413</span><span id="line.1413">        for (int j = realSize(), i = 0; j-- != 0; ) {</span>
<span class="source-line-no">1414</span><span id="line.1414">            while (key[i] == null)</span>
<span class="source-line-no">1415</span><span id="line.1415">                i++;</span>
<span class="source-line-no">1416</span><span id="line.1416">            if (this != key[i])</span>
<span class="source-line-no">1417</span><span id="line.1417">                h += hasher.hash(key[i]);</span>
<span class="source-line-no">1418</span><span id="line.1418">            i++;</span>
<span class="source-line-no">1419</span><span id="line.1419">        }</span>
<span class="source-line-no">1420</span><span id="line.1420">        // Zero / null have hash zero.</span>
<span class="source-line-no">1421</span><span id="line.1421">        return h;</span>
<span class="source-line-no">1422</span><span id="line.1422">    }</span>
<span class="source-line-no">1423</span><span id="line.1423"></span>
<span class="source-line-no">1424</span><span id="line.1424">    public long hash64()</span>
<span class="source-line-no">1425</span><span id="line.1425">    {</span>
<span class="source-line-no">1426</span><span id="line.1426">        long seed = 9069147967908697017L;</span>
<span class="source-line-no">1427</span><span id="line.1427">        final int len = order.size;</span>
<span class="source-line-no">1428</span><span id="line.1428">        final int[] data = order.items;</span>
<span class="source-line-no">1429</span><span id="line.1429">        for (int i = 3; i &lt; len; i+=4) {</span>
<span class="source-line-no">1430</span><span id="line.1430">            seed = mum(</span>
<span class="source-line-no">1431</span><span id="line.1431">                    mum(Objects.hashCode(key[data[i-3]]) ^ b1, Objects.hashCode(key[data[i-2]]) ^ b2) + seed,</span>
<span class="source-line-no">1432</span><span id="line.1432">                    mum(Objects.hashCode(key[data[i-1]]) ^ b3, Objects.hashCode(key[data[i]]) ^ b4));</span>
<span class="source-line-no">1433</span><span id="line.1433">        }</span>
<span class="source-line-no">1434</span><span id="line.1434">        switch (len &amp; 3) {</span>
<span class="source-line-no">1435</span><span id="line.1435">            case 0: seed = mum(b1 ^ seed, b4 + seed); break;</span>
<span class="source-line-no">1436</span><span id="line.1436">            case 1: seed = mum(seed ^ Objects.hashCode(key[data[len-1]]) &gt;&gt;&gt; 16, b3 ^ (Objects.hashCode(key[data[len-1]]) &amp; 0xFFFFL)); break;</span>
<span class="source-line-no">1437</span><span id="line.1437">            case 2: seed = mum(seed ^ Objects.hashCode(key[data[len-2]]), b0 ^ Objects.hashCode(key[data[len-1]])); break;</span>
<span class="source-line-no">1438</span><span id="line.1438">            case 3: seed = mum(seed ^ Objects.hashCode(key[data[len-3]]), b2 ^ Objects.hashCode(key[data[len-2]])) ^ mum(seed ^ Objects.hashCode(key[data[len-1]]), b4); break;</span>
<span class="source-line-no">1439</span><span id="line.1439">        }</span>
<span class="source-line-no">1440</span><span id="line.1440">        seed = (seed ^ seed &lt;&lt; 16) * (len ^ b0);</span>
<span class="source-line-no">1441</span><span id="line.1441">        return seed - (seed &gt;&gt;&gt; 31) + (seed &lt;&lt; 33);</span>
<span class="source-line-no">1442</span><span id="line.1442">    }</span>
<span class="source-line-no">1443</span><span id="line.1443"></span>
<span class="source-line-no">1444</span><span id="line.1444">    /**</span>
<span class="source-line-no">1445</span><span id="line.1445">     * Returns the maximum number of entries that can be filled before rehashing.</span>
<span class="source-line-no">1446</span><span id="line.1446">     *</span>
<span class="source-line-no">1447</span><span id="line.1447">     * @param n the size of the backing array.</span>
<span class="source-line-no">1448</span><span id="line.1448">     * @param f the load factor.</span>
<span class="source-line-no">1449</span><span id="line.1449">     * @return the maximum number of entries before rehashing.</span>
<span class="source-line-no">1450</span><span id="line.1450">     */</span>
<span class="source-line-no">1451</span><span id="line.1451">    public static int maxFill(final int n, final float f) {</span>
<span class="source-line-no">1452</span><span id="line.1452">        /* We must guarantee that there is always at least</span>
<span class="source-line-no">1453</span><span id="line.1453">                 * one free entry (even with pathological load factors). */</span>
<span class="source-line-no">1454</span><span id="line.1454">        return Math.min((int) Math.ceil(n * f), n - 1);</span>
<span class="source-line-no">1455</span><span id="line.1455">    }</span>
<span class="source-line-no">1456</span><span id="line.1456"></span>
<span class="source-line-no">1457</span><span id="line.1457">    /**</span>
<span class="source-line-no">1458</span><span id="line.1458">     * Returns the maximum number of entries that can be filled before rehashing.</span>
<span class="source-line-no">1459</span><span id="line.1459">     *</span>
<span class="source-line-no">1460</span><span id="line.1460">     * @param n the size of the backing array.</span>
<span class="source-line-no">1461</span><span id="line.1461">     * @param f the load factor.</span>
<span class="source-line-no">1462</span><span id="line.1462">     * @return the maximum number of entries before rehashing.</span>
<span class="source-line-no">1463</span><span id="line.1463">     */</span>
<span class="source-line-no">1464</span><span id="line.1464">    public static long maxFill(final long n, final float f) {</span>
<span class="source-line-no">1465</span><span id="line.1465">                /* We must guarantee that there is always at least</span>
<span class="source-line-no">1466</span><span id="line.1466">                 * one free entry (even with pathological load factors). */</span>
<span class="source-line-no">1467</span><span id="line.1467">        return Math.min((long) Math.ceil(n * f), n - 1);</span>
<span class="source-line-no">1468</span><span id="line.1468">    }</span>
<span class="source-line-no">1469</span><span id="line.1469"></span>
<span class="source-line-no">1470</span><span id="line.1470">    /**</span>
<span class="source-line-no">1471</span><span id="line.1471">     * Returns the least power of two smaller than or equal to 2&lt;sup&gt;30&lt;/sup&gt; and larger than or equal to &lt;code&gt;Math.ceil( expected / f )&lt;/code&gt;.</span>
<span class="source-line-no">1472</span><span id="line.1472">     *</span>
<span class="source-line-no">1473</span><span id="line.1473">     * @param expected the expected number of elements in a hash table.</span>
<span class="source-line-no">1474</span><span id="line.1474">     * @param f        the load factor.</span>
<span class="source-line-no">1475</span><span id="line.1475">     * @return the minimum possible size for a backing array.</span>
<span class="source-line-no">1476</span><span id="line.1476">     * @throws IllegalArgumentException if the necessary size is larger than 2&lt;sup&gt;30&lt;/sup&gt;.</span>
<span class="source-line-no">1477</span><span id="line.1477">     */</span>
<span class="source-line-no">1478</span><span id="line.1478">    public static int arraySize(final int expected, final float f) {</span>
<span class="source-line-no">1479</span><span id="line.1479">        final long s = Math.max(2, HashCommon.nextPowerOfTwo((long) Math.ceil(expected / f)));</span>
<span class="source-line-no">1480</span><span id="line.1480">        if (s &gt; 1 &lt;&lt; 30)</span>
<span class="source-line-no">1481</span><span id="line.1481">            throw new IllegalArgumentException("Too large (" + expected + " expected elements with load factor " + f + ")");</span>
<span class="source-line-no">1482</span><span id="line.1482">        return (int) s;</span>
<span class="source-line-no">1483</span><span id="line.1483">    }</span>
<span class="source-line-no">1484</span><span id="line.1484"></span>
<span class="source-line-no">1485</span><span id="line.1485">    @Override</span>
<span class="source-line-no">1486</span><span id="line.1486">    public Object[] toArray() {</span>
<span class="source-line-no">1487</span><span id="line.1487">        final Object[] a = new Object[size()];</span>
<span class="source-line-no">1488</span><span id="line.1488">        objectUnwrap(iterator(), a);</span>
<span class="source-line-no">1489</span><span id="line.1489">        return a;</span>
<span class="source-line-no">1490</span><span id="line.1490">    }</span>
<span class="source-line-no">1491</span><span id="line.1491"></span>
<span class="source-line-no">1492</span><span id="line.1492">    @Override</span>
<span class="source-line-no">1493</span><span id="line.1493">    public &lt;T&gt; T[] toArray(T[] a) {</span>
<span class="source-line-no">1494</span><span id="line.1494">        final int size = size();</span>
<span class="source-line-no">1495</span><span id="line.1495">        if (a.length &lt; size) a = Arrays.copyOf(a, size);</span>
<span class="source-line-no">1496</span><span id="line.1496">        objectUnwrap(iterator(), a);</span>
<span class="source-line-no">1497</span><span id="line.1497">        if (containsNull)</span>
<span class="source-line-no">1498</span><span id="line.1498">            a[size] = null;</span>
<span class="source-line-no">1499</span><span id="line.1499">        return a;</span>
<span class="source-line-no">1500</span><span id="line.1500">    }</span>
<span class="source-line-no">1501</span><span id="line.1501"></span>
<span class="source-line-no">1502</span><span id="line.1502"></span>
<span class="source-line-no">1503</span><span id="line.1503">    /**</span>
<span class="source-line-no">1504</span><span id="line.1504">     * Unwraps an iterator into an array starting at a given offset for a given number of elements.</span>
<span class="source-line-no">1505</span><span id="line.1505">     * &lt;p&gt;</span>
<span class="source-line-no">1506</span><span id="line.1506">     * &lt;P&gt;This method iterates over the given type-specific iterator and stores the elements returned, up to a maximum of &lt;code&gt;length&lt;/code&gt;, in the given array starting at &lt;code&gt;offset&lt;/code&gt;. The</span>
<span class="source-line-no">1507</span><span id="line.1507">     * number of actually unwrapped elements is returned (it may be less than &lt;code&gt;max&lt;/code&gt; if the iterator emits less than &lt;code&gt;max&lt;/code&gt; elements).</span>
<span class="source-line-no">1508</span><span id="line.1508">     *</span>
<span class="source-line-no">1509</span><span id="line.1509">     * @param i      a type-specific iterator.</span>
<span class="source-line-no">1510</span><span id="line.1510">     * @param array  an array to contain the output of the iterator.</span>
<span class="source-line-no">1511</span><span id="line.1511">     * @param offset the first element of the array to be returned.</span>
<span class="source-line-no">1512</span><span id="line.1512">     * @param max    the maximum number of elements to unwrap.</span>
<span class="source-line-no">1513</span><span id="line.1513">     * @return the number of elements unwrapped.</span>
<span class="source-line-no">1514</span><span id="line.1514">     */</span>
<span class="source-line-no">1515</span><span id="line.1515">    private static &lt;K&gt; int objectUnwrap(final Iterator&lt;? extends K&gt; i, final K[] array, int offset, final int max) {</span>
<span class="source-line-no">1516</span><span id="line.1516">        if (max &lt; 0) throw new IllegalArgumentException("The maximum number of elements (" + max + ") is negative");</span>
<span class="source-line-no">1517</span><span id="line.1517">        if (offset &lt; 0 || offset + max &gt; array.length) throw new IllegalArgumentException();</span>
<span class="source-line-no">1518</span><span id="line.1518">        int j = max;</span>
<span class="source-line-no">1519</span><span id="line.1519">        while (j-- != 0 &amp;&amp; i.hasNext())</span>
<span class="source-line-no">1520</span><span id="line.1520">            array[offset++] = i.next();</span>
<span class="source-line-no">1521</span><span id="line.1521">        return max - j - 1;</span>
<span class="source-line-no">1522</span><span id="line.1522">    }</span>
<span class="source-line-no">1523</span><span id="line.1523"></span>
<span class="source-line-no">1524</span><span id="line.1524">    /**</span>
<span class="source-line-no">1525</span><span id="line.1525">     * Unwraps an iterator into an array.</span>
<span class="source-line-no">1526</span><span id="line.1526">     * &lt;p&gt;</span>
<span class="source-line-no">1527</span><span id="line.1527">     * &lt;P&gt;This method iterates over the given type-specific iterator and stores the elements returned in the given array. The iteration will stop when the iterator has no more elements or when the end</span>
<span class="source-line-no">1528</span><span id="line.1528">     * of the array has been reached.</span>
<span class="source-line-no">1529</span><span id="line.1529">     *</span>
<span class="source-line-no">1530</span><span id="line.1530">     * @param i     a type-specific iterator.</span>
<span class="source-line-no">1531</span><span id="line.1531">     * @param array an array to contain the output of the iterator.</span>
<span class="source-line-no">1532</span><span id="line.1532">     * @return the number of elements unwrapped.</span>
<span class="source-line-no">1533</span><span id="line.1533">     */</span>
<span class="source-line-no">1534</span><span id="line.1534">    private static &lt;K&gt; int objectUnwrap(final Iterator&lt;? extends K&gt; i, final K[] array) {</span>
<span class="source-line-no">1535</span><span id="line.1535">        return objectUnwrap(i, array, 0, array.length);</span>
<span class="source-line-no">1536</span><span id="line.1536">    }</span>
<span class="source-line-no">1537</span><span id="line.1537"></span>
<span class="source-line-no">1538</span><span id="line.1538">    @Override</span>
<span class="source-line-no">1539</span><span id="line.1539">    public String toString() {</span>
<span class="source-line-no">1540</span><span id="line.1540">        final StringBuilder s = new StringBuilder();</span>
<span class="source-line-no">1541</span><span id="line.1541">        int n = size(), i = 0;</span>
<span class="source-line-no">1542</span><span id="line.1542">        boolean first = true;</span>
<span class="source-line-no">1543</span><span id="line.1543">        s.append("OrderedSet{");</span>
<span class="source-line-no">1544</span><span id="line.1544">        while (i &lt; n) {</span>
<span class="source-line-no">1545</span><span id="line.1545">            if (first) first = false;</span>
<span class="source-line-no">1546</span><span id="line.1546">            else s.append(", ");</span>
<span class="source-line-no">1547</span><span id="line.1547">            K k = getAt(i++);</span>
<span class="source-line-no">1548</span><span id="line.1548">            s.append(k == this ? "(this collection)" : String.valueOf(k));</span>
<span class="source-line-no">1549</span><span id="line.1549">        }</span>
<span class="source-line-no">1550</span><span id="line.1550">        s.append("}");</span>
<span class="source-line-no">1551</span><span id="line.1551">        return s.toString();</span>
<span class="source-line-no">1552</span><span id="line.1552">    }</span>
<span class="source-line-no">1553</span><span id="line.1553"></span>
<span class="source-line-no">1554</span><span id="line.1554">    @Override</span>
<span class="source-line-no">1555</span><span id="line.1555">    public boolean equals(final Object o) {</span>
<span class="source-line-no">1556</span><span id="line.1556">        if (o == this)</span>
<span class="source-line-no">1557</span><span id="line.1557">            return true;</span>
<span class="source-line-no">1558</span><span id="line.1558">        if (!(o instanceof Set))</span>
<span class="source-line-no">1559</span><span id="line.1559">            return false;</span>
<span class="source-line-no">1560</span><span id="line.1560">        Set&lt;?&gt; s = (Set&lt;?&gt;) o;</span>
<span class="source-line-no">1561</span><span id="line.1561">        if (s.size() != size())</span>
<span class="source-line-no">1562</span><span id="line.1562">            return false;</span>
<span class="source-line-no">1563</span><span id="line.1563">        return containsAll(s);</span>
<span class="source-line-no">1564</span><span id="line.1564">    }</span>
<span class="source-line-no">1565</span><span id="line.1565"></span>
<span class="source-line-no">1566</span><span id="line.1566">    @GwtIncompatible</span>
<span class="source-line-no">1567</span><span id="line.1567">    private void writeObject(java.io.ObjectOutputStream s)</span>
<span class="source-line-no">1568</span><span id="line.1568">            throws java.io.IOException {</span>
<span class="source-line-no">1569</span><span id="line.1569">        final ListIterator&lt;K&gt; i = iterator();</span>
<span class="source-line-no">1570</span><span id="line.1570">        s.defaultWriteObject();</span>
<span class="source-line-no">1571</span><span id="line.1571">        for (int j = size; j-- != 0; )</span>
<span class="source-line-no">1572</span><span id="line.1572">            s.writeObject(i.next());</span>
<span class="source-line-no">1573</span><span id="line.1573">    }</span>
<span class="source-line-no">1574</span><span id="line.1574"></span>
<span class="source-line-no">1575</span><span id="line.1575">    @GwtIncompatible</span>
<span class="source-line-no">1576</span><span id="line.1576">    @SuppressWarnings("unchecked")</span>
<span class="source-line-no">1577</span><span id="line.1577">    private void readObject(java.io.ObjectInputStream s)</span>
<span class="source-line-no">1578</span><span id="line.1578">            throws java.io.IOException, ClassNotFoundException {</span>
<span class="source-line-no">1579</span><span id="line.1579">        s.defaultReadObject();</span>
<span class="source-line-no">1580</span><span id="line.1580">        n = arraySize(size, f);</span>
<span class="source-line-no">1581</span><span id="line.1581">        maxFill = maxFill(n, f);</span>
<span class="source-line-no">1582</span><span id="line.1582">        mask = n - 1;</span>
<span class="source-line-no">1583</span><span id="line.1583">        final K[] key = this.key = (K[]) new Object[n + 1];</span>
<span class="source-line-no">1584</span><span id="line.1584">        final IntVLA order = this.order = new IntVLA(n + 1);</span>
<span class="source-line-no">1585</span><span id="line.1585">        K k;</span>
<span class="source-line-no">1586</span><span id="line.1586">        for (int i = size, pos; i-- != 0; ) {</span>
<span class="source-line-no">1587</span><span id="line.1587">            k = (K) s.readObject();</span>
<span class="source-line-no">1588</span><span id="line.1588">            if (k == null) {</span>
<span class="source-line-no">1589</span><span id="line.1589">                pos = n;</span>
<span class="source-line-no">1590</span><span id="line.1590">                containsNull = true;</span>
<span class="source-line-no">1591</span><span id="line.1591">            } else {</span>
<span class="source-line-no">1592</span><span id="line.1592">                if (!(key[pos = (hasher.hash(k)) &amp; mask] == null))</span>
<span class="source-line-no">1593</span><span id="line.1593">                    while (!(key[pos = pos + 1 &amp; mask] == null)) ;</span>
<span class="source-line-no">1594</span><span id="line.1594">            }</span>
<span class="source-line-no">1595</span><span id="line.1595">            key[pos] = k;</span>
<span class="source-line-no">1596</span><span id="line.1596">            order.add(pos);</span>
<span class="source-line-no">1597</span><span id="line.1597">        }</span>
<span class="source-line-no">1598</span><span id="line.1598">    }</span>
<span class="source-line-no">1599</span><span id="line.1599"></span>
<span class="source-line-no">1600</span><span id="line.1600">    /**</span>
<span class="source-line-no">1601</span><span id="line.1601">     * Gets the item at the given index in the iteration order in constant time (random-access).</span>
<span class="source-line-no">1602</span><span id="line.1602">     *</span>
<span class="source-line-no">1603</span><span id="line.1603">     * @param idx the index in the iteration order of the key to fetch</span>
<span class="source-line-no">1604</span><span id="line.1604">     * @return the key at the index, if the index is valid, otherwise null</span>
<span class="source-line-no">1605</span><span id="line.1605">     */</span>
<span class="source-line-no">1606</span><span id="line.1606">    public K getAt(final int idx) {</span>
<span class="source-line-no">1607</span><span id="line.1607">        if (idx &lt; 0 || idx &gt;= order.size)</span>
<span class="source-line-no">1608</span><span id="line.1608">            return null;</span>
<span class="source-line-no">1609</span><span id="line.1609">        final K[] key = this.key;</span>
<span class="source-line-no">1610</span><span id="line.1610">        // The starting point.</span>
<span class="source-line-no">1611</span><span id="line.1611">        return key[order.get(idx)];</span>
<span class="source-line-no">1612</span><span id="line.1612">    }</span>
<span class="source-line-no">1613</span><span id="line.1613"></span>
<span class="source-line-no">1614</span><span id="line.1614">    /**</span>
<span class="source-line-no">1615</span><span id="line.1615">     * Removes the item at the given index in the iteration order in not-exactly constant time (though it still should</span>
<span class="source-line-no">1616</span><span id="line.1616">     * be efficient).</span>
<span class="source-line-no">1617</span><span id="line.1617">     *</span>
<span class="source-line-no">1618</span><span id="line.1618">     * @param idx the index in the iteration order of the item to remove</span>
<span class="source-line-no">1619</span><span id="line.1619">     * @return true if this Set was changed as a result of this call, or false if nothing changed.</span>
<span class="source-line-no">1620</span><span id="line.1620">     */</span>
<span class="source-line-no">1621</span><span id="line.1621">    public boolean removeAt(final int idx) {</span>
<span class="source-line-no">1622</span><span id="line.1622">        if (idx &lt; 0 || idx &gt;= order.size)</span>
<span class="source-line-no">1623</span><span id="line.1623">            throw new NoSuchElementException();</span>
<span class="source-line-no">1624</span><span id="line.1624">        int pos = order.get(idx);</span>
<span class="source-line-no">1625</span><span id="line.1625">        if (key[pos] == null) {</span>
<span class="source-line-no">1626</span><span id="line.1626">            if (containsNull)</span>
<span class="source-line-no">1627</span><span id="line.1627">                return removeNullEntry();</span>
<span class="source-line-no">1628</span><span id="line.1628">            return false;</span>
<span class="source-line-no">1629</span><span id="line.1629">        }</span>
<span class="source-line-no">1630</span><span id="line.1630">        return removeEntry(pos);</span>
<span class="source-line-no">1631</span><span id="line.1631">    }</span>
<span class="source-line-no">1632</span><span id="line.1632"></span>
<span class="source-line-no">1633</span><span id="line.1633">    /**</span>
<span class="source-line-no">1634</span><span id="line.1634">     * Gets a random value from this OrderedSet in constant time, using the given IRNG to generate a random number.</span>
<span class="source-line-no">1635</span><span id="line.1635">     *</span>
<span class="source-line-no">1636</span><span id="line.1636">     * @param rng used to generate a random index for a value</span>
<span class="source-line-no">1637</span><span id="line.1637">     * @return a random value from this OrderedSet</span>
<span class="source-line-no">1638</span><span id="line.1638">     */</span>
<span class="source-line-no">1639</span><span id="line.1639">    public K randomItem(IRNG rng) {</span>
<span class="source-line-no">1640</span><span id="line.1640">        return getAt(rng.nextInt(order.size));</span>
<span class="source-line-no">1641</span><span id="line.1641">    }</span>
<span class="source-line-no">1642</span><span id="line.1642"></span>
<span class="source-line-no">1643</span><span id="line.1643">    /**</span>
<span class="source-line-no">1644</span><span id="line.1644">     * Randomly alters the iteration order for this OrderedSet using the given IRNG to shuffle.</span>
<span class="source-line-no">1645</span><span id="line.1645">     *</span>
<span class="source-line-no">1646</span><span id="line.1646">     * @param rng used to generate a random ordering</span>
<span class="source-line-no">1647</span><span id="line.1647">     * @return this for chaining</span>
<span class="source-line-no">1648</span><span id="line.1648">     */</span>
<span class="source-line-no">1649</span><span id="line.1649">    public OrderedSet&lt;K&gt; shuffle(IRNG rng) {</span>
<span class="source-line-no">1650</span><span id="line.1650">        if (size &lt; 2 || rng == null)</span>
<span class="source-line-no">1651</span><span id="line.1651">            return this;</span>
<span class="source-line-no">1652</span><span id="line.1652">        order.shuffle(rng);</span>
<span class="source-line-no">1653</span><span id="line.1653">        return this;</span>
<span class="source-line-no">1654</span><span id="line.1654">    }</span>
<span class="source-line-no">1655</span><span id="line.1655"></span>
<span class="source-line-no">1656</span><span id="line.1656">    /**</span>
<span class="source-line-no">1657</span><span id="line.1657">     * Given an array or varargs of replacement indices for this OrderedSet's iteration order, reorders this so the</span>
<span class="source-line-no">1658</span><span id="line.1658">     * first item in the returned version is the same as {@code getAt(ordering[0])} (with some care taken for negative</span>
<span class="source-line-no">1659</span><span id="line.1659">     * or too-large indices), the second item in the returned version is the same as {@code getAt(ordering[1])}, etc.</span>
<span class="source-line-no">1660</span><span id="line.1660">     * &lt;br&gt;</span>
<span class="source-line-no">1661</span><span id="line.1661">     * Negative indices are considered reversed distances from the end of ordering, so -1 refers to the same index as</span>
<span class="source-line-no">1662</span><span id="line.1662">     * {@code ordering[ordering.length - 1]}. If ordering is smaller than {@code size()}, only the indices up to the</span>
<span class="source-line-no">1663</span><span id="line.1663">     * length of ordering will be modified. If ordering is larger than {@code size()}, only as many indices will be</span>
<span class="source-line-no">1664</span><span id="line.1664">     * affected as {@code size()}, and reversed distances are measured from the end of this Set's entries instead of</span>
<span class="source-line-no">1665</span><span id="line.1665">     * the end of ordering. Duplicate values in ordering will produce duplicate values in the returned Set.</span>
<span class="source-line-no">1666</span><span id="line.1666">     * &lt;br&gt;</span>
<span class="source-line-no">1667</span><span id="line.1667">     * This method modifies this OrderedSet in-place and also returns it for chaining.</span>
<span class="source-line-no">1668</span><span id="line.1668">     *</span>
<span class="source-line-no">1669</span><span id="line.1669">     * @param ordering an array or varargs of int indices, where the nth item in ordering changes the nth item in this</span>
<span class="source-line-no">1670</span><span id="line.1670">     *                 Set to have the value currently in this Set at the index specified by the value in ordering</span>
<span class="source-line-no">1671</span><span id="line.1671">     * @return this for chaining, after modifying it in-place</span>
<span class="source-line-no">1672</span><span id="line.1672">     */</span>
<span class="source-line-no">1673</span><span id="line.1673">    public OrderedSet&lt;K&gt; reorder(int... ordering) {</span>
<span class="source-line-no">1674</span><span id="line.1674">        order.reorder(ordering);</span>
<span class="source-line-no">1675</span><span id="line.1675">        return this;</span>
<span class="source-line-no">1676</span><span id="line.1676">    }</span>
<span class="source-line-no">1677</span><span id="line.1677"></span>
<span class="source-line-no">1678</span><span id="line.1678">    private boolean alterEntry(final int pos, final K replacement) {</span>
<span class="source-line-no">1679</span><span id="line.1679">        int rep;</span>
<span class="source-line-no">1680</span><span id="line.1680">        if (replacement == null) {</span>
<span class="source-line-no">1681</span><span id="line.1681">            if (containsNull)</span>
<span class="source-line-no">1682</span><span id="line.1682">                return false;</span>
<span class="source-line-no">1683</span><span id="line.1683">            rep = n;</span>
<span class="source-line-no">1684</span><span id="line.1684">            containsNull = true;</span>
<span class="source-line-no">1685</span><span id="line.1685">        } else {</span>
<span class="source-line-no">1686</span><span id="line.1686">            K curr;</span>
<span class="source-line-no">1687</span><span id="line.1687">            final K[] key = this.key;</span>
<span class="source-line-no">1688</span><span id="line.1688">            shiftKeys(pos);</span>
<span class="source-line-no">1689</span><span id="line.1689">            // The starting point.</span>
<span class="source-line-no">1690</span><span id="line.1690">            if (!((curr = key[rep = (hasher.hash(replacement)) &amp; mask]) == null)) {</span>
<span class="source-line-no">1691</span><span id="line.1691">                if (hasher.areEqual(curr, replacement))</span>
<span class="source-line-no">1692</span><span id="line.1692">                    return false;</span>
<span class="source-line-no">1693</span><span id="line.1693">                while (!((curr = key[rep = rep + 1 &amp; mask]) == null))</span>
<span class="source-line-no">1694</span><span id="line.1694">                    if (hasher.areEqual(curr, replacement))</span>
<span class="source-line-no">1695</span><span id="line.1695">                        return false;</span>
<span class="source-line-no">1696</span><span id="line.1696">            }</span>
<span class="source-line-no">1697</span><span id="line.1697">            key[rep] = replacement;</span>
<span class="source-line-no">1698</span><span id="line.1698">        }</span>
<span class="source-line-no">1699</span><span id="line.1699">        fixOrder(pos, rep);</span>
<span class="source-line-no">1700</span><span id="line.1700">        return true;</span>
<span class="source-line-no">1701</span><span id="line.1701">    }</span>
<span class="source-line-no">1702</span><span id="line.1702"></span>
<span class="source-line-no">1703</span><span id="line.1703">    private boolean alterNullEntry(final K replacement) {</span>
<span class="source-line-no">1704</span><span id="line.1704">        containsNull = false;</span>
<span class="source-line-no">1705</span><span id="line.1705">        key[n] = null;</span>
<span class="source-line-no">1706</span><span id="line.1706">        int rep;</span>
<span class="source-line-no">1707</span><span id="line.1707">        if (replacement == null) {</span>
<span class="source-line-no">1708</span><span id="line.1708">            rep = n;</span>
<span class="source-line-no">1709</span><span id="line.1709">            containsNull = true;</span>
<span class="source-line-no">1710</span><span id="line.1710">        } else {</span>
<span class="source-line-no">1711</span><span id="line.1711">            K curr;</span>
<span class="source-line-no">1712</span><span id="line.1712">            final K[] key = this.key;</span>
<span class="source-line-no">1713</span><span id="line.1713">            // The starting point.</span>
<span class="source-line-no">1714</span><span id="line.1714">            if (!((curr = key[rep = (hasher.hash(replacement)) &amp; mask]) == null)) {</span>
<span class="source-line-no">1715</span><span id="line.1715">                if (hasher.areEqual(curr, replacement))</span>
<span class="source-line-no">1716</span><span id="line.1716">                    return false;</span>
<span class="source-line-no">1717</span><span id="line.1717">                while (!((curr = key[rep = rep + 1 &amp; mask]) == null))</span>
<span class="source-line-no">1718</span><span id="line.1718">                    if (hasher.areEqual(curr, replacement))</span>
<span class="source-line-no">1719</span><span id="line.1719">                        return false;</span>
<span class="source-line-no">1720</span><span id="line.1720">            }</span>
<span class="source-line-no">1721</span><span id="line.1721">            key[rep] = replacement;</span>
<span class="source-line-no">1722</span><span id="line.1722">        }</span>
<span class="source-line-no">1723</span><span id="line.1723">        fixOrder(n, rep);</span>
<span class="source-line-no">1724</span><span id="line.1724">        return true;</span>
<span class="source-line-no">1725</span><span id="line.1725">    }</span>
<span class="source-line-no">1726</span><span id="line.1726"></span>
<span class="source-line-no">1727</span><span id="line.1727">    /*</span>
<span class="source-line-no">1728</span><span id="line.1728">    public boolean alter(K original, K replacement)</span>
<span class="source-line-no">1729</span><span id="line.1729">    {</span>
<span class="source-line-no">1730</span><span id="line.1730">        if (original == null) {</span>
<span class="source-line-no">1731</span><span id="line.1731">            if (containsNull) {</span>
<span class="source-line-no">1732</span><span id="line.1732">                return replacement != null &amp;&amp; alterNullEntry(replacement);</span>
<span class="source-line-no">1733</span><span id="line.1733">            }</span>
<span class="source-line-no">1734</span><span id="line.1734">            else</span>
<span class="source-line-no">1735</span><span id="line.1735">                return add(replacement);</span>
<span class="source-line-no">1736</span><span id="line.1736">        }</span>
<span class="source-line-no">1737</span><span id="line.1737">        else if(hasher.areEqual(original, replacement))</span>
<span class="source-line-no">1738</span><span id="line.1738">            return false;</span>
<span class="source-line-no">1739</span><span id="line.1739">        K curr;</span>
<span class="source-line-no">1740</span><span id="line.1740">        final K[] key = this.key;</span>
<span class="source-line-no">1741</span><span id="line.1741">        int pos;</span>
<span class="source-line-no">1742</span><span id="line.1742">        // The starting point.</span>
<span class="source-line-no">1743</span><span id="line.1743">        if ((curr = key[pos = (hasher.hash(original)) &amp; mask]) == null)</span>
<span class="source-line-no">1744</span><span id="line.1744">            return add(replacement);</span>
<span class="source-line-no">1745</span><span id="line.1745">        if (hasher.areEqual(original, curr))</span>
<span class="source-line-no">1746</span><span id="line.1746">            return alterEntry(pos, replacement);</span>
<span class="source-line-no">1747</span><span id="line.1747">        while (true) {</span>
<span class="source-line-no">1748</span><span id="line.1748">            if ((curr = key[pos = (pos + 1) &amp; mask]) == null)</span>
<span class="source-line-no">1749</span><span id="line.1749">                return add(replacement);</span>
<span class="source-line-no">1750</span><span id="line.1750">            if (hasher.areEqual(original, curr))</span>
<span class="source-line-no">1751</span><span id="line.1751">                return alterEntry(pos, replacement);</span>
<span class="source-line-no">1752</span><span id="line.1752">        }</span>
<span class="source-line-no">1753</span><span id="line.1753">    }*/</span>
<span class="source-line-no">1754</span><span id="line.1754">    private int alterEntry(final int pos) {</span>
<span class="source-line-no">1755</span><span id="line.1755">        int idx = fixOrder(pos);</span>
<span class="source-line-no">1756</span><span id="line.1756">        size--;</span>
<span class="source-line-no">1757</span><span id="line.1757">        shiftKeys(pos);</span>
<span class="source-line-no">1758</span><span id="line.1758">        if (size &lt; maxFill &gt;&gt; 2 &amp;&amp; n &gt; DEFAULT_INITIAL_SIZE)</span>
<span class="source-line-no">1759</span><span id="line.1759">            rehash(n &gt;&gt; 1);</span>
<span class="source-line-no">1760</span><span id="line.1760">        return idx;</span>
<span class="source-line-no">1761</span><span id="line.1761">    }</span>
<span class="source-line-no">1762</span><span id="line.1762"></span>
<span class="source-line-no">1763</span><span id="line.1763">    private int alterNullEntry() {</span>
<span class="source-line-no">1764</span><span id="line.1764">        int idx = fixOrder(n);</span>
<span class="source-line-no">1765</span><span id="line.1765">        containsNull = false;</span>
<span class="source-line-no">1766</span><span id="line.1766">        size--;</span>
<span class="source-line-no">1767</span><span id="line.1767">        if (size &lt; maxFill &gt;&gt; 2 &amp;&amp; n &gt; DEFAULT_INITIAL_SIZE)</span>
<span class="source-line-no">1768</span><span id="line.1768">            rehash(n &gt;&gt; 1);</span>
<span class="source-line-no">1769</span><span id="line.1769">        return idx;</span>
<span class="source-line-no">1770</span><span id="line.1770">    }</span>
<span class="source-line-no">1771</span><span id="line.1771"></span>
<span class="source-line-no">1772</span><span id="line.1772">    /**</span>
<span class="source-line-no">1773</span><span id="line.1773">     * Changes a K, original, to another, replacement, while keeping replacement at the same point in the ordering.</span>
<span class="source-line-no">1774</span><span id="line.1774">     *</span>
<span class="source-line-no">1775</span><span id="line.1775">     * @param original    a K value that will be removed from this Set if present, and its iteration index remembered</span>
<span class="source-line-no">1776</span><span id="line.1776">     * @param replacement another K value that will replace original at the remembered index</span>
<span class="source-line-no">1777</span><span id="line.1777">     * @return true if the Set changed, or false if it didn't (such as if the two arguments are equal, or replacement was already in the Set but original was not)</span>
<span class="source-line-no">1778</span><span id="line.1778">     */</span>
<span class="source-line-no">1779</span><span id="line.1779">    public boolean alter(K original, K replacement) {</span>
<span class="source-line-no">1780</span><span id="line.1780">        int idx;</span>
<span class="source-line-no">1781</span><span id="line.1781">        if (original == null) {</span>
<span class="source-line-no">1782</span><span id="line.1782">            if (containsNull) {</span>
<span class="source-line-no">1783</span><span id="line.1783">                if (replacement != null) {</span>
<span class="source-line-no">1784</span><span id="line.1784">                    idx = alterNullEntry();</span>
<span class="source-line-no">1785</span><span id="line.1785">                    addAt(replacement, idx);</span>
<span class="source-line-no">1786</span><span id="line.1786">                    return true;</span>
<span class="source-line-no">1787</span><span id="line.1787">                } else</span>
<span class="source-line-no">1788</span><span id="line.1788">                    return false;</span>
<span class="source-line-no">1789</span><span id="line.1789">            }</span>
<span class="source-line-no">1790</span><span id="line.1790">            ;</span>
<span class="source-line-no">1791</span><span id="line.1791">            return false;</span>
<span class="source-line-no">1792</span><span id="line.1792">        }</span>
<span class="source-line-no">1793</span><span id="line.1793">        if (hasher.areEqual(original, replacement))</span>
<span class="source-line-no">1794</span><span id="line.1794">            return false;</span>
<span class="source-line-no">1795</span><span id="line.1795">        K curr;</span>
<span class="source-line-no">1796</span><span id="line.1796">        final K[] key = this.key;</span>
<span class="source-line-no">1797</span><span id="line.1797">        int pos;</span>
<span class="source-line-no">1798</span><span id="line.1798">        // The starting point.</span>
<span class="source-line-no">1799</span><span id="line.1799">        if ((curr = key[pos = (hasher.hash(original)) &amp; mask]) == null)</span>
<span class="source-line-no">1800</span><span id="line.1800">            return false;</span>
<span class="source-line-no">1801</span><span id="line.1801">        if (hasher.areEqual(original, curr)) {</span>
<span class="source-line-no">1802</span><span id="line.1802">            idx = alterEntry(pos);</span>
<span class="source-line-no">1803</span><span id="line.1803">            addAt(replacement, idx);</span>
<span class="source-line-no">1804</span><span id="line.1804">            return true;</span>
<span class="source-line-no">1805</span><span id="line.1805">        }</span>
<span class="source-line-no">1806</span><span id="line.1806">        while (true) {</span>
<span class="source-line-no">1807</span><span id="line.1807">            if ((curr = key[pos = pos + 1 &amp; mask]) == null)</span>
<span class="source-line-no">1808</span><span id="line.1808">                return false;</span>
<span class="source-line-no">1809</span><span id="line.1809">            if (hasher.areEqual(original, curr)) {</span>
<span class="source-line-no">1810</span><span id="line.1810">                idx = alterEntry(pos);</span>
<span class="source-line-no">1811</span><span id="line.1811">                addAt(replacement, idx);</span>
<span class="source-line-no">1812</span><span id="line.1812">                return true;</span>
<span class="source-line-no">1813</span><span id="line.1813">            }</span>
<span class="source-line-no">1814</span><span id="line.1814">        }</span>
<span class="source-line-no">1815</span><span id="line.1815">    }</span>
<span class="source-line-no">1816</span><span id="line.1816"></span>
<span class="source-line-no">1817</span><span id="line.1817">    /**</span>
<span class="source-line-no">1818</span><span id="line.1818">     * Changes the K at the given index to replacement while keeping replacement at the same point in the ordering.</span>
<span class="source-line-no">1819</span><span id="line.1819">     *</span>
<span class="source-line-no">1820</span><span id="line.1820">     * @param index       an index to replace the K item at</span>
<span class="source-line-no">1821</span><span id="line.1821">     * @param replacement another K value that will replace the original at the remembered index</span>
<span class="source-line-no">1822</span><span id="line.1822">     * @return true if the Set changed, or false if it didn't (such as if the replacement was already present at the given index)</span>
<span class="source-line-no">1823</span><span id="line.1823">     */</span>
<span class="source-line-no">1824</span><span id="line.1824">    public boolean alterAt(int index, K replacement)</span>
<span class="source-line-no">1825</span><span id="line.1825">    {</span>
<span class="source-line-no">1826</span><span id="line.1826">        return alter(getAt(index), replacement);</span>
<span class="source-line-no">1827</span><span id="line.1827">    }</span>
<span class="source-line-no">1828</span><span id="line.1828"></span>
<span class="source-line-no">1829</span><span id="line.1829">    /**</span>
<span class="source-line-no">1830</span><span id="line.1830">     * Sorts this whole OrderedSet using the supplied Comparator.</span>
<span class="source-line-no">1831</span><span id="line.1831">     * @param comparator a Comparator that can be used on the same type this uses for its keys (may need wildcards)</span>
<span class="source-line-no">1832</span><span id="line.1832">     */</span>
<span class="source-line-no">1833</span><span id="line.1833">    public void sort(Comparator&lt;? super K&gt; comparator)</span>
<span class="source-line-no">1834</span><span id="line.1834">    {</span>
<span class="source-line-no">1835</span><span id="line.1835">        sort(comparator, 0, size);</span>
<span class="source-line-no">1836</span><span id="line.1836">    }</span>
<span class="source-line-no">1837</span><span id="line.1837"></span>
<span class="source-line-no">1838</span><span id="line.1838">    /**</span>
<span class="source-line-no">1839</span><span id="line.1839">     * Sorts a sub-range of this OrderedSet from what is currently the index {@code start} up to (but not including) the</span>
<span class="source-line-no">1840</span><span id="line.1840">     * index {@code end}, using the supplied Comparator.</span>
<span class="source-line-no">1841</span><span id="line.1841">     * @param comparator a Comparator that can be used on the same type this uses for its keys (may need wildcards)</span>
<span class="source-line-no">1842</span><span id="line.1842">     * @param start the first index of a key to sort (the index can change after this)</span>
<span class="source-line-no">1843</span><span id="line.1843">     * @param end the exclusive bound on the indices to sort; often this is just {@link #size()}</span>
<span class="source-line-no">1844</span><span id="line.1844">     */</span>
<span class="source-line-no">1845</span><span id="line.1845">    public void sort(Comparator&lt;? super K&gt; comparator, int start, int end)</span>
<span class="source-line-no">1846</span><span id="line.1846">    {</span>
<span class="source-line-no">1847</span><span id="line.1847">        TimSort.sort(key, order, start, end, comparator);</span>
<span class="source-line-no">1848</span><span id="line.1848">    }</span>
<span class="source-line-no">1849</span><span id="line.1849"></span>
<span class="source-line-no">1850</span><span id="line.1850">    /**</span>
<span class="source-line-no">1851</span><span id="line.1851">     * Reverses the iteration order in linear time.</span>
<span class="source-line-no">1852</span><span id="line.1852">     */</span>
<span class="source-line-no">1853</span><span id="line.1853">    public void reverse()</span>
<span class="source-line-no">1854</span><span id="line.1854">    {</span>
<span class="source-line-no">1855</span><span id="line.1855">        order.reverse();</span>
<span class="source-line-no">1856</span><span id="line.1856">    }</span>
<span class="source-line-no">1857</span><span id="line.1857">}</span>




























































</pre>
</div>
</main>
</body>
</html>
