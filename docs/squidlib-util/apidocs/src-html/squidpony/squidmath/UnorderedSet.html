<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (16) -->
<title>Source code</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="source: package: squidpony.squidmath, class: UnorderedSet">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body class="source-page">
<main role="main">
<div class="source-container">
<pre><span class="source-line-no">001</span><span id="line.1">/*</span>
<span class="source-line-no">002</span><span id="line.2"> * Copyright (C) 2002-2015 Sebastiano Vigna</span>
<span class="source-line-no">003</span><span id="line.3"> *</span>
<span class="source-line-no">004</span><span id="line.4"> * Licensed under the Apache License, Version 2.0 (the "License");</span>
<span class="source-line-no">005</span><span id="line.5"> * you may not use this file except in compliance with the License.</span>
<span class="source-line-no">006</span><span id="line.6"> * You may obtain a copy of the License at</span>
<span class="source-line-no">007</span><span id="line.7"> *</span>
<span class="source-line-no">008</span><span id="line.8"> *     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="source-line-no">009</span><span id="line.9"> *</span>
<span class="source-line-no">010</span><span id="line.10"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="source-line-no">011</span><span id="line.11"> * distributed under the License is distributed on an "AS IS" BASIS,</span>
<span class="source-line-no">012</span><span id="line.12"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="source-line-no">013</span><span id="line.13"> * See the License for the specific language governing permissions and</span>
<span class="source-line-no">014</span><span id="line.14"> * limitations under the License. </span>
<span class="source-line-no">015</span><span id="line.15"> */</span>
<span class="source-line-no">016</span><span id="line.16">package squidpony.squidmath;</span>
<span class="source-line-no">017</span><span id="line.17"></span>
<span class="source-line-no">018</span><span id="line.18">import squidpony.annotation.GwtIncompatible;</span>
<span class="source-line-no">019</span><span id="line.19"></span>
<span class="source-line-no">020</span><span id="line.20">import java.util.*;</span>
<span class="source-line-no">021</span><span id="line.21"></span>
<span class="source-line-no">022</span><span id="line.22">/**</span>
<span class="source-line-no">023</span><span id="line.23"> * A generic unordered hash set with with a fast implementation, based on {@link OrderedSet} in this library, which is</span>
<span class="source-line-no">024</span><span id="line.24"> * based on the fastutil library's ObjectLinkedOpenHashSet class; the ordering and indexed access have been removed to</span>
<span class="source-line-no">025</span><span id="line.25"> * potentially reduce the time cost of insertion and removal at the expense of increasing time cost for access by index.</span>
<span class="source-line-no">026</span><span id="line.26"> * This does support optional hash strategies for array (and other) keys, which fastutil's collections can do in a</span>
<span class="source-line-no">027</span><span id="line.27"> * different way, and has better support than {@link HashSet} for construction with an array of items or construction</span>
<span class="source-line-no">028</span><span id="line.28"> * with a Collection of items (this also helps {@link #addAll(Object[])}).</span>
<span class="source-line-no">029</span><span id="line.29"> * &lt;p&gt;</span>
<span class="source-line-no">030</span><span id="line.30"> * Instances of this class use a hash table to represent a set. The table is</span>
<span class="source-line-no">031</span><span id="line.31"> * filled up to a specified &lt;em&gt;load factor&lt;/em&gt;, and then doubled in size to</span>
<span class="source-line-no">032</span><span id="line.32"> * accommodate new entries. If the table is emptied below &lt;em&gt;one fourth&lt;/em&gt; of</span>
<span class="source-line-no">033</span><span id="line.33"> * the load factor, it is halved in size. However, halving is not performed when</span>
<span class="source-line-no">034</span><span id="line.34"> * deleting entries from an iterator, as it would interfere with the iteration</span>
<span class="source-line-no">035</span><span id="line.35"> * process.</span>
<span class="source-line-no">036</span><span id="line.36"> * &lt;/p&gt;</span>
<span class="source-line-no">037</span><span id="line.37"> * &lt;p&gt;</span>
<span class="source-line-no">038</span><span id="line.38"> * Note that {@link #clear()} does not modify the hash table size. Rather, a</span>
<span class="source-line-no">039</span><span id="line.39"> * family of {@linkplain #trim() trimming methods} lets you control the size of</span>
<span class="source-line-no">040</span><span id="line.40"> * the table; this is particularly useful if you reuse instances of this class.</span>
<span class="source-line-no">041</span><span id="line.41"> * &lt;/p&gt;</span>
<span class="source-line-no">042</span><span id="line.42"> * &lt;p&gt;</span>
<span class="source-line-no">043</span><span id="line.43"> * This class implements the interface of a Set, not a SortedSet.</span>
<span class="source-line-no">044</span><span id="line.44"> * &lt;p&gt;</span>
<span class="source-line-no">045</span><span id="line.45"> * &lt;p&gt;</span>
<span class="source-line-no">046</span><span id="line.46"> * You can pass an {@link CrossHash.IHasher} instance such as {@link CrossHash#generalHasher} as an extra parameter to</span>
<span class="source-line-no">047</span><span id="line.47"> * most of this class' constructors, which allows the OrderedSet to use arrays (usually primitive arrays) as items. If</span>
<span class="source-line-no">048</span><span id="line.48"> * you expect only one type of array, you can use an instance like {@link CrossHash#intHasher} to hash int arrays, or</span>
<span class="source-line-no">049</span><span id="line.49"> * the aforementioned generalHasher to hash most kinds of arrays (it can't handle most multi-dimensional arrays well).</span>
<span class="source-line-no">050</span><span id="line.50"> * If you aren't using array items, you don't need to give an IHasher to the constructor and can ignore this feature.</span>
<span class="source-line-no">051</span><span id="line.51"> * &lt;/p&gt;</span>
<span class="source-line-no">052</span><span id="line.52"> * &lt;br&gt;</span>
<span class="source-line-no">053</span><span id="line.53"> * Thank you, Sebastiano Vigna, for making FastUtil available to the public with such high quality.</span>
<span class="source-line-no">054</span><span id="line.54"> * &lt;br&gt;</span>
<span class="source-line-no">055</span><span id="line.55"> * See https://github.com/vigna/fastutil for the original library.</span>
<span class="source-line-no">056</span><span id="line.56"> *</span>
<span class="source-line-no">057</span><span id="line.57"> * @author Sebastiano Vigna (responsible for all the hard parts)</span>
<span class="source-line-no">058</span><span id="line.58"> * @author Tommy Ettinger (mostly responsible for squashing several layers of parent classes into one monster class)</span>
<span class="source-line-no">059</span><span id="line.59"> */</span>
<span class="source-line-no">060</span><span id="line.60">public class UnorderedSet&lt;K&gt; implements Set&lt;K&gt;, java.io.Serializable, Cloneable {</span>
<span class="source-line-no">061</span><span id="line.61">    private static final long serialVersionUID = 0L;</span>
<span class="source-line-no">062</span><span id="line.62">    /**</span>
<span class="source-line-no">063</span><span id="line.63">     * The array of keys.</span>
<span class="source-line-no">064</span><span id="line.64">     */</span>
<span class="source-line-no">065</span><span id="line.65">    protected K[] key;</span>
<span class="source-line-no">066</span><span id="line.66">    /*</span>
<span class="source-line-no">067</span><span id="line.67">      The array of values.</span>
<span class="source-line-no">068</span><span id="line.68">     */</span>
<span class="source-line-no">069</span><span id="line.69">    //protected V[] value;</span>
<span class="source-line-no">070</span><span id="line.70">    /**</span>
<span class="source-line-no">071</span><span id="line.71">     * The mask for wrapping a position counter.</span>
<span class="source-line-no">072</span><span id="line.72">     */</span>
<span class="source-line-no">073</span><span id="line.73">    protected int mask;</span>
<span class="source-line-no">074</span><span id="line.74">    /**</span>
<span class="source-line-no">075</span><span id="line.75">     * Whether this set contains the key zero.</span>
<span class="source-line-no">076</span><span id="line.76">     */</span>
<span class="source-line-no">077</span><span id="line.77">    protected boolean containsNull;</span>
<span class="source-line-no">078</span><span id="line.78">    /**</span>
<span class="source-line-no">079</span><span id="line.79">     * The current table size.</span>
<span class="source-line-no">080</span><span id="line.80">     */</span>
<span class="source-line-no">081</span><span id="line.81">    protected int n;</span>
<span class="source-line-no">082</span><span id="line.82">    /**</span>
<span class="source-line-no">083</span><span id="line.83">     * Threshold after which we rehash. It must be the table size times {@link #f}.</span>
<span class="source-line-no">084</span><span id="line.84">     */</span>
<span class="source-line-no">085</span><span id="line.85">    protected int maxFill;</span>
<span class="source-line-no">086</span><span id="line.86">    /**</span>
<span class="source-line-no">087</span><span id="line.87">     * Number of entries in the set (including the key zero, if present).</span>
<span class="source-line-no">088</span><span id="line.88">     */</span>
<span class="source-line-no">089</span><span id="line.89">    protected int size;</span>
<span class="source-line-no">090</span><span id="line.90">    /**</span>
<span class="source-line-no">091</span><span id="line.91">     * The acceptable load factor.</span>
<span class="source-line-no">092</span><span id="line.92">     */</span>
<span class="source-line-no">093</span><span id="line.93">    public final float f;</span>
<span class="source-line-no">094</span><span id="line.94"></span>
<span class="source-line-no">095</span><span id="line.95">    /**</span>
<span class="source-line-no">096</span><span id="line.96">     * The initial default size of a hash table.</span>
<span class="source-line-no">097</span><span id="line.97">     */</span>
<span class="source-line-no">098</span><span id="line.98">    public static final int DEFAULT_INITIAL_SIZE = 16;</span>
<span class="source-line-no">099</span><span id="line.99">    /**</span>
<span class="source-line-no">100</span><span id="line.100">     * The default load factor of a hash table.</span>
<span class="source-line-no">101</span><span id="line.101">     */</span>
<span class="source-line-no">102</span><span id="line.102">    public static final float DEFAULT_LOAD_FACTOR = .25f; // .1875f; // .75f;</span>
<span class="source-line-no">103</span><span id="line.103">    /**</span>
<span class="source-line-no">104</span><span id="line.104">     * The load factor for a (usually small) table that is meant to be particularly fast.</span>
<span class="source-line-no">105</span><span id="line.105">     */</span>
<span class="source-line-no">106</span><span id="line.106">    public static final float FAST_LOAD_FACTOR = .5f;</span>
<span class="source-line-no">107</span><span id="line.107">    /**</span>
<span class="source-line-no">108</span><span id="line.108">     * The load factor for a (usually very small) table that is meant to be extremely fast.</span>
<span class="source-line-no">109</span><span id="line.109">     */</span>
<span class="source-line-no">110</span><span id="line.110">    public static final float VERY_FAST_LOAD_FACTOR = .25f;</span>
<span class="source-line-no">111</span><span id="line.111"></span>
<span class="source-line-no">112</span><span id="line.112">    protected final CrossHash.IHasher hasher;</span>
<span class="source-line-no">113</span><span id="line.113"></span>
<span class="source-line-no">114</span><span id="line.114">    /**</span>
<span class="source-line-no">115</span><span id="line.115">     * Creates a new hash map.</span>
<span class="source-line-no">116</span><span id="line.116">     * &lt;p&gt;</span>
<span class="source-line-no">117</span><span id="line.117">     * &lt;p&gt;The actual table size will be the least power of two greater than &lt;code&gt;expected&lt;/code&gt;/&lt;code&gt;f&lt;/code&gt;.</span>
<span class="source-line-no">118</span><span id="line.118">     *</span>
<span class="source-line-no">119</span><span id="line.119">     * @param expected the expected number of elements in the hash set.</span>
<span class="source-line-no">120</span><span id="line.120">     * @param f        the load factor.</span>
<span class="source-line-no">121</span><span id="line.121">     */</span>
<span class="source-line-no">122</span><span id="line.122"></span>
<span class="source-line-no">123</span><span id="line.123">    @SuppressWarnings("unchecked")</span>
<span class="source-line-no">124</span><span id="line.124">    public UnorderedSet(final int expected, final float f) {</span>
<span class="source-line-no">125</span><span id="line.125">        if (f &lt;= 0 || f &gt; 1)</span>
<span class="source-line-no">126</span><span id="line.126">            throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than or equal to 1");</span>
<span class="source-line-no">127</span><span id="line.127">        if (expected &lt; 0) throw new IllegalArgumentException("The expected number of elements must be nonnegative");</span>
<span class="source-line-no">128</span><span id="line.128">        this.f = f;</span>
<span class="source-line-no">129</span><span id="line.129">        n = arraySize(expected, f);</span>
<span class="source-line-no">130</span><span id="line.130">        mask = n - 1;</span>
<span class="source-line-no">131</span><span id="line.131">        maxFill = maxFill(n, f);</span>
<span class="source-line-no">132</span><span id="line.132">        key = (K[]) new Object[n + 1];</span>
<span class="source-line-no">133</span><span id="line.133">        hasher = CrossHash.mildHasher;</span>
<span class="source-line-no">134</span><span id="line.134">    }</span>
<span class="source-line-no">135</span><span id="line.135"></span>
<span class="source-line-no">136</span><span id="line.136">    /**</span>
<span class="source-line-no">137</span><span id="line.137">     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load</span>
<span class="source-line-no">138</span><span id="line.138">     * factor.</span>
<span class="source-line-no">139</span><span id="line.139">     *</span>
<span class="source-line-no">140</span><span id="line.140">     * @param expected the expected number of elements in the hash set.</span>
<span class="source-line-no">141</span><span id="line.141">     */</span>
<span class="source-line-no">142</span><span id="line.142">    public UnorderedSet(final int expected) {</span>
<span class="source-line-no">143</span><span id="line.143">        this(expected, DEFAULT_LOAD_FACTOR);</span>
<span class="source-line-no">144</span><span id="line.144">    }</span>
<span class="source-line-no">145</span><span id="line.145"></span>
<span class="source-line-no">146</span><span id="line.146">    /**</span>
<span class="source-line-no">147</span><span id="line.147">     * Creates a new hash set with initial expected</span>
<span class="source-line-no">148</span><span id="line.148">     * {@link #DEFAULT_INITIAL_SIZE} elements and</span>
<span class="source-line-no">149</span><span id="line.149">     * {@link #DEFAULT_LOAD_FACTOR} as load factor.</span>
<span class="source-line-no">150</span><span id="line.150">     */</span>
<span class="source-line-no">151</span><span id="line.151">    public UnorderedSet() {</span>
<span class="source-line-no">152</span><span id="line.152">        this(DEFAULT_INITIAL_SIZE, DEFAULT_LOAD_FACTOR);</span>
<span class="source-line-no">153</span><span id="line.153">    }</span>
<span class="source-line-no">154</span><span id="line.154"></span>
<span class="source-line-no">155</span><span id="line.155">    /**</span>
<span class="source-line-no">156</span><span id="line.156">     * Creates a new hash set copying a given collection.</span>
<span class="source-line-no">157</span><span id="line.157">     *</span>
<span class="source-line-no">158</span><span id="line.158">     * @param c a {@link Collection} to be copied into the new hash set.</span>
<span class="source-line-no">159</span><span id="line.159">     * @param f the load factor.</span>
<span class="source-line-no">160</span><span id="line.160">     */</span>
<span class="source-line-no">161</span><span id="line.161">    public UnorderedSet(final Collection&lt;? extends K&gt; c,</span>
<span class="source-line-no">162</span><span id="line.162">                        final float f) {</span>
<span class="source-line-no">163</span><span id="line.163">        this(c.size(), f, (c instanceof UnorderedSet) ? ((UnorderedSet) c).hasher : CrossHash.mildHasher);</span>
<span class="source-line-no">164</span><span id="line.164">        addAll(c);</span>
<span class="source-line-no">165</span><span id="line.165">    }</span>
<span class="source-line-no">166</span><span id="line.166"></span>
<span class="source-line-no">167</span><span id="line.167">    /**</span>
<span class="source-line-no">168</span><span id="line.168">     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load</span>
<span class="source-line-no">169</span><span id="line.169">     * factor copying a given collection.</span>
<span class="source-line-no">170</span><span id="line.170">     *</span>
<span class="source-line-no">171</span><span id="line.171">     * @param c a {@link Collection} to be copied into the new hash set.</span>
<span class="source-line-no">172</span><span id="line.172">     */</span>
<span class="source-line-no">173</span><span id="line.173">    public UnorderedSet(final Collection&lt;? extends K&gt; c) {</span>
<span class="source-line-no">174</span><span id="line.174">        this(c, (c instanceof UnorderedSet) ? ((UnorderedSet) c).f : DEFAULT_LOAD_FACTOR, (c instanceof UnorderedSet) ? ((UnorderedSet) c).hasher : CrossHash.mildHasher);</span>
<span class="source-line-no">175</span><span id="line.175">    }</span>
<span class="source-line-no">176</span><span id="line.176"></span>
<span class="source-line-no">177</span><span id="line.177">    /**</span>
<span class="source-line-no">178</span><span id="line.178">     * Creates a new hash set using elements provided by a type-specific</span>
<span class="source-line-no">179</span><span id="line.179">     * iterator.</span>
<span class="source-line-no">180</span><span id="line.180">     *</span>
<span class="source-line-no">181</span><span id="line.181">     * @param i a type-specific iterator whose elements will fill the set.</span>
<span class="source-line-no">182</span><span id="line.182">     * @param f the load factor.</span>
<span class="source-line-no">183</span><span id="line.183">     */</span>
<span class="source-line-no">184</span><span id="line.184">    public UnorderedSet(final Iterator&lt;? extends K&gt; i, final float f) {</span>
<span class="source-line-no">185</span><span id="line.185">        this(DEFAULT_INITIAL_SIZE, f);</span>
<span class="source-line-no">186</span><span id="line.186">        while (i.hasNext())</span>
<span class="source-line-no">187</span><span id="line.187">            add(i.next());</span>
<span class="source-line-no">188</span><span id="line.188">    }</span>
<span class="source-line-no">189</span><span id="line.189"></span>
<span class="source-line-no">190</span><span id="line.190">    /**</span>
<span class="source-line-no">191</span><span id="line.191">     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load</span>
<span class="source-line-no">192</span><span id="line.192">     * factor using elements provided by a type-specific iterator.</span>
<span class="source-line-no">193</span><span id="line.193">     *</span>
<span class="source-line-no">194</span><span id="line.194">     * @param i a type-specific iterator whose elements will fill the set.</span>
<span class="source-line-no">195</span><span id="line.195">     */</span>
<span class="source-line-no">196</span><span id="line.196">    public UnorderedSet(final Iterator&lt;? extends K&gt; i) {</span>
<span class="source-line-no">197</span><span id="line.197">        this(i, DEFAULT_LOAD_FACTOR);</span>
<span class="source-line-no">198</span><span id="line.198">    }</span>
<span class="source-line-no">199</span><span id="line.199"></span>
<span class="source-line-no">200</span><span id="line.200">    /**</span>
<span class="source-line-no">201</span><span id="line.201">     * Creates a new hash set and fills it with the elements of a given array.</span>
<span class="source-line-no">202</span><span id="line.202">     *</span>
<span class="source-line-no">203</span><span id="line.203">     * @param a      an array whose elements will be used to fill the set.</span>
<span class="source-line-no">204</span><span id="line.204">     * @param offset the first element to use.</span>
<span class="source-line-no">205</span><span id="line.205">     * @param length the number of elements to use.</span>
<span class="source-line-no">206</span><span id="line.206">     * @param f      the load factor.</span>
<span class="source-line-no">207</span><span id="line.207">     */</span>
<span class="source-line-no">208</span><span id="line.208">    public UnorderedSet(final K[] a, final int offset,</span>
<span class="source-line-no">209</span><span id="line.209">                        final int length, final float f) {</span>
<span class="source-line-no">210</span><span id="line.210">        this(Math.max(length, 0), f);</span>
<span class="source-line-no">211</span><span id="line.211">        if (a == null) throw new NullPointerException("Array passed to OrderedSet constructor cannot be null");</span>
<span class="source-line-no">212</span><span id="line.212">        if (offset &lt; 0) throw new ArrayIndexOutOfBoundsException("Offset (" + offset + ") is negative");</span>
<span class="source-line-no">213</span><span id="line.213">        if (length &lt; 0) throw new IllegalArgumentException("Length (" + length + ") is negative");</span>
<span class="source-line-no">214</span><span id="line.214">        if (offset + length &gt; a.length) {</span>
<span class="source-line-no">215</span><span id="line.215">            throw new ArrayIndexOutOfBoundsException(</span>
<span class="source-line-no">216</span><span id="line.216">                    "Last index (" + (offset + length) + ") is greater than array length (" + a.length + ")");</span>
<span class="source-line-no">217</span><span id="line.217">        }</span>
<span class="source-line-no">218</span><span id="line.218">        for (int i = 0; i &lt; length; i++)</span>
<span class="source-line-no">219</span><span id="line.219">            add(a[offset + i]);</span>
<span class="source-line-no">220</span><span id="line.220">    }</span>
<span class="source-line-no">221</span><span id="line.221"></span>
<span class="source-line-no">222</span><span id="line.222">    /**</span>
<span class="source-line-no">223</span><span id="line.223">     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load</span>
<span class="source-line-no">224</span><span id="line.224">     * factor and fills it with the elements of a given array.</span>
<span class="source-line-no">225</span><span id="line.225">     *</span>
<span class="source-line-no">226</span><span id="line.226">     * @param a      an array whose elements will be used to fill the set.</span>
<span class="source-line-no">227</span><span id="line.227">     * @param offset the first element to use.</span>
<span class="source-line-no">228</span><span id="line.228">     * @param length the number of elements to use.</span>
<span class="source-line-no">229</span><span id="line.229">     */</span>
<span class="source-line-no">230</span><span id="line.230">    public UnorderedSet(final K[] a, final int offset,</span>
<span class="source-line-no">231</span><span id="line.231">                        final int length) {</span>
<span class="source-line-no">232</span><span id="line.232">        this(a, offset, length, DEFAULT_LOAD_FACTOR);</span>
<span class="source-line-no">233</span><span id="line.233">    }</span>
<span class="source-line-no">234</span><span id="line.234"></span>
<span class="source-line-no">235</span><span id="line.235">    /**</span>
<span class="source-line-no">236</span><span id="line.236">     * Creates a new hash set copying the elements of an array.</span>
<span class="source-line-no">237</span><span id="line.237">     *</span>
<span class="source-line-no">238</span><span id="line.238">     * @param a an array to be copied into the new hash set.</span>
<span class="source-line-no">239</span><span id="line.239">     * @param f the load factor.</span>
<span class="source-line-no">240</span><span id="line.240">     */</span>
<span class="source-line-no">241</span><span id="line.241">    public UnorderedSet(final K[] a, final float f) {</span>
<span class="source-line-no">242</span><span id="line.242">        this(a, 0, a.length, f);</span>
<span class="source-line-no">243</span><span id="line.243">    }</span>
<span class="source-line-no">244</span><span id="line.244"></span>
<span class="source-line-no">245</span><span id="line.245">    /**</span>
<span class="source-line-no">246</span><span id="line.246">     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load</span>
<span class="source-line-no">247</span><span id="line.247">     * factor copying the elements of an array.</span>
<span class="source-line-no">248</span><span id="line.248">     *</span>
<span class="source-line-no">249</span><span id="line.249">     * @param a an array to be copied into the new hash set.</span>
<span class="source-line-no">250</span><span id="line.250">     */</span>
<span class="source-line-no">251</span><span id="line.251">    public UnorderedSet(final K[] a) {</span>
<span class="source-line-no">252</span><span id="line.252">        this(a, DEFAULT_LOAD_FACTOR);</span>
<span class="source-line-no">253</span><span id="line.253">    }</span>
<span class="source-line-no">254</span><span id="line.254"></span>
<span class="source-line-no">255</span><span id="line.255">    /**</span>
<span class="source-line-no">256</span><span id="line.256">     * Creates a new hash map.</span>
<span class="source-line-no">257</span><span id="line.257">     * &lt;p&gt;</span>
<span class="source-line-no">258</span><span id="line.258">     * &lt;p&gt;The actual table size will be the least power of two greater than &lt;code&gt;expected&lt;/code&gt;/&lt;code&gt;f&lt;/code&gt;.</span>
<span class="source-line-no">259</span><span id="line.259">     *</span>
<span class="source-line-no">260</span><span id="line.260">     * @param expected the expected number of elements in the hash set.</span>
<span class="source-line-no">261</span><span id="line.261">     * @param f        the load factor.</span>
<span class="source-line-no">262</span><span id="line.262">     * @param hasher   used to hash items; typically only needed when K is an array, where CrossHash has implementations</span>
<span class="source-line-no">263</span><span id="line.263">     */</span>
<span class="source-line-no">264</span><span id="line.264">    @SuppressWarnings("unchecked")</span>
<span class="source-line-no">265</span><span id="line.265">    public UnorderedSet(final int expected, final float f, CrossHash.IHasher hasher) {</span>
<span class="source-line-no">266</span><span id="line.266">        if (f &lt;= 0 || f &gt; 1)</span>
<span class="source-line-no">267</span><span id="line.267">            throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than or equal to 1");</span>
<span class="source-line-no">268</span><span id="line.268">        if (expected &lt; 0) throw new IllegalArgumentException("The expected number of elements must be nonnegative");</span>
<span class="source-line-no">269</span><span id="line.269">        this.f = f;</span>
<span class="source-line-no">270</span><span id="line.270">        n = arraySize(expected, f);</span>
<span class="source-line-no">271</span><span id="line.271">        mask = n - 1;</span>
<span class="source-line-no">272</span><span id="line.272">        maxFill = maxFill(n, f);</span>
<span class="source-line-no">273</span><span id="line.273">        key = (K[]) new Object[n + 1];</span>
<span class="source-line-no">274</span><span id="line.274">        this.hasher = hasher == null ? CrossHash.mildHasher : hasher;</span>
<span class="source-line-no">275</span><span id="line.275">    }</span>
<span class="source-line-no">276</span><span id="line.276"></span>
<span class="source-line-no">277</span><span id="line.277">    /**</span>
<span class="source-line-no">278</span><span id="line.278">     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load</span>
<span class="source-line-no">279</span><span id="line.279">     * factor.</span>
<span class="source-line-no">280</span><span id="line.280">     *</span>
<span class="source-line-no">281</span><span id="line.281">     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations</span>
<span class="source-line-no">282</span><span id="line.282">     */</span>
<span class="source-line-no">283</span><span id="line.283">    public UnorderedSet(CrossHash.IHasher hasher) {</span>
<span class="source-line-no">284</span><span id="line.284">        this(DEFAULT_INITIAL_SIZE, DEFAULT_LOAD_FACTOR, hasher);</span>
<span class="source-line-no">285</span><span id="line.285">    }</span>
<span class="source-line-no">286</span><span id="line.286"></span>
<span class="source-line-no">287</span><span id="line.287">    /**</span>
<span class="source-line-no">288</span><span id="line.288">     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load</span>
<span class="source-line-no">289</span><span id="line.289">     * factor.</span>
<span class="source-line-no">290</span><span id="line.290">     *</span>
<span class="source-line-no">291</span><span id="line.291">     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations</span>
<span class="source-line-no">292</span><span id="line.292">     */</span>
<span class="source-line-no">293</span><span id="line.293">    public UnorderedSet(final int expected, CrossHash.IHasher hasher) {</span>
<span class="source-line-no">294</span><span id="line.294">        this(expected, DEFAULT_LOAD_FACTOR, hasher);</span>
<span class="source-line-no">295</span><span id="line.295">    }</span>
<span class="source-line-no">296</span><span id="line.296"></span>
<span class="source-line-no">297</span><span id="line.297">    /**</span>
<span class="source-line-no">298</span><span id="line.298">     * Creates a new hash set copying a given collection.</span>
<span class="source-line-no">299</span><span id="line.299">     *</span>
<span class="source-line-no">300</span><span id="line.300">     * @param c      a {@link Collection} to be copied into the new hash set.</span>
<span class="source-line-no">301</span><span id="line.301">     * @param f      the load factor.</span>
<span class="source-line-no">302</span><span id="line.302">     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations</span>
<span class="source-line-no">303</span><span id="line.303">     */</span>
<span class="source-line-no">304</span><span id="line.304">    public UnorderedSet(final Collection&lt;? extends K&gt; c,</span>
<span class="source-line-no">305</span><span id="line.305">                        final float f, CrossHash.IHasher hasher) {</span>
<span class="source-line-no">306</span><span id="line.306">        this(c.size(), f, hasher);</span>
<span class="source-line-no">307</span><span id="line.307">        addAll(c);</span>
<span class="source-line-no">308</span><span id="line.308">    }</span>
<span class="source-line-no">309</span><span id="line.309"></span>
<span class="source-line-no">310</span><span id="line.310">    /**</span>
<span class="source-line-no">311</span><span id="line.311">     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load</span>
<span class="source-line-no">312</span><span id="line.312">     * factor copying a given collection.</span>
<span class="source-line-no">313</span><span id="line.313">     *</span>
<span class="source-line-no">314</span><span id="line.314">     * @param c      a {@link Collection} to be copied into the new hash set.</span>
<span class="source-line-no">315</span><span id="line.315">     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations</span>
<span class="source-line-no">316</span><span id="line.316">     */</span>
<span class="source-line-no">317</span><span id="line.317">    public UnorderedSet(final Collection&lt;? extends K&gt; c, CrossHash.IHasher hasher) {</span>
<span class="source-line-no">318</span><span id="line.318">        this(c, DEFAULT_LOAD_FACTOR, hasher);</span>
<span class="source-line-no">319</span><span id="line.319">    }</span>
<span class="source-line-no">320</span><span id="line.320"></span>
<span class="source-line-no">321</span><span id="line.321">    /**</span>
<span class="source-line-no">322</span><span id="line.322">     * Creates a new hash set and fills it with the elements of a given array.</span>
<span class="source-line-no">323</span><span id="line.323">     *</span>
<span class="source-line-no">324</span><span id="line.324">     * @param a      an array whose elements will be used to fill the set.</span>
<span class="source-line-no">325</span><span id="line.325">     * @param offset the first element to use.</span>
<span class="source-line-no">326</span><span id="line.326">     * @param length the number of elements to use.</span>
<span class="source-line-no">327</span><span id="line.327">     * @param f      the load factor.</span>
<span class="source-line-no">328</span><span id="line.328">     */</span>
<span class="source-line-no">329</span><span id="line.329">    public UnorderedSet(final K[] a, final int offset,</span>
<span class="source-line-no">330</span><span id="line.330">                        final int length, final float f, CrossHash.IHasher hasher) {</span>
<span class="source-line-no">331</span><span id="line.331">        this(Math.max(length, 0), f, hasher);</span>
<span class="source-line-no">332</span><span id="line.332">        if (a == null) throw new NullPointerException("Array passed to OrderedSet constructor cannot be null");</span>
<span class="source-line-no">333</span><span id="line.333">        if (offset &lt; 0) throw new ArrayIndexOutOfBoundsException("Offset (" + offset + ") is negative");</span>
<span class="source-line-no">334</span><span id="line.334">        if (length &lt; 0) throw new IllegalArgumentException("Length (" + length + ") is negative");</span>
<span class="source-line-no">335</span><span id="line.335">        if (offset + length &gt; a.length) {</span>
<span class="source-line-no">336</span><span id="line.336">            throw new ArrayIndexOutOfBoundsException(</span>
<span class="source-line-no">337</span><span id="line.337">                    "Last index (" + (offset + length) + ") is greater than array length (" + a.length + ")");</span>
<span class="source-line-no">338</span><span id="line.338">        }</span>
<span class="source-line-no">339</span><span id="line.339">        for (int i = 0; i &lt; length; i++)</span>
<span class="source-line-no">340</span><span id="line.340">            add(a[offset + i]);</span>
<span class="source-line-no">341</span><span id="line.341">    }</span>
<span class="source-line-no">342</span><span id="line.342"></span>
<span class="source-line-no">343</span><span id="line.343">    /**</span>
<span class="source-line-no">344</span><span id="line.344">     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load</span>
<span class="source-line-no">345</span><span id="line.345">     * factor and fills it with the elements of a given array.</span>
<span class="source-line-no">346</span><span id="line.346">     *</span>
<span class="source-line-no">347</span><span id="line.347">     * @param a      an array whose elements will be used to fill the set.</span>
<span class="source-line-no">348</span><span id="line.348">     * @param offset the first element to use.</span>
<span class="source-line-no">349</span><span id="line.349">     * @param length the number of elements to use.</span>
<span class="source-line-no">350</span><span id="line.350">     */</span>
<span class="source-line-no">351</span><span id="line.351">    public UnorderedSet(final K[] a, final int offset,</span>
<span class="source-line-no">352</span><span id="line.352">                        final int length, CrossHash.IHasher hasher) {</span>
<span class="source-line-no">353</span><span id="line.353">        this(a, offset, length, DEFAULT_LOAD_FACTOR, hasher);</span>
<span class="source-line-no">354</span><span id="line.354">    }</span>
<span class="source-line-no">355</span><span id="line.355"></span>
<span class="source-line-no">356</span><span id="line.356">    /**</span>
<span class="source-line-no">357</span><span id="line.357">     * Creates a new hash set copying the elements of an array.</span>
<span class="source-line-no">358</span><span id="line.358">     *</span>
<span class="source-line-no">359</span><span id="line.359">     * @param a an array to be copied into the new hash set.</span>
<span class="source-line-no">360</span><span id="line.360">     * @param f the load factor.</span>
<span class="source-line-no">361</span><span id="line.361">     */</span>
<span class="source-line-no">362</span><span id="line.362">    public UnorderedSet(final K[] a, final float f, CrossHash.IHasher hasher) {</span>
<span class="source-line-no">363</span><span id="line.363">        this(a, 0, a.length, f, hasher);</span>
<span class="source-line-no">364</span><span id="line.364">    }</span>
<span class="source-line-no">365</span><span id="line.365"></span>
<span class="source-line-no">366</span><span id="line.366">    /**</span>
<span class="source-line-no">367</span><span id="line.367">     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load</span>
<span class="source-line-no">368</span><span id="line.368">     * factor copying the elements of an array.</span>
<span class="source-line-no">369</span><span id="line.369">     *</span>
<span class="source-line-no">370</span><span id="line.370">     * @param a an array to be copied into the new hash set.</span>
<span class="source-line-no">371</span><span id="line.371">     */</span>
<span class="source-line-no">372</span><span id="line.372">    public UnorderedSet(final K[] a, CrossHash.IHasher hasher) {</span>
<span class="source-line-no">373</span><span id="line.373">        this(a, DEFAULT_LOAD_FACTOR, hasher);</span>
<span class="source-line-no">374</span><span id="line.374">    }</span>
<span class="source-line-no">375</span><span id="line.375"></span>
<span class="source-line-no">376</span><span id="line.376">    private int realSize() {</span>
<span class="source-line-no">377</span><span id="line.377">        return containsNull ? size - 1 : size;</span>
<span class="source-line-no">378</span><span id="line.378">    }</span>
<span class="source-line-no">379</span><span id="line.379"></span>
<span class="source-line-no">380</span><span id="line.380">    private void ensureCapacity(final int capacity) {</span>
<span class="source-line-no">381</span><span id="line.381">        final int needed = arraySize(capacity, f);</span>
<span class="source-line-no">382</span><span id="line.382">        if (needed &gt; n)</span>
<span class="source-line-no">383</span><span id="line.383">            rehash(needed);</span>
<span class="source-line-no">384</span><span id="line.384">    }</span>
<span class="source-line-no">385</span><span id="line.385"></span>
<span class="source-line-no">386</span><span id="line.386">    private void tryCapacity(final long capacity) {</span>
<span class="source-line-no">387</span><span id="line.387">        final int needed = (int) Math.min(</span>
<span class="source-line-no">388</span><span id="line.388">                1 &lt;&lt; 30,</span>
<span class="source-line-no">389</span><span id="line.389">                Math.max(2, HashCommon.nextPowerOfTwo((long) Math.ceil(capacity</span>
<span class="source-line-no">390</span><span id="line.390">                        / f))));</span>
<span class="source-line-no">391</span><span id="line.391">        if (needed &gt; n)</span>
<span class="source-line-no">392</span><span id="line.392">            rehash(needed);</span>
<span class="source-line-no">393</span><span id="line.393">    }</span>
<span class="source-line-no">394</span><span id="line.394"></span>
<span class="source-line-no">395</span><span id="line.395">    public boolean addAll(Collection&lt;? extends K&gt; c) {</span>
<span class="source-line-no">396</span><span id="line.396">        int n = c.size();</span>
<span class="source-line-no">397</span><span id="line.397">        // The resulting collection will be at least c.size() big</span>
<span class="source-line-no">398</span><span id="line.398">        if (f &lt;= .5)</span>
<span class="source-line-no">399</span><span id="line.399">            ensureCapacity(n); // The resulting collection will be sized</span>
<span class="source-line-no">400</span><span id="line.400">            // for c.size() elements</span>
<span class="source-line-no">401</span><span id="line.401">        else</span>
<span class="source-line-no">402</span><span id="line.402">            tryCapacity(size + n); // The resulting collection will be</span>
<span class="source-line-no">403</span><span id="line.403">        // tentatively sized for size() + c.size() elements</span>
<span class="source-line-no">404</span><span id="line.404">        boolean retVal = false;</span>
<span class="source-line-no">405</span><span id="line.405">        final Iterator&lt;? extends K&gt; i = c.iterator();</span>
<span class="source-line-no">406</span><span id="line.406">        while (n-- != 0)</span>
<span class="source-line-no">407</span><span id="line.407">            if (add(i.next()))</span>
<span class="source-line-no">408</span><span id="line.408">                retVal = true;</span>
<span class="source-line-no">409</span><span id="line.409">        return retVal;</span>
<span class="source-line-no">410</span><span id="line.410">    }</span>
<span class="source-line-no">411</span><span id="line.411"></span>
<span class="source-line-no">412</span><span id="line.412">    public boolean addAll(K[] a) {</span>
<span class="source-line-no">413</span><span id="line.413">        if(a == null)</span>
<span class="source-line-no">414</span><span id="line.414">            return false;</span>
<span class="source-line-no">415</span><span id="line.415">        int n = a.length;</span>
<span class="source-line-no">416</span><span id="line.416">        // The resulting collection will be at least a.length big</span>
<span class="source-line-no">417</span><span id="line.417">        if (f &lt;= .5)</span>
<span class="source-line-no">418</span><span id="line.418">            ensureCapacity(n); // The resulting collection will be sized</span>
<span class="source-line-no">419</span><span id="line.419">            // for a.length elements</span>
<span class="source-line-no">420</span><span id="line.420">        else</span>
<span class="source-line-no">421</span><span id="line.421">            tryCapacity(size + n); // The resulting collection will be</span>
<span class="source-line-no">422</span><span id="line.422">        // tentatively sized for size() + a.length elements</span>
<span class="source-line-no">423</span><span id="line.423">        boolean retVal = false;</span>
<span class="source-line-no">424</span><span id="line.424">        for (int i = 0; i &lt; n; i++) {</span>
<span class="source-line-no">425</span><span id="line.425">            if(add(a[i]))</span>
<span class="source-line-no">426</span><span id="line.426">                retVal = true;</span>
<span class="source-line-no">427</span><span id="line.427">        }</span>
<span class="source-line-no">428</span><span id="line.428">        return retVal;</span>
<span class="source-line-no">429</span><span id="line.429">    }</span>
<span class="source-line-no">430</span><span id="line.430"></span>
<span class="source-line-no">431</span><span id="line.431"></span>
<span class="source-line-no">432</span><span id="line.432">    public boolean add(final K k) {</span>
<span class="source-line-no">433</span><span id="line.433">        int pos;</span>
<span class="source-line-no">434</span><span id="line.434">        if (k == null) {</span>
<span class="source-line-no">435</span><span id="line.435">            if (containsNull)</span>
<span class="source-line-no">436</span><span id="line.436">                return false;</span>
<span class="source-line-no">437</span><span id="line.437">            containsNull = true;</span>
<span class="source-line-no">438</span><span id="line.438">        } else {</span>
<span class="source-line-no">439</span><span id="line.439">            K curr;</span>
<span class="source-line-no">440</span><span id="line.440">            final K[] key = this.key;</span>
<span class="source-line-no">441</span><span id="line.441">            // The starting point.</span>
<span class="source-line-no">442</span><span id="line.442">            if (!((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)) {</span>
<span class="source-line-no">443</span><span id="line.443">                if (hasher.areEqual(curr, k))</span>
<span class="source-line-no">444</span><span id="line.444">                    return false;</span>
<span class="source-line-no">445</span><span id="line.445">                while (!((curr = key[pos = pos + 1 &amp; mask]) == null))</span>
<span class="source-line-no">446</span><span id="line.446">                    if (hasher.areEqual(curr, k))</span>
<span class="source-line-no">447</span><span id="line.447">                        return false;</span>
<span class="source-line-no">448</span><span id="line.448">            }</span>
<span class="source-line-no">449</span><span id="line.449">            key[pos] = k;</span>
<span class="source-line-no">450</span><span id="line.450">        }</span>
<span class="source-line-no">451</span><span id="line.451">        if (size++ &gt;= maxFill)</span>
<span class="source-line-no">452</span><span id="line.452">            rehash(arraySize(size + 1, f));</span>
<span class="source-line-no">453</span><span id="line.453">        return true;</span>
<span class="source-line-no">454</span><span id="line.454">    }</span>
<span class="source-line-no">455</span><span id="line.455"></span>
<span class="source-line-no">456</span><span id="line.456">    /**</span>
<span class="source-line-no">457</span><span id="line.457">     * Add a random element if not present, get the existing value if already</span>
<span class="source-line-no">458</span><span id="line.458">     * present.</span>
<span class="source-line-no">459</span><span id="line.459">     * &lt;p&gt;</span>
<span class="source-line-no">460</span><span id="line.460">     * This is equivalent to (but faster than) doing a:</span>
<span class="source-line-no">461</span><span id="line.461">     * &lt;p&gt;</span>
<span class="source-line-no">462</span><span id="line.462">     * &lt;pre&gt;</span>
<span class="source-line-no">463</span><span id="line.463">     * K exist = set.get(k);</span>
<span class="source-line-no">464</span><span id="line.464">     * if (exist == null) {</span>
<span class="source-line-no">465</span><span id="line.465">     *  set.add(k);</span>
<span class="source-line-no">466</span><span id="line.466">     *  exist = k;</span>
<span class="source-line-no">467</span><span id="line.467">     * }</span>
<span class="source-line-no">468</span><span id="line.468">     * &lt;/pre&gt;</span>
<span class="source-line-no">469</span><span id="line.469">     */</span>
<span class="source-line-no">470</span><span id="line.470">    public K addOrGet(final K k) {</span>
<span class="source-line-no">471</span><span id="line.471">        int pos;</span>
<span class="source-line-no">472</span><span id="line.472">        if (k == null) {</span>
<span class="source-line-no">473</span><span id="line.473">            if (containsNull)</span>
<span class="source-line-no">474</span><span id="line.474">                return key[n];</span>
<span class="source-line-no">475</span><span id="line.475">            containsNull = true;</span>
<span class="source-line-no">476</span><span id="line.476">        } else {</span>
<span class="source-line-no">477</span><span id="line.477">            K curr;</span>
<span class="source-line-no">478</span><span id="line.478">            final K[] key = this.key;</span>
<span class="source-line-no">479</span><span id="line.479">            // The starting point.</span>
<span class="source-line-no">480</span><span id="line.480">            if (!((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)) {</span>
<span class="source-line-no">481</span><span id="line.481">                if (hasher.areEqual(curr, k))</span>
<span class="source-line-no">482</span><span id="line.482">                    return curr;</span>
<span class="source-line-no">483</span><span id="line.483">                while (!((curr = key[pos = pos + 1 &amp; mask]) == null))</span>
<span class="source-line-no">484</span><span id="line.484">                    if (hasher.areEqual(curr, k))</span>
<span class="source-line-no">485</span><span id="line.485">                        return curr;</span>
<span class="source-line-no">486</span><span id="line.486">            }</span>
<span class="source-line-no">487</span><span id="line.487">            key[pos] = k;</span>
<span class="source-line-no">488</span><span id="line.488">        }</span>
<span class="source-line-no">489</span><span id="line.489">        if (size++ &gt;= maxFill)</span>
<span class="source-line-no">490</span><span id="line.490">            rehash(arraySize(size + 1, f));</span>
<span class="source-line-no">491</span><span id="line.491">        return k;</span>
<span class="source-line-no">492</span><span id="line.492">    }</span>
<span class="source-line-no">493</span><span id="line.493"></span>
<span class="source-line-no">494</span><span id="line.494">    /**</span>
<span class="source-line-no">495</span><span id="line.495">     * Shifts left entries with the specified hash code, starting at the</span>
<span class="source-line-no">496</span><span id="line.496">     * specified position, and empties the resulting free entry.</span>
<span class="source-line-no">497</span><span id="line.497">     *</span>
<span class="source-line-no">498</span><span id="line.498">     * @param pos a starting position.</span>
<span class="source-line-no">499</span><span id="line.499">     */</span>
<span class="source-line-no">500</span><span id="line.500">    protected final void shiftKeys(int pos) {</span>
<span class="source-line-no">501</span><span id="line.501">        // Shift entries with the same hash.</span>
<span class="source-line-no">502</span><span id="line.502">        int last, slot;</span>
<span class="source-line-no">503</span><span id="line.503">        K curr;</span>
<span class="source-line-no">504</span><span id="line.504">        final K[] key = this.key;</span>
<span class="source-line-no">505</span><span id="line.505">        for (; ; ) {</span>
<span class="source-line-no">506</span><span id="line.506">            pos = (last = pos) + 1 &amp; mask;</span>
<span class="source-line-no">507</span><span id="line.507">            for (; ; ) {</span>
<span class="source-line-no">508</span><span id="line.508">                if ((curr = key[pos]) == null) {</span>
<span class="source-line-no">509</span><span id="line.509">                    key[last] = null;</span>
<span class="source-line-no">510</span><span id="line.510">                    return;</span>
<span class="source-line-no">511</span><span id="line.511">                }</span>
<span class="source-line-no">512</span><span id="line.512">                slot = (hasher.hash(curr))</span>
<span class="source-line-no">513</span><span id="line.513">                        &amp; mask;</span>
<span class="source-line-no">514</span><span id="line.514">                if (last &lt;= pos ? last &gt;= slot || slot &gt; pos : last &gt;= slot</span>
<span class="source-line-no">515</span><span id="line.515">                        &amp;&amp; slot &gt; pos)</span>
<span class="source-line-no">516</span><span id="line.516">                    break;</span>
<span class="source-line-no">517</span><span id="line.517">                pos = pos + 1 &amp; mask;</span>
<span class="source-line-no">518</span><span id="line.518">            }</span>
<span class="source-line-no">519</span><span id="line.519">            key[last] = curr;</span>
<span class="source-line-no">520</span><span id="line.520">        }</span>
<span class="source-line-no">521</span><span id="line.521">    }</span>
<span class="source-line-no">522</span><span id="line.522"></span>
<span class="source-line-no">523</span><span id="line.523">    private boolean removeEntry(final int pos) {</span>
<span class="source-line-no">524</span><span id="line.524">        size--;</span>
<span class="source-line-no">525</span><span id="line.525">        shiftKeys(pos);</span>
<span class="source-line-no">526</span><span id="line.526">        if (size &lt; maxFill / 4 &amp;&amp; n &gt; DEFAULT_INITIAL_SIZE)</span>
<span class="source-line-no">527</span><span id="line.527">            rehash(n / 2);</span>
<span class="source-line-no">528</span><span id="line.528">        return true;</span>
<span class="source-line-no">529</span><span id="line.529">    }</span>
<span class="source-line-no">530</span><span id="line.530"></span>
<span class="source-line-no">531</span><span id="line.531">    private boolean removeNullEntry() {</span>
<span class="source-line-no">532</span><span id="line.532">        containsNull = false;</span>
<span class="source-line-no">533</span><span id="line.533">        key[n] = null;</span>
<span class="source-line-no">534</span><span id="line.534">        size--;</span>
<span class="source-line-no">535</span><span id="line.535">        if (size &lt; maxFill / 4 &amp;&amp; n &gt; DEFAULT_INITIAL_SIZE)</span>
<span class="source-line-no">536</span><span id="line.536">            rehash(n / 2);</span>
<span class="source-line-no">537</span><span id="line.537">        return true;</span>
<span class="source-line-no">538</span><span id="line.538">    }</span>
<span class="source-line-no">539</span><span id="line.539"></span>
<span class="source-line-no">540</span><span id="line.540">    @Override</span>
<span class="source-line-no">541</span><span id="line.541">    public boolean remove(final Object k) {</span>
<span class="source-line-no">542</span><span id="line.542">        if (k == null)</span>
<span class="source-line-no">543</span><span id="line.543">            return containsNull &amp;&amp; removeNullEntry();</span>
<span class="source-line-no">544</span><span id="line.544">        K curr;</span>
<span class="source-line-no">545</span><span id="line.545">        final K[] key = this.key;</span>
<span class="source-line-no">546</span><span id="line.546">        int pos;</span>
<span class="source-line-no">547</span><span id="line.547">        // The starting point.</span>
<span class="source-line-no">548</span><span id="line.548">        if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)</span>
<span class="source-line-no">549</span><span id="line.549">            return false;</span>
<span class="source-line-no">550</span><span id="line.550">        if (hasher.areEqual(k, curr))</span>
<span class="source-line-no">551</span><span id="line.551">            return removeEntry(pos);</span>
<span class="source-line-no">552</span><span id="line.552">        while (true) {</span>
<span class="source-line-no">553</span><span id="line.553">            if ((curr = key[pos = pos + 1 &amp; mask]) == null)</span>
<span class="source-line-no">554</span><span id="line.554">                return false;</span>
<span class="source-line-no">555</span><span id="line.555">            if (hasher.areEqual(k, curr))</span>
<span class="source-line-no">556</span><span id="line.556">                return removeEntry(pos);</span>
<span class="source-line-no">557</span><span id="line.557">        }</span>
<span class="source-line-no">558</span><span id="line.558">    }</span>
<span class="source-line-no">559</span><span id="line.559"></span>
<span class="source-line-no">560</span><span id="line.560">    /**</span>
<span class="source-line-no">561</span><span id="line.561">     * Returns the element of this set that is equal to the given key, or</span>
<span class="source-line-no">562</span><span id="line.562">     * &lt;code&gt;null&lt;/code&gt;.</span>
<span class="source-line-no">563</span><span id="line.563">     *</span>
<span class="source-line-no">564</span><span id="line.564">     * @return the element of this set that is equal to the given key, or</span>
<span class="source-line-no">565</span><span id="line.565">     * &lt;code&gt;null&lt;/code&gt;.</span>
<span class="source-line-no">566</span><span id="line.566">     */</span>
<span class="source-line-no">567</span><span id="line.567">    public K get(final Object k) {</span>
<span class="source-line-no">568</span><span id="line.568">        if (k == null)</span>
<span class="source-line-no">569</span><span id="line.569">            return key[n]; // This is correct independently of the value of</span>
<span class="source-line-no">570</span><span id="line.570">        // containsNull and of the map being custom</span>
<span class="source-line-no">571</span><span id="line.571">        K curr;</span>
<span class="source-line-no">572</span><span id="line.572">        final K[] key = this.key;</span>
<span class="source-line-no">573</span><span id="line.573">        int pos;</span>
<span class="source-line-no">574</span><span id="line.574">        // The starting point.</span>
<span class="source-line-no">575</span><span id="line.575">        if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)</span>
<span class="source-line-no">576</span><span id="line.576">            return null;</span>
<span class="source-line-no">577</span><span id="line.577">        if (hasher.areEqual(k, curr))</span>
<span class="source-line-no">578</span><span id="line.578">            return curr;</span>
<span class="source-line-no">579</span><span id="line.579">        // There's always an unused entry.</span>
<span class="source-line-no">580</span><span id="line.580">        while (true) {</span>
<span class="source-line-no">581</span><span id="line.581">            if ((curr = key[pos = pos + 1 &amp; mask]) == null)</span>
<span class="source-line-no">582</span><span id="line.582">                return null;</span>
<span class="source-line-no">583</span><span id="line.583">            if (hasher.areEqual(k, curr))</span>
<span class="source-line-no">584</span><span id="line.584">                return curr;</span>
<span class="source-line-no">585</span><span id="line.585">        }</span>
<span class="source-line-no">586</span><span id="line.586">    }</span>
<span class="source-line-no">587</span><span id="line.587"></span>
<span class="source-line-no">588</span><span id="line.588">    public boolean contains(final Object k) {</span>
<span class="source-line-no">589</span><span id="line.589">        if (k == null)</span>
<span class="source-line-no">590</span><span id="line.590">            return containsNull;</span>
<span class="source-line-no">591</span><span id="line.591">        K curr;</span>
<span class="source-line-no">592</span><span id="line.592">        final K[] key = this.key;</span>
<span class="source-line-no">593</span><span id="line.593">        int pos;</span>
<span class="source-line-no">594</span><span id="line.594">        // The starting point.</span>
<span class="source-line-no">595</span><span id="line.595">        if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)</span>
<span class="source-line-no">596</span><span id="line.596">            return false;</span>
<span class="source-line-no">597</span><span id="line.597">        if (hasher.areEqual(k, curr))</span>
<span class="source-line-no">598</span><span id="line.598">            return true;</span>
<span class="source-line-no">599</span><span id="line.599">        // There's always an unused entry.</span>
<span class="source-line-no">600</span><span id="line.600">        while (true) {</span>
<span class="source-line-no">601</span><span id="line.601">            if ((curr = key[pos = pos + 1 &amp; mask]) == null)</span>
<span class="source-line-no">602</span><span id="line.602">                return false;</span>
<span class="source-line-no">603</span><span id="line.603">            if (hasher.areEqual(k, curr))</span>
<span class="source-line-no">604</span><span id="line.604">                return true;</span>
<span class="source-line-no">605</span><span id="line.605">        }</span>
<span class="source-line-no">606</span><span id="line.606">    }</span>
<span class="source-line-no">607</span><span id="line.607"></span>
<span class="source-line-no">608</span><span id="line.608">    protected int positionOf(final Object k) {</span>
<span class="source-line-no">609</span><span id="line.609">        if (k == null)</span>
<span class="source-line-no">610</span><span id="line.610">        {</span>
<span class="source-line-no">611</span><span id="line.611">            if(containsNull)</span>
<span class="source-line-no">612</span><span id="line.612">                return n;</span>
<span class="source-line-no">613</span><span id="line.613">            else</span>
<span class="source-line-no">614</span><span id="line.614">                return -1;</span>
<span class="source-line-no">615</span><span id="line.615">        }</span>
<span class="source-line-no">616</span><span id="line.616">        K curr;</span>
<span class="source-line-no">617</span><span id="line.617">        final K[] key = this.key;</span>
<span class="source-line-no">618</span><span id="line.618">        int pos;</span>
<span class="source-line-no">619</span><span id="line.619">        // The starting point.</span>
<span class="source-line-no">620</span><span id="line.620">        if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)</span>
<span class="source-line-no">621</span><span id="line.621">            return -1;</span>
<span class="source-line-no">622</span><span id="line.622">        if (hasher.areEqual(k, curr))</span>
<span class="source-line-no">623</span><span id="line.623">            return pos;</span>
<span class="source-line-no">624</span><span id="line.624">        // There's always an unused entry.</span>
<span class="source-line-no">625</span><span id="line.625">        while (true) {</span>
<span class="source-line-no">626</span><span id="line.626">            if ((curr = key[pos = pos + 1 &amp; mask]) == null)</span>
<span class="source-line-no">627</span><span id="line.627">                return -1;</span>
<span class="source-line-no">628</span><span id="line.628">            if (hasher.areEqual(k, curr))</span>
<span class="source-line-no">629</span><span id="line.629">                return pos;</span>
<span class="source-line-no">630</span><span id="line.630">        }</span>
<span class="source-line-no">631</span><span id="line.631">    }</span>
<span class="source-line-no">632</span><span id="line.632"></span>
<span class="source-line-no">633</span><span id="line.633">    /*</span>
<span class="source-line-no">634</span><span id="line.634">     * Removes all elements from this set.</span>
<span class="source-line-no">635</span><span id="line.635">     *</span>
<span class="source-line-no">636</span><span id="line.636">     * &lt;P&gt;To increase object reuse, this method does not change the table size.</span>
<span class="source-line-no">637</span><span id="line.637">     * If you want to reduce the table size, you must use {@link #trim()}.</span>
<span class="source-line-no">638</span><span id="line.638">     */</span>
<span class="source-line-no">639</span><span id="line.639">    public void clear() {</span>
<span class="source-line-no">640</span><span id="line.640">        if (size == 0)</span>
<span class="source-line-no">641</span><span id="line.641">            return;</span>
<span class="source-line-no">642</span><span id="line.642">        size = 0;</span>
<span class="source-line-no">643</span><span id="line.643">        containsNull = false;</span>
<span class="source-line-no">644</span><span id="line.644">        Arrays.fill(key, null);</span>
<span class="source-line-no">645</span><span id="line.645">    }</span>
<span class="source-line-no">646</span><span id="line.646"></span>
<span class="source-line-no">647</span><span id="line.647">    public int size() {</span>
<span class="source-line-no">648</span><span id="line.648">        return size;</span>
<span class="source-line-no">649</span><span id="line.649">    }</span>
<span class="source-line-no">650</span><span id="line.650"></span>
<span class="source-line-no">651</span><span id="line.651">    /**</span>
<span class="source-line-no">652</span><span id="line.652">     * Checks whether this collection contains all elements from the given</span>
<span class="source-line-no">653</span><span id="line.653">     * collection.</span>
<span class="source-line-no">654</span><span id="line.654">     *</span>
<span class="source-line-no">655</span><span id="line.655">     * @param c a collection.</span>
<span class="source-line-no">656</span><span id="line.656">     * @return &lt;code&gt;true&lt;/code&gt; if this collection contains all elements of the</span>
<span class="source-line-no">657</span><span id="line.657">     * argument.</span>
<span class="source-line-no">658</span><span id="line.658">     */</span>
<span class="source-line-no">659</span><span id="line.659">    public boolean containsAll(Collection&lt;?&gt; c) {</span>
<span class="source-line-no">660</span><span id="line.660">        int n = c.size();</span>
<span class="source-line-no">661</span><span id="line.661">        final Iterator&lt;?&gt; i = c.iterator();</span>
<span class="source-line-no">662</span><span id="line.662">        while (n-- != 0)</span>
<span class="source-line-no">663</span><span id="line.663">            if (!contains(i.next()))</span>
<span class="source-line-no">664</span><span id="line.664">                return false;</span>
<span class="source-line-no">665</span><span id="line.665">        return true;</span>
<span class="source-line-no">666</span><span id="line.666">    }</span>
<span class="source-line-no">667</span><span id="line.667"></span>
<span class="source-line-no">668</span><span id="line.668">    /**</span>
<span class="source-line-no">669</span><span id="line.669">     * Retains in this collection only elements from the given collection.</span>
<span class="source-line-no">670</span><span id="line.670">     *</span>
<span class="source-line-no">671</span><span id="line.671">     * @param c a collection.</span>
<span class="source-line-no">672</span><span id="line.672">     * @return &lt;code&gt;true&lt;/code&gt; if this collection changed as a result of the</span>
<span class="source-line-no">673</span><span id="line.673">     * call.</span>
<span class="source-line-no">674</span><span id="line.674">     */</span>
<span class="source-line-no">675</span><span id="line.675">    public boolean retainAll(Collection&lt;?&gt; c) {</span>
<span class="source-line-no">676</span><span id="line.676">        boolean retVal = false;</span>
<span class="source-line-no">677</span><span id="line.677">        int n = size;</span>
<span class="source-line-no">678</span><span id="line.678">        final Iterator&lt;?&gt; i = iterator();</span>
<span class="source-line-no">679</span><span id="line.679">        while (n-- != 0) {</span>
<span class="source-line-no">680</span><span id="line.680">            if (!c.contains(i.next())) {</span>
<span class="source-line-no">681</span><span id="line.681">                i.remove();</span>
<span class="source-line-no">682</span><span id="line.682">                retVal = true;</span>
<span class="source-line-no">683</span><span id="line.683">            }</span>
<span class="source-line-no">684</span><span id="line.684">        }</span>
<span class="source-line-no">685</span><span id="line.685">        return retVal;</span>
<span class="source-line-no">686</span><span id="line.686">    }</span>
<span class="source-line-no">687</span><span id="line.687"></span>
<span class="source-line-no">688</span><span id="line.688">    /**</span>
<span class="source-line-no">689</span><span id="line.689">     * Remove from this collection all elements in the given collection. If the</span>
<span class="source-line-no">690</span><span id="line.690">     * collection is an instance of this class, it uses faster iterators.</span>
<span class="source-line-no">691</span><span id="line.691">     *</span>
<span class="source-line-no">692</span><span id="line.692">     * @param c a collection.</span>
<span class="source-line-no">693</span><span id="line.693">     * @return &lt;code&gt;true&lt;/code&gt; if this collection changed as a result of the</span>
<span class="source-line-no">694</span><span id="line.694">     * call.</span>
<span class="source-line-no">695</span><span id="line.695">     */</span>
<span class="source-line-no">696</span><span id="line.696">    public boolean removeAll(Collection&lt;?&gt; c) {</span>
<span class="source-line-no">697</span><span id="line.697">        boolean retVal = false;</span>
<span class="source-line-no">698</span><span id="line.698">        int n = c.size();</span>
<span class="source-line-no">699</span><span id="line.699">        final Iterator&lt;?&gt; i = c.iterator();</span>
<span class="source-line-no">700</span><span id="line.700">        while (n-- != 0)</span>
<span class="source-line-no">701</span><span id="line.701">            if (remove(i.next()))</span>
<span class="source-line-no">702</span><span id="line.702">                retVal = true;</span>
<span class="source-line-no">703</span><span id="line.703">        return retVal;</span>
<span class="source-line-no">704</span><span id="line.704">    }</span>
<span class="source-line-no">705</span><span id="line.705"></span>
<span class="source-line-no">706</span><span id="line.706">    public boolean isEmpty() {</span>
<span class="source-line-no">707</span><span id="line.707">        return size == 0;</span>
<span class="source-line-no">708</span><span id="line.708">    }</span>
<span class="source-line-no">709</span><span id="line.709"></span>
<span class="source-line-no">710</span><span id="line.710"></span>
<span class="source-line-no">711</span><span id="line.711">    /*</span>
<span class="source-line-no">712</span><span id="line.712">     * A list iterator over a set.</span>
<span class="source-line-no">713</span><span id="line.713">     * &lt;p&gt;</span>
<span class="source-line-no">714</span><span id="line.714">     * &lt;p&gt;</span>
<span class="source-line-no">715</span><span id="line.715">     * This class provides a list iterator over a hash set. The</span>
<span class="source-line-no">716</span><span id="line.716">     * constructor takes constant time.</span>
<span class="source-line-no">717</span><span id="line.717">     */</span>
<span class="source-line-no">718</span><span id="line.718">    private class SetIterator implements Iterator &lt;K&gt; {</span>
<span class="source-line-no">719</span><span id="line.719">        /** The index of the last entry returned, if positive or zero; initially, {@link #n}. If negative, the last</span>
<span class="source-line-no">720</span><span id="line.720">         element returned was that of index {@code - pos - 1} from the {@link #wrapped} list. */</span>
<span class="source-line-no">721</span><span id="line.721">        int pos = n;</span>
<span class="source-line-no">722</span><span id="line.722">        /** The index of the last entry that has been returned (more precisely, the value of {@link #pos} if {@link #pos} is positive,</span>
<span class="source-line-no">723</span><span id="line.723">         or {@link Integer#MIN_VALUE} if {@link #pos} is negative). It is -1 if either</span>
<span class="source-line-no">724</span><span id="line.724">         we did not return an entry yet, or the last returned entry has been removed. */</span>
<span class="source-line-no">725</span><span id="line.725">        int last = -1;</span>
<span class="source-line-no">726</span><span id="line.726">        /** A downward counter measuring how many entries must still be returned. */</span>
<span class="source-line-no">727</span><span id="line.727">        int c = size;</span>
<span class="source-line-no">728</span><span id="line.728">        /** A boolean telling us whether we should return the null key. */</span>
<span class="source-line-no">729</span><span id="line.729">        boolean mustReturnNull = UnorderedSet.this.containsNull;</span>
<span class="source-line-no">730</span><span id="line.730">        /** A lazily allocated list containing elements that have wrapped around the table because of removals. */</span>
<span class="source-line-no">731</span><span id="line.731">        ArrayList &lt;K&gt; wrapped;</span>
<span class="source-line-no">732</span><span id="line.732">        public boolean hasNext() {</span>
<span class="source-line-no">733</span><span id="line.733">            return c != 0;</span>
<span class="source-line-no">734</span><span id="line.734">        }</span>
<span class="source-line-no">735</span><span id="line.735">        public K next() {</span>
<span class="source-line-no">736</span><span id="line.736">            if ( ! hasNext() ) throw new NoSuchElementException();</span>
<span class="source-line-no">737</span><span id="line.737">            c--;</span>
<span class="source-line-no">738</span><span id="line.738">            if ( mustReturnNull ) {</span>
<span class="source-line-no">739</span><span id="line.739">                mustReturnNull = false;</span>
<span class="source-line-no">740</span><span id="line.740">                last = n;</span>
<span class="source-line-no">741</span><span id="line.741">                return key[ n ];</span>
<span class="source-line-no">742</span><span id="line.742">            }</span>
<span class="source-line-no">743</span><span id="line.743">            final K[] key = UnorderedSet.this.key;</span>
<span class="source-line-no">744</span><span id="line.744">            for(;;) {</span>
<span class="source-line-no">745</span><span id="line.745">                if ( --pos &lt; 0 ) {</span>
<span class="source-line-no">746</span><span id="line.746">                    // We are just enumerating elements from the wrapped list.</span>
<span class="source-line-no">747</span><span id="line.747">                    last = Integer.MIN_VALUE;</span>
<span class="source-line-no">748</span><span id="line.748">                    return wrapped.get( - pos - 1 );</span>
<span class="source-line-no">749</span><span id="line.749">                }</span>
<span class="source-line-no">750</span><span id="line.750">                if ( ! ( (key[ pos ]) == null ) ) return key[ last = pos ];</span>
<span class="source-line-no">751</span><span id="line.751">            }</span>
<span class="source-line-no">752</span><span id="line.752">        }</span>
<span class="source-line-no">753</span><span id="line.753">        /** Shifts left entries with the specified hash code, starting at the specified position,</span>
<span class="source-line-no">754</span><span id="line.754">         * and empties the resulting free entry.</span>
<span class="source-line-no">755</span><span id="line.755">         *</span>
<span class="source-line-no">756</span><span id="line.756">         * @param pos a starting position.</span>
<span class="source-line-no">757</span><span id="line.757">         */</span>
<span class="source-line-no">758</span><span id="line.758">        private void shiftKeys(int pos ) {</span>
<span class="source-line-no">759</span><span id="line.759">            // Shift entries with the same hash.</span>
<span class="source-line-no">760</span><span id="line.760">            int last, slot;</span>
<span class="source-line-no">761</span><span id="line.761">            K current;</span>
<span class="source-line-no">762</span><span id="line.762">            final K[] key = UnorderedSet.this.key;</span>
<span class="source-line-no">763</span><span id="line.763">            for(;;) {</span>
<span class="source-line-no">764</span><span id="line.764">                pos = ( ( last = pos ) + 1 ) &amp; mask;</span>
<span class="source-line-no">765</span><span id="line.765">                for(;;) {</span>
<span class="source-line-no">766</span><span id="line.766">                    if ( ( (current = key[ pos ]) == null ) ) {</span>
<span class="source-line-no">767</span><span id="line.767">                        key[ last ] = (null);</span>
<span class="source-line-no">768</span><span id="line.768">                        return;</span>
<span class="source-line-no">769</span><span id="line.769">                    }</span>
<span class="source-line-no">770</span><span id="line.770">                    slot = ( (hasher.hash(current)) ) &amp; mask;</span>
<span class="source-line-no">771</span><span id="line.771">                    if ( last &lt;= pos ? last &gt;= slot || slot &gt; pos : last &gt;= slot &amp;&amp; slot &gt; pos ) break;</span>
<span class="source-line-no">772</span><span id="line.772">                    pos = ( pos + 1 ) &amp; mask;</span>
<span class="source-line-no">773</span><span id="line.773">                }</span>
<span class="source-line-no">774</span><span id="line.774">                if ( pos &lt; last ) { // Wrapped entry.</span>
<span class="source-line-no">775</span><span id="line.775">                    if ( wrapped == null ) wrapped = new ArrayList&lt;K&gt;( 2 );</span>
<span class="source-line-no">776</span><span id="line.776">                    wrapped.add( key[ pos ] );</span>
<span class="source-line-no">777</span><span id="line.777">                }</span>
<span class="source-line-no">778</span><span id="line.778">                key[ last ] = current;</span>
<span class="source-line-no">779</span><span id="line.779">            }</span>
<span class="source-line-no">780</span><span id="line.780">        }</span>
<span class="source-line-no">781</span><span id="line.781">        public void remove() {</span>
<span class="source-line-no">782</span><span id="line.782">            if ( last == -1 ) throw new IllegalStateException();</span>
<span class="source-line-no">783</span><span id="line.783">            if ( last == n ) {</span>
<span class="source-line-no">784</span><span id="line.784">                UnorderedSet.this.containsNull = false;</span>
<span class="source-line-no">785</span><span id="line.785">                UnorderedSet.this.key[ n ] = (null);</span>
<span class="source-line-no">786</span><span id="line.786">            }</span>
<span class="source-line-no">787</span><span id="line.787">            else if ( pos &gt;= 0 ) shiftKeys( last );</span>
<span class="source-line-no">788</span><span id="line.788">            else {</span>
<span class="source-line-no">789</span><span id="line.789">                // We're removing wrapped entries.</span>
<span class="source-line-no">790</span><span id="line.790">                UnorderedSet.this.remove( wrapped.set( - pos - 1, null ) );</span>
<span class="source-line-no">791</span><span id="line.791">                last = -1; // Note that we must not decrement size</span>
<span class="source-line-no">792</span><span id="line.792">                return;</span>
<span class="source-line-no">793</span><span id="line.793">            }</span>
<span class="source-line-no">794</span><span id="line.794">            size--;</span>
<span class="source-line-no">795</span><span id="line.795">            last = -1; // You can no longer remove this entry.</span>
<span class="source-line-no">796</span><span id="line.796">        }</span>
<span class="source-line-no">797</span><span id="line.797">        /** This method just iterates the type-specific version of {@link #next()} for at most</span>
<span class="source-line-no">798</span><span id="line.798">         * &lt;code&gt;n&lt;/code&gt; times, stopping if {@link #hasNext()} becomes false.*/</span>
<span class="source-line-no">799</span><span id="line.799">        public int skip( final int n ) {</span>
<span class="source-line-no">800</span><span id="line.800">            int i = n;</span>
<span class="source-line-no">801</span><span id="line.801">            while( i-- != 0 &amp;&amp; hasNext() ) next();</span>
<span class="source-line-no">802</span><span id="line.802">            return n - i - 1;</span>
<span class="source-line-no">803</span><span id="line.803">        }</span>
<span class="source-line-no">804</span><span id="line.804">    }</span>
<span class="source-line-no">805</span><span id="line.805"></span>
<span class="source-line-no">806</span><span id="line.806">    public Iterator&lt;K&gt; iterator() {</span>
<span class="source-line-no">807</span><span id="line.807">        return new SetIterator();</span>
<span class="source-line-no">808</span><span id="line.808">    }</span>
<span class="source-line-no">809</span><span id="line.809"></span>
<span class="source-line-no">810</span><span id="line.810">    /**</span>
<span class="source-line-no">811</span><span id="line.811">     * Rehashes the map, making the table as small as possible.</span>
<span class="source-line-no">812</span><span id="line.812">     * &lt;p&gt;</span>
<span class="source-line-no">813</span><span id="line.813">     * &lt;P&gt;This method rehashes the table to the smallest size satisfying the load factor. It can be used when the set will not be changed anymore, so to optimize access speed and size.</span>
<span class="source-line-no">814</span><span id="line.814">     * &lt;p&gt;</span>
<span class="source-line-no">815</span><span id="line.815">     * &lt;P&gt;If the table size is already the minimum possible, this method does nothing.</span>
<span class="source-line-no">816</span><span id="line.816">     *</span>
<span class="source-line-no">817</span><span id="line.817">     * @return true if there was enough memory to trim the map.</span>
<span class="source-line-no">818</span><span id="line.818">     * @see #trim(int)</span>
<span class="source-line-no">819</span><span id="line.819">     */</span>
<span class="source-line-no">820</span><span id="line.820">    public boolean trim() {</span>
<span class="source-line-no">821</span><span id="line.821">        final int l = arraySize(size, f);</span>
<span class="source-line-no">822</span><span id="line.822">        if (l &gt;= n || size &gt; maxFill(l, f)) return true;</span>
<span class="source-line-no">823</span><span id="line.823">        try {</span>
<span class="source-line-no">824</span><span id="line.824">            rehash(l);</span>
<span class="source-line-no">825</span><span id="line.825">        } catch (Exception cantDoIt) {</span>
<span class="source-line-no">826</span><span id="line.826">            return false;</span>
<span class="source-line-no">827</span><span id="line.827">        }</span>
<span class="source-line-no">828</span><span id="line.828">        return true;</span>
<span class="source-line-no">829</span><span id="line.829">    }</span>
<span class="source-line-no">830</span><span id="line.830"></span>
<span class="source-line-no">831</span><span id="line.831">    /**</span>
<span class="source-line-no">832</span><span id="line.832">     * Rehashes this map if the table is too large.</span>
<span class="source-line-no">833</span><span id="line.833">     * &lt;p&gt;</span>
<span class="source-line-no">834</span><span id="line.834">     * &lt;P&gt;Let &lt;var&gt;N&lt;/var&gt; be the smallest table size that can hold &lt;code&gt;max(n,{@link #size()})&lt;/code&gt; entries, still satisfying the load factor. If the current table size is smaller than or equal to</span>
<span class="source-line-no">835</span><span id="line.835">     * &lt;var&gt;N&lt;/var&gt;, this method does nothing. Otherwise, it rehashes this map in a table of size &lt;var&gt;N&lt;/var&gt;.</span>
<span class="source-line-no">836</span><span id="line.836">     * &lt;p&gt;</span>
<span class="source-line-no">837</span><span id="line.837">     * &lt;P&gt;This method is useful when reusing maps. {@linkplain #clear() Clearing a map} leaves the table size untouched. If you are reusing a map many times, you can call this method with a typical</span>
<span class="source-line-no">838</span><span id="line.838">     * size to avoid keeping around a very large table just because of a few large transient maps.</span>
<span class="source-line-no">839</span><span id="line.839">     *</span>
<span class="source-line-no">840</span><span id="line.840">     * @param n the threshold for the trimming.</span>
<span class="source-line-no">841</span><span id="line.841">     * @return true if there was enough memory to trim the map.</span>
<span class="source-line-no">842</span><span id="line.842">     * @see #trim()</span>
<span class="source-line-no">843</span><span id="line.843">     */</span>
<span class="source-line-no">844</span><span id="line.844">    public boolean trim(final int n) {</span>
<span class="source-line-no">845</span><span id="line.845">        final int l = HashCommon.nextPowerOfTwo((int) Math.ceil(n / f));</span>
<span class="source-line-no">846</span><span id="line.846">        if (l &gt;= n || size &gt; maxFill(l, f)) return true;</span>
<span class="source-line-no">847</span><span id="line.847">        try {</span>
<span class="source-line-no">848</span><span id="line.848">            rehash(l);</span>
<span class="source-line-no">849</span><span id="line.849">        } catch (Exception cantDoIt) {</span>
<span class="source-line-no">850</span><span id="line.850">            return false;</span>
<span class="source-line-no">851</span><span id="line.851">        }</span>
<span class="source-line-no">852</span><span id="line.852">        return true;</span>
<span class="source-line-no">853</span><span id="line.853">    }</span>
<span class="source-line-no">854</span><span id="line.854"></span>
<span class="source-line-no">855</span><span id="line.855">    /**</span>
<span class="source-line-no">856</span><span id="line.856">     * Given a hash position, this finds the next position that contains an item, or -1 if none remain.</span>
<span class="source-line-no">857</span><span id="line.857">     * To scan from the start, give this -1 for position.</span>
<span class="source-line-no">858</span><span id="line.858">     * @param position a hash-based masked position in the K array</span>
<span class="source-line-no">859</span><span id="line.859">     * @return the next position after the given one</span>
<span class="source-line-no">860</span><span id="line.860">     */</span>
<span class="source-line-no">861</span><span id="line.861">    private int scanNext(int position)</span>
<span class="source-line-no">862</span><span id="line.862">    {</span>
<span class="source-line-no">863</span><span id="line.863">        int h = position;</span>
<span class="source-line-no">864</span><span id="line.864">        while (++h &lt; n)</span>
<span class="source-line-no">865</span><span id="line.865">        {</span>
<span class="source-line-no">866</span><span id="line.866">            if(key[h] != null)</span>
<span class="source-line-no">867</span><span id="line.867">            {</span>
<span class="source-line-no">868</span><span id="line.868">                return h;</span>
<span class="source-line-no">869</span><span id="line.869">            }</span>
<span class="source-line-no">870</span><span id="line.870">        }</span>
<span class="source-line-no">871</span><span id="line.871">        if(containsNull)</span>
<span class="source-line-no">872</span><span id="line.872">            return n;</span>
<span class="source-line-no">873</span><span id="line.873">        return -1;</span>
<span class="source-line-no">874</span><span id="line.874">    }</span>
<span class="source-line-no">875</span><span id="line.875"></span>
<span class="source-line-no">876</span><span id="line.876">    /**</span>
<span class="source-line-no">877</span><span id="line.877">     * Rehashes the map.</span>
<span class="source-line-no">878</span><span id="line.878">     * &lt;p&gt;</span>
<span class="source-line-no">879</span><span id="line.879">     * &lt;p&gt;</span>
<span class="source-line-no">880</span><span id="line.880">     * This method implements the basic rehashing strategy, and may be overriden</span>
<span class="source-line-no">881</span><span id="line.881">     * by subclasses implementing different rehashing strategies (e.g.,</span>
<span class="source-line-no">882</span><span id="line.882">     * disk-based rehashing). However, you should not override this method</span>
<span class="source-line-no">883</span><span id="line.883">     * unless you understand the internal workings of this class.</span>
<span class="source-line-no">884</span><span id="line.884">     *</span>
<span class="source-line-no">885</span><span id="line.885">     * @param newN the new size</span>
<span class="source-line-no">886</span><span id="line.886">     */</span>
<span class="source-line-no">887</span><span id="line.887">    @SuppressWarnings("unchecked")</span>
<span class="source-line-no">888</span><span id="line.888">    protected void rehash(final int newN) {</span>
<span class="source-line-no">889</span><span id="line.889">        final K[] key = this.key;</span>
<span class="source-line-no">890</span><span id="line.890">        final int mask = newN - 1;</span>
<span class="source-line-no">891</span><span id="line.891">        final K[] newKey = (K[]) new Object[newN + 1];</span>
<span class="source-line-no">892</span><span id="line.892">        K k;</span>
<span class="source-line-no">893</span><span id="line.893">        int i = -1, pos, sz = size;</span>
<span class="source-line-no">894</span><span id="line.894">        for (int q = 0; q &lt; sz; q++) {</span>
<span class="source-line-no">895</span><span id="line.895">            i = scanNext(i);</span>
<span class="source-line-no">896</span><span id="line.896">            if ((k = key[i]) == null)</span>
<span class="source-line-no">897</span><span id="line.897">                pos = newN;</span>
<span class="source-line-no">898</span><span id="line.898">            else {</span>
<span class="source-line-no">899</span><span id="line.899">                pos = (hasher.hash(k)) &amp; mask;</span>
<span class="source-line-no">900</span><span id="line.900">                while (!(newKey[pos] == null))</span>
<span class="source-line-no">901</span><span id="line.901">                    pos = pos + 1 &amp; mask;</span>
<span class="source-line-no">902</span><span id="line.902">            }</span>
<span class="source-line-no">903</span><span id="line.903">            newKey[pos] = k;</span>
<span class="source-line-no">904</span><span id="line.904">        }</span>
<span class="source-line-no">905</span><span id="line.905">        n = newN;</span>
<span class="source-line-no">906</span><span id="line.906">        this.mask = mask;</span>
<span class="source-line-no">907</span><span id="line.907">        maxFill = maxFill(n, f);</span>
<span class="source-line-no">908</span><span id="line.908">        this.key = newKey;</span>
<span class="source-line-no">909</span><span id="line.909">    }</span>
<span class="source-line-no">910</span><span id="line.910"></span>
<span class="source-line-no">911</span><span id="line.911">    /**</span>
<span class="source-line-no">912</span><span id="line.912">     * Returns a deep copy of this map.</span>
<span class="source-line-no">913</span><span id="line.913">     * &lt;p&gt;</span>
<span class="source-line-no">914</span><span id="line.914">     * &lt;p&gt;</span>
<span class="source-line-no">915</span><span id="line.915">     * This method performs a deep copy of this hash map; the data stored in the</span>
<span class="source-line-no">916</span><span id="line.916">     * map, however, is not cloned. Note that this makes a difference only for</span>
<span class="source-line-no">917</span><span id="line.917">     * object keys.</span>
<span class="source-line-no">918</span><span id="line.918">     *</span>
<span class="source-line-no">919</span><span id="line.919">     * @return a deep copy of this map.</span>
<span class="source-line-no">920</span><span id="line.920">     */</span>
<span class="source-line-no">921</span><span id="line.921">    @SuppressWarnings("unchecked")</span>
<span class="source-line-no">922</span><span id="line.922">    @GwtIncompatible</span>
<span class="source-line-no">923</span><span id="line.923">    public Object clone() {</span>
<span class="source-line-no">924</span><span id="line.924">        UnorderedSet&lt;K&gt; c;</span>
<span class="source-line-no">925</span><span id="line.925">        try {</span>
<span class="source-line-no">926</span><span id="line.926">            c = new UnorderedSet&lt;&gt;(hasher);</span>
<span class="source-line-no">927</span><span id="line.927">            c.key = (K[]) new Object[n + 1];</span>
<span class="source-line-no">928</span><span id="line.928">            System.arraycopy(key, 0, c.key, 0, n + 1);</span>
<span class="source-line-no">929</span><span id="line.929">            return c;</span>
<span class="source-line-no">930</span><span id="line.930">        } catch (Exception cantHappen) {</span>
<span class="source-line-no">931</span><span id="line.931">            throw new UnsupportedOperationException(cantHappen + (cantHappen.getMessage() != null ?</span>
<span class="source-line-no">932</span><span id="line.932">                    "; " + cantHappen.getMessage() : ""));</span>
<span class="source-line-no">933</span><span id="line.933">        }</span>
<span class="source-line-no">934</span><span id="line.934">    }</span>
<span class="source-line-no">935</span><span id="line.935"></span>
<span class="source-line-no">936</span><span id="line.936">    /**</span>
<span class="source-line-no">937</span><span id="line.937">     * Returns a hash code for this set.</span>
<span class="source-line-no">938</span><span id="line.938">     * &lt;p&gt;</span>
<span class="source-line-no">939</span><span id="line.939">     * This method overrides the generic method provided by the superclass.</span>
<span class="source-line-no">940</span><span id="line.940">     * Since &lt;code&gt;equals()&lt;/code&gt; is not overriden, it is important that the</span>
<span class="source-line-no">941</span><span id="line.941">     * value returned by this method is the same value as the one returned by</span>
<span class="source-line-no">942</span><span id="line.942">     * the overriden method.</span>
<span class="source-line-no">943</span><span id="line.943">     *</span>
<span class="source-line-no">944</span><span id="line.944">     * @return a hash code for this set.</span>
<span class="source-line-no">945</span><span id="line.945">     */</span>
<span class="source-line-no">946</span><span id="line.946">    public int hashCode() {</span>
<span class="source-line-no">947</span><span id="line.947">        int h = 0;</span>
<span class="source-line-no">948</span><span id="line.948">        for (int j = realSize(), i = 0; j-- != 0; ) {</span>
<span class="source-line-no">949</span><span id="line.949">            while (key[i] == null)</span>
<span class="source-line-no">950</span><span id="line.950">                i++;</span>
<span class="source-line-no">951</span><span id="line.951">            if (this != key[i])</span>
<span class="source-line-no">952</span><span id="line.952">                h += hasher.hash(key[i]);</span>
<span class="source-line-no">953</span><span id="line.953">            i++;</span>
<span class="source-line-no">954</span><span id="line.954">        }</span>
<span class="source-line-no">955</span><span id="line.955">        // Zero / null have hash zero.</span>
<span class="source-line-no">956</span><span id="line.956">        return h;</span>
<span class="source-line-no">957</span><span id="line.957">    }</span>
<span class="source-line-no">958</span><span id="line.958"></span>
<span class="source-line-no">959</span><span id="line.959">    public long hash64()</span>
<span class="source-line-no">960</span><span id="line.960">    {</span>
<span class="source-line-no">961</span><span id="line.961">        return 31L * size + CrossHash.hash64(key);</span>
<span class="source-line-no">962</span><span id="line.962">    }</span>
<span class="source-line-no">963</span><span id="line.963"></span>
<span class="source-line-no">964</span><span id="line.964">    /**</span>
<span class="source-line-no">965</span><span id="line.965">     * Returns the maximum number of entries that can be filled before rehashing.</span>
<span class="source-line-no">966</span><span id="line.966">     *</span>
<span class="source-line-no">967</span><span id="line.967">     * @param n the size of the backing array.</span>
<span class="source-line-no">968</span><span id="line.968">     * @param f the load factor.</span>
<span class="source-line-no">969</span><span id="line.969">     * @return the maximum number of entries before rehashing.</span>
<span class="source-line-no">970</span><span id="line.970">     */</span>
<span class="source-line-no">971</span><span id="line.971">    public static int maxFill(final int n, final float f) {</span>
<span class="source-line-no">972</span><span id="line.972">        /* We must guarantee that there is always at least</span>
<span class="source-line-no">973</span><span id="line.973">                 * one free entry (even with pathological load factors). */</span>
<span class="source-line-no">974</span><span id="line.974">        return Math.min((int) Math.ceil(n * f), n - 1);</span>
<span class="source-line-no">975</span><span id="line.975">    }</span>
<span class="source-line-no">976</span><span id="line.976"></span>
<span class="source-line-no">977</span><span id="line.977">    /**</span>
<span class="source-line-no">978</span><span id="line.978">     * Returns the maximum number of entries that can be filled before rehashing.</span>
<span class="source-line-no">979</span><span id="line.979">     *</span>
<span class="source-line-no">980</span><span id="line.980">     * @param n the size of the backing array.</span>
<span class="source-line-no">981</span><span id="line.981">     * @param f the load factor.</span>
<span class="source-line-no">982</span><span id="line.982">     * @return the maximum number of entries before rehashing.</span>
<span class="source-line-no">983</span><span id="line.983">     */</span>
<span class="source-line-no">984</span><span id="line.984">    public static long maxFill(final long n, final float f) {</span>
<span class="source-line-no">985</span><span id="line.985">                /* We must guarantee that there is always at least</span>
<span class="source-line-no">986</span><span id="line.986">                 * one free entry (even with pathological load factors). */</span>
<span class="source-line-no">987</span><span id="line.987">        return Math.min((long) Math.ceil(n * f), n - 1);</span>
<span class="source-line-no">988</span><span id="line.988">    }</span>
<span class="source-line-no">989</span><span id="line.989"></span>
<span class="source-line-no">990</span><span id="line.990">    /**</span>
<span class="source-line-no">991</span><span id="line.991">     * Returns the least power of two smaller than or equal to 2&lt;sup&gt;30&lt;/sup&gt; and larger than or equal to &lt;code&gt;Math.ceil( expected / f )&lt;/code&gt;.</span>
<span class="source-line-no">992</span><span id="line.992">     *</span>
<span class="source-line-no">993</span><span id="line.993">     * @param expected the expected number of elements in a hash table.</span>
<span class="source-line-no">994</span><span id="line.994">     * @param f        the load factor.</span>
<span class="source-line-no">995</span><span id="line.995">     * @return the minimum possible size for a backing array.</span>
<span class="source-line-no">996</span><span id="line.996">     * @throws IllegalArgumentException if the necessary size is larger than 2&lt;sup&gt;30&lt;/sup&gt;.</span>
<span class="source-line-no">997</span><span id="line.997">     */</span>
<span class="source-line-no">998</span><span id="line.998">    public static int arraySize(final int expected, final float f) {</span>
<span class="source-line-no">999</span><span id="line.999">        final long s = Math.max(2, HashCommon.nextPowerOfTwo((long) Math.ceil(expected / f)));</span>
<span class="source-line-no">1000</span><span id="line.1000">        if (s &gt; 1 &lt;&lt; 30)</span>
<span class="source-line-no">1001</span><span id="line.1001">            throw new IllegalArgumentException("Too large (" + expected + " expected elements with load factor " + f + ")");</span>
<span class="source-line-no">1002</span><span id="line.1002">        return (int) s;</span>
<span class="source-line-no">1003</span><span id="line.1003">    }</span>
<span class="source-line-no">1004</span><span id="line.1004"></span>
<span class="source-line-no">1005</span><span id="line.1005">    @Override</span>
<span class="source-line-no">1006</span><span id="line.1006">    public Object[] toArray() {</span>
<span class="source-line-no">1007</span><span id="line.1007">        final Object[] a = new Object[size];</span>
<span class="source-line-no">1008</span><span id="line.1008">        objectUnwrap(iterator(), a);</span>
<span class="source-line-no">1009</span><span id="line.1009">        return a;</span>
<span class="source-line-no">1010</span><span id="line.1010">    }</span>
<span class="source-line-no">1011</span><span id="line.1011"></span>
<span class="source-line-no">1012</span><span id="line.1012">    @Override</span>
<span class="source-line-no">1013</span><span id="line.1013">    public &lt;T&gt; T[] toArray(T[] a) {</span>
<span class="source-line-no">1014</span><span id="line.1014">        final int size = size();</span>
<span class="source-line-no">1015</span><span id="line.1015">        if (a.length &lt; size) a = Arrays.copyOf(a, size);</span>
<span class="source-line-no">1016</span><span id="line.1016">        objectUnwrap(iterator(), a);</span>
<span class="source-line-no">1017</span><span id="line.1017">        if (size &lt; a.length)</span>
<span class="source-line-no">1018</span><span id="line.1018">            a[size] = null;</span>
<span class="source-line-no">1019</span><span id="line.1019">        return a;</span>
<span class="source-line-no">1020</span><span id="line.1020">    }</span>
<span class="source-line-no">1021</span><span id="line.1021"></span>
<span class="source-line-no">1022</span><span id="line.1022"></span>
<span class="source-line-no">1023</span><span id="line.1023">    /**</span>
<span class="source-line-no">1024</span><span id="line.1024">     * Unwraps an iterator into an array starting at a given offset for a given number of elements.</span>
<span class="source-line-no">1025</span><span id="line.1025">     * &lt;p&gt;</span>
<span class="source-line-no">1026</span><span id="line.1026">     * &lt;P&gt;This method iterates over the given type-specific iterator and stores the elements returned, up to a maximum of &lt;code&gt;length&lt;/code&gt;, in the given array starting at &lt;code&gt;offset&lt;/code&gt;. The</span>
<span class="source-line-no">1027</span><span id="line.1027">     * number of actually unwrapped elements is returned (it may be less than &lt;code&gt;max&lt;/code&gt; if the iterator emits less than &lt;code&gt;max&lt;/code&gt; elements).</span>
<span class="source-line-no">1028</span><span id="line.1028">     *</span>
<span class="source-line-no">1029</span><span id="line.1029">     * @param i      a type-specific iterator.</span>
<span class="source-line-no">1030</span><span id="line.1030">     * @param array  an array to contain the output of the iterator.</span>
<span class="source-line-no">1031</span><span id="line.1031">     * @param offset the first element of the array to be returned.</span>
<span class="source-line-no">1032</span><span id="line.1032">     * @param max    the maximum number of elements to unwrap.</span>
<span class="source-line-no">1033</span><span id="line.1033">     * @return the number of elements unwrapped.</span>
<span class="source-line-no">1034</span><span id="line.1034">     */</span>
<span class="source-line-no">1035</span><span id="line.1035">    private static &lt;K&gt; int objectUnwrap(final Iterator&lt;? extends K&gt; i, final K[] array, int offset, final int max) {</span>
<span class="source-line-no">1036</span><span id="line.1036">        if (max &lt; 0) throw new IllegalArgumentException("The maximum number of elements (" + max + ") is negative");</span>
<span class="source-line-no">1037</span><span id="line.1037">        if (offset &lt; 0 || offset + max &gt; array.length) throw new IllegalArgumentException();</span>
<span class="source-line-no">1038</span><span id="line.1038">        int j = max;</span>
<span class="source-line-no">1039</span><span id="line.1039">        while (j-- != 0 &amp;&amp; i.hasNext())</span>
<span class="source-line-no">1040</span><span id="line.1040">            array[offset++] = i.next();</span>
<span class="source-line-no">1041</span><span id="line.1041">        return max - j - 1;</span>
<span class="source-line-no">1042</span><span id="line.1042">    }</span>
<span class="source-line-no">1043</span><span id="line.1043"></span>
<span class="source-line-no">1044</span><span id="line.1044">    /**</span>
<span class="source-line-no">1045</span><span id="line.1045">     * Unwraps an iterator into an array.</span>
<span class="source-line-no">1046</span><span id="line.1046">     * &lt;p&gt;</span>
<span class="source-line-no">1047</span><span id="line.1047">     * &lt;P&gt;This method iterates over the given type-specific iterator and stores the elements returned in the given array. The iteration will stop when the iterator has no more elements or when the end</span>
<span class="source-line-no">1048</span><span id="line.1048">     * of the array has been reached.</span>
<span class="source-line-no">1049</span><span id="line.1049">     *</span>
<span class="source-line-no">1050</span><span id="line.1050">     * @param i     a type-specific iterator.</span>
<span class="source-line-no">1051</span><span id="line.1051">     * @param array an array to contain the output of the iterator.</span>
<span class="source-line-no">1052</span><span id="line.1052">     * @return the number of elements unwrapped.</span>
<span class="source-line-no">1053</span><span id="line.1053">     */</span>
<span class="source-line-no">1054</span><span id="line.1054">    private static &lt;K&gt; int objectUnwrap(final Iterator&lt;? extends K&gt; i, final K[] array) {</span>
<span class="source-line-no">1055</span><span id="line.1055">        return objectUnwrap(i, array, 0, array.length);</span>
<span class="source-line-no">1056</span><span id="line.1056">    }</span>
<span class="source-line-no">1057</span><span id="line.1057"></span>
<span class="source-line-no">1058</span><span id="line.1058">    @Override</span>
<span class="source-line-no">1059</span><span id="line.1059">    public String toString() {</span>
<span class="source-line-no">1060</span><span id="line.1060">        final StringBuilder s = new StringBuilder();</span>
<span class="source-line-no">1061</span><span id="line.1061">        int i = scanNext(-1);</span>
<span class="source-line-no">1062</span><span id="line.1062">        boolean first = true;</span>
<span class="source-line-no">1063</span><span id="line.1063">        s.append("OrderedSet{");</span>
<span class="source-line-no">1064</span><span id="line.1064">        while (i != -1) {</span>
<span class="source-line-no">1065</span><span id="line.1065">            if (first) first = false;</span>
<span class="source-line-no">1066</span><span id="line.1066">            else s.append(", ");</span>
<span class="source-line-no">1067</span><span id="line.1067">            s.append(key[i]);</span>
<span class="source-line-no">1068</span><span id="line.1068">            i = scanNext(i);</span>
<span class="source-line-no">1069</span><span id="line.1069">        }</span>
<span class="source-line-no">1070</span><span id="line.1070">        s.append("}");</span>
<span class="source-line-no">1071</span><span id="line.1071">        return s.toString();</span>
<span class="source-line-no">1072</span><span id="line.1072">    }</span>
<span class="source-line-no">1073</span><span id="line.1073"></span>
<span class="source-line-no">1074</span><span id="line.1074">    @Override</span>
<span class="source-line-no">1075</span><span id="line.1075">    public boolean equals(final Object o) {</span>
<span class="source-line-no">1076</span><span id="line.1076">        if (o == this)</span>
<span class="source-line-no">1077</span><span id="line.1077">            return true;</span>
<span class="source-line-no">1078</span><span id="line.1078">        if (!(o instanceof Set))</span>
<span class="source-line-no">1079</span><span id="line.1079">            return false;</span>
<span class="source-line-no">1080</span><span id="line.1080">        Set&lt;?&gt; s = (Set&lt;?&gt;) o;</span>
<span class="source-line-no">1081</span><span id="line.1081">        if (s.size() != size)</span>
<span class="source-line-no">1082</span><span id="line.1082">            return false;</span>
<span class="source-line-no">1083</span><span id="line.1083">        return containsAll(s);</span>
<span class="source-line-no">1084</span><span id="line.1084">    }</span>
<span class="source-line-no">1085</span><span id="line.1085"></span>
<span class="source-line-no">1086</span><span id="line.1086">    @GwtIncompatible</span>
<span class="source-line-no">1087</span><span id="line.1087">    private void writeObject(java.io.ObjectOutputStream s)</span>
<span class="source-line-no">1088</span><span id="line.1088">            throws java.io.IOException {</span>
<span class="source-line-no">1089</span><span id="line.1089">        final Iterator&lt;K&gt; i = iterator();</span>
<span class="source-line-no">1090</span><span id="line.1090">        s.defaultWriteObject();</span>
<span class="source-line-no">1091</span><span id="line.1091">        for (int j = size; j-- != 0; )</span>
<span class="source-line-no">1092</span><span id="line.1092">            s.writeObject(i.next());</span>
<span class="source-line-no">1093</span><span id="line.1093">    }</span>
<span class="source-line-no">1094</span><span id="line.1094"></span>
<span class="source-line-no">1095</span><span id="line.1095">    @GwtIncompatible</span>
<span class="source-line-no">1096</span><span id="line.1096">    @SuppressWarnings("unchecked")</span>
<span class="source-line-no">1097</span><span id="line.1097">    private void readObject(java.io.ObjectInputStream s)</span>
<span class="source-line-no">1098</span><span id="line.1098">            throws java.io.IOException, ClassNotFoundException {</span>
<span class="source-line-no">1099</span><span id="line.1099">        s.defaultReadObject();</span>
<span class="source-line-no">1100</span><span id="line.1100">        n = arraySize(size, f);</span>
<span class="source-line-no">1101</span><span id="line.1101">        maxFill = maxFill(n, f);</span>
<span class="source-line-no">1102</span><span id="line.1102">        mask = n - 1;</span>
<span class="source-line-no">1103</span><span id="line.1103">        final K[] key = this.key = (K[]) new Object[n + 1];</span>
<span class="source-line-no">1104</span><span id="line.1104">        K k;</span>
<span class="source-line-no">1105</span><span id="line.1105">        for (int i = size, pos; i-- != 0; ) {</span>
<span class="source-line-no">1106</span><span id="line.1106">            k = (K) s.readObject();</span>
<span class="source-line-no">1107</span><span id="line.1107">            if (k == null) {</span>
<span class="source-line-no">1108</span><span id="line.1108">                pos = n;</span>
<span class="source-line-no">1109</span><span id="line.1109">                containsNull = true;</span>
<span class="source-line-no">1110</span><span id="line.1110">            } else {</span>
<span class="source-line-no">1111</span><span id="line.1111">                if (!(key[pos = (hasher.hash(k)) &amp; mask] == null))</span>
<span class="source-line-no">1112</span><span id="line.1112">                    while (!(key[pos = pos + 1 &amp; mask] == null)) ;</span>
<span class="source-line-no">1113</span><span id="line.1113">            }</span>
<span class="source-line-no">1114</span><span id="line.1114">            key[pos] = k;</span>
<span class="source-line-no">1115</span><span id="line.1115">        }</span>
<span class="source-line-no">1116</span><span id="line.1116">    }</span>
<span class="source-line-no">1117</span><span id="line.1117">}</span>




























































</pre>
</div>
</main>
</body>
</html>
