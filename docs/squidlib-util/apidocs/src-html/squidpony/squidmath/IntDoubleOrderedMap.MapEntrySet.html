<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (16) -->
<title>Source code</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="source: package: squidpony.squidmath, class: IntDoubleOrderedMap, class: MapEntrySet">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body class="source-page">
<main role="main">
<div class="source-container">
<pre><span class="source-line-no">001</span><span id="line.1">/*</span>
<span class="source-line-no">002</span><span id="line.2"> * Copyright (C) 2002-2015 Sebastiano Vigna</span>
<span class="source-line-no">003</span><span id="line.3"> *</span>
<span class="source-line-no">004</span><span id="line.4"> * Licensed under the Apache License, Version 2.0 (the "License");</span>
<span class="source-line-no">005</span><span id="line.5"> * you may not use this file except in compliance with the License.</span>
<span class="source-line-no">006</span><span id="line.6"> * You may obtain a copy of the License at</span>
<span class="source-line-no">007</span><span id="line.7"> *</span>
<span class="source-line-no">008</span><span id="line.8"> *     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="source-line-no">009</span><span id="line.9"> *</span>
<span class="source-line-no">010</span><span id="line.10"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="source-line-no">011</span><span id="line.11"> * distributed under the License is distributed on an "AS IS" BASIS,</span>
<span class="source-line-no">012</span><span id="line.12"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="source-line-no">013</span><span id="line.13"> * See the License for the specific language governing permissions and</span>
<span class="source-line-no">014</span><span id="line.14"> * limitations under the License.</span>
<span class="source-line-no">015</span><span id="line.15"> */</span>
<span class="source-line-no">016</span><span id="line.16">package squidpony.squidmath;</span>
<span class="source-line-no">017</span><span id="line.17"></span>
<span class="source-line-no">018</span><span id="line.18">import squidpony.annotation.GwtIncompatible;</span>
<span class="source-line-no">019</span><span id="line.19"></span>
<span class="source-line-no">020</span><span id="line.20">import java.io.Serializable;</span>
<span class="source-line-no">021</span><span id="line.21">import java.util.*;</span>
<span class="source-line-no">022</span><span id="line.22"></span>
<span class="source-line-no">023</span><span id="line.23">/**</span>
<span class="source-line-no">024</span><span id="line.24"> * An int-key and int-value insertion-ordered hash map with with a fast implementation, originally from fastutil as</span>
<span class="source-line-no">025</span><span id="line.25"> * Object2ObjectLinkedOpenHashMap but modified (in {@link OrderedMap}) to support constant-time indexed access of keys,</span>
<span class="source-line-no">026</span><span id="line.26"> * values, and entries, and reordering. Deletion is slower with this algorithm (O(n) because the array used to keep</span>
<span class="source-line-no">027</span><span id="line.27"> * track of ordering and indexing only allows linear-time deletion, instead of a linked-list approach allowing</span>
<span class="source-line-no">028</span><span id="line.28"> * constant-time deletion but not helping at all with indexed access), and insertion sometimes takes longer than an</span>
<span class="source-line-no">029</span><span id="line.29"> * ordered map using a linked-list for order because rehashing is more expensive. The benefits from constant-time access</span>
<span class="source-line-no">030</span><span id="line.30"> * by index are numerous, especially for games, since fetching a random element becomes O(1) instead of O(n), and the</span>
<span class="source-line-no">031</span><span id="line.31"> * index can be used to store extra info for no cost.</span>
<span class="source-line-no">032</span><span id="line.32"> * &lt;br&gt;</span>
<span class="source-line-no">033</span><span id="line.33"> * An older version of this class didn't support the useful {@link #keyAt(int)} and {@link #getAt(int)} operations,</span>
<span class="source-line-no">034</span><span id="line.34"> * among many others, and a refactor of the class has made it much closer to {@link IntIntOrderedMap} and to some extent</span>
<span class="source-line-no">035</span><span id="line.35"> * {@link OrderedMap}, making order control a priority. Some method names have changed; if you used code like</span>
<span class="source-line-no">036</span><span id="line.36"> * {@code putAndMoveToFirst(k, v)}, that should be replaced with {@code putAt(k, v, 0)}. The API for the data structures</span>
<span class="source-line-no">037</span><span id="line.37"> * returned by {@link #keySet()} and {@link #values()} has changed in some places; you should use</span>
<span class="source-line-no">038</span><span id="line.38"> * {@link #keysAsArray()} and {@link #valuesAsArray()} instead of creating a key set or values collection and calling</span>
<span class="source-line-no">039</span><span id="line.39"> * toArray() on that, as you had to before. The usage of this class should now be similar to the rest of the library.</span>
<span class="source-line-no">040</span><span id="line.40"> * &lt;br&gt;</span>
<span class="source-line-no">041</span><span id="line.41"> * Instances of this class use a hash table to represent a map. The table is filled up to a specified &lt;em&gt;load factor&lt;/em&gt;, and then doubled in size to accommodate new entries. If the table is</span>
<span class="source-line-no">042</span><span id="line.42"> * emptied below &lt;em&gt;one fourth&lt;/em&gt; of the load factor, it is halved in size. However, halving is not performed when deleting entries from an iterator, as it would interfere with the iteration</span>
<span class="source-line-no">043</span><span id="line.43"> * process.</span>
<span class="source-line-no">044</span><span id="line.44"> * &lt;br&gt;</span>
<span class="source-line-no">045</span><span id="line.45"> * Note that {@link #clear()} does not modify the hash table size. Rather, a family of {@linkplain #trim() trimming methods} lets you control the size of the table; this is particularly useful if</span>
<span class="source-line-no">046</span><span id="line.46"> * you reuse instances of this class.</span>
<span class="source-line-no">047</span><span id="line.47"> * &lt;br&gt;</span>
<span class="source-line-no">048</span><span id="line.48"> * Iterators generated by this map will enumerate pairs in the same order in which they have been added to the map (addition of pairs whose key is already present in the set does not change the</span>
<span class="source-line-no">049</span><span id="line.49"> * iteration order). Note that this order has nothing in common with the natural order of the keys. The order is kept by means of a int-specialized list, {@link IntVLA}, and is modifiable with this</span>
<span class="source-line-no">050</span><span id="line.50"> * class' {@link #reorder(int...)} and {@link #shuffle(IRNG)} methods, among other tools. It may be preferable to avoid instantiating an Iterator object and instead</span>
<span class="source-line-no">051</span><span id="line.51"> * use a normal int-based for loop with {@link #getAt(int)} called in each iteration. Though this doesn't allow easy deletion of items during iteration, it may be the</span>
<span class="source-line-no">052</span><span id="line.52"> * fastest way to iterate through an OrderedMap.</span>
<span class="source-line-no">053</span><span id="line.53"> * &lt;br&gt;</span>
<span class="source-line-no">054</span><span id="line.54"> * This class allows approximately constant-time lookup of keys or values by their index in the ordering, which can</span>
<span class="source-line-no">055</span><span id="line.55"> * allow some novel usage of the data structure. {@link OrderedSet} can be used like a list of unique elements, keeping</span>
<span class="source-line-no">056</span><span id="line.56"> * order like a list does but also allowing rapid checks for whether an item exists in the OrderedSet, and OrderedMap</span>
<span class="source-line-no">057</span><span id="line.57"> * can be used like that but with values associated as well (where OrderedSet uses contains(), OrderedMap uses</span>
<span class="source-line-no">058</span><span id="line.58"> * containsKey()). You can also set the key and value at a position with {@link #putAt(int, double, int)}, or alter</span>
<span class="source-line-no">059</span><span id="line.59"> * the key while keeping its value and index the same with {@link #alter(int, int)}. Reordering works here too,</span>
<span class="source-line-no">060</span><span id="line.60"> * both with completely random orders from {@link #shuffle(IRNG)} or with a previously-generated ordering from</span>
<span class="source-line-no">061</span><span id="line.61"> * {@link #reorder(int...)} (you can produce such an ordering for a given size and reuse it across multiple Ordered data</span>
<span class="source-line-no">062</span><span id="line.62"> * structures with {@link IRNG#randomOrdering(int)}). Note that putAt() and {@link #removeAt(int)} do not run in constant</span>
<span class="source-line-no">063</span><span id="line.63"> * time, and depending on the point of insertion/removal, they are likely to run in linear time (but also note that most</span>
<span class="source-line-no">064</span><span id="line.64"> * insertion-ordered Maps and Sets don't allow insertion or removal at anywhere but the beginning or end of the order).</span>
<span class="source-line-no">065</span><span id="line.65"> * &lt;br&gt;</span>
<span class="source-line-no">066</span><span id="line.66"> * This doesn't allow custom IHashers because IHasher expects an Object to hash, and that would box the keys every time.</span>
<span class="source-line-no">067</span><span id="line.67"> * &lt;br&gt;</span>
<span class="source-line-no">068</span><span id="line.68"> * Thank you, Sebastiano Vigna, for making FastUtil available to the public with such high quality.</span>
<span class="source-line-no">069</span><span id="line.69"> * &lt;br&gt;</span>
<span class="source-line-no">070</span><span id="line.70"> * See https://github.com/vigna/fastutil for the original library.</span>
<span class="source-line-no">071</span><span id="line.71"> * @author Sebastiano Vigna (responsible for all the hard parts)</span>
<span class="source-line-no">072</span><span id="line.72"> * @author Tommy Ettinger (mostly responsible for squashing several layers of parent classes into one monster class)</span>
<span class="source-line-no">073</span><span id="line.73"> */</span>
<span class="source-line-no">074</span><span id="line.74">public class IntDoubleOrderedMap implements Serializable, Cloneable {</span>
<span class="source-line-no">075</span><span id="line.75">    private static final long serialVersionUID = 0L;</span>
<span class="source-line-no">076</span><span id="line.76">    /**</span>
<span class="source-line-no">077</span><span id="line.77">     * The array of keys.</span>
<span class="source-line-no">078</span><span id="line.78">     */</span>
<span class="source-line-no">079</span><span id="line.79">    protected int[] key;</span>
<span class="source-line-no">080</span><span id="line.80">    /**</span>
<span class="source-line-no">081</span><span id="line.81">     * The array of values.</span>
<span class="source-line-no">082</span><span id="line.82">     */</span>
<span class="source-line-no">083</span><span id="line.83">    protected double[] value;</span>
<span class="source-line-no">084</span><span id="line.84">    /**</span>
<span class="source-line-no">085</span><span id="line.85">     * The mask for wrapping a position counter.</span>
<span class="source-line-no">086</span><span id="line.86">     */</span>
<span class="source-line-no">087</span><span id="line.87">    protected int mask;</span>
<span class="source-line-no">088</span><span id="line.88">    /**</span>
<span class="source-line-no">089</span><span id="line.89">     * Whether this set contains the key zero.</span>
<span class="source-line-no">090</span><span id="line.90">     */</span>
<span class="source-line-no">091</span><span id="line.91">    protected boolean containsNullKey;</span>
<span class="source-line-no">092</span><span id="line.92">    /**</span>
<span class="source-line-no">093</span><span id="line.93">     * An IntVLA (variable-length int sequence) that stores the positions in the key array of specific keys, with the</span>
<span class="source-line-no">094</span><span id="line.94">     * positions in insertion order. The order can be changed with {@link #reorder(int...)} and other methods.</span>
<span class="source-line-no">095</span><span id="line.95">     */</span>
<span class="source-line-no">096</span><span id="line.96">    protected IntVLA order;</span>
<span class="source-line-no">097</span><span id="line.97">    /**</span>
<span class="source-line-no">098</span><span id="line.98">     * The current table size.</span>
<span class="source-line-no">099</span><span id="line.99">     */</span>
<span class="source-line-no">100</span><span id="line.100">    protected int n;</span>
<span class="source-line-no">101</span><span id="line.101">    /**</span>
<span class="source-line-no">102</span><span id="line.102">     * Threshold after which we rehash. It must be the table size times {@link #f}.</span>
<span class="source-line-no">103</span><span id="line.103">     */</span>
<span class="source-line-no">104</span><span id="line.104">    protected int maxFill;</span>
<span class="source-line-no">105</span><span id="line.105">    /**</span>
<span class="source-line-no">106</span><span id="line.106">     * Number of entries in the set (including the key zero, if present).</span>
<span class="source-line-no">107</span><span id="line.107">     */</span>
<span class="source-line-no">108</span><span id="line.108">    protected int size;</span>
<span class="source-line-no">109</span><span id="line.109">    /**</span>
<span class="source-line-no">110</span><span id="line.110">     * The acceptable load factor.</span>
<span class="source-line-no">111</span><span id="line.111">     */</span>
<span class="source-line-no">112</span><span id="line.112">    public final float f;</span>
<span class="source-line-no">113</span><span id="line.113">    /**</span>
<span class="source-line-no">114</span><span id="line.114">     * Cached set of entries.</span>
<span class="source-line-no">115</span><span id="line.115">     */</span>
<span class="source-line-no">116</span><span id="line.116">    protected volatile MapEntrySet entries;</span>
<span class="source-line-no">117</span><span id="line.117">    /**</span>
<span class="source-line-no">118</span><span id="line.118">     * Cached set of keys.</span>
<span class="source-line-no">119</span><span id="line.119">     */</span>
<span class="source-line-no">120</span><span id="line.120">    protected volatile KeySet keys;</span>
<span class="source-line-no">121</span><span id="line.121">    /**</span>
<span class="source-line-no">122</span><span id="line.122">     * Cached collection of values.</span>
<span class="source-line-no">123</span><span id="line.123">     */</span>
<span class="source-line-no">124</span><span id="line.124">    protected volatile ValueCollection values;</span>
<span class="source-line-no">125</span><span id="line.125">    /**</span>
<span class="source-line-no">126</span><span id="line.126">     * Default return value.</span>
<span class="source-line-no">127</span><span id="line.127">     */</span>
<span class="source-line-no">128</span><span id="line.128">    protected double defRetValue = Double.NaN;</span>
<span class="source-line-no">129</span><span id="line.129"></span>
<span class="source-line-no">130</span><span id="line.130">    /**</span>
<span class="source-line-no">131</span><span id="line.131">     * The initial default size of a hash table.</span>
<span class="source-line-no">132</span><span id="line.132">     */</span>
<span class="source-line-no">133</span><span id="line.133">    public static final int DEFAULT_INITIAL_SIZE = 16;</span>
<span class="source-line-no">134</span><span id="line.134">    /**</span>
<span class="source-line-no">135</span><span id="line.135">     * The default load factor of a hash table.</span>
<span class="source-line-no">136</span><span id="line.136">     */</span>
<span class="source-line-no">137</span><span id="line.137">    public static final float DEFAULT_LOAD_FACTOR = .25f; // .1875f; // .75f;</span>
<span class="source-line-no">138</span><span id="line.138">    /**</span>
<span class="source-line-no">139</span><span id="line.139">     * The load factor for a (usually small) table that is meant to be particularly fast.</span>
<span class="source-line-no">140</span><span id="line.140">     */</span>
<span class="source-line-no">141</span><span id="line.141">    public static final float FAST_LOAD_FACTOR = .5f;</span>
<span class="source-line-no">142</span><span id="line.142">    /**</span>
<span class="source-line-no">143</span><span id="line.143">     * The load factor for a (usually very small) table that is meant to be extremely fast.</span>
<span class="source-line-no">144</span><span id="line.144">     */</span>
<span class="source-line-no">145</span><span id="line.145">    public static final float VERY_FAST_LOAD_FACTOR = .25f;</span>
<span class="source-line-no">146</span><span id="line.146"></span>
<span class="source-line-no">147</span><span id="line.147">    public void defaultReturnValue(final double rv) {</span>
<span class="source-line-no">148</span><span id="line.148">        defRetValue = rv;</span>
<span class="source-line-no">149</span><span id="line.149">    }</span>
<span class="source-line-no">150</span><span id="line.150"></span>
<span class="source-line-no">151</span><span id="line.151">    public double defaultReturnValue() {</span>
<span class="source-line-no">152</span><span id="line.152">        return defRetValue;</span>
<span class="source-line-no">153</span><span id="line.153">    }</span>
<span class="source-line-no">154</span><span id="line.154"></span>
<span class="source-line-no">155</span><span id="line.155">    /**</span>
<span class="source-line-no">156</span><span id="line.156">     * Creates a new OrderedMap.</span>
<span class="source-line-no">157</span><span id="line.157">     * &lt;p&gt;</span>
<span class="source-line-no">158</span><span id="line.158">     * &lt;p&gt;The actual table size will be the least power of two greater than &lt;code&gt;expected&lt;/code&gt;/&lt;code&gt;f&lt;/code&gt;.</span>
<span class="source-line-no">159</span><span id="line.159">     *</span>
<span class="source-line-no">160</span><span id="line.160">     * @param expected the expected number of elements in the hash set.</span>
<span class="source-line-no">161</span><span id="line.161">     * @param f        the load factor.</span>
<span class="source-line-no">162</span><span id="line.162">     */</span>
<span class="source-line-no">163</span><span id="line.163"></span>
<span class="source-line-no">164</span><span id="line.164">    public IntDoubleOrderedMap(final int expected, final float f) {</span>
<span class="source-line-no">165</span><span id="line.165">        if (f &lt;= 0 || f &gt; 1)</span>
<span class="source-line-no">166</span><span id="line.166">            throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than or equal to 1");</span>
<span class="source-line-no">167</span><span id="line.167">        if (expected &lt; 0) throw new IllegalArgumentException("The expected number of elements must be nonnegative");</span>
<span class="source-line-no">168</span><span id="line.168">        this.f = f;</span>
<span class="source-line-no">169</span><span id="line.169">        n = arraySize(expected, f);</span>
<span class="source-line-no">170</span><span id="line.170">        mask = n - 1;</span>
<span class="source-line-no">171</span><span id="line.171">        maxFill = maxFill(n, f);</span>
<span class="source-line-no">172</span><span id="line.172">        key = new int[n + 1];</span>
<span class="source-line-no">173</span><span id="line.173">        value = new double[n + 1];</span>
<span class="source-line-no">174</span><span id="line.174">        //link = new long[n + 1];</span>
<span class="source-line-no">175</span><span id="line.175">        order = new IntVLA(expected);</span>
<span class="source-line-no">176</span><span id="line.176">    }</span>
<span class="source-line-no">177</span><span id="line.177"></span>
<span class="source-line-no">178</span><span id="line.178">    /**</span>
<span class="source-line-no">179</span><span id="line.179">     * Creates a new OrderedMap with 0.75f as load factor.</span>
<span class="source-line-no">180</span><span id="line.180">     *</span>
<span class="source-line-no">181</span><span id="line.181">     * @param expected the expected number of elements in the OrderedMap.</span>
<span class="source-line-no">182</span><span id="line.182">     */</span>
<span class="source-line-no">183</span><span id="line.183">    public IntDoubleOrderedMap(final int expected) {</span>
<span class="source-line-no">184</span><span id="line.184">        this(expected, DEFAULT_LOAD_FACTOR);</span>
<span class="source-line-no">185</span><span id="line.185">    }</span>
<span class="source-line-no">186</span><span id="line.186"></span>
<span class="source-line-no">187</span><span id="line.187">    /**</span>
<span class="source-line-no">188</span><span id="line.188">     * Creates a new OrderedMap with initial expected 16 entries and 0.75f as load factor.</span>
<span class="source-line-no">189</span><span id="line.189">     */</span>
<span class="source-line-no">190</span><span id="line.190">    public IntDoubleOrderedMap() {</span>
<span class="source-line-no">191</span><span id="line.191">        this(DEFAULT_INITIAL_SIZE, DEFAULT_LOAD_FACTOR);</span>
<span class="source-line-no">192</span><span id="line.192">    }</span>
<span class="source-line-no">193</span><span id="line.193"></span>
<span class="source-line-no">194</span><span id="line.194">    /**</span>
<span class="source-line-no">195</span><span id="line.195">     * Creates a new OrderedMap copying a given one.</span>
<span class="source-line-no">196</span><span id="line.196">     *</span>
<span class="source-line-no">197</span><span id="line.197">     * @param m a {@link Map} to be copied into the new OrderedMap.</span>
<span class="source-line-no">198</span><span id="line.198">     * @param f the load factor.</span>
<span class="source-line-no">199</span><span id="line.199">     */</span>
<span class="source-line-no">200</span><span id="line.200">    public IntDoubleOrderedMap(final IntDoubleOrderedMap m, final float f) {</span>
<span class="source-line-no">201</span><span id="line.201">        this(m.size(), f);</span>
<span class="source-line-no">202</span><span id="line.202">        putAll(m);</span>
<span class="source-line-no">203</span><span id="line.203">    }</span>
<span class="source-line-no">204</span><span id="line.204"></span>
<span class="source-line-no">205</span><span id="line.205">    /**</span>
<span class="source-line-no">206</span><span id="line.206">     * Creates a new OrderedMap with 0.75f as load factor copying a given one.</span>
<span class="source-line-no">207</span><span id="line.207">     *</span>
<span class="source-line-no">208</span><span id="line.208">     * @param m a {@link Map} to be copied into the new OrderedMap.</span>
<span class="source-line-no">209</span><span id="line.209">     */</span>
<span class="source-line-no">210</span><span id="line.210">    public IntDoubleOrderedMap(final IntDoubleOrderedMap m) {</span>
<span class="source-line-no">211</span><span id="line.211">        this(m, m.f);</span>
<span class="source-line-no">212</span><span id="line.212">    }</span>
<span class="source-line-no">213</span><span id="line.213"></span>
<span class="source-line-no">214</span><span id="line.214">    /**</span>
<span class="source-line-no">215</span><span id="line.215">     * Creates a new OrderedMap using the elements of two parallel arrays.</span>
<span class="source-line-no">216</span><span id="line.216">     *</span>
<span class="source-line-no">217</span><span id="line.217">     * @param keyArray the array of keys of the new OrderedMap.</span>
<span class="source-line-no">218</span><span id="line.218">     * @param valueArray the array of corresponding values in the new OrderedMap.</span>
<span class="source-line-no">219</span><span id="line.219">     * @param f the load factor.</span>
<span class="source-line-no">220</span><span id="line.220">     * @throws IllegalArgumentException if &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; have different lengths.</span>
<span class="source-line-no">221</span><span id="line.221">     */</span>
<span class="source-line-no">222</span><span id="line.222">    public IntDoubleOrderedMap(final int[] keyArray, final double[] valueArray, final float f) {</span>
<span class="source-line-no">223</span><span id="line.223">        this(keyArray.length, f);</span>
<span class="source-line-no">224</span><span id="line.224">        if (keyArray.length != valueArray.length)</span>
<span class="source-line-no">225</span><span id="line.225">            throw new IllegalArgumentException("The key array and the value array have different lengths (" + keyArray.length + " and " + valueArray.length + ")");</span>
<span class="source-line-no">226</span><span id="line.226">        for (int i = 0; i &lt; keyArray.length; i++)</span>
<span class="source-line-no">227</span><span id="line.227">            put(keyArray[i], valueArray[i]);</span>
<span class="source-line-no">228</span><span id="line.228">    }</span>
<span class="source-line-no">229</span><span id="line.229"></span>
<span class="source-line-no">230</span><span id="line.230">    /**</span>
<span class="source-line-no">231</span><span id="line.231">     * Creates a new OrderedMap with 0.75f as load factor using the elements of two parallel arrays.</span>
<span class="source-line-no">232</span><span id="line.232">     *</span>
<span class="source-line-no">233</span><span id="line.233">     * @param keyArray the array of keys of the new OrderedMap.</span>
<span class="source-line-no">234</span><span id="line.234">     * @param valueArray the array of corresponding values in the new OrderedMap.</span>
<span class="source-line-no">235</span><span id="line.235">     * @throws IllegalArgumentException if &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; have different lengths.</span>
<span class="source-line-no">236</span><span id="line.236">     */</span>
<span class="source-line-no">237</span><span id="line.237">    public IntDoubleOrderedMap(final int[] keyArray, final double[] valueArray) {</span>
<span class="source-line-no">238</span><span id="line.238">        this(keyArray, valueArray, DEFAULT_LOAD_FACTOR);</span>
<span class="source-line-no">239</span><span id="line.239">    }</span>
<span class="source-line-no">240</span><span id="line.240">    private int realSize() {</span>
<span class="source-line-no">241</span><span id="line.241">        return containsNullKey ? size - 1 : size;</span>
<span class="source-line-no">242</span><span id="line.242">    }</span>
<span class="source-line-no">243</span><span id="line.243">    private void ensureCapacity(final int capacity) {</span>
<span class="source-line-no">244</span><span id="line.244">        final int needed = arraySize(capacity, f);</span>
<span class="source-line-no">245</span><span id="line.245">        if (needed &gt; n)</span>
<span class="source-line-no">246</span><span id="line.246">            rehash(needed);</span>
<span class="source-line-no">247</span><span id="line.247">    }</span>
<span class="source-line-no">248</span><span id="line.248">    private void tryCapacity(final long capacity) {</span>
<span class="source-line-no">249</span><span id="line.249">        final int needed = (int) Math.min(</span>
<span class="source-line-no">250</span><span id="line.250">                1 &lt;&lt; 30,</span>
<span class="source-line-no">251</span><span id="line.251">                Math.max(2, HashCommon.nextPowerOfTwo((long) Math.ceil(capacity</span>
<span class="source-line-no">252</span><span id="line.252">                        / f))));</span>
<span class="source-line-no">253</span><span id="line.253">        if (needed &gt; n)</span>
<span class="source-line-no">254</span><span id="line.254">            rehash(needed);</span>
<span class="source-line-no">255</span><span id="line.255">    }</span>
<span class="source-line-no">256</span><span id="line.256">    private double removeEntry(final int pos) {</span>
<span class="source-line-no">257</span><span id="line.257">        final double oldValue = value[pos];</span>
<span class="source-line-no">258</span><span id="line.258">        size--;</span>
<span class="source-line-no">259</span><span id="line.259">        fixOrder(pos);</span>
<span class="source-line-no">260</span><span id="line.260">        shiftKeys(pos);</span>
<span class="source-line-no">261</span><span id="line.261">        if (size &lt; (maxFill &gt;&gt; 2) &amp;&amp; n &gt; DEFAULT_INITIAL_SIZE)</span>
<span class="source-line-no">262</span><span id="line.262">            rehash(n &gt;&gt; 1);</span>
<span class="source-line-no">263</span><span id="line.263">        return oldValue;</span>
<span class="source-line-no">264</span><span id="line.264">    }</span>
<span class="source-line-no">265</span><span id="line.265">    private double removeNullEntry() {</span>
<span class="source-line-no">266</span><span id="line.266">        containsNullKey = false;</span>
<span class="source-line-no">267</span><span id="line.267">        final double oldValue = value[n];</span>
<span class="source-line-no">268</span><span id="line.268">        size--;</span>
<span class="source-line-no">269</span><span id="line.269">        fixOrder(n);</span>
<span class="source-line-no">270</span><span id="line.270">        if (size &lt; (maxFill &gt;&gt; 2) &amp;&amp; n &gt; DEFAULT_INITIAL_SIZE)</span>
<span class="source-line-no">271</span><span id="line.271">            rehash(n &gt;&gt; 1);</span>
<span class="source-line-no">272</span><span id="line.272">        return oldValue;</span>
<span class="source-line-no">273</span><span id="line.273">    }</span>
<span class="source-line-no">274</span><span id="line.274"></span>
<span class="source-line-no">275</span><span id="line.275">    /**</span>
<span class="source-line-no">276</span><span id="line.276">     * Puts the first key in keyArray with the first value in valueArray, then the second in each and so on.</span>
<span class="source-line-no">277</span><span id="line.277">     * The entries are all appended to the end of the iteration order, unless a key was already present. Then,</span>
<span class="source-line-no">278</span><span id="line.278">     * its value is changed at the existing position in the iteration order.</span>
<span class="source-line-no">279</span><span id="line.279">     * If the lengths of the two arrays are not equal, this puts a number of entries equal to the lesser length.</span>
<span class="source-line-no">280</span><span id="line.280">     * If either array is null, this returns without performing any changes.</span>
<span class="source-line-no">281</span><span id="line.281">     * @param keyArray an array of int keys that should usually have the same length as valueArray</span>
<span class="source-line-no">282</span><span id="line.282">     * @param valueArray an array of int values that should usually have the same length as keyArray</span>
<span class="source-line-no">283</span><span id="line.283">     */</span>
<span class="source-line-no">284</span><span id="line.284">    public void putAll(final int[] keyArray, final double[] valueArray)</span>
<span class="source-line-no">285</span><span id="line.285">    {</span>
<span class="source-line-no">286</span><span id="line.286">        if(keyArray == null || valueArray == null)</span>
<span class="source-line-no">287</span><span id="line.287">            return;</span>
<span class="source-line-no">288</span><span id="line.288">        for (int i = 0; i &lt; keyArray.length &amp;&amp; i &lt; valueArray.length; i++)</span>
<span class="source-line-no">289</span><span id="line.289">            put(keyArray[i], valueArray[i]);</span>
<span class="source-line-no">290</span><span id="line.290"></span>
<span class="source-line-no">291</span><span id="line.291">    }</span>
<span class="source-line-no">292</span><span id="line.292"></span>
<span class="source-line-no">293</span><span id="line.293">    /**</span>
<span class="source-line-no">294</span><span id="line.294">     * Puts all key-value pairs in the Map m into this OrderedMap.</span>
<span class="source-line-no">295</span><span id="line.295">     * The entries are all appended to the end of the iteration order, unless a key was already present. Then,</span>
<span class="source-line-no">296</span><span id="line.296">     * its value is changed at the existing position in the iteration order. This can take any kind of Map,</span>
<span class="source-line-no">297</span><span id="line.297">     * including unordered HashMap objects; if the Map does not have stable ordering, the order in which entries</span>
<span class="source-line-no">298</span><span id="line.298">     * will be appended is not stable either. For this reason, OrderedMap, LinkedHashMap, and TreeMap (or other</span>
<span class="source-line-no">299</span><span id="line.299">     * SortedMap implementations) will work best when order matters.</span>
<span class="source-line-no">300</span><span id="line.300">     * @param m an IntIntOrderedMap to add into this</span>
<span class="source-line-no">301</span><span id="line.301">     */</span>
<span class="source-line-no">302</span><span id="line.302">    public void putAll(IntDoubleOrderedMap m) {</span>
<span class="source-line-no">303</span><span id="line.303">        if (f &lt;= .5)</span>
<span class="source-line-no">304</span><span id="line.304">            ensureCapacity(m.size()); // The resulting map will be sized for m.size() elements</span>
<span class="source-line-no">305</span><span id="line.305">        else</span>
<span class="source-line-no">306</span><span id="line.306">            tryCapacity(size() + m.size()); // The resulting map will be size() +  m.size() elements</span>
<span class="source-line-no">307</span><span id="line.307">        int n = m.size();</span>
<span class="source-line-no">308</span><span id="line.308">        for (int i = 0; i &lt; n; i++) {             </span>
<span class="source-line-no">309</span><span id="line.309">            put(m.keyAt(i), m.getAt(i));</span>
<span class="source-line-no">310</span><span id="line.310">        }</span>
<span class="source-line-no">311</span><span id="line.311">    }</span>
<span class="source-line-no">312</span><span id="line.312">    private int insert(final int k, final double v) {</span>
<span class="source-line-no">313</span><span id="line.313">        int pos;</span>
<span class="source-line-no">314</span><span id="line.314">        if (k == 0) {</span>
<span class="source-line-no">315</span><span id="line.315">            if (containsNullKey)</span>
<span class="source-line-no">316</span><span id="line.316">                return n;</span>
<span class="source-line-no">317</span><span id="line.317">            containsNullKey = true;</span>
<span class="source-line-no">318</span><span id="line.318">            pos = n;</span>
<span class="source-line-no">319</span><span id="line.319">        } else {</span>
<span class="source-line-no">320</span><span id="line.320">            int curr;</span>
<span class="source-line-no">321</span><span id="line.321">            final int[] key = this.key;</span>
<span class="source-line-no">322</span><span id="line.322">            // The starting point.</span>
<span class="source-line-no">323</span><span id="line.323">            if ((curr = key[pos = (HashCommon.mix(k)) &amp; mask]) != 0) {</span>
<span class="source-line-no">324</span><span id="line.324">                if (curr == k)</span>
<span class="source-line-no">325</span><span id="line.325">                    return pos;</span>
<span class="source-line-no">326</span><span id="line.326">                while ((curr = key[pos = (pos + 1) &amp; mask]) != 0)</span>
<span class="source-line-no">327</span><span id="line.327">                    if (curr == k)</span>
<span class="source-line-no">328</span><span id="line.328">                        return pos;</span>
<span class="source-line-no">329</span><span id="line.329">            }</span>
<span class="source-line-no">330</span><span id="line.330">        }</span>
<span class="source-line-no">331</span><span id="line.331">        key[pos] = k;</span>
<span class="source-line-no">332</span><span id="line.332">        value[pos] = v;</span>
<span class="source-line-no">333</span><span id="line.333">        order.add(pos);</span>
<span class="source-line-no">334</span><span id="line.334">        if (size++ &gt;= maxFill)</span>
<span class="source-line-no">335</span><span id="line.335">            rehash(arraySize(size + 1, f));</span>
<span class="source-line-no">336</span><span id="line.336">        return -1;</span>
<span class="source-line-no">337</span><span id="line.337">    }</span>
<span class="source-line-no">338</span><span id="line.338">    private int insertAt(final int k, final double v, final int idx) {</span>
<span class="source-line-no">339</span><span id="line.339">        int pos;</span>
<span class="source-line-no">340</span><span id="line.340">        if (k == 0) {</span>
<span class="source-line-no">341</span><span id="line.341">            if (containsNullKey)</span>
<span class="source-line-no">342</span><span id="line.342">            {</span>
<span class="source-line-no">343</span><span id="line.343">                fixOrder(n);</span>
<span class="source-line-no">344</span><span id="line.344">                order.insert(idx, n);</span>
<span class="source-line-no">345</span><span id="line.345">                return n;</span>
<span class="source-line-no">346</span><span id="line.346">            }</span>
<span class="source-line-no">347</span><span id="line.347">            containsNullKey = true;</span>
<span class="source-line-no">348</span><span id="line.348">            pos = n;</span>
<span class="source-line-no">349</span><span id="line.349">        } else {</span>
<span class="source-line-no">350</span><span id="line.350">            int curr;</span>
<span class="source-line-no">351</span><span id="line.351">            final int[] key = this.key;</span>
<span class="source-line-no">352</span><span id="line.352">            // The starting point.</span>
<span class="source-line-no">353</span><span id="line.353">            if ((curr = key[pos = (HashCommon.mix(k)) &amp; mask]) != 0) {</span>
<span class="source-line-no">354</span><span id="line.354">                if (curr == k)</span>
<span class="source-line-no">355</span><span id="line.355">                {</span>
<span class="source-line-no">356</span><span id="line.356">                    fixOrder(pos);</span>
<span class="source-line-no">357</span><span id="line.357">                    order.insert(idx, pos);</span>
<span class="source-line-no">358</span><span id="line.358">                    return pos;</span>
<span class="source-line-no">359</span><span id="line.359">                }</span>
<span class="source-line-no">360</span><span id="line.360">                while ((curr = key[pos = (pos + 1) &amp; mask]) != 0)</span>
<span class="source-line-no">361</span><span id="line.361">                    if (curr == k)</span>
<span class="source-line-no">362</span><span id="line.362">                    {</span>
<span class="source-line-no">363</span><span id="line.363">                        fixOrder(pos);</span>
<span class="source-line-no">364</span><span id="line.364">                        order.insert(idx, pos);</span>
<span class="source-line-no">365</span><span id="line.365">                        return pos;</span>
<span class="source-line-no">366</span><span id="line.366">                    }</span>
<span class="source-line-no">367</span><span id="line.367">            }</span>
<span class="source-line-no">368</span><span id="line.368">        }</span>
<span class="source-line-no">369</span><span id="line.369">        key[pos] = k;</span>
<span class="source-line-no">370</span><span id="line.370">        value[pos] = v;</span>
<span class="source-line-no">371</span><span id="line.371">        order.insert(idx, pos);</span>
<span class="source-line-no">372</span><span id="line.372">        if (size++ &gt;= maxFill)</span>
<span class="source-line-no">373</span><span id="line.373">            rehash(arraySize(size + 1, f));</span>
<span class="source-line-no">374</span><span id="line.374">        return -1;</span>
<span class="source-line-no">375</span><span id="line.375">    }</span>
<span class="source-line-no">376</span><span id="line.376">    public double put(final int k, final double v) {</span>
<span class="source-line-no">377</span><span id="line.377">        final int pos = insert(k, v);</span>
<span class="source-line-no">378</span><span id="line.378">        if (pos &lt; 0)</span>
<span class="source-line-no">379</span><span id="line.379">            return defRetValue;</span>
<span class="source-line-no">380</span><span id="line.380">        final double oldValue = value[pos];</span>
<span class="source-line-no">381</span><span id="line.381">        value[pos] = v;</span>
<span class="source-line-no">382</span><span id="line.382">        return oldValue;</span>
<span class="source-line-no">383</span><span id="line.383">    }</span>
<span class="source-line-no">384</span><span id="line.384">    public double putAt(final int k, final double v, final int idx) {</span>
<span class="source-line-no">385</span><span id="line.385">        final int pos = insertAt(k, v, idx);</span>
<span class="source-line-no">386</span><span id="line.386">        if (pos &lt; 0)</span>
<span class="source-line-no">387</span><span id="line.387">            return defRetValue;</span>
<span class="source-line-no">388</span><span id="line.388">        final double oldValue = value[pos];</span>
<span class="source-line-no">389</span><span id="line.389">        value[pos] = v;</span>
<span class="source-line-no">390</span><span id="line.390">        return oldValue;</span>
<span class="source-line-no">391</span><span id="line.391">    }</span>
<span class="source-line-no">392</span><span id="line.392">    /**</span>
<span class="source-line-no">393</span><span id="line.393">     * Shifts left entries with the specified hash code, starting at the</span>
<span class="source-line-no">394</span><span id="line.394">     * specified position, and empties the resulting free entry.</span>
<span class="source-line-no">395</span><span id="line.395">     *</span>
<span class="source-line-no">396</span><span id="line.396">     * @param pos</span>
<span class="source-line-no">397</span><span id="line.397">     *            a starting position.</span>
<span class="source-line-no">398</span><span id="line.398">     */</span>
<span class="source-line-no">399</span><span id="line.399">    protected final void shiftKeys(int pos) {</span>
<span class="source-line-no">400</span><span id="line.400">        // Shift entries with the same hash.</span>
<span class="source-line-no">401</span><span id="line.401">        int last, slot;</span>
<span class="source-line-no">402</span><span id="line.402">        int curr;</span>
<span class="source-line-no">403</span><span id="line.403">        final int[] key = this.key;</span>
<span class="source-line-no">404</span><span id="line.404">        for (;;) {</span>
<span class="source-line-no">405</span><span id="line.405">            pos = ((last = pos) + 1) &amp; mask;</span>
<span class="source-line-no">406</span><span id="line.406">            for (;;) {</span>
<span class="source-line-no">407</span><span id="line.407">                if ((curr = key[pos]) == 0) {</span>
<span class="source-line-no">408</span><span id="line.408">                    key[last] = 0;</span>
<span class="source-line-no">409</span><span id="line.409">                    return;</span>
<span class="source-line-no">410</span><span id="line.410">                }</span>
<span class="source-line-no">411</span><span id="line.411">                slot = (HashCommon.mix(curr))</span>
<span class="source-line-no">412</span><span id="line.412">                        &amp; mask;</span>
<span class="source-line-no">413</span><span id="line.413">                if (last &lt;= pos ? last &gt;= slot || slot &gt; pos : last &gt;= slot</span>
<span class="source-line-no">414</span><span id="line.414">                        &amp;&amp; slot &gt; pos)</span>
<span class="source-line-no">415</span><span id="line.415">                    break;</span>
<span class="source-line-no">416</span><span id="line.416">                pos = (pos + 1) &amp; mask;</span>
<span class="source-line-no">417</span><span id="line.417">            }</span>
<span class="source-line-no">418</span><span id="line.418">            key[last] = curr;</span>
<span class="source-line-no">419</span><span id="line.419">            value[last] = value[pos];</span>
<span class="source-line-no">420</span><span id="line.420">            fixOrder(pos, last);</span>
<span class="source-line-no">421</span><span id="line.421">        }</span>
<span class="source-line-no">422</span><span id="line.422">    }</span>
<span class="source-line-no">423</span><span id="line.423">    public double remove(final int k) {</span>
<span class="source-line-no">424</span><span id="line.424">        if (k == 0) {</span>
<span class="source-line-no">425</span><span id="line.425">            if (containsNullKey)</span>
<span class="source-line-no">426</span><span id="line.426">                return removeNullEntry();</span>
<span class="source-line-no">427</span><span id="line.427">            return defRetValue;</span>
<span class="source-line-no">428</span><span id="line.428">        }</span>
<span class="source-line-no">429</span><span id="line.429">        int curr;</span>
<span class="source-line-no">430</span><span id="line.430">        final int[] key = this.key;</span>
<span class="source-line-no">431</span><span id="line.431">        int pos;</span>
<span class="source-line-no">432</span><span id="line.432">        // The starting point.</span>
<span class="source-line-no">433</span><span id="line.433">        if ((curr = key[pos = (HashCommon.mix(k)) &amp; mask]) == 0)</span>
<span class="source-line-no">434</span><span id="line.434">            return defRetValue;</span>
<span class="source-line-no">435</span><span id="line.435">        if (k == curr)</span>
<span class="source-line-no">436</span><span id="line.436">            return removeEntry(pos);</span>
<span class="source-line-no">437</span><span id="line.437">        while (true) {</span>
<span class="source-line-no">438</span><span id="line.438">            if ((curr = key[pos = (pos + 1) &amp; mask]) == 0)</span>
<span class="source-line-no">439</span><span id="line.439">                return defRetValue;</span>
<span class="source-line-no">440</span><span id="line.440">            if (k == curr)</span>
<span class="source-line-no">441</span><span id="line.441">                return removeEntry(pos);</span>
<span class="source-line-no">442</span><span id="line.442">        }</span>
<span class="source-line-no">443</span><span id="line.443">    }</span>
<span class="source-line-no">444</span><span id="line.444">    private double setValue(final int pos, final double v) {</span>
<span class="source-line-no">445</span><span id="line.445">        final double oldValue = value[pos];</span>
<span class="source-line-no">446</span><span id="line.446">        value[pos] = v;</span>
<span class="source-line-no">447</span><span id="line.447">        return oldValue;</span>
<span class="source-line-no">448</span><span id="line.448">    }</span>
<span class="source-line-no">449</span><span id="line.449">    /**</span>
<span class="source-line-no">450</span><span id="line.450">     * Removes the mapping associated with the first key in iteration order.</span>
<span class="source-line-no">451</span><span id="line.451">     *</span>
<span class="source-line-no">452</span><span id="line.452">     * @return the value previously associated with the first key in iteration</span>
<span class="source-line-no">453</span><span id="line.453">     *         order.</span>
<span class="source-line-no">454</span><span id="line.454">     * @throws NoSuchElementException</span>
<span class="source-line-no">455</span><span id="line.455">     *             is this map is empty.</span>
<span class="source-line-no">456</span><span id="line.456">     */</span>
<span class="source-line-no">457</span><span id="line.457">    public double removeFirst() {</span>
<span class="source-line-no">458</span><span id="line.458">        return removeAt(0);</span>
<span class="source-line-no">459</span><span id="line.459">    }</span>
<span class="source-line-no">460</span><span id="line.460">    /**</span>
<span class="source-line-no">461</span><span id="line.461">     * Removes the mapping associated with the last key in iteration order.</span>
<span class="source-line-no">462</span><span id="line.462">     *</span>
<span class="source-line-no">463</span><span id="line.463">     * @return the value previously associated with the last key in iteration</span>
<span class="source-line-no">464</span><span id="line.464">     *         order.</span>
<span class="source-line-no">465</span><span id="line.465">     * @throws NoSuchElementException</span>
<span class="source-line-no">466</span><span id="line.466">     *             is this map is empty.</span>
<span class="source-line-no">467</span><span id="line.467">     */</span>
<span class="source-line-no">468</span><span id="line.468">    public double removeLast() {</span>
<span class="source-line-no">469</span><span id="line.469">        return removeAt(size-1);</span>
<span class="source-line-no">470</span><span id="line.470">    }</span>
<span class="source-line-no">471</span><span id="line.471">    public double get(final int k) {</span>
<span class="source-line-no">472</span><span id="line.472">        if (k == 0)</span>
<span class="source-line-no">473</span><span id="line.473">            return containsNullKey ? value[n] : defRetValue;</span>
<span class="source-line-no">474</span><span id="line.474">        int curr;</span>
<span class="source-line-no">475</span><span id="line.475">        final int[] key = this.key;</span>
<span class="source-line-no">476</span><span id="line.476">        int pos;</span>
<span class="source-line-no">477</span><span id="line.477">        // The starting point.</span>
<span class="source-line-no">478</span><span id="line.478">        if ((curr = key[pos = (HashCommon.mix(k)) &amp; mask]) == 0)</span>
<span class="source-line-no">479</span><span id="line.479">            return defRetValue;</span>
<span class="source-line-no">480</span><span id="line.480">        if (k == curr)</span>
<span class="source-line-no">481</span><span id="line.481">            return value[pos];</span>
<span class="source-line-no">482</span><span id="line.482">        // There's always an unused entry.</span>
<span class="source-line-no">483</span><span id="line.483">        while (true) {</span>
<span class="source-line-no">484</span><span id="line.484">            if ((curr = key[pos = (pos + 1) &amp; mask]) == 0)</span>
<span class="source-line-no">485</span><span id="line.485">                return defRetValue;</span>
<span class="source-line-no">486</span><span id="line.486">            if (k == curr)</span>
<span class="source-line-no">487</span><span id="line.487">                return value[pos];</span>
<span class="source-line-no">488</span><span id="line.488">        }</span>
<span class="source-line-no">489</span><span id="line.489">    }</span>
<span class="source-line-no">490</span><span id="line.490"></span>
<span class="source-line-no">491</span><span id="line.491"></span>
<span class="source-line-no">492</span><span id="line.492">    public double getOrDefault(final int k, final double defaultValue) {</span>
<span class="source-line-no">493</span><span id="line.493">        if (k == 0)</span>
<span class="source-line-no">494</span><span id="line.494">            return containsNullKey ? value[n] : defaultValue;</span>
<span class="source-line-no">495</span><span id="line.495">        int curr;</span>
<span class="source-line-no">496</span><span id="line.496">        final int[] key = this.key;</span>
<span class="source-line-no">497</span><span id="line.497">        int pos;</span>
<span class="source-line-no">498</span><span id="line.498">        // The starting point.</span>
<span class="source-line-no">499</span><span id="line.499">        if ((curr = key[pos = (HashCommon.mix(k)) &amp; mask]) == 0)</span>
<span class="source-line-no">500</span><span id="line.500">            return defaultValue;</span>
<span class="source-line-no">501</span><span id="line.501">        if (k == curr)</span>
<span class="source-line-no">502</span><span id="line.502">            return value[pos];</span>
<span class="source-line-no">503</span><span id="line.503">        // There's always an unused entry.</span>
<span class="source-line-no">504</span><span id="line.504">        while (true) {</span>
<span class="source-line-no">505</span><span id="line.505">            if ((curr = key[pos = (pos + 1) &amp; mask]) == 0)</span>
<span class="source-line-no">506</span><span id="line.506">                return defaultValue;</span>
<span class="source-line-no">507</span><span id="line.507">            if (k == curr)</span>
<span class="source-line-no">508</span><span id="line.508">                return value[pos];</span>
<span class="source-line-no">509</span><span id="line.509">        }</span>
<span class="source-line-no">510</span><span id="line.510">    }</span>
<span class="source-line-no">511</span><span id="line.511"></span>
<span class="source-line-no">512</span><span id="line.512">    protected int positionOf(final int k) {</span>
<span class="source-line-no">513</span><span id="line.513">        if (k == 0)</span>
<span class="source-line-no">514</span><span id="line.514">        {</span>
<span class="source-line-no">515</span><span id="line.515">            if(containsNullKey)</span>
<span class="source-line-no">516</span><span id="line.516">                return n;</span>
<span class="source-line-no">517</span><span id="line.517">            else</span>
<span class="source-line-no">518</span><span id="line.518">                return -1;</span>
<span class="source-line-no">519</span><span id="line.519">        }</span>
<span class="source-line-no">520</span><span id="line.520">        int curr;</span>
<span class="source-line-no">521</span><span id="line.521">        final int[] key = this.key;</span>
<span class="source-line-no">522</span><span id="line.522">        int pos;</span>
<span class="source-line-no">523</span><span id="line.523">        // The starting point.</span>
<span class="source-line-no">524</span><span id="line.524">        if ((curr = key[pos = (HashCommon.mix(k)) &amp; mask]) == 0)</span>
<span class="source-line-no">525</span><span id="line.525">            return -1;</span>
<span class="source-line-no">526</span><span id="line.526">        if (k == curr)</span>
<span class="source-line-no">527</span><span id="line.527">            return pos;</span>
<span class="source-line-no">528</span><span id="line.528">        // There's always an unused entry.</span>
<span class="source-line-no">529</span><span id="line.529">        while (true) {</span>
<span class="source-line-no">530</span><span id="line.530">            if ((curr = key[pos = pos + 1 &amp; mask]) == 0)</span>
<span class="source-line-no">531</span><span id="line.531">                return -1;</span>
<span class="source-line-no">532</span><span id="line.532">            if (k == curr)</span>
<span class="source-line-no">533</span><span id="line.533">                return pos;</span>
<span class="source-line-no">534</span><span id="line.534">        }</span>
<span class="source-line-no">535</span><span id="line.535">    }</span>
<span class="source-line-no">536</span><span id="line.536"></span>
<span class="source-line-no">537</span><span id="line.537">    /**</span>
<span class="source-line-no">538</span><span id="line.538">     * Gets the position in the ordering of the given key, though not as efficiently as some data structures can do it</span>
<span class="source-line-no">539</span><span id="line.539">     * (e.g. {@link Arrangement} can access ordering position very quickly but doesn't store other values on its own).</span>
<span class="source-line-no">540</span><span id="line.540">     * Returns a value that is at least 0 if it found k, or -1 if k was not present.</span>
<span class="source-line-no">541</span><span id="line.541">     * @param k a key or possible key that this should find the index of</span>
<span class="source-line-no">542</span><span id="line.542">     * @return the index of k, if present, or -1 if it is not present in this OrderedMap</span>
<span class="source-line-no">543</span><span id="line.543">     */</span>
<span class="source-line-no">544</span><span id="line.544">    public int indexOf(final int k)</span>
<span class="source-line-no">545</span><span id="line.545">    {</span>
<span class="source-line-no">546</span><span id="line.546">        int pos = positionOf(k);</span>
<span class="source-line-no">547</span><span id="line.547">        return (pos &lt; 0) ? -1 : order.indexOf(pos);</span>
<span class="source-line-no">548</span><span id="line.548">    }</span>
<span class="source-line-no">549</span><span id="line.549"></span>
<span class="source-line-no">550</span><span id="line.550">    /**</span>
<span class="source-line-no">551</span><span id="line.551">     * Swaps the positions in the ordering for the given items, if they are both present. Returns true if the ordering</span>
<span class="source-line-no">552</span><span id="line.552">     * changed as a result of this call, or false if it stayed the same (which can be because left or right was not</span>
<span class="source-line-no">553</span><span id="line.553">     * present, or because left and right are the same reference (so swapping would do nothing)).</span>
<span class="source-line-no">554</span><span id="line.554">     * @param left an item that should be present in this OrderedMap</span>
<span class="source-line-no">555</span><span id="line.555">     * @param right an item that should be present in this OrderedMap</span>
<span class="source-line-no">556</span><span id="line.556">     * @return true if this OrderedMap changed in ordering as a result of this call, or false otherwise</span>
<span class="source-line-no">557</span><span id="line.557">     */</span>
<span class="source-line-no">558</span><span id="line.558">    public boolean swap(final int left, final int right)</span>
<span class="source-line-no">559</span><span id="line.559">    {</span>
<span class="source-line-no">560</span><span id="line.560">        if(left == right) return false;</span>
<span class="source-line-no">561</span><span id="line.561">        int l = indexOf(left);</span>
<span class="source-line-no">562</span><span id="line.562">        if(l &lt; 0) return false;</span>
<span class="source-line-no">563</span><span id="line.563">        int r = indexOf(right);</span>
<span class="source-line-no">564</span><span id="line.564">        if(r &lt; 0) return false;</span>
<span class="source-line-no">565</span><span id="line.565">        order.swap(l, r);</span>
<span class="source-line-no">566</span><span id="line.566">        return true;</span>
<span class="source-line-no">567</span><span id="line.567">    }</span>
<span class="source-line-no">568</span><span id="line.568">    /**</span>
<span class="source-line-no">569</span><span id="line.569">     * Swaps the given indices in the ordering, if they are both valid int indices. Returns true if the ordering</span>
<span class="source-line-no">570</span><span id="line.570">     * changed as a result of this call, or false if it stayed the same (which can be because left or right referred to</span>
<span class="source-line-no">571</span><span id="line.571">     * an out-of-bounds index, or because left and right are equal (so swapping would do nothing)).</span>
<span class="source-line-no">572</span><span id="line.572">     * @param left an index of an item in this OrderedMap, at least 0 and less than {@link #size()}</span>
<span class="source-line-no">573</span><span id="line.573">     * @param right an index of an item in this OrderedMap, at least 0 and less than {@link #size()}</span>
<span class="source-line-no">574</span><span id="line.574">     * @return true if this OrderedMap changed in ordering as a result of this call, or false otherwise</span>
<span class="source-line-no">575</span><span id="line.575">     */</span>
<span class="source-line-no">576</span><span id="line.576">    public boolean swapIndices(final int left, final int right)</span>
<span class="source-line-no">577</span><span id="line.577">    {</span>
<span class="source-line-no">578</span><span id="line.578">        if(left &lt; 0 || right &lt; 0 || left &gt;= order.size || right &gt;= order.size || left == right) return false;</span>
<span class="source-line-no">579</span><span id="line.579">        order.swap(left, right);</span>
<span class="source-line-no">580</span><span id="line.580">        return true;</span>
<span class="source-line-no">581</span><span id="line.581">    }</span>
<span class="source-line-no">582</span><span id="line.582"></span>
<span class="source-line-no">583</span><span id="line.583"></span>
<span class="source-line-no">584</span><span id="line.584">    public boolean containsKey(final int k) {</span>
<span class="source-line-no">585</span><span id="line.585">        if (k == 0)</span>
<span class="source-line-no">586</span><span id="line.586">            return containsNullKey;</span>
<span class="source-line-no">587</span><span id="line.587">        int curr;</span>
<span class="source-line-no">588</span><span id="line.588">        final int[] key = this.key;</span>
<span class="source-line-no">589</span><span id="line.589">        int pos;</span>
<span class="source-line-no">590</span><span id="line.590">        // The starting point.</span>
<span class="source-line-no">591</span><span id="line.591">        if ((curr = key[pos = (HashCommon.mix(k)) &amp; mask]) == 0)</span>
<span class="source-line-no">592</span><span id="line.592">            return false;</span>
<span class="source-line-no">593</span><span id="line.593">        if (k == curr)</span>
<span class="source-line-no">594</span><span id="line.594">            return true;</span>
<span class="source-line-no">595</span><span id="line.595">        // There's always an unused entry.</span>
<span class="source-line-no">596</span><span id="line.596">        while (true) {</span>
<span class="source-line-no">597</span><span id="line.597">            if ((curr = key[pos = (pos + 1) &amp; mask]) == 0)</span>
<span class="source-line-no">598</span><span id="line.598">                return false;</span>
<span class="source-line-no">599</span><span id="line.599">            if (k == curr)</span>
<span class="source-line-no">600</span><span id="line.600">                return true;</span>
<span class="source-line-no">601</span><span id="line.601">        }</span>
<span class="source-line-no">602</span><span id="line.602">    }</span>
<span class="source-line-no">603</span><span id="line.603">    public boolean containsValue(final double v) {</span>
<span class="source-line-no">604</span><span id="line.604">        final double[] value = this.value;</span>
<span class="source-line-no">605</span><span id="line.605">        final int[] key = this.key;</span>
<span class="source-line-no">606</span><span id="line.606">        if (containsNullKey &amp;&amp; value[n] == v)</span>
<span class="source-line-no">607</span><span id="line.607">            return true;</span>
<span class="source-line-no">608</span><span id="line.608">        for (int i = n; i-- != 0;)</span>
<span class="source-line-no">609</span><span id="line.609">            if (key[i] != 0 &amp;&amp; value[i] == v)</span>
<span class="source-line-no">610</span><span id="line.610">                return true;</span>
<span class="source-line-no">611</span><span id="line.611">        return false;</span>
<span class="source-line-no">612</span><span id="line.612">    }</span>
<span class="source-line-no">613</span><span id="line.613">    /*</span>
<span class="source-line-no">614</span><span id="line.614">     * Removes all elements from this map.</span>
<span class="source-line-no">615</span><span id="line.615">     *</span>
<span class="source-line-no">616</span><span id="line.616">     * &lt;P&gt;To increase object reuse, this method does not change the table size.</span>
<span class="source-line-no">617</span><span id="line.617">     * If you want to reduce the table size, you must use {@link #trim()}.</span>
<span class="source-line-no">618</span><span id="line.618">     */</span>
<span class="source-line-no">619</span><span id="line.619">    public void clear() {</span>
<span class="source-line-no">620</span><span id="line.620">        if (size == 0)</span>
<span class="source-line-no">621</span><span id="line.621">            return;</span>
<span class="source-line-no">622</span><span id="line.622">        size = 0;</span>
<span class="source-line-no">623</span><span id="line.623">        containsNullKey = false;</span>
<span class="source-line-no">624</span><span id="line.624">        Arrays.fill(key, 0);</span>
<span class="source-line-no">625</span><span id="line.625">        order.clear();</span>
<span class="source-line-no">626</span><span id="line.626">    }</span>
<span class="source-line-no">627</span><span id="line.627"></span>
<span class="source-line-no">628</span><span id="line.628">    public int size() {</span>
<span class="source-line-no">629</span><span id="line.629">        return size;</span>
<span class="source-line-no">630</span><span id="line.630">    }</span>
<span class="source-line-no">631</span><span id="line.631"></span>
<span class="source-line-no">632</span><span id="line.632">    public boolean isEmpty() {</span>
<span class="source-line-no">633</span><span id="line.633">        return size == 0;</span>
<span class="source-line-no">634</span><span id="line.634">    }</span>
<span class="source-line-no">635</span><span id="line.635"></span>
<span class="source-line-no">636</span><span id="line.636">    /**</span>
<span class="source-line-no">637</span><span id="line.637">     * Looks up the key {@code k} in this map, remembers the associated value (which will be</span>
<span class="source-line-no">638</span><span id="line.638">     * {@link #defaultReturnValue()} if k wasn't found), adds {@code increment} to the actual associated value in the</span>
<span class="source-line-no">639</span><span id="line.639">     * map, and returns the remembered value.</span>
<span class="source-line-no">640</span><span id="line.640">     * @param k a key to look up</span>
<span class="source-line-no">641</span><span id="line.641">     * @param increment a double to add to the value associated with {@code k}</span>
<span class="source-line-no">642</span><span id="line.642">     * @return the previous value associated with k, or {@link #defaultReturnValue()} if k wasn't found</span>
<span class="source-line-no">643</span><span id="line.643">     */</span>
<span class="source-line-no">644</span><span id="line.644">    public double getAndIncrement(int k, double increment) {</span>
<span class="source-line-no">645</span><span id="line.645">        if (k == 0) {</span>
<span class="source-line-no">646</span><span id="line.646">            if (containsNullKey) {</span>
<span class="source-line-no">647</span><span id="line.647">                double got = value[n];</span>
<span class="source-line-no">648</span><span id="line.648">                value[n] += increment;</span>
<span class="source-line-no">649</span><span id="line.649">                return got;</span>
<span class="source-line-no">650</span><span id="line.650">            } else {</span>
<span class="source-line-no">651</span><span id="line.651">                value[n] = defRetValue + increment;</span>
<span class="source-line-no">652</span><span id="line.652">                return defRetValue;</span>
<span class="source-line-no">653</span><span id="line.653">            }</span>
<span class="source-line-no">654</span><span id="line.654">        }</span>
<span class="source-line-no">655</span><span id="line.655">        int curr;</span>
<span class="source-line-no">656</span><span id="line.656">        final int[] key = this.key;</span>
<span class="source-line-no">657</span><span id="line.657">        int pos;</span>
<span class="source-line-no">658</span><span id="line.658">        // The starting point.</span>
<span class="source-line-no">659</span><span id="line.659">        if ((curr = key[pos = (HashCommon.mix(k)) &amp; mask]) == 0)</span>
<span class="source-line-no">660</span><span id="line.660">        {</span>
<span class="source-line-no">661</span><span id="line.661">            put(k, defRetValue + increment);</span>
<span class="source-line-no">662</span><span id="line.662">            return defRetValue;</span>
<span class="source-line-no">663</span><span id="line.663">        }</span>
<span class="source-line-no">664</span><span id="line.664">        if (k == curr)</span>
<span class="source-line-no">665</span><span id="line.665">        {</span>
<span class="source-line-no">666</span><span id="line.666">            double got = value[pos];</span>
<span class="source-line-no">667</span><span id="line.667">            value[pos] += increment;</span>
<span class="source-line-no">668</span><span id="line.668">            return got;</span>
<span class="source-line-no">669</span><span id="line.669">        }</span>
<span class="source-line-no">670</span><span id="line.670">        // There's always an unused entry.</span>
<span class="source-line-no">671</span><span id="line.671">        while (true) {</span>
<span class="source-line-no">672</span><span id="line.672">            if ((curr = key[pos = (pos + 1) &amp; mask]) == 0)</span>
<span class="source-line-no">673</span><span id="line.673">            {</span>
<span class="source-line-no">674</span><span id="line.674">                put(k, defRetValue + increment);</span>
<span class="source-line-no">675</span><span id="line.675">                return defRetValue;</span>
<span class="source-line-no">676</span><span id="line.676">            }</span>
<span class="source-line-no">677</span><span id="line.677">            if (k == curr)</span>
<span class="source-line-no">678</span><span id="line.678">            {</span>
<span class="source-line-no">679</span><span id="line.679">                double got = value[pos];</span>
<span class="source-line-no">680</span><span id="line.680">                value[pos] += increment;</span>
<span class="source-line-no">681</span><span id="line.681">                return got;</span>
<span class="source-line-no">682</span><span id="line.682">            }</span>
<span class="source-line-no">683</span><span id="line.683">        }</span>
<span class="source-line-no">684</span><span id="line.684">    }</span>
<span class="source-line-no">685</span><span id="line.685"></span>
<span class="source-line-no">686</span><span id="line.686">    /**</span>
<span class="source-line-no">687</span><span id="line.687">     * The entry class for a OrderedMap does not record key and value, but rather the position in the hash table of the corresponding entry. This is necessary so that calls to</span>
<span class="source-line-no">688</span><span id="line.688">     * {@link MapEntry#setValue(double)} are reflected in the map</span>
<span class="source-line-no">689</span><span id="line.689">     */</span>
<span class="source-line-no">690</span><span id="line.690">    public final class MapEntry {</span>
<span class="source-line-no">691</span><span id="line.691">        // The table index this entry refers to, or -1 if this entry has been</span>
<span class="source-line-no">692</span><span id="line.692">        // deleted.</span>
<span class="source-line-no">693</span><span id="line.693">        int index;</span>
<span class="source-line-no">694</span><span id="line.694">        MapEntry(final int index) {</span>
<span class="source-line-no">695</span><span id="line.695">            this.index = index;</span>
<span class="source-line-no">696</span><span id="line.696">        }</span>
<span class="source-line-no">697</span><span id="line.697">        MapEntry() {</span>
<span class="source-line-no">698</span><span id="line.698">        }</span>
<span class="source-line-no">699</span><span id="line.699">        public int getKey() {</span>
<span class="source-line-no">700</span><span id="line.700">            return key[index];</span>
<span class="source-line-no">701</span><span id="line.701">        }</span>
<span class="source-line-no">702</span><span id="line.702">        public double getValue() {</span>
<span class="source-line-no">703</span><span id="line.703">            return value[index];</span>
<span class="source-line-no">704</span><span id="line.704">        }</span>
<span class="source-line-no">705</span><span id="line.705">        public double setValue(final double v) {</span>
<span class="source-line-no">706</span><span id="line.706">            final double oldValue = value[index];</span>
<span class="source-line-no">707</span><span id="line.707">            value[index] = v;</span>
<span class="source-line-no">708</span><span id="line.708">            return oldValue;</span>
<span class="source-line-no">709</span><span id="line.709">        }</span>
<span class="source-line-no">710</span><span id="line.710">        public boolean equals(final Object o) {</span>
<span class="source-line-no">711</span><span id="line.711">            if (!(o instanceof MapEntry))</span>
<span class="source-line-no">712</span><span id="line.712">                return false;</span>
<span class="source-line-no">713</span><span id="line.713">            MapEntry e = (MapEntry) o;</span>
<span class="source-line-no">714</span><span id="line.714">            return (key[index] == e.getKey())</span>
<span class="source-line-no">715</span><span id="line.715">                    &amp;&amp; (value[index] == e.getValue());</span>
<span class="source-line-no">716</span><span id="line.716">        }</span>
<span class="source-line-no">717</span><span id="line.717">        public int hashCode() {</span>
<span class="source-line-no">718</span><span id="line.718">            return HashCommon.mix(key[index])</span>
<span class="source-line-no">719</span><span id="line.719">                    ^ HashCommon.mix(NumberTools.doubleToMixedIntBits(value[index]));</span>
<span class="source-line-no">720</span><span id="line.720">        }</span>
<span class="source-line-no">721</span><span id="line.721">        @Override</span>
<span class="source-line-no">722</span><span id="line.722">        public String toString() {</span>
<span class="source-line-no">723</span><span id="line.723">            return key[index] + "=&gt;" + value[index];</span>
<span class="source-line-no">724</span><span id="line.724">        }</span>
<span class="source-line-no">725</span><span id="line.725">    }</span>
<span class="source-line-no">726</span><span id="line.726"></span>
<span class="source-line-no">727</span><span id="line.727">    /**</span>
<span class="source-line-no">728</span><span id="line.728">     * Modifies the ordering so that the given entry is removed. This method will complete in logarithmic time.</span>
<span class="source-line-no">729</span><span id="line.729">     *</span>
<span class="source-line-no">730</span><span id="line.730">     * @param i the index of an entry.</span>
<span class="source-line-no">731</span><span id="line.731">     * @return the iteration-order index of the removed entry</span>
<span class="source-line-no">732</span><span id="line.732">     */</span>
<span class="source-line-no">733</span><span id="line.733">    protected int fixOrder(final int i) {</span>
<span class="source-line-no">734</span><span id="line.734">        if (size == 0) {</span>
<span class="source-line-no">735</span><span id="line.735">            order.clear();</span>
<span class="source-line-no">736</span><span id="line.736">            return -1;</span>
<span class="source-line-no">737</span><span id="line.737">        }</span>
<span class="source-line-no">738</span><span id="line.738">        return order.removeValue(i);</span>
<span class="source-line-no">739</span><span id="line.739">    }</span>
<span class="source-line-no">740</span><span id="line.740"></span>
<span class="source-line-no">741</span><span id="line.741">    /**</span>
<span class="source-line-no">742</span><span id="line.742">     * Modifies the ordering for a shift from s to d.</span>
<span class="source-line-no">743</span><span id="line.743">     * &lt;br&gt;</span>
<span class="source-line-no">744</span><span id="line.744">     * This method will complete in logarithmic time or better.</span>
<span class="source-line-no">745</span><span id="line.745">     *</span>
<span class="source-line-no">746</span><span id="line.746">     * @param s the source position.</span>
<span class="source-line-no">747</span><span id="line.747">     * @param d the destination position.</span>
<span class="source-line-no">748</span><span id="line.748">     */</span>
<span class="source-line-no">749</span><span id="line.749">    protected void fixOrder(int s, int d) {</span>
<span class="source-line-no">750</span><span id="line.750">        if(size == 0)</span>
<span class="source-line-no">751</span><span id="line.751">            return;</span>
<span class="source-line-no">752</span><span id="line.752">        if (size == 1 || order.items[0] == s) {</span>
<span class="source-line-no">753</span><span id="line.753">            order.set(0, d);</span>
<span class="source-line-no">754</span><span id="line.754">        }</span>
<span class="source-line-no">755</span><span id="line.755">        else if (order.items[order.size-1] == s) {</span>
<span class="source-line-no">756</span><span id="line.756">            order.set(order.size - 1, d);</span>
<span class="source-line-no">757</span><span id="line.757">        }</span>
<span class="source-line-no">758</span><span id="line.758">        else</span>
<span class="source-line-no">759</span><span id="line.759">        {</span>
<span class="source-line-no">760</span><span id="line.760">            order.set(order.indexOf(s), d);</span>
<span class="source-line-no">761</span><span id="line.761">        }</span>
<span class="source-line-no">762</span><span id="line.762">    }</span>
<span class="source-line-no">763</span><span id="line.763"></span>
<span class="source-line-no">764</span><span id="line.764">    /**</span>
<span class="source-line-no">765</span><span id="line.765">     * Returns the first key of this map in iteration order.</span>
<span class="source-line-no">766</span><span id="line.766">     *</span>
<span class="source-line-no">767</span><span id="line.767">     * @return the first key in iteration order.</span>
<span class="source-line-no">768</span><span id="line.768">     */</span>
<span class="source-line-no">769</span><span id="line.769">    public int firstKey() {</span>
<span class="source-line-no">770</span><span id="line.770">        if (size == 0)</span>
<span class="source-line-no">771</span><span id="line.771">            throw new NoSuchElementException();</span>
<span class="source-line-no">772</span><span id="line.772">        return key[order.items[0]];</span>
<span class="source-line-no">773</span><span id="line.773">    }</span>
<span class="source-line-no">774</span><span id="line.774">    /**</span>
<span class="source-line-no">775</span><span id="line.775">     * Returns the last key of this map in iteration order.</span>
<span class="source-line-no">776</span><span id="line.776">     *</span>
<span class="source-line-no">777</span><span id="line.777">     * @return the last key in iteration order.</span>
<span class="source-line-no">778</span><span id="line.778">     */</span>
<span class="source-line-no">779</span><span id="line.779">    public int lastKey() {</span>
<span class="source-line-no">780</span><span id="line.780">        if (size == 0)</span>
<span class="source-line-no">781</span><span id="line.781">            throw new NoSuchElementException();</span>
<span class="source-line-no">782</span><span id="line.782">        return key[order.items[order.size-1]];</span>
<span class="source-line-no">783</span><span id="line.783">    }</span>
<span class="source-line-no">784</span><span id="line.784">    /**</span>
<span class="source-line-no">785</span><span id="line.785">     * A list iterator over a OrderedMap.</span>
<span class="source-line-no">786</span><span id="line.786">     *</span>
<span class="source-line-no">787</span><span id="line.787">     * &lt;P&gt;</span>
<span class="source-line-no">788</span><span id="line.788">     * This class provides a list iterator over a OrderedMap. The</span>
<span class="source-line-no">789</span><span id="line.789">     * constructor runs in constant time.</span>
<span class="source-line-no">790</span><span id="line.790">     */</span>
<span class="source-line-no">791</span><span id="line.791">    private class MapIterator {</span>
<span class="source-line-no">792</span><span id="line.792">        /**</span>
<span class="source-line-no">793</span><span id="line.793">         * The entry that will be returned by the next call to</span>
<span class="source-line-no">794</span><span id="line.794">         * {@link ListIterator#previous()} (or &lt;code&gt;null&lt;/code&gt; if no</span>
<span class="source-line-no">795</span><span id="line.795">         * previous entry exists).</span>
<span class="source-line-no">796</span><span id="line.796">         */</span>
<span class="source-line-no">797</span><span id="line.797">        int prev = -1;</span>
<span class="source-line-no">798</span><span id="line.798">        /**</span>
<span class="source-line-no">799</span><span id="line.799">         * The entry that will be returned by the next call to</span>
<span class="source-line-no">800</span><span id="line.800">         * {@link ListIterator#next()} (or &lt;code&gt;null&lt;/code&gt; if no</span>
<span class="source-line-no">801</span><span id="line.801">         * next entry exists).</span>
<span class="source-line-no">802</span><span id="line.802">         */</span>
<span class="source-line-no">803</span><span id="line.803">        int next;</span>
<span class="source-line-no">804</span><span id="line.804">        /**</span>
<span class="source-line-no">805</span><span id="line.805">         * The last entry that was returned (or -1 if we did not iterate or used</span>
<span class="source-line-no">806</span><span id="line.806">         * {@link Iterator#remove()}).</span>
<span class="source-line-no">807</span><span id="line.807">         */</span>
<span class="source-line-no">808</span><span id="line.808">        int curr = -1;</span>
<span class="source-line-no">809</span><span id="line.809">        /**</span>
<span class="source-line-no">810</span><span id="line.810">         * The current index (in the sense of a {@link ListIterator}).</span>
<span class="source-line-no">811</span><span id="line.811">         * Note that this value is not meaningful when this iterator has been</span>
<span class="source-line-no">812</span><span id="line.812">         * created using the nonempty constructor.</span>
<span class="source-line-no">813</span><span id="line.813">         */</span>
<span class="source-line-no">814</span><span id="line.814">        int index;</span>
<span class="source-line-no">815</span><span id="line.815">        private MapIterator() {</span>
<span class="source-line-no">816</span><span id="line.816">            next = size == 0 ? -1 : order.items[0];</span>
<span class="source-line-no">817</span><span id="line.817">            index = 0;</span>
<span class="source-line-no">818</span><span id="line.818">        }</span>
<span class="source-line-no">819</span><span id="line.819">        /*</span>
<span class="source-line-no">820</span><span id="line.820">        private MapIterator(final K from) {</span>
<span class="source-line-no">821</span><span id="line.821">            if (((from) == null)) {</span>
<span class="source-line-no">822</span><span id="line.822">                if (containsNullKey) {</span>
<span class="source-line-no">823</span><span id="line.823">                    next = (int) link[n];</span>
<span class="source-line-no">824</span><span id="line.824">                    prev = n;</span>
<span class="source-line-no">825</span><span id="line.825">                    return;</span>
<span class="source-line-no">826</span><span id="line.826">                } else</span>
<span class="source-line-no">827</span><span id="line.827">                    throw new NoSuchElementException("The key null"</span>
<span class="source-line-no">828</span><span id="line.828">                            + " does not belong to this map.");</span>
<span class="source-line-no">829</span><span id="line.829">            }</span>
<span class="source-line-no">830</span><span id="line.830">            if (((key[last]) != null &amp;&amp; (key[last]).equals(from))) {</span>
<span class="source-line-no">831</span><span id="line.831">                prev = last;</span>
<span class="source-line-no">832</span><span id="line.832">                index = size;</span>
<span class="source-line-no">833</span><span id="line.833">                return;</span>
<span class="source-line-no">834</span><span id="line.834">            }</span>
<span class="source-line-no">835</span><span id="line.835">            // The starting point.</span>
<span class="source-line-no">836</span><span id="line.836">            int pos = (((from).hashCode()))</span>
<span class="source-line-no">837</span><span id="line.837">                    &amp; mask;</span>
<span class="source-line-no">838</span><span id="line.838">            // There's always an unused entry.</span>
<span class="source-line-no">839</span><span id="line.839">            while (!((key[pos]) == null)) {</span>
<span class="source-line-no">840</span><span id="line.840">                if (((key[pos]).equals(from))) {</span>
<span class="source-line-no">841</span><span id="line.841">                    // Note: no valid index known.</span>
<span class="source-line-no">842</span><span id="line.842">                    next = (int) link[pos];</span>
<span class="source-line-no">843</span><span id="line.843">                    prev = pos;</span>
<span class="source-line-no">844</span><span id="line.844">                    return;</span>
<span class="source-line-no">845</span><span id="line.845">                }</span>
<span class="source-line-no">846</span><span id="line.846">                pos = (pos + 1) &amp; mask;</span>
<span class="source-line-no">847</span><span id="line.847">            }</span>
<span class="source-line-no">848</span><span id="line.848">            throw new NoSuchElementException("The key " + from</span>
<span class="source-line-no">849</span><span id="line.849">                    + " does not belong to this map.");</span>
<span class="source-line-no">850</span><span id="line.850">        }*/</span>
<span class="source-line-no">851</span><span id="line.851">        public boolean hasNext() {</span>
<span class="source-line-no">852</span><span id="line.852">            return next != -1;</span>
<span class="source-line-no">853</span><span id="line.853">        }</span>
<span class="source-line-no">854</span><span id="line.854">        public boolean hasPrevious() {</span>
<span class="source-line-no">855</span><span id="line.855">            return prev != -1;</span>
<span class="source-line-no">856</span><span id="line.856">        }</span>
<span class="source-line-no">857</span><span id="line.857">        private void ensureIndexKnown() {</span>
<span class="source-line-no">858</span><span id="line.858">            if (index &gt;= 0)</span>
<span class="source-line-no">859</span><span id="line.859">                return;</span>
<span class="source-line-no">860</span><span id="line.860">            if (prev == -1) {</span>
<span class="source-line-no">861</span><span id="line.861">                index = 0;</span>
<span class="source-line-no">862</span><span id="line.862">                return;</span>
<span class="source-line-no">863</span><span id="line.863">            }</span>
<span class="source-line-no">864</span><span id="line.864">            if (next == -1) {</span>
<span class="source-line-no">865</span><span id="line.865">                index = size;</span>
<span class="source-line-no">866</span><span id="line.866">                return;</span>
<span class="source-line-no">867</span><span id="line.867">            }</span>
<span class="source-line-no">868</span><span id="line.868">            index = 0;</span>
<span class="source-line-no">869</span><span id="line.869">            /*while (pos != prev) {</span>
<span class="source-line-no">870</span><span id="line.870">                pos = (int) link[pos];</span>
<span class="source-line-no">871</span><span id="line.871">                index++;</span>
<span class="source-line-no">872</span><span id="line.872">            }*/</span>
<span class="source-line-no">873</span><span id="line.873">        }</span>
<span class="source-line-no">874</span><span id="line.874">        public int nextIndex() {</span>
<span class="source-line-no">875</span><span id="line.875">            ensureIndexKnown();</span>
<span class="source-line-no">876</span><span id="line.876">            return index + 1;</span>
<span class="source-line-no">877</span><span id="line.877">        }</span>
<span class="source-line-no">878</span><span id="line.878">        public int previousIndex() {</span>
<span class="source-line-no">879</span><span id="line.879">            ensureIndexKnown();</span>
<span class="source-line-no">880</span><span id="line.880">            return index - 1;</span>
<span class="source-line-no">881</span><span id="line.881">        }</span>
<span class="source-line-no">882</span><span id="line.882">        public int nextEntry() {</span>
<span class="source-line-no">883</span><span id="line.883">            if (!hasNext())</span>
<span class="source-line-no">884</span><span id="line.884">                throw new NoSuchElementException();</span>
<span class="source-line-no">885</span><span id="line.885">            curr = next;</span>
<span class="source-line-no">886</span><span id="line.886">            if(++index &gt;= order.size)</span>
<span class="source-line-no">887</span><span id="line.887">                next = -1;</span>
<span class="source-line-no">888</span><span id="line.888">            else</span>
<span class="source-line-no">889</span><span id="line.889">                next = order.get(index);//(int) link[curr];</span>
<span class="source-line-no">890</span><span id="line.890">            prev = curr;</span>
<span class="source-line-no">891</span><span id="line.891">            return curr;</span>
<span class="source-line-no">892</span><span id="line.892">        }</span>
<span class="source-line-no">893</span><span id="line.893">        public int previousEntry() {</span>
<span class="source-line-no">894</span><span id="line.894">            if (!hasPrevious())</span>
<span class="source-line-no">895</span><span id="line.895">                throw new NoSuchElementException();</span>
<span class="source-line-no">896</span><span id="line.896">            curr = prev;</span>
<span class="source-line-no">897</span><span id="line.897">            if(--index &lt; 1)</span>
<span class="source-line-no">898</span><span id="line.898">                prev = -1;</span>
<span class="source-line-no">899</span><span id="line.899">            else</span>
<span class="source-line-no">900</span><span id="line.900">                prev = order.get(index - 1);</span>
<span class="source-line-no">901</span><span id="line.901">            //prev = (int) (link[curr] &gt;&gt;&gt; 32);</span>
<span class="source-line-no">902</span><span id="line.902">            next = curr;</span>
<span class="source-line-no">903</span><span id="line.903">            return curr;</span>
<span class="source-line-no">904</span><span id="line.904">        }</span>
<span class="source-line-no">905</span><span id="line.905">        public void remove() {</span>
<span class="source-line-no">906</span><span id="line.906">            ensureIndexKnown();</span>
<span class="source-line-no">907</span><span id="line.907">            if (curr == -1)</span>
<span class="source-line-no">908</span><span id="line.908">                throw new IllegalStateException();</span>
<span class="source-line-no">909</span><span id="line.909">            if (curr == prev) {</span>
<span class="source-line-no">910</span><span id="line.910">                /*</span>
<span class="source-line-no">911</span><span id="line.911">                 * If the last operation was a next(), we are removing an entry</span>
<span class="source-line-no">912</span><span id="line.912">                 * that precedes the current index, and thus we must decrement</span>
<span class="source-line-no">913</span><span id="line.913">                 * it.</span>
<span class="source-line-no">914</span><span id="line.914">                 */</span>
<span class="source-line-no">915</span><span id="line.915">                if(--index &gt;= 1)</span>
<span class="source-line-no">916</span><span id="line.916">                    prev = order.get(index - 1); //(int) (link[curr] &gt;&gt;&gt; 32);</span>
<span class="source-line-no">917</span><span id="line.917">                else</span>
<span class="source-line-no">918</span><span id="line.918">                    prev = -1;</span>
<span class="source-line-no">919</span><span id="line.919">            } else {</span>
<span class="source-line-no">920</span><span id="line.920">                if(index &lt; order.size - 1)</span>
<span class="source-line-no">921</span><span id="line.921">                    next = order.get(index + 1);</span>
<span class="source-line-no">922</span><span id="line.922">                else</span>
<span class="source-line-no">923</span><span id="line.923">                    next = -1;</span>
<span class="source-line-no">924</span><span id="line.924">            }</span>
<span class="source-line-no">925</span><span id="line.925">            order.removeIndex(index);</span>
<span class="source-line-no">926</span><span id="line.926">            size--;</span>
<span class="source-line-no">927</span><span id="line.927">            int last, slot, pos = curr;</span>
<span class="source-line-no">928</span><span id="line.928">            curr = -1;</span>
<span class="source-line-no">929</span><span id="line.929">            if (pos == n) {</span>
<span class="source-line-no">930</span><span id="line.930">                containsNullKey = false;</span>
<span class="source-line-no">931</span><span id="line.931">            } else {</span>
<span class="source-line-no">932</span><span id="line.932">                int curr;</span>
<span class="source-line-no">933</span><span id="line.933">                final int[] key = IntDoubleOrderedMap.this.key;</span>
<span class="source-line-no">934</span><span id="line.934">                // We have to horribly duplicate the shiftKeys() code because we</span>
<span class="source-line-no">935</span><span id="line.935">                // need to update next/prev.</span>
<span class="source-line-no">936</span><span id="line.936">                for (;;) {</span>
<span class="source-line-no">937</span><span id="line.937">                    pos = ((last = pos) + 1) &amp; mask;</span>
<span class="source-line-no">938</span><span id="line.938">                    for (;;) {</span>
<span class="source-line-no">939</span><span id="line.939">                        if ((curr = key[pos]) == 0) {</span>
<span class="source-line-no">940</span><span id="line.940">                            key[last] = 0;</span>
<span class="source-line-no">941</span><span id="line.941">                            return;</span>
<span class="source-line-no">942</span><span id="line.942">                        }</span>
<span class="source-line-no">943</span><span id="line.943">                        slot = (HashCommon.mix(curr)) &amp; mask;</span>
<span class="source-line-no">944</span><span id="line.944">                        if (last &lt;= pos</span>
<span class="source-line-no">945</span><span id="line.945">                                ? last &gt;= slot || slot &gt; pos</span>
<span class="source-line-no">946</span><span id="line.946">                                : last &gt;= slot &amp;&amp; slot &gt; pos)</span>
<span class="source-line-no">947</span><span id="line.947">                            break;</span>
<span class="source-line-no">948</span><span id="line.948">                        pos = (pos + 1) &amp; mask;</span>
<span class="source-line-no">949</span><span id="line.949">                    }</span>
<span class="source-line-no">950</span><span id="line.950">                    key[last] = curr;</span>
<span class="source-line-no">951</span><span id="line.951">                    value[last] = value[pos];</span>
<span class="source-line-no">952</span><span id="line.952">                    if (next == pos)</span>
<span class="source-line-no">953</span><span id="line.953">                        next = last;</span>
<span class="source-line-no">954</span><span id="line.954">                    if (prev == pos)</span>
<span class="source-line-no">955</span><span id="line.955">                        prev = last;</span>
<span class="source-line-no">956</span><span id="line.956">                    fixOrder(pos, last);</span>
<span class="source-line-no">957</span><span id="line.957">                }</span>
<span class="source-line-no">958</span><span id="line.958">            }</span>
<span class="source-line-no">959</span><span id="line.959">        }</span>
<span class="source-line-no">960</span><span id="line.960">        public int skip(final int n) {</span>
<span class="source-line-no">961</span><span id="line.961">            int i = n;</span>
<span class="source-line-no">962</span><span id="line.962">            while (i-- != 0 &amp;&amp; hasNext())</span>
<span class="source-line-no">963</span><span id="line.963">                nextEntry();</span>
<span class="source-line-no">964</span><span id="line.964">            return n - i - 1;</span>
<span class="source-line-no">965</span><span id="line.965">        }</span>
<span class="source-line-no">966</span><span id="line.966">        public int back(final int n) {</span>
<span class="source-line-no">967</span><span id="line.967">            int i = n;</span>
<span class="source-line-no">968</span><span id="line.968">            while (i-- != 0 &amp;&amp; hasPrevious())</span>
<span class="source-line-no">969</span><span id="line.969">                previousEntry();</span>
<span class="source-line-no">970</span><span id="line.970">            return n - i - 1;</span>
<span class="source-line-no">971</span><span id="line.971">        }</span>
<span class="source-line-no">972</span><span id="line.972">    }</span>
<span class="source-line-no">973</span><span id="line.973">    private class EntryIterator extends MapIterator</span>
<span class="source-line-no">974</span><span id="line.974">            implements</span>
<span class="source-line-no">975</span><span id="line.975">            Iterator&lt;MapEntry&gt;, Serializable {</span>
<span class="source-line-no">976</span><span id="line.976">        private static final long serialVersionUID = 0L;</span>
<span class="source-line-no">977</span><span id="line.977"></span>
<span class="source-line-no">978</span><span id="line.978">        private MapEntry entry;</span>
<span class="source-line-no">979</span><span id="line.979">        public EntryIterator() {</span>
<span class="source-line-no">980</span><span id="line.980">        }</span>
<span class="source-line-no">981</span><span id="line.981">        public MapEntry next() {</span>
<span class="source-line-no">982</span><span id="line.982">            return entry = new MapEntry(nextEntry());</span>
<span class="source-line-no">983</span><span id="line.983">        }</span>
<span class="source-line-no">984</span><span id="line.984">        public MapEntry previous() {</span>
<span class="source-line-no">985</span><span id="line.985">            return entry = new MapEntry(previousEntry());</span>
<span class="source-line-no">986</span><span id="line.986">        }</span>
<span class="source-line-no">987</span><span id="line.987">        @Override</span>
<span class="source-line-no">988</span><span id="line.988">        public void remove() {</span>
<span class="source-line-no">989</span><span id="line.989">            super.remove();</span>
<span class="source-line-no">990</span><span id="line.990">            entry.index = -1; // You cannot use a deleted entry.</span>
<span class="source-line-no">991</span><span id="line.991">        }</span>
<span class="source-line-no">992</span><span id="line.992">    }</span>
<span class="source-line-no">993</span><span id="line.993"></span>
<span class="source-line-no">994</span><span id="line.994">    public class FastEntryIterator extends MapIterator implements ListIterator&lt;MapEntry&gt;, Serializable {</span>
<span class="source-line-no">995</span><span id="line.995">        private static final long serialVersionUID = 0L;</span>
<span class="source-line-no">996</span><span id="line.996"></span>
<span class="source-line-no">997</span><span id="line.997">        final MapEntry entry = new MapEntry();</span>
<span class="source-line-no">998</span><span id="line.998"></span>
<span class="source-line-no">999</span><span id="line.999">        public FastEntryIterator() {</span>
<span class="source-line-no">1000</span><span id="line.1000">        }</span>
<span class="source-line-no">1001</span><span id="line.1001">        public MapEntry next() {</span>
<span class="source-line-no">1002</span><span id="line.1002">            entry.index = nextEntry();</span>
<span class="source-line-no">1003</span><span id="line.1003">            return entry;</span>
<span class="source-line-no">1004</span><span id="line.1004">        }</span>
<span class="source-line-no">1005</span><span id="line.1005">        public MapEntry previous() {</span>
<span class="source-line-no">1006</span><span id="line.1006">            entry.index = previousEntry();</span>
<span class="source-line-no">1007</span><span id="line.1007">            return entry;</span>
<span class="source-line-no">1008</span><span id="line.1008">        }</span>
<span class="source-line-no">1009</span><span id="line.1009">        public void set(MapEntry ok) {</span>
<span class="source-line-no">1010</span><span id="line.1010">            throw new UnsupportedOperationException();</span>
<span class="source-line-no">1011</span><span id="line.1011">        }</span>
<span class="source-line-no">1012</span><span id="line.1012">        public void add(MapEntry ok) {</span>
<span class="source-line-no">1013</span><span id="line.1013">            throw new UnsupportedOperationException();</span>
<span class="source-line-no">1014</span><span id="line.1014">        }</span>
<span class="source-line-no">1015</span><span id="line.1015">    }</span>
<span class="source-line-no">1016</span><span id="line.1016">    public final class MapEntrySet</span>
<span class="source-line-no">1017</span><span id="line.1017">            implements Cloneable, SortedSet&lt;MapEntry&gt;, Set&lt;MapEntry&gt;, Serializable {</span>
<span class="source-line-no">1018</span><span id="line.1018">        private static final long serialVersionUID = 0L;</span>
<span class="source-line-no">1019</span><span id="line.1019">        public EntryIterator iterator() {</span>
<span class="source-line-no">1020</span><span id="line.1020">            return new EntryIterator();</span>
<span class="source-line-no">1021</span><span id="line.1021">        }</span>
<span class="source-line-no">1022</span><span id="line.1022">        public Comparator&lt;? super MapEntry&gt; comparator() {</span>
<span class="source-line-no">1023</span><span id="line.1023">            return null;</span>
<span class="source-line-no">1024</span><span id="line.1024">        }</span>
<span class="source-line-no">1025</span><span id="line.1025">        public SortedSet&lt;MapEntry&gt; subSet(</span>
<span class="source-line-no">1026</span><span id="line.1026">                MapEntry fromElement,</span>
<span class="source-line-no">1027</span><span id="line.1027">                MapEntry toElement) {</span>
<span class="source-line-no">1028</span><span id="line.1028">            throw new UnsupportedOperationException();</span>
<span class="source-line-no">1029</span><span id="line.1029">        }</span>
<span class="source-line-no">1030</span><span id="line.1030">        public SortedSet&lt;MapEntry&gt; headSet(</span>
<span class="source-line-no">1031</span><span id="line.1031">                MapEntry toElement) {</span>
<span class="source-line-no">1032</span><span id="line.1032">            throw new UnsupportedOperationException();</span>
<span class="source-line-no">1033</span><span id="line.1033">        }</span>
<span class="source-line-no">1034</span><span id="line.1034">        public SortedSet&lt;MapEntry&gt; tailSet(</span>
<span class="source-line-no">1035</span><span id="line.1035">                MapEntry fromElement) {</span>
<span class="source-line-no">1036</span><span id="line.1036">            throw new UnsupportedOperationException();</span>
<span class="source-line-no">1037</span><span id="line.1037">        }</span>
<span class="source-line-no">1038</span><span id="line.1038">        public MapEntry first() {</span>
<span class="source-line-no">1039</span><span id="line.1039">            if (size == 0)</span>
<span class="source-line-no">1040</span><span id="line.1040">                throw new NoSuchElementException();</span>
<span class="source-line-no">1041</span><span id="line.1041">            return new MapEntry(order.items[0]);</span>
<span class="source-line-no">1042</span><span id="line.1042">        }</span>
<span class="source-line-no">1043</span><span id="line.1043">        public MapEntry last() {</span>
<span class="source-line-no">1044</span><span id="line.1044">            if (size == 0)</span>
<span class="source-line-no">1045</span><span id="line.1045">                throw new NoSuchElementException();</span>
<span class="source-line-no">1046</span><span id="line.1046">            return new MapEntry(order.items[order.size-1]);</span>
<span class="source-line-no">1047</span><span id="line.1047">        }</span>
<span class="source-line-no">1048</span><span id="line.1048">        public boolean contains(final Object o) {</span>
<span class="source-line-no">1049</span><span id="line.1049">            if (!(o instanceof MapEntry))</span>
<span class="source-line-no">1050</span><span id="line.1050">                return false;</span>
<span class="source-line-no">1051</span><span id="line.1051">            final MapEntry e = (MapEntry) o;</span>
<span class="source-line-no">1052</span><span id="line.1052">            final int k = e.getKey();</span>
<span class="source-line-no">1053</span><span id="line.1053">            final double v = e.getValue();</span>
<span class="source-line-no">1054</span><span id="line.1054">            if (k == 0)</span>
<span class="source-line-no">1055</span><span id="line.1055">                return containsNullKey &amp;&amp; (value[n] == v);</span>
<span class="source-line-no">1056</span><span id="line.1056">            int curr;</span>
<span class="source-line-no">1057</span><span id="line.1057">            final int[] key = IntDoubleOrderedMap.this.key;</span>
<span class="source-line-no">1058</span><span id="line.1058">            int pos;</span>
<span class="source-line-no">1059</span><span id="line.1059">            // The starting point.</span>
<span class="source-line-no">1060</span><span id="line.1060">            if ((curr = key[pos = (HashCommon.mix(k)) &amp; mask]) == 0)</span>
<span class="source-line-no">1061</span><span id="line.1061">                return false;</span>
<span class="source-line-no">1062</span><span id="line.1062">            if (k == curr)</span>
<span class="source-line-no">1063</span><span id="line.1063">                return value[pos] == v;</span>
<span class="source-line-no">1064</span><span id="line.1064">            // There's always an unused entry.</span>
<span class="source-line-no">1065</span><span id="line.1065">            while (true) {</span>
<span class="source-line-no">1066</span><span id="line.1066">                if ((curr = key[pos = (pos + 1) &amp; mask]) == 0)</span>
<span class="source-line-no">1067</span><span id="line.1067">                    return false;</span>
<span class="source-line-no">1068</span><span id="line.1068">                if (k == curr)</span>
<span class="source-line-no">1069</span><span id="line.1069">                    return value[pos] == v;</span>
<span class="source-line-no">1070</span><span id="line.1070">            }</span>
<span class="source-line-no">1071</span><span id="line.1071">        }</span>
<span class="source-line-no">1072</span><span id="line.1072">        public boolean remove(final Object o) {</span>
<span class="source-line-no">1073</span><span id="line.1073">            if (!(o instanceof MapEntry))</span>
<span class="source-line-no">1074</span><span id="line.1074">                return false;</span>
<span class="source-line-no">1075</span><span id="line.1075">            final MapEntry e = (MapEntry) o;</span>
<span class="source-line-no">1076</span><span id="line.1076">            final int k = e.getKey();</span>
<span class="source-line-no">1077</span><span id="line.1077">            final double v = e.getValue();</span>
<span class="source-line-no">1078</span><span id="line.1078">            if (k == 0) {</span>
<span class="source-line-no">1079</span><span id="line.1079">                if (containsNullKey &amp;&amp; value[n] == v) {</span>
<span class="source-line-no">1080</span><span id="line.1080">                    removeNullEntry();</span>
<span class="source-line-no">1081</span><span id="line.1081">                    return true;</span>
<span class="source-line-no">1082</span><span id="line.1082">                }</span>
<span class="source-line-no">1083</span><span id="line.1083">                return false;</span>
<span class="source-line-no">1084</span><span id="line.1084">            }</span>
<span class="source-line-no">1085</span><span id="line.1085">            int curr;</span>
<span class="source-line-no">1086</span><span id="line.1086">            final int[] key = IntDoubleOrderedMap.this.key;</span>
<span class="source-line-no">1087</span><span id="line.1087">            int pos;</span>
<span class="source-line-no">1088</span><span id="line.1088">            // The starting point.</span>
<span class="source-line-no">1089</span><span id="line.1089">            if ((curr = key[pos = (HashCommon.mix(k)) &amp; mask]) == 0)</span>
<span class="source-line-no">1090</span><span id="line.1090">                return false;</span>
<span class="source-line-no">1091</span><span id="line.1091">            if (curr == k) {</span>
<span class="source-line-no">1092</span><span id="line.1092">                if (value[pos] == v) {</span>
<span class="source-line-no">1093</span><span id="line.1093">                    removeEntry(pos);</span>
<span class="source-line-no">1094</span><span id="line.1094">                    return true;</span>
<span class="source-line-no">1095</span><span id="line.1095">                }</span>
<span class="source-line-no">1096</span><span id="line.1096">                return false;</span>
<span class="source-line-no">1097</span><span id="line.1097">            }</span>
<span class="source-line-no">1098</span><span id="line.1098">            while (true) {</span>
<span class="source-line-no">1099</span><span id="line.1099">                if ((curr = key[pos = (pos + 1) &amp; mask]) == 0)</span>
<span class="source-line-no">1100</span><span id="line.1100">                    return false;</span>
<span class="source-line-no">1101</span><span id="line.1101">                if (curr == k) {</span>
<span class="source-line-no">1102</span><span id="line.1102">                    if (value[pos] == v) {</span>
<span class="source-line-no">1103</span><span id="line.1103">                        removeEntry(pos);</span>
<span class="source-line-no">1104</span><span id="line.1104">                        return true;</span>
<span class="source-line-no">1105</span><span id="line.1105">                    }</span>
<span class="source-line-no">1106</span><span id="line.1106">                }</span>
<span class="source-line-no">1107</span><span id="line.1107">            }</span>
<span class="source-line-no">1108</span><span id="line.1108">        }</span>
<span class="source-line-no">1109</span><span id="line.1109">        public int size() {</span>
<span class="source-line-no">1110</span><span id="line.1110">            return size;</span>
<span class="source-line-no">1111</span><span id="line.1111">        }</span>
<span class="source-line-no">1112</span><span id="line.1112">        public void clear() {</span>
<span class="source-line-no">1113</span><span id="line.1113">            IntDoubleOrderedMap.this.clear();</span>
<span class="source-line-no">1114</span><span id="line.1114">        }</span>
<span class="source-line-no">1115</span><span id="line.1115"></span>
<span class="source-line-no">1116</span><span id="line.1116">        public FastEntryIterator fastIterator() {</span>
<span class="source-line-no">1117</span><span id="line.1117">            return new FastEntryIterator();</span>
<span class="source-line-no">1118</span><span id="line.1118">        }</span>
<span class="source-line-no">1119</span><span id="line.1119"></span>
<span class="source-line-no">1120</span><span id="line.1120">        @Override</span>
<span class="source-line-no">1121</span><span id="line.1121">        public boolean equals(final Object o) {</span>
<span class="source-line-no">1122</span><span id="line.1122">            if (o == this)</span>
<span class="source-line-no">1123</span><span id="line.1123">                return true;</span>
<span class="source-line-no">1124</span><span id="line.1124">            if (!(o instanceof Set))</span>
<span class="source-line-no">1125</span><span id="line.1125">                return false;</span>
<span class="source-line-no">1126</span><span id="line.1126">            Set&lt;?&gt; s = (Set&lt;?&gt;) o;</span>
<span class="source-line-no">1127</span><span id="line.1127">            return s.size() == size() &amp;&amp; containsAll(s);</span>
<span class="source-line-no">1128</span><span id="line.1128">        }</span>
<span class="source-line-no">1129</span><span id="line.1129"></span>
<span class="source-line-no">1130</span><span id="line.1130">        public Object[] toArray() {</span>
<span class="source-line-no">1131</span><span id="line.1131">            final Object[] a = new Object[size()];</span>
<span class="source-line-no">1132</span><span id="line.1132">            objectUnwrap(iterator(), a);</span>
<span class="source-line-no">1133</span><span id="line.1133">            return a;</span>
<span class="source-line-no">1134</span><span id="line.1134">        }</span>
<span class="source-line-no">1135</span><span id="line.1135"></span>
<span class="source-line-no">1136</span><span id="line.1136">        @SuppressWarnings("unchecked")</span>
<span class="source-line-no">1137</span><span id="line.1137">        public &lt;T&gt; T[] toArray(T[] a) {</span>
<span class="source-line-no">1138</span><span id="line.1138">            if (a.length &lt; size) a = Arrays.copyOf(a, size);</span>
<span class="source-line-no">1139</span><span id="line.1139">            objectUnwrap(iterator(), a);</span>
<span class="source-line-no">1140</span><span id="line.1140">            return a;</span>
<span class="source-line-no">1141</span><span id="line.1141">        }</span>
<span class="source-line-no">1142</span><span id="line.1142"></span>
<span class="source-line-no">1143</span><span id="line.1143">        /**</span>
<span class="source-line-no">1144</span><span id="line.1144">         * Unsupported.</span>
<span class="source-line-no">1145</span><span id="line.1145">         *</span>
<span class="source-line-no">1146</span><span id="line.1146">         * @param c ignored</span>
<span class="source-line-no">1147</span><span id="line.1147">         * @return nothing, throws UnsupportedOperationException</span>
<span class="source-line-no">1148</span><span id="line.1148">         * @throws UnsupportedOperationException always</span>
<span class="source-line-no">1149</span><span id="line.1149">         */</span>
<span class="source-line-no">1150</span><span id="line.1150">        public boolean addAll(Collection&lt;? extends MapEntry&gt; c) {</span>
<span class="source-line-no">1151</span><span id="line.1151">            throw new UnsupportedOperationException("addAll not supported");</span>
<span class="source-line-no">1152</span><span id="line.1152">        }</span>
<span class="source-line-no">1153</span><span id="line.1153"></span>
<span class="source-line-no">1154</span><span id="line.1154">        /**</span>
<span class="source-line-no">1155</span><span id="line.1155">         * Unsupported.</span>
<span class="source-line-no">1156</span><span id="line.1156">         *</span>
<span class="source-line-no">1157</span><span id="line.1157">         * @param k ignored</span>
<span class="source-line-no">1158</span><span id="line.1158">         * @return nothing, throws UnsupportedOperationException</span>
<span class="source-line-no">1159</span><span id="line.1159">         * @throws UnsupportedOperationException always</span>
<span class="source-line-no">1160</span><span id="line.1160">         */</span>
<span class="source-line-no">1161</span><span id="line.1161">        public boolean add(MapEntry k) {</span>
<span class="source-line-no">1162</span><span id="line.1162">            throw new UnsupportedOperationException("add not supported");</span>
<span class="source-line-no">1163</span><span id="line.1163">        }</span>
<span class="source-line-no">1164</span><span id="line.1164"></span>
<span class="source-line-no">1165</span><span id="line.1165">        /**</span>
<span class="source-line-no">1166</span><span id="line.1166">         * Checks whether this collection contains all elements from the given</span>
<span class="source-line-no">1167</span><span id="line.1167">         * collection.</span>
<span class="source-line-no">1168</span><span id="line.1168">         *</span>
<span class="source-line-no">1169</span><span id="line.1169">         * @param c a collection.</span>
<span class="source-line-no">1170</span><span id="line.1170">         * @return &lt;code&gt;true&lt;/code&gt; if this collection contains all elements of the</span>
<span class="source-line-no">1171</span><span id="line.1171">         * argument.</span>
<span class="source-line-no">1172</span><span id="line.1172">         */</span>
<span class="source-line-no">1173</span><span id="line.1173">        public boolean containsAll(Collection&lt;?&gt; c) {</span>
<span class="source-line-no">1174</span><span id="line.1174">            int n = c.size();</span>
<span class="source-line-no">1175</span><span id="line.1175">            final Iterator&lt;?&gt; i = c.iterator();</span>
<span class="source-line-no">1176</span><span id="line.1176">            while (n-- != 0)</span>
<span class="source-line-no">1177</span><span id="line.1177">                if (!contains(i.next()))</span>
<span class="source-line-no">1178</span><span id="line.1178">                    return false;</span>
<span class="source-line-no">1179</span><span id="line.1179">            return true;</span>
<span class="source-line-no">1180</span><span id="line.1180">        }</span>
<span class="source-line-no">1181</span><span id="line.1181"></span>
<span class="source-line-no">1182</span><span id="line.1182">        /**</span>
<span class="source-line-no">1183</span><span id="line.1183">         * Retains in this collection only elements from the given collection.</span>
<span class="source-line-no">1184</span><span id="line.1184">         *</span>
<span class="source-line-no">1185</span><span id="line.1185">         * @param c a collection.</span>
<span class="source-line-no">1186</span><span id="line.1186">         * @return &lt;code&gt;true&lt;/code&gt; if this collection changed as a result of the</span>
<span class="source-line-no">1187</span><span id="line.1187">         * call.</span>
<span class="source-line-no">1188</span><span id="line.1188">         */</span>
<span class="source-line-no">1189</span><span id="line.1189">        public boolean retainAll(Collection&lt;?&gt; c) {</span>
<span class="source-line-no">1190</span><span id="line.1190">            boolean retVal = false;</span>
<span class="source-line-no">1191</span><span id="line.1191">            int n = size();</span>
<span class="source-line-no">1192</span><span id="line.1192">            final Iterator&lt;?&gt; i = iterator();</span>
<span class="source-line-no">1193</span><span id="line.1193">            while (n-- != 0) {</span>
<span class="source-line-no">1194</span><span id="line.1194">                if (!c.contains(i.next())) {</span>
<span class="source-line-no">1195</span><span id="line.1195">                    i.remove();</span>
<span class="source-line-no">1196</span><span id="line.1196">                    retVal = true;</span>
<span class="source-line-no">1197</span><span id="line.1197">                }</span>
<span class="source-line-no">1198</span><span id="line.1198">            }</span>
<span class="source-line-no">1199</span><span id="line.1199">            return retVal;</span>
<span class="source-line-no">1200</span><span id="line.1200">        }</span>
<span class="source-line-no">1201</span><span id="line.1201"></span>
<span class="source-line-no">1202</span><span id="line.1202">        /**</span>
<span class="source-line-no">1203</span><span id="line.1203">         * Remove from this collection all elements in the given collection. If the</span>
<span class="source-line-no">1204</span><span id="line.1204">         * collection is an instance of this class, it uses faster iterators.</span>
<span class="source-line-no">1205</span><span id="line.1205">         *</span>
<span class="source-line-no">1206</span><span id="line.1206">         * @param c a collection.</span>
<span class="source-line-no">1207</span><span id="line.1207">         * @return &lt;code&gt;true&lt;/code&gt; if this collection changed as a result of the</span>
<span class="source-line-no">1208</span><span id="line.1208">         * call.</span>
<span class="source-line-no">1209</span><span id="line.1209">         */</span>
<span class="source-line-no">1210</span><span id="line.1210">        public boolean removeAll(Collection&lt;?&gt; c) {</span>
<span class="source-line-no">1211</span><span id="line.1211">            boolean retVal = false;</span>
<span class="source-line-no">1212</span><span id="line.1212">            int n = c.size();</span>
<span class="source-line-no">1213</span><span id="line.1213">            final Iterator&lt;?&gt; i = c.iterator();</span>
<span class="source-line-no">1214</span><span id="line.1214">            while (n-- != 0)</span>
<span class="source-line-no">1215</span><span id="line.1215">                if (remove(i.next()))</span>
<span class="source-line-no">1216</span><span id="line.1216">                    retVal = true;</span>
<span class="source-line-no">1217</span><span id="line.1217">            return retVal;</span>
<span class="source-line-no">1218</span><span id="line.1218">        }</span>
<span class="source-line-no">1219</span><span id="line.1219"></span>
<span class="source-line-no">1220</span><span id="line.1220">        public boolean isEmpty() {</span>
<span class="source-line-no">1221</span><span id="line.1221">            return size() == 0;</span>
<span class="source-line-no">1222</span><span id="line.1222">        }</span>
<span class="source-line-no">1223</span><span id="line.1223"></span>
<span class="source-line-no">1224</span><span id="line.1224">        @Override</span>
<span class="source-line-no">1225</span><span id="line.1225">        public String toString() {</span>
<span class="source-line-no">1226</span><span id="line.1226">            final StringBuilder s = new StringBuilder();</span>
<span class="source-line-no">1227</span><span id="line.1227">            final EntryIterator i = iterator();</span>
<span class="source-line-no">1228</span><span id="line.1228">            int n = size();</span>
<span class="source-line-no">1229</span><span id="line.1229">            MapEntry k;</span>
<span class="source-line-no">1230</span><span id="line.1230">            boolean first = true;</span>
<span class="source-line-no">1231</span><span id="line.1231">            s.append("{");</span>
<span class="source-line-no">1232</span><span id="line.1232">            while (n-- != 0) {</span>
<span class="source-line-no">1233</span><span id="line.1233">                if (first)</span>
<span class="source-line-no">1234</span><span id="line.1234">                    first = false;</span>
<span class="source-line-no">1235</span><span id="line.1235">                else</span>
<span class="source-line-no">1236</span><span id="line.1236">                    s.append(", ");</span>
<span class="source-line-no">1237</span><span id="line.1237">                k = i.next();                 </span>
<span class="source-line-no">1238</span><span id="line.1238">                s.append(key[k.index]).append("=&gt;").append(value[k.index]);</span>
<span class="source-line-no">1239</span><span id="line.1239">            }</span>
<span class="source-line-no">1240</span><span id="line.1240">            s.append("}");</span>
<span class="source-line-no">1241</span><span id="line.1241">            return s.toString();</span>
<span class="source-line-no">1242</span><span id="line.1242">        }</span>
<span class="source-line-no">1243</span><span id="line.1243"></span>
<span class="source-line-no">1244</span><span id="line.1244">    }</span>
<span class="source-line-no">1245</span><span id="line.1245"></span>
<span class="source-line-no">1246</span><span id="line.1246">    public SortedSet&lt;MapEntry&gt; entrySet() {</span>
<span class="source-line-no">1247</span><span id="line.1247">        if (entries == null) entries = new MapEntrySet();</span>
<span class="source-line-no">1248</span><span id="line.1248">        return entries;</span>
<span class="source-line-no">1249</span><span id="line.1249">    }</span>
<span class="source-line-no">1250</span><span id="line.1250"></span>
<span class="source-line-no">1251</span><span id="line.1251">    /**</span>
<span class="source-line-no">1252</span><span id="line.1252">     * An iterator on keys.</span>
<span class="source-line-no">1253</span><span id="line.1253">     * &lt;p&gt;</span>
<span class="source-line-no">1254</span><span id="line.1254">     * &lt;P&gt;We simply override the {@link ListIterator#next()}/{@link ListIterator#previous()} methods (and possibly their type-specific counterparts) so that they return keys</span>
<span class="source-line-no">1255</span><span id="line.1255">     * instead of entries.</span>
<span class="source-line-no">1256</span><span id="line.1256">     */</span>
<span class="source-line-no">1257</span><span id="line.1257">    public final class KeyIterator extends MapIterator implements Iterator&lt;Integer&gt;, Serializable {</span>
<span class="source-line-no">1258</span><span id="line.1258">        private static final long serialVersionUID = 0L;</span>
<span class="source-line-no">1259</span><span id="line.1259">        public Integer previous() {</span>
<span class="source-line-no">1260</span><span id="line.1260">            return key[previousEntry()];</span>
<span class="source-line-no">1261</span><span id="line.1261">        }        </span>
<span class="source-line-no">1262</span><span id="line.1262">        public int previousInt() {</span>
<span class="source-line-no">1263</span><span id="line.1263">            return key[previousEntry()];</span>
<span class="source-line-no">1264</span><span id="line.1264">        }</span>
<span class="source-line-no">1265</span><span id="line.1265">        public void set(Integer k) {</span>
<span class="source-line-no">1266</span><span id="line.1266">            throw new UnsupportedOperationException();</span>
<span class="source-line-no">1267</span><span id="line.1267">        }</span>
<span class="source-line-no">1268</span><span id="line.1268">        public void add(Integer k) {</span>
<span class="source-line-no">1269</span><span id="line.1269">            throw new UnsupportedOperationException();</span>
<span class="source-line-no">1270</span><span id="line.1270">        }</span>
<span class="source-line-no">1271</span><span id="line.1271">        public KeyIterator() {}</span>
<span class="source-line-no">1272</span><span id="line.1272">        public Integer next() {</span>
<span class="source-line-no">1273</span><span id="line.1273">            return key[nextEntry()];</span>
<span class="source-line-no">1274</span><span id="line.1274">        }</span>
<span class="source-line-no">1275</span><span id="line.1275">        public int nextInt() {</span>
<span class="source-line-no">1276</span><span id="line.1276">            return key[nextEntry()];</span>
<span class="source-line-no">1277</span><span id="line.1277">        }</span>
<span class="source-line-no">1278</span><span id="line.1278">        public void remove() { super.remove(); }</span>
<span class="source-line-no">1279</span><span id="line.1279">    }</span>
<span class="source-line-no">1280</span><span id="line.1280"></span>
<span class="source-line-no">1281</span><span id="line.1281">    public final class KeySet implements SortedSet&lt;Integer&gt;, Serializable {</span>
<span class="source-line-no">1282</span><span id="line.1282">        private static final long serialVersionUID = 0L;</span>
<span class="source-line-no">1283</span><span id="line.1283"></span>
<span class="source-line-no">1284</span><span id="line.1284">        public KeyIterator iterator() {</span>
<span class="source-line-no">1285</span><span id="line.1285">            return new KeyIterator();</span>
<span class="source-line-no">1286</span><span id="line.1286">        }</span>
<span class="source-line-no">1287</span><span id="line.1287"></span>
<span class="source-line-no">1288</span><span id="line.1288">        public int size() {</span>
<span class="source-line-no">1289</span><span id="line.1289">            return size;</span>
<span class="source-line-no">1290</span><span id="line.1290">        }</span>
<span class="source-line-no">1291</span><span id="line.1291"></span>
<span class="source-line-no">1292</span><span id="line.1292">        public void clear() {</span>
<span class="source-line-no">1293</span><span id="line.1293">            IntDoubleOrderedMap.this.clear();</span>
<span class="source-line-no">1294</span><span id="line.1294">        }</span>
<span class="source-line-no">1295</span><span id="line.1295"></span>
<span class="source-line-no">1296</span><span id="line.1296">        public Integer first() {</span>
<span class="source-line-no">1297</span><span id="line.1297">            if (size == 0) throw new NoSuchElementException();</span>
<span class="source-line-no">1298</span><span id="line.1298">            return key[order.items[0]];</span>
<span class="source-line-no">1299</span><span id="line.1299">        }</span>
<span class="source-line-no">1300</span><span id="line.1300"></span>
<span class="source-line-no">1301</span><span id="line.1301">        public Integer last() {</span>
<span class="source-line-no">1302</span><span id="line.1302">            if (size == 0) throw new NoSuchElementException();</span>
<span class="source-line-no">1303</span><span id="line.1303">            return key[order.items[order.size-1]];</span>
<span class="source-line-no">1304</span><span id="line.1304">        }</span>
<span class="source-line-no">1305</span><span id="line.1305"></span>
<span class="source-line-no">1306</span><span id="line.1306">        public Comparator&lt;Integer&gt; comparator() {</span>
<span class="source-line-no">1307</span><span id="line.1307">            return null;</span>
<span class="source-line-no">1308</span><span id="line.1308">        }</span>
<span class="source-line-no">1309</span><span id="line.1309"></span>
<span class="source-line-no">1310</span><span id="line.1310">        public final SortedSet&lt;Integer&gt; tailSet(Integer from) {</span>
<span class="source-line-no">1311</span><span id="line.1311">            throw new UnsupportedOperationException();</span>
<span class="source-line-no">1312</span><span id="line.1312">        }</span>
<span class="source-line-no">1313</span><span id="line.1313"></span>
<span class="source-line-no">1314</span><span id="line.1314">        public final SortedSet&lt;Integer&gt; headSet(Integer to) {</span>
<span class="source-line-no">1315</span><span id="line.1315">            throw new UnsupportedOperationException();</span>
<span class="source-line-no">1316</span><span id="line.1316">        }</span>
<span class="source-line-no">1317</span><span id="line.1317"></span>
<span class="source-line-no">1318</span><span id="line.1318">        public final SortedSet&lt;Integer&gt; subSet(Integer from, Integer to) {</span>
<span class="source-line-no">1319</span><span id="line.1319">            throw new UnsupportedOperationException();</span>
<span class="source-line-no">1320</span><span id="line.1320">        }</span>
<span class="source-line-no">1321</span><span id="line.1321"></span>
<span class="source-line-no">1322</span><span id="line.1322">        @SuppressWarnings("unchecked")</span>
<span class="source-line-no">1323</span><span id="line.1323">        @Override</span>
<span class="source-line-no">1324</span><span id="line.1324">        public &lt;T&gt; T[] toArray(T[] a) {</span>
<span class="source-line-no">1325</span><span id="line.1325">            if (a.length &lt; size) a = Arrays.copyOf(a, size);</span>
<span class="source-line-no">1326</span><span id="line.1326">            unwrap(iterator(), a);</span>
<span class="source-line-no">1327</span><span id="line.1327">            return a;</span>
<span class="source-line-no">1328</span><span id="line.1328">        }</span>
<span class="source-line-no">1329</span><span id="line.1329"></span>
<span class="source-line-no">1330</span><span id="line.1330">        /**</span>
<span class="source-line-no">1331</span><span id="line.1331">         * Always throws an UnsupportedOperationException</span>
<span class="source-line-no">1332</span><span id="line.1332">         */</span>
<span class="source-line-no">1333</span><span id="line.1333">        public boolean remove(Object ok) {</span>
<span class="source-line-no">1334</span><span id="line.1334">            throw new UnsupportedOperationException("Cannot remove from the key set directly");</span>
<span class="source-line-no">1335</span><span id="line.1335">        }</span>
<span class="source-line-no">1336</span><span id="line.1336"></span>
<span class="source-line-no">1337</span><span id="line.1337">        /**</span>
<span class="source-line-no">1338</span><span id="line.1338">         * Always throws an UnsupportedOperationException</span>
<span class="source-line-no">1339</span><span id="line.1339">         */</span>
<span class="source-line-no">1340</span><span id="line.1340">        public boolean add(final Integer o) {</span>
<span class="source-line-no">1341</span><span id="line.1341">            throw new UnsupportedOperationException("Cannot add to the key set directly");</span>
<span class="source-line-no">1342</span><span id="line.1342">        }</span>
<span class="source-line-no">1343</span><span id="line.1343"></span>
<span class="source-line-no">1344</span><span id="line.1344">        /**</span>
<span class="source-line-no">1345</span><span id="line.1345">         * Delegates to the corresponding type-specific method.</span>
<span class="source-line-no">1346</span><span id="line.1346">         */</span>
<span class="source-line-no">1347</span><span id="line.1347">        public boolean contains(final Object o) {</span>
<span class="source-line-no">1348</span><span id="line.1348">            return o instanceof Integer &amp;&amp; containsKey((Integer) o);</span>
<span class="source-line-no">1349</span><span id="line.1349">        }</span>
<span class="source-line-no">1350</span><span id="line.1350"></span>
<span class="source-line-no">1351</span><span id="line.1351">        /**</span>
<span class="source-line-no">1352</span><span id="line.1352">         * Checks whether this collection contains all elements from the given type-specific collection.</span>
<span class="source-line-no">1353</span><span id="line.1353">         *</span>
<span class="source-line-no">1354</span><span id="line.1354">         * @param c a type-specific collection.</span>
<span class="source-line-no">1355</span><span id="line.1355">         * @return &lt;code&gt;true&lt;/code&gt; if this collection contains all elements of the argument.</span>
<span class="source-line-no">1356</span><span id="line.1356">         */</span>
<span class="source-line-no">1357</span><span id="line.1357">        public boolean containsAll(Collection&lt;?&gt; c) {</span>
<span class="source-line-no">1358</span><span id="line.1358">            final Iterator&lt;?&gt; i = c.iterator();</span>
<span class="source-line-no">1359</span><span id="line.1359">            int n = c.size();</span>
<span class="source-line-no">1360</span><span id="line.1360">            while (n-- != 0)</span>
<span class="source-line-no">1361</span><span id="line.1361">                if (!contains(i.next())) return false;</span>
<span class="source-line-no">1362</span><span id="line.1362">            return true;</span>
<span class="source-line-no">1363</span><span id="line.1363">        }</span>
<span class="source-line-no">1364</span><span id="line.1364"></span>
<span class="source-line-no">1365</span><span id="line.1365">        /**</span>
<span class="source-line-no">1366</span><span id="line.1366">         * Retains in this collection only elements from the given type-specific collection.</span>
<span class="source-line-no">1367</span><span id="line.1367">         *</span>
<span class="source-line-no">1368</span><span id="line.1368">         * @param c a type-specific collection.</span>
<span class="source-line-no">1369</span><span id="line.1369">         * @return &lt;code&gt;true&lt;/code&gt; if this collection changed as a result of the call.</span>
<span class="source-line-no">1370</span><span id="line.1370">         */</span>
<span class="source-line-no">1371</span><span id="line.1371">        public boolean retainAll(Collection&lt;?&gt; c) {</span>
<span class="source-line-no">1372</span><span id="line.1372">            boolean retVal = false;</span>
<span class="source-line-no">1373</span><span id="line.1373">            int n = size();</span>
<span class="source-line-no">1374</span><span id="line.1374">            final Iterator&lt;?&gt; i = iterator();</span>
<span class="source-line-no">1375</span><span id="line.1375">            while (n-- != 0) {</span>
<span class="source-line-no">1376</span><span id="line.1376">                if (!c.contains(i.next())) {</span>
<span class="source-line-no">1377</span><span id="line.1377">                    i.remove();</span>
<span class="source-line-no">1378</span><span id="line.1378">                    retVal = true;</span>
<span class="source-line-no">1379</span><span id="line.1379">                }</span>
<span class="source-line-no">1380</span><span id="line.1380">            }</span>
<span class="source-line-no">1381</span><span id="line.1381">            return retVal;</span>
<span class="source-line-no">1382</span><span id="line.1382">        }</span>
<span class="source-line-no">1383</span><span id="line.1383"></span>
<span class="source-line-no">1384</span><span id="line.1384">        /**</span>
<span class="source-line-no">1385</span><span id="line.1385">         * Remove from this collection all elements in the given type-specific collection.</span>
<span class="source-line-no">1386</span><span id="line.1386">         *</span>
<span class="source-line-no">1387</span><span id="line.1387">         * @param c a type-specific collection.</span>
<span class="source-line-no">1388</span><span id="line.1388">         * @return &lt;code&gt;true&lt;/code&gt; if this collection changed as a result of the call.</span>
<span class="source-line-no">1389</span><span id="line.1389">         */</span>
<span class="source-line-no">1390</span><span id="line.1390">        public boolean removeAll(Collection&lt;?&gt; c) {</span>
<span class="source-line-no">1391</span><span id="line.1391">            boolean retVal = false;</span>
<span class="source-line-no">1392</span><span id="line.1392">            int n = c.size();</span>
<span class="source-line-no">1393</span><span id="line.1393">            final Iterator&lt;?&gt; i = c.iterator();</span>
<span class="source-line-no">1394</span><span id="line.1394">            while (n-- != 0)</span>
<span class="source-line-no">1395</span><span id="line.1395">                if (remove(i.next())) retVal = true;</span>
<span class="source-line-no">1396</span><span id="line.1396">            return false;</span>
<span class="source-line-no">1397</span><span id="line.1397">        }</span>
<span class="source-line-no">1398</span><span id="line.1398"></span>
<span class="source-line-no">1399</span><span id="line.1399">        public Object[] toArray() {</span>
<span class="source-line-no">1400</span><span id="line.1400">            final Object[] a = new Object[size()];</span>
<span class="source-line-no">1401</span><span id="line.1401">            objectUnwrap(iterator(), a);</span>
<span class="source-line-no">1402</span><span id="line.1402">            return a;</span>
<span class="source-line-no">1403</span><span id="line.1403">        }</span>
<span class="source-line-no">1404</span><span id="line.1404"></span>
<span class="source-line-no">1405</span><span id="line.1405">        /**</span>
<span class="source-line-no">1406</span><span id="line.1406">         * Adds all elements of the given collection to this collection.</span>
<span class="source-line-no">1407</span><span id="line.1407">         *</span>
<span class="source-line-no">1408</span><span id="line.1408">         * @param c a collection.</span>
<span class="source-line-no">1409</span><span id="line.1409">         * @return &lt;code&gt;true&lt;/code&gt; if this collection changed as a result of the call.</span>
<span class="source-line-no">1410</span><span id="line.1410">         */</span>
<span class="source-line-no">1411</span><span id="line.1411">        public boolean addAll(Collection&lt;? extends Integer&gt; c) {</span>
<span class="source-line-no">1412</span><span id="line.1412">            boolean retVal = false;</span>
<span class="source-line-no">1413</span><span id="line.1413">            final Iterator&lt;? extends Integer&gt; i = c.iterator();</span>
<span class="source-line-no">1414</span><span id="line.1414">            int n = c.size();</span>
<span class="source-line-no">1415</span><span id="line.1415">            while (n-- != 0)</span>
<span class="source-line-no">1416</span><span id="line.1416">                if (add(i.next())) retVal = true;</span>
<span class="source-line-no">1417</span><span id="line.1417">            return false;</span>
<span class="source-line-no">1418</span><span id="line.1418">        }</span>
<span class="source-line-no">1419</span><span id="line.1419"></span>
<span class="source-line-no">1420</span><span id="line.1420">        @Override</span>
<span class="source-line-no">1421</span><span id="line.1421">        public boolean equals(final Object o) {</span>
<span class="source-line-no">1422</span><span id="line.1422">            if (o == this)</span>
<span class="source-line-no">1423</span><span id="line.1423">                return true;</span>
<span class="source-line-no">1424</span><span id="line.1424">            if (!(o instanceof Set))</span>
<span class="source-line-no">1425</span><span id="line.1425">                return false;</span>
<span class="source-line-no">1426</span><span id="line.1426">            Set&lt;?&gt; s = (Set&lt;?&gt;) o;</span>
<span class="source-line-no">1427</span><span id="line.1427">            if (s.size() != size())</span>
<span class="source-line-no">1428</span><span id="line.1428">                return false;</span>
<span class="source-line-no">1429</span><span id="line.1429">            return containsAll(s);</span>
<span class="source-line-no">1430</span><span id="line.1430">        }</span>
<span class="source-line-no">1431</span><span id="line.1431">        /**</span>
<span class="source-line-no">1432</span><span id="line.1432">         * Unwraps an iterator into an array starting at a given offset for a given number of elements.</span>
<span class="source-line-no">1433</span><span id="line.1433">         * &lt;p&gt;</span>
<span class="source-line-no">1434</span><span id="line.1434">         * &lt;P&gt;This method iterates over the given type-specific iterator and stores the elements returned, up to a maximum of &lt;code&gt;length&lt;/code&gt;, in the given array starting at &lt;code&gt;offset&lt;/code&gt;. The</span>
<span class="source-line-no">1435</span><span id="line.1435">         * number of actually unwrapped elements is returned (it may be less than &lt;code&gt;max&lt;/code&gt; if the iterator emits less than &lt;code&gt;max&lt;/code&gt; elements).</span>
<span class="source-line-no">1436</span><span id="line.1436">         *</span>
<span class="source-line-no">1437</span><span id="line.1437">         * @param i      a type-specific iterator.</span>
<span class="source-line-no">1438</span><span id="line.1438">         * @param array  an array to contain the output of the iterator.</span>
<span class="source-line-no">1439</span><span id="line.1439">         * @param offset the first element of the array to be returned.</span>
<span class="source-line-no">1440</span><span id="line.1440">         * @param max    the maximum number of elements to unwrap.</span>
<span class="source-line-no">1441</span><span id="line.1441">         * @return the number of elements unwrapped.</span>
<span class="source-line-no">1442</span><span id="line.1442">         */</span>
<span class="source-line-no">1443</span><span id="line.1443">        public int unwrap(final KeyIterator i, final int[] array, int offset, final int max) {</span>
<span class="source-line-no">1444</span><span id="line.1444">            if (max &lt; 0) throw new IllegalArgumentException("The maximum number of elements (" + max + ") is negative");</span>
<span class="source-line-no">1445</span><span id="line.1445">            if (offset &lt; 0 || offset + max &gt; array.length) throw new IllegalArgumentException();</span>
<span class="source-line-no">1446</span><span id="line.1446">            int j = max;</span>
<span class="source-line-no">1447</span><span id="line.1447">            while (j-- != 0 &amp;&amp; i.hasNext())</span>
<span class="source-line-no">1448</span><span id="line.1448">                array[offset++] = i.nextInt();</span>
<span class="source-line-no">1449</span><span id="line.1449">            return max - j - 1;</span>
<span class="source-line-no">1450</span><span id="line.1450">        }</span>
<span class="source-line-no">1451</span><span id="line.1451">        /**</span>
<span class="source-line-no">1452</span><span id="line.1452">         * Unwraps an iterator into an array.</span>
<span class="source-line-no">1453</span><span id="line.1453">         * &lt;p&gt;</span>
<span class="source-line-no">1454</span><span id="line.1454">         * &lt;P&gt;This method iterates over the given type-specific iterator and stores the elements returned in the given array. The iteration will stop when the iterator has no more elements or when the end</span>
<span class="source-line-no">1455</span><span id="line.1455">         * of the array has been reached.</span>
<span class="source-line-no">1456</span><span id="line.1456">         *</span>
<span class="source-line-no">1457</span><span id="line.1457">         * @param i     a type-specific iterator.</span>
<span class="source-line-no">1458</span><span id="line.1458">         * @param array an array to contain the output of the iterator.</span>
<span class="source-line-no">1459</span><span id="line.1459">         * @return the number of elements unwrapped.</span>
<span class="source-line-no">1460</span><span id="line.1460">         */</span>
<span class="source-line-no">1461</span><span id="line.1461">        public int unwrap(final KeyIterator i, final int[] array) {</span>
<span class="source-line-no">1462</span><span id="line.1462">            return unwrap(i, array, 0, array.length);</span>
<span class="source-line-no">1463</span><span id="line.1463">        }</span>
<span class="source-line-no">1464</span><span id="line.1464">        public int[] toIntArray() {</span>
<span class="source-line-no">1465</span><span id="line.1465">            int[] a = new int[size()];</span>
<span class="source-line-no">1466</span><span id="line.1466">            unwrap(iterator(), a);</span>
<span class="source-line-no">1467</span><span id="line.1467">            return a;</span>
<span class="source-line-no">1468</span><span id="line.1468">        }</span>
<span class="source-line-no">1469</span><span id="line.1469"></span>
<span class="source-line-no">1470</span><span id="line.1470">        public int[] toIntArray(int[] a) {</span>
<span class="source-line-no">1471</span><span id="line.1471">            if (a == null || a.length &lt; size()) a = new int[size()];</span>
<span class="source-line-no">1472</span><span id="line.1472">            unwrap(iterator(), a);</span>
<span class="source-line-no">1473</span><span id="line.1473">            return a;</span>
<span class="source-line-no">1474</span><span id="line.1474">        }</span>
<span class="source-line-no">1475</span><span id="line.1475"></span>
<span class="source-line-no">1476</span><span id="line.1476">        /**</span>
<span class="source-line-no">1477</span><span id="line.1477">         * Unwraps an iterator into an array starting at a given offset for a given number of elements.</span>
<span class="source-line-no">1478</span><span id="line.1478">         * &lt;p&gt;</span>
<span class="source-line-no">1479</span><span id="line.1479">         * &lt;P&gt;This method iterates over the given type-specific iterator and stores the elements returned, up to a maximum of &lt;code&gt;length&lt;/code&gt;, in the given array starting at &lt;code&gt;offset&lt;/code&gt;. The</span>
<span class="source-line-no">1480</span><span id="line.1480">         * number of actually unwrapped elements is returned (it may be less than &lt;code&gt;max&lt;/code&gt; if the iterator emits less than &lt;code&gt;max&lt;/code&gt; elements).</span>
<span class="source-line-no">1481</span><span id="line.1481">         *</span>
<span class="source-line-no">1482</span><span id="line.1482">         * @param i      a type-specific iterator.</span>
<span class="source-line-no">1483</span><span id="line.1483">         * @param array  an array to contain the output of the iterator.</span>
<span class="source-line-no">1484</span><span id="line.1484">         * @param offset the first element of the array to be returned.</span>
<span class="source-line-no">1485</span><span id="line.1485">         * @param max    the maximum number of elements to unwrap.</span>
<span class="source-line-no">1486</span><span id="line.1486">         * @return the number of elements unwrapped.</span>
<span class="source-line-no">1487</span><span id="line.1487">         */</span>
<span class="source-line-no">1488</span><span id="line.1488">        public int unwrap(final KeyIterator i, final Object[] array, int offset, final int max) {</span>
<span class="source-line-no">1489</span><span id="line.1489">            if (max &lt; 0) throw new IllegalArgumentException("The maximum number of elements (" + max + ") is negative");</span>
<span class="source-line-no">1490</span><span id="line.1490">            if (offset &lt; 0 || offset + max &gt; array.length) throw new IllegalArgumentException();</span>
<span class="source-line-no">1491</span><span id="line.1491">            int j = max;</span>
<span class="source-line-no">1492</span><span id="line.1492">            while (j-- != 0 &amp;&amp; i.hasNext())</span>
<span class="source-line-no">1493</span><span id="line.1493">                array[offset++] = i.next();</span>
<span class="source-line-no">1494</span><span id="line.1494">            return max - j - 1;</span>
<span class="source-line-no">1495</span><span id="line.1495">        }</span>
<span class="source-line-no">1496</span><span id="line.1496"></span>
<span class="source-line-no">1497</span><span id="line.1497">        /**</span>
<span class="source-line-no">1498</span><span id="line.1498">         * Unwraps an iterator into an array.</span>
<span class="source-line-no">1499</span><span id="line.1499">         * &lt;p&gt;</span>
<span class="source-line-no">1500</span><span id="line.1500">         * &lt;P&gt;This method iterates over the given type-specific iterator and stores the elements returned in the given array. The iteration will stop when the iterator has no more elements or when the end</span>
<span class="source-line-no">1501</span><span id="line.1501">         * of the array has been reached.</span>
<span class="source-line-no">1502</span><span id="line.1502">         *</span>
<span class="source-line-no">1503</span><span id="line.1503">         * @param i     a type-specific iterator.</span>
<span class="source-line-no">1504</span><span id="line.1504">         * @param array an array to contain the output of the iterator.</span>
<span class="source-line-no">1505</span><span id="line.1505">         * @return the number of elements unwrapped.</span>
<span class="source-line-no">1506</span><span id="line.1506">         */</span>
<span class="source-line-no">1507</span><span id="line.1507">        public int unwrap(final KeyIterator i, final Object[] array) {</span>
<span class="source-line-no">1508</span><span id="line.1508">            return unwrap(i, array, 0, array.length);</span>
<span class="source-line-no">1509</span><span id="line.1509">        }</span>
<span class="source-line-no">1510</span><span id="line.1510"></span>
<span class="source-line-no">1511</span><span id="line.1511">        public boolean isEmpty() {</span>
<span class="source-line-no">1512</span><span id="line.1512">            return size() == 0;</span>
<span class="source-line-no">1513</span><span id="line.1513">        }</span>
<span class="source-line-no">1514</span><span id="line.1514"></span>
<span class="source-line-no">1515</span><span id="line.1515">        @Override</span>
<span class="source-line-no">1516</span><span id="line.1516">        public String toString() {</span>
<span class="source-line-no">1517</span><span id="line.1517">            final StringBuilder s = new StringBuilder();</span>
<span class="source-line-no">1518</span><span id="line.1518">            final KeyIterator i = iterator();</span>
<span class="source-line-no">1519</span><span id="line.1519">            int n = size();</span>
<span class="source-line-no">1520</span><span id="line.1520">            boolean first = true;</span>
<span class="source-line-no">1521</span><span id="line.1521">            s.append("{");</span>
<span class="source-line-no">1522</span><span id="line.1522">            while (n-- != 0) {</span>
<span class="source-line-no">1523</span><span id="line.1523">                if (first) first = false;</span>
<span class="source-line-no">1524</span><span id="line.1524">                else s.append(", ");</span>
<span class="source-line-no">1525</span><span id="line.1525">                s.append(i.next());</span>
<span class="source-line-no">1526</span><span id="line.1526">            }</span>
<span class="source-line-no">1527</span><span id="line.1527">            s.append("}");</span>
<span class="source-line-no">1528</span><span id="line.1528">            return s.toString();</span>
<span class="source-line-no">1529</span><span id="line.1529">        }</span>
<span class="source-line-no">1530</span><span id="line.1530">    }</span>
<span class="source-line-no">1531</span><span id="line.1531"></span>
<span class="source-line-no">1532</span><span id="line.1532">    public KeySet keySet() {</span>
<span class="source-line-no">1533</span><span id="line.1533">        if (keys == null) keys = new KeySet();</span>
<span class="source-line-no">1534</span><span id="line.1534">        return keys;</span>
<span class="source-line-no">1535</span><span id="line.1535">    }</span>
<span class="source-line-no">1536</span><span id="line.1536"></span>
<span class="source-line-no">1537</span><span id="line.1537">    public OrderedSet&lt;Integer&gt; keysAsOrderedSet()</span>
<span class="source-line-no">1538</span><span id="line.1538">    {</span>
<span class="source-line-no">1539</span><span id="line.1539">        OrderedSet&lt;Integer&gt; os = new OrderedSet&lt;&gt;(size, f);</span>
<span class="source-line-no">1540</span><span id="line.1540">        for (int i = 0; i &lt; size; i++) {</span>
<span class="source-line-no">1541</span><span id="line.1541">            os.add(keyAt(i));</span>
<span class="source-line-no">1542</span><span id="line.1542">        }</span>
<span class="source-line-no">1543</span><span id="line.1543">        return os;</span>
<span class="source-line-no">1544</span><span id="line.1544">    }</span>
<span class="source-line-no">1545</span><span id="line.1545">    public int[] keysAsArray() {</span>
<span class="source-line-no">1546</span><span id="line.1546">        return keySet().toIntArray();</span>
<span class="source-line-no">1547</span><span id="line.1547">    }</span>
<span class="source-line-no">1548</span><span id="line.1548"></span>
<span class="source-line-no">1549</span><span id="line.1549">    /**</span>
<span class="source-line-no">1550</span><span id="line.1550">     * An iterator on values.</span>
<span class="source-line-no">1551</span><span id="line.1551">     * &lt;p&gt;</span>
<span class="source-line-no">1552</span><span id="line.1552">     * &lt;P&gt;We simply override the {@link ListIterator#next()}/{@link ListIterator#previous()} methods (and possibly their type-specific counterparts) so that they return values</span>
<span class="source-line-no">1553</span><span id="line.1553">     * instead of entries.</span>
<span class="source-line-no">1554</span><span id="line.1554">     */</span>
<span class="source-line-no">1555</span><span id="line.1555">    public final class ValueIterator extends MapIterator implements ListIterator&lt;Double&gt;, Serializable {</span>
<span class="source-line-no">1556</span><span id="line.1556">        private static final long serialVersionUID = 0L;</span>
<span class="source-line-no">1557</span><span id="line.1557"></span>
<span class="source-line-no">1558</span><span id="line.1558">        public Double previous() {</span>
<span class="source-line-no">1559</span><span id="line.1559">            return value[previousEntry()];</span>
<span class="source-line-no">1560</span><span id="line.1560">        }</span>
<span class="source-line-no">1561</span><span id="line.1561">        public void set(Double v) {</span>
<span class="source-line-no">1562</span><span id="line.1562">            throw new UnsupportedOperationException();</span>
<span class="source-line-no">1563</span><span id="line.1563">        }</span>
<span class="source-line-no">1564</span><span id="line.1564">        public void add(Double v) {</span>
<span class="source-line-no">1565</span><span id="line.1565">            throw new UnsupportedOperationException();</span>
<span class="source-line-no">1566</span><span id="line.1566">        }</span>
<span class="source-line-no">1567</span><span id="line.1567">        public ValueIterator() {}</span>
<span class="source-line-no">1568</span><span id="line.1568">        public Double next() {</span>
<span class="source-line-no">1569</span><span id="line.1569">            return value[nextEntry()];</span>
<span class="source-line-no">1570</span><span id="line.1570">        }</span>
<span class="source-line-no">1571</span><span id="line.1571">        public void remove() { super.remove(); }</span>
<span class="source-line-no">1572</span><span id="line.1572">    }</span>
<span class="source-line-no">1573</span><span id="line.1573">    public final class ValueCollection extends AbstractCollection&lt;Double&gt; implements Serializable</span>
<span class="source-line-no">1574</span><span id="line.1574">    {</span>
<span class="source-line-no">1575</span><span id="line.1575">        private static final long serialVersionUID = 0L;</span>
<span class="source-line-no">1576</span><span id="line.1576">        public ValueIterator iterator() {</span>
<span class="source-line-no">1577</span><span id="line.1577">            return new ValueIterator();</span>
<span class="source-line-no">1578</span><span id="line.1578">        }</span>
<span class="source-line-no">1579</span><span id="line.1579">        public int size() {</span>
<span class="source-line-no">1580</span><span id="line.1580">            return size;</span>
<span class="source-line-no">1581</span><span id="line.1581">        }</span>
<span class="source-line-no">1582</span><span id="line.1582">        public boolean contains(Object v) {</span>
<span class="source-line-no">1583</span><span id="line.1583">            return v instanceof Double &amp;&amp; containsValue((Double)v);</span>
<span class="source-line-no">1584</span><span id="line.1584">        }</span>
<span class="source-line-no">1585</span><span id="line.1585">        public void clear() {</span>
<span class="source-line-no">1586</span><span id="line.1586">            IntDoubleOrderedMap.this.clear();</span>
<span class="source-line-no">1587</span><span id="line.1587">        }</span>
<span class="source-line-no">1588</span><span id="line.1588">    }</span>
<span class="source-line-no">1589</span><span id="line.1589">    public Collection&lt;Double&gt; values() {</span>
<span class="source-line-no">1590</span><span id="line.1590">        if (values == null) values = new ValueCollection();</span>
<span class="source-line-no">1591</span><span id="line.1591">        return values;</span>
<span class="source-line-no">1592</span><span id="line.1592">    }</span>
<span class="source-line-no">1593</span><span id="line.1593"></span>
<span class="source-line-no">1594</span><span id="line.1594">    public double[] valuesAsArray()</span>
<span class="source-line-no">1595</span><span id="line.1595">    {</span>
<span class="source-line-no">1596</span><span id="line.1596">        double[] ls = new double[size];</span>
<span class="source-line-no">1597</span><span id="line.1597">        for (int i = 0; i &lt; size; i++) {</span>
<span class="source-line-no">1598</span><span id="line.1598">            ls[i] = getAt(i);</span>
<span class="source-line-no">1599</span><span id="line.1599">        }</span>
<span class="source-line-no">1600</span><span id="line.1600">        return ls;</span>
<span class="source-line-no">1601</span><span id="line.1601">    }</span>
<span class="source-line-no">1602</span><span id="line.1602"></span>
<span class="source-line-no">1603</span><span id="line.1603">    /**</span>
<span class="source-line-no">1604</span><span id="line.1604">     * Rehashes the map, making the table as small as possible.</span>
<span class="source-line-no">1605</span><span id="line.1605">     * &lt;p&gt;</span>
<span class="source-line-no">1606</span><span id="line.1606">     * &lt;P&gt;This method rehashes the table to the smallest size satisfying the load factor. It can be used when the set will not be changed anymore, so to optimize access speed and size.</span>
<span class="source-line-no">1607</span><span id="line.1607">     * &lt;p&gt;</span>
<span class="source-line-no">1608</span><span id="line.1608">     * &lt;P&gt;If the table size is already the minimum possible, this method does nothing.</span>
<span class="source-line-no">1609</span><span id="line.1609">     *</span>
<span class="source-line-no">1610</span><span id="line.1610">     * @return true if there was enough memory to trim the map.</span>
<span class="source-line-no">1611</span><span id="line.1611">     * @see #trim(int)</span>
<span class="source-line-no">1612</span><span id="line.1612">     */</span>
<span class="source-line-no">1613</span><span id="line.1613">    public boolean trim() {</span>
<span class="source-line-no">1614</span><span id="line.1614">        final int l = arraySize(size, f);</span>
<span class="source-line-no">1615</span><span id="line.1615">        if (l &gt;= n || size &gt; maxFill(l, f)) return true;</span>
<span class="source-line-no">1616</span><span id="line.1616">        try {</span>
<span class="source-line-no">1617</span><span id="line.1617">            rehash(l);</span>
<span class="source-line-no">1618</span><span id="line.1618">        } catch (Exception cantDoIt) {</span>
<span class="source-line-no">1619</span><span id="line.1619">            return false;</span>
<span class="source-line-no">1620</span><span id="line.1620">        }</span>
<span class="source-line-no">1621</span><span id="line.1621">        return true;</span>
<span class="source-line-no">1622</span><span id="line.1622">    }</span>
<span class="source-line-no">1623</span><span id="line.1623"></span>
<span class="source-line-no">1624</span><span id="line.1624">    /**</span>
<span class="source-line-no">1625</span><span id="line.1625">     * Rehashes this map if the table is too large.</span>
<span class="source-line-no">1626</span><span id="line.1626">     * &lt;p&gt;</span>
<span class="source-line-no">1627</span><span id="line.1627">     * &lt;P&gt;Let &lt;var&gt;N&lt;/var&gt; be the smallest table size that can hold &lt;code&gt;max(n,{@link #size()})&lt;/code&gt; entries, still satisfying the load factor. If the current table size is smaller than or equal to</span>
<span class="source-line-no">1628</span><span id="line.1628">     * &lt;var&gt;N&lt;/var&gt;, this method does nothing. Otherwise, it rehashes this map in a table of size &lt;var&gt;N&lt;/var&gt;.</span>
<span class="source-line-no">1629</span><span id="line.1629">     * &lt;p&gt;</span>
<span class="source-line-no">1630</span><span id="line.1630">     * &lt;P&gt;This method is useful when reusing maps. {@linkplain #clear() Clearing a map} leaves the table size untouched. If you are reusing a map many times, you can call this method with a typical</span>
<span class="source-line-no">1631</span><span id="line.1631">     * size to avoid keeping around a very large table just because of a few large transient maps.</span>
<span class="source-line-no">1632</span><span id="line.1632">     *</span>
<span class="source-line-no">1633</span><span id="line.1633">     * @param n the threshold for the trimming.</span>
<span class="source-line-no">1634</span><span id="line.1634">     * @return true if there was enough memory to trim the map.</span>
<span class="source-line-no">1635</span><span id="line.1635">     * @see #trim()</span>
<span class="source-line-no">1636</span><span id="line.1636">     */</span>
<span class="source-line-no">1637</span><span id="line.1637">    public boolean trim(final int n) {</span>
<span class="source-line-no">1638</span><span id="line.1638">        final int l = HashCommon.nextPowerOfTwo((int) Math.ceil(n / f));</span>
<span class="source-line-no">1639</span><span id="line.1639">        if (l &gt;= n || size &gt; maxFill(l, f)) return true;</span>
<span class="source-line-no">1640</span><span id="line.1640">        try {</span>
<span class="source-line-no">1641</span><span id="line.1641">            rehash(l);</span>
<span class="source-line-no">1642</span><span id="line.1642">        } catch (Exception cantDoIt) {</span>
<span class="source-line-no">1643</span><span id="line.1643">            return false;</span>
<span class="source-line-no">1644</span><span id="line.1644">        }</span>
<span class="source-line-no">1645</span><span id="line.1645">        return true;</span>
<span class="source-line-no">1646</span><span id="line.1646">    }</span>
<span class="source-line-no">1647</span><span id="line.1647"></span>
<span class="source-line-no">1648</span><span id="line.1648">    /**</span>
<span class="source-line-no">1649</span><span id="line.1649">     * Rehashes the map.</span>
<span class="source-line-no">1650</span><span id="line.1650">     *</span>
<span class="source-line-no">1651</span><span id="line.1651">     * &lt;P&gt;</span>
<span class="source-line-no">1652</span><span id="line.1652">     * This method implements the basic rehashing strategy, and may be overriden</span>
<span class="source-line-no">1653</span><span id="line.1653">     * by subclasses implementing different rehashing strategies (e.g.,</span>
<span class="source-line-no">1654</span><span id="line.1654">     * disk-based rehashing). However, you should not override this method</span>
<span class="source-line-no">1655</span><span id="line.1655">     * unless you understand the internal workings of this class.</span>
<span class="source-line-no">1656</span><span id="line.1656">     *</span>
<span class="source-line-no">1657</span><span id="line.1657">     * @param newN</span>
<span class="source-line-no">1658</span><span id="line.1658">     *            the new size</span>
<span class="source-line-no">1659</span><span id="line.1659">     */</span>
<span class="source-line-no">1660</span><span id="line.1660"></span>
<span class="source-line-no">1661</span><span id="line.1661">    protected void rehash(final int newN) {</span>
<span class="source-line-no">1662</span><span id="line.1662">        final int[] key = this.key;</span>
<span class="source-line-no">1663</span><span id="line.1663">        final double[] value = this.value;</span>
<span class="source-line-no">1664</span><span id="line.1664">        final int mask = newN - 1; // Note that this is used by the hashing macro</span>
<span class="source-line-no">1665</span><span id="line.1665">        final int[] newKey = new int[newN + 1];</span>
<span class="source-line-no">1666</span><span id="line.1666">        final double[] newValue = new double[newN + 1];</span>
<span class="source-line-no">1667</span><span id="line.1667">        final int sz = order.size;</span>
<span class="source-line-no">1668</span><span id="line.1668">        int k;</span>
<span class="source-line-no">1669</span><span id="line.1669">        int i, pos;</span>
<span class="source-line-no">1670</span><span id="line.1670">        final int[] oi = order.items;</span>
<span class="source-line-no">1671</span><span id="line.1671">        for (int q = 0; q &lt; sz; q++) {</span>
<span class="source-line-no">1672</span><span id="line.1672">            i = oi[q];</span>
<span class="source-line-no">1673</span><span id="line.1673">            if ((k = key[i]) == 0)</span>
<span class="source-line-no">1674</span><span id="line.1674">                pos = newN;</span>
<span class="source-line-no">1675</span><span id="line.1675">            else {</span>
<span class="source-line-no">1676</span><span id="line.1676">                pos = (HashCommon.mix(k)) &amp; mask;</span>
<span class="source-line-no">1677</span><span id="line.1677">                while (newKey[pos] != 0)</span>
<span class="source-line-no">1678</span><span id="line.1678">                    pos = (pos + 1) &amp; mask;</span>
<span class="source-line-no">1679</span><span id="line.1679">            }</span>
<span class="source-line-no">1680</span><span id="line.1680">            newKey[pos] = k;</span>
<span class="source-line-no">1681</span><span id="line.1681">            newValue[pos] = value[i];</span>
<span class="source-line-no">1682</span><span id="line.1682">            oi[q] = pos;</span>
<span class="source-line-no">1683</span><span id="line.1683">        }</span>
<span class="source-line-no">1684</span><span id="line.1684">        n = newN;</span>
<span class="source-line-no">1685</span><span id="line.1685">        this.mask = mask;</span>
<span class="source-line-no">1686</span><span id="line.1686">        maxFill = maxFill(n, f);</span>
<span class="source-line-no">1687</span><span id="line.1687">        this.key = newKey;</span>
<span class="source-line-no">1688</span><span id="line.1688">        this.value = newValue;</span>
<span class="source-line-no">1689</span><span id="line.1689">    }</span>
<span class="source-line-no">1690</span><span id="line.1690">    /**</span>
<span class="source-line-no">1691</span><span id="line.1691">     * Returns a deep copy of this map.</span>
<span class="source-line-no">1692</span><span id="line.1692">     *</span>
<span class="source-line-no">1693</span><span id="line.1693">     * &lt;P&gt;</span>
<span class="source-line-no">1694</span><span id="line.1694">     * This method performs a deep copy of this OrderedMap; the data stored in the</span>
<span class="source-line-no">1695</span><span id="line.1695">     * map, however, is not cloned. Note that this makes a difference only for</span>
<span class="source-line-no">1696</span><span id="line.1696">     * object keys.</span>
<span class="source-line-no">1697</span><span id="line.1697">     *</span>
<span class="source-line-no">1698</span><span id="line.1698">     * @return a deep copy of this map.</span>
<span class="source-line-no">1699</span><span id="line.1699">     */</span>
<span class="source-line-no">1700</span><span id="line.1700">    @GwtIncompatible</span>
<span class="source-line-no">1701</span><span id="line.1701">    public IntDoubleOrderedMap clone() {</span>
<span class="source-line-no">1702</span><span id="line.1702">        IntDoubleOrderedMap c;</span>
<span class="source-line-no">1703</span><span id="line.1703">        try {</span>
<span class="source-line-no">1704</span><span id="line.1704">            c = (IntDoubleOrderedMap) super.clone();</span>
<span class="source-line-no">1705</span><span id="line.1705">            c.key = new int[n + 1];</span>
<span class="source-line-no">1706</span><span id="line.1706">            System.arraycopy(key, 0, c.key, 0, n + 1);</span>
<span class="source-line-no">1707</span><span id="line.1707">            c.value = new double[n + 1];</span>
<span class="source-line-no">1708</span><span id="line.1708">            System.arraycopy(value, 0, c.value, 0, n + 1);</span>
<span class="source-line-no">1709</span><span id="line.1709">            c.order = order.copy();</span>
<span class="source-line-no">1710</span><span id="line.1710">            return c;</span>
<span class="source-line-no">1711</span><span id="line.1711">        } catch (Exception cantHappen) {</span>
<span class="source-line-no">1712</span><span id="line.1712">            throw new UnsupportedOperationException(cantHappen + (cantHappen.getMessage() != null ?</span>
<span class="source-line-no">1713</span><span id="line.1713">                    "; " + cantHappen.getMessage() : ""));</span>
<span class="source-line-no">1714</span><span id="line.1714">        }</span>
<span class="source-line-no">1715</span><span id="line.1715">    }</span>
<span class="source-line-no">1716</span><span id="line.1716">    /**</span>
<span class="source-line-no">1717</span><span id="line.1717">     * Returns a hash code for this map.</span>
<span class="source-line-no">1718</span><span id="line.1718">     *</span>
<span class="source-line-no">1719</span><span id="line.1719">     * @return a hash code for this map.</span>
<span class="source-line-no">1720</span><span id="line.1720">     */</span>
<span class="source-line-no">1721</span><span id="line.1721">    public int hashCode() {</span>
<span class="source-line-no">1722</span><span id="line.1722">        int h = 0;</span>
<span class="source-line-no">1723</span><span id="line.1723">        for (int j = realSize(), i = 0, t; j-- != 0;) {</span>
<span class="source-line-no">1724</span><span id="line.1724">            while (key[i] == 0)</span>
<span class="source-line-no">1725</span><span id="line.1725">                i++;             </span>
<span class="source-line-no">1726</span><span id="line.1726">            t = HashCommon.mix(key[i]) ^ HashCommon.mix(</span>
<span class="source-line-no">1727</span><span id="line.1727">                    NumberTools.doubleToMixedIntBits(value[i]) ^ HashCommon.INV_INT_PHI);</span>
<span class="source-line-no">1728</span><span id="line.1728">            h += t;</span>
<span class="source-line-no">1729</span><span id="line.1729">            i++;</span>
<span class="source-line-no">1730</span><span id="line.1730">        }</span>
<span class="source-line-no">1731</span><span id="line.1731">        // Zero / null keys have hash zero.</span>
<span class="source-line-no">1732</span><span id="line.1732">        if (containsNullKey)</span>
<span class="source-line-no">1733</span><span id="line.1733">            h += HashCommon.mix(NumberTools.doubleToMixedIntBits(value[n]) ^ HashCommon.INV_INT_PHI);</span>
<span class="source-line-no">1734</span><span id="line.1734">        return h;</span>
<span class="source-line-no">1735</span><span id="line.1735">    }</span>
<span class="source-line-no">1736</span><span id="line.1736"></span>
<span class="source-line-no">1737</span><span id="line.1737">    public long hash64()</span>
<span class="source-line-no">1738</span><span id="line.1738">    {</span>
<span class="source-line-no">1739</span><span id="line.1739">        return 31L * (31L * CrossHash.hash64(key) + CrossHash.hash64(value)) + size;</span>
<span class="source-line-no">1740</span><span id="line.1740">    }</span>
<span class="source-line-no">1741</span><span id="line.1741">    /**</span>
<span class="source-line-no">1742</span><span id="line.1742">     * Returns the maximum number of entries that can be filled before rehashing.</span>
<span class="source-line-no">1743</span><span id="line.1743">     *</span>
<span class="source-line-no">1744</span><span id="line.1744">     * @param n the size of the backing array.</span>
<span class="source-line-no">1745</span><span id="line.1745">     * @param f the load factor.</span>
<span class="source-line-no">1746</span><span id="line.1746">     * @return the maximum number of entries before rehashing.</span>
<span class="source-line-no">1747</span><span id="line.1747">     */</span>
<span class="source-line-no">1748</span><span id="line.1748">    public static int maxFill(final int n, final float f) {</span>
<span class="source-line-no">1749</span><span id="line.1749">        /* We must guarantee that there is always at least</span>
<span class="source-line-no">1750</span><span id="line.1750">         * one free entry (even with pathological load factors). */</span>
<span class="source-line-no">1751</span><span id="line.1751">        return Math.min((int)(n * f + 0.99999994f), n - 1);</span>
<span class="source-line-no">1752</span><span id="line.1752">    }</span>
<span class="source-line-no">1753</span><span id="line.1753"></span>
<span class="source-line-no">1754</span><span id="line.1754">    /**</span>
<span class="source-line-no">1755</span><span id="line.1755">     * Returns the least power of two smaller than or equal to 2&lt;sup&gt;30&lt;/sup&gt; and larger than or equal to &lt;code&gt;Math.ceil( expected / f )&lt;/code&gt;.</span>
<span class="source-line-no">1756</span><span id="line.1756">     *</span>
<span class="source-line-no">1757</span><span id="line.1757">     * @param expected the expected number of elements in a hash table.</span>
<span class="source-line-no">1758</span><span id="line.1758">     * @param f        the load factor.</span>
<span class="source-line-no">1759</span><span id="line.1759">     * @return the minimum possible size for a backing array.</span>
<span class="source-line-no">1760</span><span id="line.1760">     * @throws IllegalArgumentException if the necessary size is larger than 2&lt;sup&gt;30&lt;/sup&gt;.</span>
<span class="source-line-no">1761</span><span id="line.1761">     */</span>
<span class="source-line-no">1762</span><span id="line.1762">    public static int arraySize(final int expected, final float f) {</span>
<span class="source-line-no">1763</span><span id="line.1763">        final long s = Math.max(2, HashCommon.nextPowerOfTwo((long) Math.ceil(expected / f)));</span>
<span class="source-line-no">1764</span><span id="line.1764">        if (s &gt; (1 &lt;&lt; 30))</span>
<span class="source-line-no">1765</span><span id="line.1765">            throw new IllegalArgumentException("Too large (" + expected + " expected elements with load factor " + f + ")");</span>
<span class="source-line-no">1766</span><span id="line.1766">        return (int) s;</span>
<span class="source-line-no">1767</span><span id="line.1767">    }</span>
<span class="source-line-no">1768</span><span id="line.1768"></span>
<span class="source-line-no">1769</span><span id="line.1769">    /**</span>
<span class="source-line-no">1770</span><span id="line.1770">     * Unwraps an iterator into an array starting at a given offset for a given number of elements.</span>
<span class="source-line-no">1771</span><span id="line.1771">     * &lt;p&gt;</span>
<span class="source-line-no">1772</span><span id="line.1772">     * &lt;P&gt;This method iterates over the given type-specific iterator and stores the elements returned, up to a maximum of &lt;code&gt;length&lt;/code&gt;, in the given array starting at &lt;code&gt;offset&lt;/code&gt;. The</span>
<span class="source-line-no">1773</span><span id="line.1773">     * number of actually unwrapped elements is returned (it may be less than &lt;code&gt;max&lt;/code&gt; if the iterator emits less than &lt;code&gt;max&lt;/code&gt; elements).</span>
<span class="source-line-no">1774</span><span id="line.1774">     *</span>
<span class="source-line-no">1775</span><span id="line.1775">     * @param i      a type-specific iterator.</span>
<span class="source-line-no">1776</span><span id="line.1776">     * @param array  an array to contain the output of the iterator.</span>
<span class="source-line-no">1777</span><span id="line.1777">     * @param offset the first element of the array to be returned.</span>
<span class="source-line-no">1778</span><span id="line.1778">     * @param max    the maximum number of elements to unwrap.</span>
<span class="source-line-no">1779</span><span id="line.1779">     * @return the number of elements unwrapped.</span>
<span class="source-line-no">1780</span><span id="line.1780">     */</span>
<span class="source-line-no">1781</span><span id="line.1781">    private int unwrap(final ValueIterator i, final Object[] array, int offset, final int max) {</span>
<span class="source-line-no">1782</span><span id="line.1782">        if (max &lt; 0) throw new IllegalArgumentException("The maximum number of elements (" + max + ") is negative");</span>
<span class="source-line-no">1783</span><span id="line.1783">        if (offset &lt; 0 || offset + max &gt; array.length) throw new IllegalArgumentException();</span>
<span class="source-line-no">1784</span><span id="line.1784">        int j = max;</span>
<span class="source-line-no">1785</span><span id="line.1785">        while (j-- != 0 &amp;&amp; i.hasNext())</span>
<span class="source-line-no">1786</span><span id="line.1786">            array[offset++] = i.next();</span>
<span class="source-line-no">1787</span><span id="line.1787">        return max - j - 1;</span>
<span class="source-line-no">1788</span><span id="line.1788">    }</span>
<span class="source-line-no">1789</span><span id="line.1789"></span>
<span class="source-line-no">1790</span><span id="line.1790">    /**</span>
<span class="source-line-no">1791</span><span id="line.1791">     * Unwraps an iterator into an array.</span>
<span class="source-line-no">1792</span><span id="line.1792">     * &lt;p&gt;</span>
<span class="source-line-no">1793</span><span id="line.1793">     * &lt;P&gt;This method iterates over the given type-specific iterator and stores the elements returned in the given array. The iteration will stop when the iterator has no more elements or when the end</span>
<span class="source-line-no">1794</span><span id="line.1794">     * of the array has been reached.</span>
<span class="source-line-no">1795</span><span id="line.1795">     *</span>
<span class="source-line-no">1796</span><span id="line.1796">     * @param i     a type-specific iterator.</span>
<span class="source-line-no">1797</span><span id="line.1797">     * @param array an array to contain the output of the iterator.</span>
<span class="source-line-no">1798</span><span id="line.1798">     * @return the number of elements unwrapped.</span>
<span class="source-line-no">1799</span><span id="line.1799">     */</span>
<span class="source-line-no">1800</span><span id="line.1800">    private int unwrap(final ValueIterator i, final Object[] array) {</span>
<span class="source-line-no">1801</span><span id="line.1801">        return unwrap(i, array, 0, array.length);</span>
<span class="source-line-no">1802</span><span id="line.1802">    }</span>
<span class="source-line-no">1803</span><span id="line.1803"></span>
<span class="source-line-no">1804</span><span id="line.1804"></span>
<span class="source-line-no">1805</span><span id="line.1805">    /** Unwraps an iterator into an array starting at a given offset for a given number of elements.</span>
<span class="source-line-no">1806</span><span id="line.1806">     *</span>
<span class="source-line-no">1807</span><span id="line.1807">     * &lt;P&gt;This method iterates over the given type-specific iterator and stores the elements returned, up to a maximum of &lt;code&gt;length&lt;/code&gt;, in the given array starting at &lt;code&gt;offset&lt;/code&gt;. The</span>
<span class="source-line-no">1808</span><span id="line.1808">     * number of actually unwrapped elements is returned (it may be less than &lt;code&gt;max&lt;/code&gt; if the iterator emits less than &lt;code&gt;max&lt;/code&gt; elements).</span>
<span class="source-line-no">1809</span><span id="line.1809">     *</span>
<span class="source-line-no">1810</span><span id="line.1810">     * @param i a type-specific iterator.</span>
<span class="source-line-no">1811</span><span id="line.1811">     * @param array an array to contain the output of the iterator.</span>
<span class="source-line-no">1812</span><span id="line.1812">     * @param offset the first element of the array to be returned.</span>
<span class="source-line-no">1813</span><span id="line.1813">     * @param max the maximum number of elements to unwrap.</span>
<span class="source-line-no">1814</span><span id="line.1814">     * @return the number of elements unwrapped. */</span>
<span class="source-line-no">1815</span><span id="line.1815">    private static &lt;K&gt; int objectUnwrap(final Iterator&lt;? extends K&gt; i, final K[] array, int offset, final int max ) {</span>
<span class="source-line-no">1816</span><span id="line.1816">        if ( max &lt; 0 ) throw new IllegalArgumentException( "The maximum number of elements (" + max + ") is negative" );</span>
<span class="source-line-no">1817</span><span id="line.1817">        if ( offset &lt; 0 || offset + max &gt; array.length ) throw new IllegalArgumentException();</span>
<span class="source-line-no">1818</span><span id="line.1818">        int j = max;</span>
<span class="source-line-no">1819</span><span id="line.1819">        while ( j-- != 0 &amp;&amp; i.hasNext() )</span>
<span class="source-line-no">1820</span><span id="line.1820">            array[ offset++ ] = i.next();</span>
<span class="source-line-no">1821</span><span id="line.1821">        return max - j - 1;</span>
<span class="source-line-no">1822</span><span id="line.1822">    }</span>
<span class="source-line-no">1823</span><span id="line.1823"></span>
<span class="source-line-no">1824</span><span id="line.1824">    /** Unwraps an iterator into an array.</span>
<span class="source-line-no">1825</span><span id="line.1825">     *</span>
<span class="source-line-no">1826</span><span id="line.1826">     * &lt;P&gt;This method iterates over the given type-specific iterator and stores the elements returned in the given array. The iteration will stop when the iterator has no more elements or when the end</span>
<span class="source-line-no">1827</span><span id="line.1827">     * of the array has been reached.</span>
<span class="source-line-no">1828</span><span id="line.1828">     *</span>
<span class="source-line-no">1829</span><span id="line.1829">     * @param i a type-specific iterator.</span>
<span class="source-line-no">1830</span><span id="line.1830">     * @param array an array to contain the output of the iterator.</span>
<span class="source-line-no">1831</span><span id="line.1831">     * @return the number of elements unwrapped. */</span>
<span class="source-line-no">1832</span><span id="line.1832">    private static &lt;K&gt; int objectUnwrap(final Iterator&lt;? extends K&gt; i, final K[] array) {</span>
<span class="source-line-no">1833</span><span id="line.1833">        return objectUnwrap(i, array, 0, array.length );</span>
<span class="source-line-no">1834</span><span id="line.1834">    }</span>
<span class="source-line-no">1835</span><span id="line.1835"></span>
<span class="source-line-no">1836</span><span id="line.1836">    @Override</span>
<span class="source-line-no">1837</span><span id="line.1837">    public String toString() {</span>
<span class="source-line-no">1838</span><span id="line.1838">        final StringBuilder s = new StringBuilder();</span>
<span class="source-line-no">1839</span><span id="line.1839">        int n = size(), i = 0;</span>
<span class="source-line-no">1840</span><span id="line.1840">        boolean first = true;</span>
<span class="source-line-no">1841</span><span id="line.1841">        s.append("IntDoubleOrderedMap{");</span>
<span class="source-line-no">1842</span><span id="line.1842">        while (i &lt; n) {</span>
<span class="source-line-no">1843</span><span id="line.1843">            if (first) first = false;</span>
<span class="source-line-no">1844</span><span id="line.1844">            else s.append(", ");</span>
<span class="source-line-no">1845</span><span id="line.1845">            s.append(entryAt(i++));</span>
<span class="source-line-no">1846</span><span id="line.1846">        }</span>
<span class="source-line-no">1847</span><span id="line.1847">        s.append("}");</span>
<span class="source-line-no">1848</span><span id="line.1848">        return s.toString();</span>
<span class="source-line-no">1849</span><span id="line.1849">    }</span>
<span class="source-line-no">1850</span><span id="line.1850">    @Override</span>
<span class="source-line-no">1851</span><span id="line.1851">    public boolean equals(Object o) {</span>
<span class="source-line-no">1852</span><span id="line.1852">        if (o == this)</span>
<span class="source-line-no">1853</span><span id="line.1853">            return true;</span>
<span class="source-line-no">1854</span><span id="line.1854">        if (!(o instanceof IntDoubleOrderedMap))</span>
<span class="source-line-no">1855</span><span id="line.1855">            return false;</span>
<span class="source-line-no">1856</span><span id="line.1856">        IntDoubleOrderedMap m = (IntDoubleOrderedMap) o;</span>
<span class="source-line-no">1857</span><span id="line.1857">        if (m.size() != size())</span>
<span class="source-line-no">1858</span><span id="line.1858">            return false;</span>
<span class="source-line-no">1859</span><span id="line.1859">        return entrySet().containsAll(m.entrySet());</span>
<span class="source-line-no">1860</span><span id="line.1860">    }</span>
<span class="source-line-no">1861</span><span id="line.1861"></span>
<span class="source-line-no">1862</span><span id="line.1862">    @GwtIncompatible</span>
<span class="source-line-no">1863</span><span id="line.1863">    private void writeObject(java.io.ObjectOutputStream s)</span>
<span class="source-line-no">1864</span><span id="line.1864">            throws java.io.IOException {</span>
<span class="source-line-no">1865</span><span id="line.1865">        final int[] key = this.key;</span>
<span class="source-line-no">1866</span><span id="line.1866">        final double[] value = this.value;</span>
<span class="source-line-no">1867</span><span id="line.1867">        final MapIterator i = new MapIterator();</span>
<span class="source-line-no">1868</span><span id="line.1868">        s.defaultWriteObject();</span>
<span class="source-line-no">1869</span><span id="line.1869">        for (int j = size, e; j-- != 0;) {</span>
<span class="source-line-no">1870</span><span id="line.1870">            e = i.nextEntry();</span>
<span class="source-line-no">1871</span><span id="line.1871">            s.writeInt(key[e]);</span>
<span class="source-line-no">1872</span><span id="line.1872">            s.writeDouble(value[e]);</span>
<span class="source-line-no">1873</span><span id="line.1873">        }</span>
<span class="source-line-no">1874</span><span id="line.1874">    }</span>
<span class="source-line-no">1875</span><span id="line.1875">    @GwtIncompatible</span>
<span class="source-line-no">1876</span><span id="line.1876">    private void readObject(java.io.ObjectInputStream s)</span>
<span class="source-line-no">1877</span><span id="line.1877">            throws java.io.IOException, ClassNotFoundException {</span>
<span class="source-line-no">1878</span><span id="line.1878">        s.defaultReadObject();</span>
<span class="source-line-no">1879</span><span id="line.1879">        n = arraySize(size, f);</span>
<span class="source-line-no">1880</span><span id="line.1880">        maxFill = maxFill(n, f);</span>
<span class="source-line-no">1881</span><span id="line.1881">        mask = n - 1;</span>
<span class="source-line-no">1882</span><span id="line.1882">        final int[] key = this.key = new int[n + 1];</span>
<span class="source-line-no">1883</span><span id="line.1883">        final double[] value = this.value = new double[n + 1];</span>
<span class="source-line-no">1884</span><span id="line.1884">        final IntVLA order = this.order = new IntVLA(n + 1);</span>
<span class="source-line-no">1885</span><span id="line.1885">        int k;</span>
<span class="source-line-no">1886</span><span id="line.1886">        double v;</span>
<span class="source-line-no">1887</span><span id="line.1887">        for (int i = size, pos; i-- != 0;) {</span>
<span class="source-line-no">1888</span><span id="line.1888">            k = s.readInt();</span>
<span class="source-line-no">1889</span><span id="line.1889">            v = s.readDouble();</span>
<span class="source-line-no">1890</span><span id="line.1890">            if (k == 0) {</span>
<span class="source-line-no">1891</span><span id="line.1891">                pos = n;</span>
<span class="source-line-no">1892</span><span id="line.1892">                containsNullKey = true;</span>
<span class="source-line-no">1893</span><span id="line.1893">            } else {</span>
<span class="source-line-no">1894</span><span id="line.1894">                pos = (HashCommon.mix(k))</span>
<span class="source-line-no">1895</span><span id="line.1895">                        &amp; mask;</span>
<span class="source-line-no">1896</span><span id="line.1896">                while (!(key[pos] == 0))</span>
<span class="source-line-no">1897</span><span id="line.1897">                    pos = (pos + 1) &amp; mask;</span>
<span class="source-line-no">1898</span><span id="line.1898">            }</span>
<span class="source-line-no">1899</span><span id="line.1899"></span>
<span class="source-line-no">1900</span><span id="line.1900">            key[pos] = k;</span>
<span class="source-line-no">1901</span><span id="line.1901">            value[pos] = v;</span>
<span class="source-line-no">1902</span><span id="line.1902">            order.add(pos);</span>
<span class="source-line-no">1903</span><span id="line.1903">        }</span>
<span class="source-line-no">1904</span><span id="line.1904">    }</span>
<span class="source-line-no">1905</span><span id="line.1905"></span>
<span class="source-line-no">1906</span><span id="line.1906">    /**</span>
<span class="source-line-no">1907</span><span id="line.1907">     * Gets the value at the given index in the iteration order in constant time (random-access).</span>
<span class="source-line-no">1908</span><span id="line.1908">     * @param idx the index in the iteration order of the value to fetch</span>
<span class="source-line-no">1909</span><span id="line.1909">     * @return the value at the index, if the index is valid, otherwise the default return value</span>
<span class="source-line-no">1910</span><span id="line.1910">     */</span>
<span class="source-line-no">1911</span><span id="line.1911">    public double getAt(final int idx) {</span>
<span class="source-line-no">1912</span><span id="line.1912">        int pos;</span>
<span class="source-line-no">1913</span><span id="line.1913">        if (idx &lt; 0 || idx &gt;= order.size)</span>
<span class="source-line-no">1914</span><span id="line.1914">            return defRetValue;</span>
<span class="source-line-no">1915</span><span id="line.1915">        // The starting point.</span>
<span class="source-line-no">1916</span><span id="line.1916">        if (key[pos = order.get(idx)] == 0)</span>
<span class="source-line-no">1917</span><span id="line.1917">            return containsNullKey ? value[n] : defRetValue;</span>
<span class="source-line-no">1918</span><span id="line.1918">        return value[pos];</span>
<span class="source-line-no">1919</span><span id="line.1919">    }</span>
<span class="source-line-no">1920</span><span id="line.1920">    /**</span>
<span class="source-line-no">1921</span><span id="line.1921">     * Gets the key at the given index in the iteration order in constant time (random-access).</span>
<span class="source-line-no">1922</span><span id="line.1922">     * @param idx the index in the iteration order of the key to fetch</span>
<span class="source-line-no">1923</span><span id="line.1923">     * @return the key at the index, if the index is valid, otherwise 0</span>
<span class="source-line-no">1924</span><span id="line.1924">     */</span>
<span class="source-line-no">1925</span><span id="line.1925">    public int keyAt(final int idx) {</span>
<span class="source-line-no">1926</span><span id="line.1926">        if (idx &lt; 0 || idx &gt;= order.size)</span>
<span class="source-line-no">1927</span><span id="line.1927">            return 0;</span>
<span class="source-line-no">1928</span><span id="line.1928">        // The starting point.</span>
<span class="source-line-no">1929</span><span id="line.1929">        return key[order.get(idx)];</span>
<span class="source-line-no">1930</span><span id="line.1930">    }</span>
<span class="source-line-no">1931</span><span id="line.1931"></span>
<span class="source-line-no">1932</span><span id="line.1932">    /**</span>
<span class="source-line-no">1933</span><span id="line.1933">     * Gets the key-value Map.Entry at the given index in the iteration order in constant time (random-access).</span>
<span class="source-line-no">1934</span><span id="line.1934">     * @param idx the index in the iteration order of the entry to fetch</span>
<span class="source-line-no">1935</span><span id="line.1935">     * @return the key-value entry at the index, if the index is valid, otherwise null</span>
<span class="source-line-no">1936</span><span id="line.1936">     */</span>
<span class="source-line-no">1937</span><span id="line.1937">    public MapEntry entryAt(final int idx)</span>
<span class="source-line-no">1938</span><span id="line.1938">    {</span>
<span class="source-line-no">1939</span><span id="line.1939">        if (idx &lt; 0 || idx &gt;= order.size)</span>
<span class="source-line-no">1940</span><span id="line.1940">            return null;</span>
<span class="source-line-no">1941</span><span id="line.1941">        return new MapEntry(order.get(idx));</span>
<span class="source-line-no">1942</span><span id="line.1942">    }</span>
<span class="source-line-no">1943</span><span id="line.1943"></span>
<span class="source-line-no">1944</span><span id="line.1944">    /**</span>
<span class="source-line-no">1945</span><span id="line.1945">     * Removes the key and value at the given index in the iteration order in not-exactly constant time (though it still</span>
<span class="source-line-no">1946</span><span id="line.1946">     * should be efficient).</span>
<span class="source-line-no">1947</span><span id="line.1947">     * @param idx the index in the iteration order of the key and value to remove</span>
<span class="source-line-no">1948</span><span id="line.1948">     * @return the value removed, if there was anything removed, or the default return value otherwise (often null)</span>
<span class="source-line-no">1949</span><span id="line.1949">     */</span>
<span class="source-line-no">1950</span><span id="line.1950">    public double removeAt(final int idx) {</span>
<span class="source-line-no">1951</span><span id="line.1951"></span>
<span class="source-line-no">1952</span><span id="line.1952">        if (idx &lt; 0 || idx &gt;= order.size)</span>
<span class="source-line-no">1953</span><span id="line.1953">            return defRetValue;</span>
<span class="source-line-no">1954</span><span id="line.1954">        int pos = order.get(idx);</span>
<span class="source-line-no">1955</span><span id="line.1955">        if (key[pos] == 0) {</span>
<span class="source-line-no">1956</span><span id="line.1956">            if (containsNullKey)</span>
<span class="source-line-no">1957</span><span id="line.1957">                return removeNullEntry();</span>
<span class="source-line-no">1958</span><span id="line.1958">            return defRetValue;</span>
<span class="source-line-no">1959</span><span id="line.1959">        }</span>
<span class="source-line-no">1960</span><span id="line.1960">        return removeEntry(pos);</span>
<span class="source-line-no">1961</span><span id="line.1961">    }</span>
<span class="source-line-no">1962</span><span id="line.1962">    /**</span>
<span class="source-line-no">1963</span><span id="line.1963">     * Gets a random value from this OrderedMap in constant time, using the given IRNG to generate a random number.</span>
<span class="source-line-no">1964</span><span id="line.1964">     * @param rng used to generate a random index for a value</span>
<span class="source-line-no">1965</span><span id="line.1965">     * @return a random value from this OrderedMap</span>
<span class="source-line-no">1966</span><span id="line.1966">     */</span>
<span class="source-line-no">1967</span><span id="line.1967">    public double randomValue(IRNG rng)</span>
<span class="source-line-no">1968</span><span id="line.1968">    {</span>
<span class="source-line-no">1969</span><span id="line.1969">        return getAt(rng.nextInt(order.size));</span>
<span class="source-line-no">1970</span><span id="line.1970">    }</span>
<span class="source-line-no">1971</span><span id="line.1971"></span>
<span class="source-line-no">1972</span><span id="line.1972">    /**</span>
<span class="source-line-no">1973</span><span id="line.1973">     * Gets a random key from this OrderedMap in constant time, using the given IRNG to generate a random number.</span>
<span class="source-line-no">1974</span><span id="line.1974">     * @param rng used to generate a random index for a key</span>
<span class="source-line-no">1975</span><span id="line.1975">     * @return a random key from this OrderedMap</span>
<span class="source-line-no">1976</span><span id="line.1976">     */</span>
<span class="source-line-no">1977</span><span id="line.1977">    public int randomKey(IRNG rng)</span>
<span class="source-line-no">1978</span><span id="line.1978">    {</span>
<span class="source-line-no">1979</span><span id="line.1979">        return keyAt(rng.nextInt(order.size));</span>
<span class="source-line-no">1980</span><span id="line.1980">    }</span>
<span class="source-line-no">1981</span><span id="line.1981"></span>
<span class="source-line-no">1982</span><span id="line.1982">    /**</span>
<span class="source-line-no">1983</span><span id="line.1983">     * Gets a random entry from this OrderedMap in constant time, using the given IRNG to generate a random number.</span>
<span class="source-line-no">1984</span><span id="line.1984">     * @param rng used to generate a random index for a entry</span>
<span class="source-line-no">1985</span><span id="line.1985">     * @return a random key-value entry from this OrderedMap</span>
<span class="source-line-no">1986</span><span id="line.1986">     */</span>
<span class="source-line-no">1987</span><span id="line.1987">    public MapEntry randomEntry(IRNG rng)</span>
<span class="source-line-no">1988</span><span id="line.1988">    {</span>
<span class="source-line-no">1989</span><span id="line.1989">        return new MapEntry(order.getRandomElement(rng));</span>
<span class="source-line-no">1990</span><span id="line.1990">    }</span>
<span class="source-line-no">1991</span><span id="line.1991"></span>
<span class="source-line-no">1992</span><span id="line.1992">    /**</span>
<span class="source-line-no">1993</span><span id="line.1993">     * Randomly alters the iteration order for this OrderedMap using the given IRNG to shuffle.</span>
<span class="source-line-no">1994</span><span id="line.1994">     * @param rng used to generate a random ordering</span>
<span class="source-line-no">1995</span><span id="line.1995">     * @return this for chaining</span>
<span class="source-line-no">1996</span><span id="line.1996">     */</span>
<span class="source-line-no">1997</span><span id="line.1997">    public IntDoubleOrderedMap shuffle(IRNG rng)</span>
<span class="source-line-no">1998</span><span id="line.1998">    {</span>
<span class="source-line-no">1999</span><span id="line.1999">        if(size &lt; 2)</span>
<span class="source-line-no">2000</span><span id="line.2000">            return this;</span>
<span class="source-line-no">2001</span><span id="line.2001">        order.shuffle(rng);</span>
<span class="source-line-no">2002</span><span id="line.2002">        return this;</span>
<span class="source-line-no">2003</span><span id="line.2003">    }</span>
<span class="source-line-no">2004</span><span id="line.2004"></span>
<span class="source-line-no">2005</span><span id="line.2005">    /**</span>
<span class="source-line-no">2006</span><span id="line.2006">     * Given an array or varargs of replacement indices for this OrderedMap's iteration order, reorders this so the</span>
<span class="source-line-no">2007</span><span id="line.2007">     * first item in the returned version is the same as {@code getAt(ordering[0])} (with some care taken for negative</span>
<span class="source-line-no">2008</span><span id="line.2008">     * or too-large indices), the second item in the returned version is the same as {@code getAt(ordering[1])}, etc.</span>
<span class="source-line-no">2009</span><span id="line.2009">     * &lt;br&gt;</span>
<span class="source-line-no">2010</span><span id="line.2010">     * Negative indices are considered reversed distances from the end of ordering, so -1 refers to the same index as</span>
<span class="source-line-no">2011</span><span id="line.2011">     * {@code ordering[ordering.length - 1]}. If ordering is smaller than {@code size()}, only the indices up to the</span>
<span class="source-line-no">2012</span><span id="line.2012">     * length of ordering will be modified. If ordering is larger than {@code size()}, only as many indices will be</span>
<span class="source-line-no">2013</span><span id="line.2013">     * affected as {@code size()}, and reversed distances are measured from the end of this Map's entries instead of</span>
<span class="source-line-no">2014</span><span id="line.2014">     * the end of ordering. Duplicate values in ordering will produce duplicate values in the returned Map.</span>
<span class="source-line-no">2015</span><span id="line.2015">     * &lt;br&gt;</span>
<span class="source-line-no">2016</span><span id="line.2016">     * This method modifies this OrderedMap in-place and also returns it for chaining.</span>
<span class="source-line-no">2017</span><span id="line.2017">     * @param ordering an array or varargs of int indices, where the nth item in ordering changes the nth item in this</span>
<span class="source-line-no">2018</span><span id="line.2018">     *                 Map to have the value currently in this Map at the index specified by the value in ordering</span>
<span class="source-line-no">2019</span><span id="line.2019">     * @return this for chaining, after modifying it in-place</span>
<span class="source-line-no">2020</span><span id="line.2020">     */</span>
<span class="source-line-no">2021</span><span id="line.2021">    public IntDoubleOrderedMap reorder(int... ordering)</span>
<span class="source-line-no">2022</span><span id="line.2022">    {</span>
<span class="source-line-no">2023</span><span id="line.2023">        order.reorder(ordering);</span>
<span class="source-line-no">2024</span><span id="line.2024">        return this;</span>
<span class="source-line-no">2025</span><span id="line.2025">    }</span>
<span class="source-line-no">2026</span><span id="line.2026">    private int alterEntry(final int pos) {</span>
<span class="source-line-no">2027</span><span id="line.2027">        int idx = fixOrder(pos);</span>
<span class="source-line-no">2028</span><span id="line.2028">        size--;</span>
<span class="source-line-no">2029</span><span id="line.2029">        shiftKeys(pos);</span>
<span class="source-line-no">2030</span><span id="line.2030">        return idx;</span>
<span class="source-line-no">2031</span><span id="line.2031">    }</span>
<span class="source-line-no">2032</span><span id="line.2032">    private int alterNullEntry() {</span>
<span class="source-line-no">2033</span><span id="line.2033">        int idx = fixOrder(n);</span>
<span class="source-line-no">2034</span><span id="line.2034">        containsNullKey = false;</span>
<span class="source-line-no">2035</span><span id="line.2035">        size--;</span>
<span class="source-line-no">2036</span><span id="line.2036">        return idx;</span>
<span class="source-line-no">2037</span><span id="line.2037">    }</span>
<span class="source-line-no">2038</span><span id="line.2038">    /**</span>
<span class="source-line-no">2039</span><span id="line.2039">     * Swaps a key, original, for another key, replacement, while keeping replacement at the same point in the iteration</span>
<span class="source-line-no">2040</span><span id="line.2040">     * order as original and keeping it associated with the same value (which also keeps its iteration index). Unlike</span>
<span class="source-line-no">2041</span><span id="line.2041">     * the similar method {@link #alter(int, int)}, this will not change this OrderedMap if replacement is already</span>
<span class="source-line-no">2042</span><span id="line.2042">     * present. To contrast, alter() can reduce the size of the OrderedMap if both original and replacement are already</span>
<span class="source-line-no">2043</span><span id="line.2043">     * in the Map. If replacement is found, this returns the default return value, otherwise it switches out original</span>
<span class="source-line-no">2044</span><span id="line.2044">     * for replacement and returns whatever was associated with original.</span>
<span class="source-line-no">2045</span><span id="line.2045">     * @param original the key to find and swap out</span>
<span class="source-line-no">2046</span><span id="line.2046">     * @param replacement the key to replace original with</span>
<span class="source-line-no">2047</span><span id="line.2047">     * @return the value associated with original before, and replacement now</span>
<span class="source-line-no">2048</span><span id="line.2048">     */</span>
<span class="source-line-no">2049</span><span id="line.2049">    public double alterCarefully(final int original, final int replacement) {</span>
<span class="source-line-no">2050</span><span id="line.2050">        if(!containsKey(replacement))</span>
<span class="source-line-no">2051</span><span id="line.2051">            return alter(original, replacement);</span>
<span class="source-line-no">2052</span><span id="line.2052">        else</span>
<span class="source-line-no">2053</span><span id="line.2053">            return defRetValue;</span>
<span class="source-line-no">2054</span><span id="line.2054">    }</span>
<span class="source-line-no">2055</span><span id="line.2055">    /**</span>
<span class="source-line-no">2056</span><span id="line.2056">     * Swaps a key, original, for another key, replacement, while keeping replacement at the same point in the iteration</span>
<span class="source-line-no">2057</span><span id="line.2057">     * order as original and keeping it associated with the same value (which also keeps its iteration index).</span>
<span class="source-line-no">2058</span><span id="line.2058">     * Be aware that if both original and replacement are present in the OrderedMap, this will still replace original</span>
<span class="source-line-no">2059</span><span id="line.2059">     * with replacement but will also remove the other occurrence of replacement to avoid duplicate keys. This can throw</span>
<span class="source-line-no">2060</span><span id="line.2060">     * off the expected order because the duplicate could be at any point in the ordering when it is removed. You may</span>
<span class="source-line-no">2061</span><span id="line.2061">     * want to prefer {@link #alterCarefully(int, int)} if you don't feel like checking by hand for whether</span>
<span class="source-line-no">2062</span><span id="line.2062">     * replacement is already present, but using this method is perfectly reasonable if you know overlaps won't happen.</span>
<span class="source-line-no">2063</span><span id="line.2063">     * @param original the key to find and swap out</span>
<span class="source-line-no">2064</span><span id="line.2064">     * @param replacement the key to replace original with</span>
<span class="source-line-no">2065</span><span id="line.2065">     * @return the value associated with original before, and replacement now</span>
<span class="source-line-no">2066</span><span id="line.2066">     */</span>
<span class="source-line-no">2067</span><span id="line.2067">    public double alter(final int original, final int replacement) {</span>
<span class="source-line-no">2068</span><span id="line.2068">        double v;</span>
<span class="source-line-no">2069</span><span id="line.2069">        int idx;</span>
<span class="source-line-no">2070</span><span id="line.2070">        if (original == 0) {</span>
<span class="source-line-no">2071</span><span id="line.2071">            if (containsNullKey) {</span>
<span class="source-line-no">2072</span><span id="line.2072">                v = value[n];</span>
<span class="source-line-no">2073</span><span id="line.2073">                idx = alterNullEntry();</span>
<span class="source-line-no">2074</span><span id="line.2074">                putAt(replacement, v, idx);</span>
<span class="source-line-no">2075</span><span id="line.2075">                return v;</span>
<span class="source-line-no">2076</span><span id="line.2076">            }</span>
<span class="source-line-no">2077</span><span id="line.2077">            else</span>
<span class="source-line-no">2078</span><span id="line.2078">                v = defRetValue;</span>
<span class="source-line-no">2079</span><span id="line.2079">            return v;</span>
<span class="source-line-no">2080</span><span id="line.2080">        }</span>
<span class="source-line-no">2081</span><span id="line.2081">        int curr;</span>
<span class="source-line-no">2082</span><span id="line.2082">        final int[] key = this.key;</span>
<span class="source-line-no">2083</span><span id="line.2083">        int pos;</span>
<span class="source-line-no">2084</span><span id="line.2084">        // The starting point.</span>
<span class="source-line-no">2085</span><span id="line.2085">        if ((curr = key[pos = (HashCommon.mix(original)) &amp; mask]) == 0)</span>
<span class="source-line-no">2086</span><span id="line.2086">            return defRetValue;</span>
<span class="source-line-no">2087</span><span id="line.2087">        if (original == curr)</span>
<span class="source-line-no">2088</span><span id="line.2088">        {</span>
<span class="source-line-no">2089</span><span id="line.2089">            v = value[pos];</span>
<span class="source-line-no">2090</span><span id="line.2090">            idx = alterEntry(pos);</span>
<span class="source-line-no">2091</span><span id="line.2091">            putAt(replacement, v, idx);</span>
<span class="source-line-no">2092</span><span id="line.2092">            return v;</span>
<span class="source-line-no">2093</span><span id="line.2093">        }</span>
<span class="source-line-no">2094</span><span id="line.2094">        while (true) {</span>
<span class="source-line-no">2095</span><span id="line.2095">            if ((curr = key[pos = (pos + 1) &amp; mask]) == 0)</span>
<span class="source-line-no">2096</span><span id="line.2096">                return defRetValue;</span>
<span class="source-line-no">2097</span><span id="line.2097">            if (original == curr)</span>
<span class="source-line-no">2098</span><span id="line.2098">            {</span>
<span class="source-line-no">2099</span><span id="line.2099">                v = value[pos];</span>
<span class="source-line-no">2100</span><span id="line.2100">                idx = alterEntry(pos);</span>
<span class="source-line-no">2101</span><span id="line.2101">                putAt(replacement, v, idx);</span>
<span class="source-line-no">2102</span><span id="line.2102">                return v;</span>
<span class="source-line-no">2103</span><span id="line.2103">            }</span>
<span class="source-line-no">2104</span><span id="line.2104">        }</span>
<span class="source-line-no">2105</span><span id="line.2105">    }</span>
<span class="source-line-no">2106</span><span id="line.2106"></span>
<span class="source-line-no">2107</span><span id="line.2107">    public double[] getMany(int... keys)</span>
<span class="source-line-no">2108</span><span id="line.2108">    {</span>
<span class="source-line-no">2109</span><span id="line.2109">        if(keys == null || keys.length == 0)</span>
<span class="source-line-no">2110</span><span id="line.2110">            return new double[0];</span>
<span class="source-line-no">2111</span><span id="line.2111">        final int len = keys.length;</span>
<span class="source-line-no">2112</span><span id="line.2112">        double[] vals = new double[len];</span>
<span class="source-line-no">2113</span><span id="line.2113">        for (int i = 0; i &lt; len; i++) {</span>
<span class="source-line-no">2114</span><span id="line.2114">            vals[i] = get(keys[i]);</span>
<span class="source-line-no">2115</span><span id="line.2115">        }</span>
<span class="source-line-no">2116</span><span id="line.2116">        return vals;</span>
<span class="source-line-no">2117</span><span id="line.2117">    }</span>
<span class="source-line-no">2118</span><span id="line.2118">    /**</span>
<span class="source-line-no">2119</span><span id="line.2119">     * Changes the int at the given index to replacement while keeping replacement at the same point in the ordering.</span>
<span class="source-line-no">2120</span><span id="line.2120">     * Be aware that if replacement is present in the OrderedMap, this will still replace the given index</span>
<span class="source-line-no">2121</span><span id="line.2121">     * with replacement but will also remove the other occurrence of replacement to avoid duplicate keys. This can throw</span>
<span class="source-line-no">2122</span><span id="line.2122">     * off the expected order because the duplicate could be at any point in the ordering when it is removed. You may</span>
<span class="source-line-no">2123</span><span id="line.2123">     * want to prefer {@link #alterAtCarefully(int, int)} if you don't feel like checking by hand for whether</span>
<span class="source-line-no">2124</span><span id="line.2124">     * replacement is already present, but using this method is perfectly reasonable if you know overlaps won't happen.</span>
<span class="source-line-no">2125</span><span id="line.2125">     * @param index       an index to replace the int key at</span>
<span class="source-line-no">2126</span><span id="line.2126">     * @param replacement another int key that will replace the original at the remembered index</span>
<span class="source-line-no">2127</span><span id="line.2127">     * @return the value associated with the possibly-altered key</span>
<span class="source-line-no">2128</span><span id="line.2128">     */</span>
<span class="source-line-no">2129</span><span id="line.2129">    public double alterAt(int index, int replacement)</span>
<span class="source-line-no">2130</span><span id="line.2130">    {</span>
<span class="source-line-no">2131</span><span id="line.2131">        return alter(keyAt(index), replacement);</span>
<span class="source-line-no">2132</span><span id="line.2132">    }</span>
<span class="source-line-no">2133</span><span id="line.2133">    /**</span>
<span class="source-line-no">2134</span><span id="line.2134">     * Changes the int at the given index to replacement while keeping replacement at the same point in the ordering.</span>
<span class="source-line-no">2135</span><span id="line.2135">     * Unlike the similar method {@link #alterAt(int, int)}, this will not change this OrderedMap if replacement is</span>
<span class="source-line-no">2136</span><span id="line.2136">     * already present. To contrast, alterAt() can reduce the size of the OrderedMap if replacement is already</span>
<span class="source-line-no">2137</span><span id="line.2137">     * in the Map. If replacement is found, this returns the default return value, otherwise it switches out the index</span>
<span class="source-line-no">2138</span><span id="line.2138">     * for replacement and returns whatever value was at the index before.</span>
<span class="source-line-no">2139</span><span id="line.2139">     * @param index       an index to replace the int key at</span>
<span class="source-line-no">2140</span><span id="line.2140">     * @param replacement another int key that will replace the original at the remembered index</span>
<span class="source-line-no">2141</span><span id="line.2141">     * @return the value associated with the key at the altered index before, and replacement now</span>
<span class="source-line-no">2142</span><span id="line.2142">     */</span>
<span class="source-line-no">2143</span><span id="line.2143">    public double alterAtCarefully(int index, int replacement)</span>
<span class="source-line-no">2144</span><span id="line.2144">    {</span>
<span class="source-line-no">2145</span><span id="line.2145">        return alterCarefully(keyAt(index), replacement);</span>
<span class="source-line-no">2146</span><span id="line.2146">    }</span>
<span class="source-line-no">2147</span><span id="line.2147"></span>
<span class="source-line-no">2148</span><span id="line.2148">    /**</span>
<span class="source-line-no">2149</span><span id="line.2149">     * If the specified key is not already associated with a value, associates it with the given value</span>
<span class="source-line-no">2150</span><span id="line.2150">     * and returns that value, else returns the current value without changing anything.</span>
<span class="source-line-no">2151</span><span id="line.2151">     *</span>
<span class="source-line-no">2152</span><span id="line.2152">     * @param key   key with which the specified value is to be associated</span>
<span class="source-line-no">2153</span><span id="line.2153">     * @param value value to be associated with the specified key</span>
<span class="source-line-no">2154</span><span id="line.2154">     * @return the previous value associated with the specified key, or</span>
<span class="source-line-no">2155</span><span id="line.2155">     * {@code value} if there was no mapping for the key.</span>
<span class="source-line-no">2156</span><span id="line.2156">     */</span>
<span class="source-line-no">2157</span><span id="line.2157">    public double putIfAbsent(int key, double value) {</span>
<span class="source-line-no">2158</span><span id="line.2158">        if(containsKey(key))</span>
<span class="source-line-no">2159</span><span id="line.2159">            return get(key);         </span>
<span class="source-line-no">2160</span><span id="line.2160">        put(key, value);</span>
<span class="source-line-no">2161</span><span id="line.2161">        return value;</span>
<span class="source-line-no">2162</span><span id="line.2162">    }</span>
<span class="source-line-no">2163</span><span id="line.2163"></span>
<span class="source-line-no">2164</span><span id="line.2164">    /**</span>
<span class="source-line-no">2165</span><span id="line.2165">     * Removes the entry for the specified key only if it is currently</span>
<span class="source-line-no">2166</span><span id="line.2166">     * mapped to the specified value.</span>
<span class="source-line-no">2167</span><span id="line.2167">     *</span>
<span class="source-line-no">2168</span><span id="line.2168">     * @param key   key with which the specified value is associated</span>
<span class="source-line-no">2169</span><span id="line.2169">     * @param value value expected to be associated with the specified key</span>
<span class="source-line-no">2170</span><span id="line.2170">     * @return {@code true} if the value was removed</span>
<span class="source-line-no">2171</span><span id="line.2171">     */</span>
<span class="source-line-no">2172</span><span id="line.2172">    public boolean remove(int key, double value) {</span>
<span class="source-line-no">2173</span><span id="line.2173">        if (containsKey(key) &amp;&amp; get(key) == value) {</span>
<span class="source-line-no">2174</span><span id="line.2174">            remove(key);</span>
<span class="source-line-no">2175</span><span id="line.2175">            return true;</span>
<span class="source-line-no">2176</span><span id="line.2176">        } else</span>
<span class="source-line-no">2177</span><span id="line.2177">            return false;</span>
<span class="source-line-no">2178</span><span id="line.2178">    }</span>
<span class="source-line-no">2179</span><span id="line.2179"></span>
<span class="source-line-no">2180</span><span id="line.2180">    /**</span>
<span class="source-line-no">2181</span><span id="line.2181">     * Replaces the entry for the specified key only if currently</span>
<span class="source-line-no">2182</span><span id="line.2182">     * mapped to the specified value. The position in the iteration</span>
<span class="source-line-no">2183</span><span id="line.2183">     * order is retained.</span>
<span class="source-line-no">2184</span><span id="line.2184">     *</span>
<span class="source-line-no">2185</span><span id="line.2185">     * @param key      key with which the specified value is associated</span>
<span class="source-line-no">2186</span><span id="line.2186">     * @param oldValue value expected to be associated with the specified key</span>
<span class="source-line-no">2187</span><span id="line.2187">     * @param newValue value to be associated with the specified key</span>
<span class="source-line-no">2188</span><span id="line.2188">     * @return {@code true} if the value was replaced</span>
<span class="source-line-no">2189</span><span id="line.2189">     */</span>
<span class="source-line-no">2190</span><span id="line.2190">    public boolean replace(int key, double oldValue, double newValue) {</span>
<span class="source-line-no">2191</span><span id="line.2191">        if (containsKey(key) &amp;&amp; get(key) == oldValue) {</span>
<span class="source-line-no">2192</span><span id="line.2192">            put(key, newValue);</span>
<span class="source-line-no">2193</span><span id="line.2193">            return true;</span>
<span class="source-line-no">2194</span><span id="line.2194">        } else</span>
<span class="source-line-no">2195</span><span id="line.2195">            return false;</span>
<span class="source-line-no">2196</span><span id="line.2196">    }</span>
<span class="source-line-no">2197</span><span id="line.2197"></span>
<span class="source-line-no">2198</span><span id="line.2198">    /**</span>
<span class="source-line-no">2199</span><span id="line.2199">     * Replaces the entry for the specified key only if it is</span>
<span class="source-line-no">2200</span><span id="line.2200">     * currently mapped to some value. Preserves the existing key's</span>
<span class="source-line-no">2201</span><span id="line.2201">     * position in the iteration order.</span>
<span class="source-line-no">2202</span><span id="line.2202">     *</span>
<span class="source-line-no">2203</span><span id="line.2203">     * @param key   key with which the specified value is associated</span>
<span class="source-line-no">2204</span><span id="line.2204">     * @param value value to be associated with the specified key</span>
<span class="source-line-no">2205</span><span id="line.2205">     * @return the previous value associated with the specified key, or</span>
<span class="source-line-no">2206</span><span id="line.2206">     * {@code null} if there was no mapping for the key.</span>
<span class="source-line-no">2207</span><span id="line.2207">     * (A {@code null} return can also indicate that the map</span>
<span class="source-line-no">2208</span><span id="line.2208">     * previously associated {@code null} with the key.)</span>
<span class="source-line-no">2209</span><span id="line.2209">     */</span>
<span class="source-line-no">2210</span><span id="line.2210">    public double replace(int key, double value) {</span>
<span class="source-line-no">2211</span><span id="line.2211">        if (containsKey(key)) {</span>
<span class="source-line-no">2212</span><span id="line.2212">            return put(key, value);</span>
<span class="source-line-no">2213</span><span id="line.2213">        } else</span>
<span class="source-line-no">2214</span><span id="line.2214">            return defRetValue;</span>
<span class="source-line-no">2215</span><span id="line.2215">    }</span>
<span class="source-line-no">2216</span><span id="line.2216">    </span>
<span class="source-line-no">2217</span><span id="line.2217">    /**</span>
<span class="source-line-no">2218</span><span id="line.2218">     * Reverses the iteration order in linear time.</span>
<span class="source-line-no">2219</span><span id="line.2219">     */</span>
<span class="source-line-no">2220</span><span id="line.2220">    public void reverse()</span>
<span class="source-line-no">2221</span><span id="line.2221">    {</span>
<span class="source-line-no">2222</span><span id="line.2222">        order.reverse();</span>
<span class="source-line-no">2223</span><span id="line.2223">    }</span>
<span class="source-line-no">2224</span><span id="line.2224">}</span>




























































</pre>
</div>
</main>
</body>
</html>
