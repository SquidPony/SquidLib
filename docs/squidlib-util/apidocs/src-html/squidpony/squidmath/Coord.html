<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>Source code</title>
<meta name="description" content="source: package: squidpony.squidmath, class: Coord">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body class="source-page">
<main role="main">
<div class="source-container">
<pre><span class="source-line-no">001</span><span id="line.1">package squidpony.squidmath;</span>
<span class="source-line-no">002</span><span id="line.2"></span>
<span class="source-line-no">003</span><span id="line.3">import squidpony.squidgrid.Direction;</span>
<span class="source-line-no">004</span><span id="line.4"></span>
<span class="source-line-no">005</span><span id="line.5">import java.io.Serializable;</span>
<span class="source-line-no">006</span><span id="line.6"></span>
<span class="source-line-no">007</span><span id="line.7">/**</span>
<span class="source-line-no">008</span><span id="line.8"> * A 2D coordinate with (constant) x and y fields. Coord objects are immutable; a single pool of Coord values, with</span>
<span class="source-line-no">009</span><span id="line.9"> * x and y each ranging from -3 to 255, is shared by all users of Coord. This pool helps reduce pressure on the</span>
<span class="source-line-no">010</span><span id="line.10"> * garbage collector when many Coord values would have been created for some purpose and quickly discarded; instead</span>
<span class="source-line-no">011</span><span id="line.11"> * of creating a new Coord with a constructor, you use the static method {@link #get(int, int)}, which retrieves an</span>
<span class="source-line-no">012</span><span id="line.12"> * already-existing Coord from the pool if possible, and always returns a usable Coord.</span>
<span class="source-line-no">013</span><span id="line.13"> * &lt;br&gt;</span>
<span class="source-line-no">014</span><span id="line.14"> * The Coord class is a fundamental part of SquidLib; any class that uses positions on a grid makes use of it here.</span>
<span class="source-line-no">015</span><span id="line.15"> * It finds usage naturally in classes throughout {@link squidpony.squidgrid}, with {@link squidpony.squidgrid.zone}</span>
<span class="source-line-no">016</span><span id="line.16"> * providing an abstraction around groups of Coord and {@link squidpony.squidgrid.iterator} providing various ways to</span>
<span class="source-line-no">017</span><span id="line.17"> * iterate through the Coords that make up a larger shape. In this package, {@link squidpony.squidmath}, a few classes</span>
<span class="source-line-no">018</span><span id="line.18"> * should be pointed out. {@link CoordPacker} is a class with all static methods that provides various ways to compress</span>
<span class="source-line-no">019</span><span id="line.19"> * the memory usage of regions made of many Coord values (and can be constructed in other ways but still provide Coords</span>
<span class="source-line-no">020</span><span id="line.20"> * later), but since Coords don't use much memory anyway, the real use of the class is for manipulating the shapes and</span>
<span class="source-line-no">021</span><span id="line.21"> * sizes of the regions those Coords are part of. {@link GreasedRegion} has similar functionality to CoordPacker, but</span>
<span class="source-line-no">022</span><span id="line.22"> * where CoordPacker is purely static, taking and returning regions as encoded, usually-low-memory-cost arrays of</span>
<span class="source-line-no">023</span><span id="line.23"> * {@code short} that it considers immutable, a GreasedRegion is a mutable object that allows the same region-altering</span>
<span class="source-line-no">024</span><span id="line.24"> * techniques to be applied in-place in a way that is relatively (very) low-time-cost. If deciding between the two,</span>
<span class="source-line-no">025</span><span id="line.25"> * GreasedRegion should usually be preferred, and CoordPacker cannot actually be used when storing regions in larger</span>
<span class="source-line-no">026</span><span id="line.26"> * than a 256x256 space (usually when the Coord pool has been expanded; see below); GreasedRegion can store potentially</span>
<span class="source-line-no">027</span><span id="line.27"> * large positions.</span>
<span class="source-line-no">028</span><span id="line.28"> * &lt;br&gt;</span>
<span class="source-line-no">029</span><span id="line.29"> * More on the Coord pool used by this class:  Coords can't always be retrieved from the pool; Coord.get constructs a</span>
<span class="source-line-no">030</span><span id="line.30"> * new Coord if one of x or y is unusually large (greater than 255) or too negative (below -3). The upper limit of 255</span>
<span class="source-line-no">031</span><span id="line.31"> * is not a hard rule; you can increase the limit on the pool by calling {@link #expandPoolTo(int, int)} or</span>
<span class="source-line-no">032</span><span id="line.32"> * {@link #expandPool(int, int)}, which cause more memory to be spent initially on storing Coords but can save memory</span>
<span class="source-line-no">033</span><span id="line.33"> * or ease GC pressure over the long term by preventing duplicate Coords from being created many times. The pool can</span>
<span class="source-line-no">034</span><span id="line.34"> * never shrink because allowing that would cause completely unpredictable results if existing Coords were in use, or</span>
<span class="source-line-no">035</span><span id="line.35"> * could easily cause crashes on Android after resuming an application that had previously shrunken the pool due to</span>
<span class="source-line-no">036</span><span id="line.36"> * platform quirks. Long story short, you should only expand the pool size when your game needs a larger set of 2D</span>
<span class="source-line-no">037</span><span id="line.37"> * points it will commonly use, and in most cases you shouldn't need to change it at all.</span>
<span class="source-line-no">038</span><span id="line.38"> * </span>
<span class="source-line-no">039</span><span id="line.39"> * Created by Tommy Ettinger on 8/12/2015.</span>
<span class="source-line-no">040</span><span id="line.40"> */</span>
<span class="source-line-no">041</span><span id="line.41">public class Coord implements Serializable {</span>
<span class="source-line-no">042</span><span id="line.42">    private static final long serialVersionUID = 300L;</span>
<span class="source-line-no">043</span><span id="line.43"></span>
<span class="source-line-no">044</span><span id="line.44">        /** The x-coordinate. */</span>
<span class="source-line-no">045</span><span id="line.45">        public final int x;</span>
<span class="source-line-no">046</span><span id="line.46"></span>
<span class="source-line-no">047</span><span id="line.47">        /** The y-coordinate (the ordinate) */</span>
<span class="source-line-no">048</span><span id="line.48">        public final int y;</span>
<span class="source-line-no">049</span><span id="line.49"></span>
<span class="source-line-no">050</span><span id="line.50">    protected Coord()</span>
<span class="source-line-no">051</span><span id="line.51">    {</span>
<span class="source-line-no">052</span><span id="line.52">        this(0, 0);</span>
<span class="source-line-no">053</span><span id="line.53">    }</span>
<span class="source-line-no">054</span><span id="line.54">    protected Coord(final int x, final int y)</span>
<span class="source-line-no">055</span><span id="line.55">    {</span>
<span class="source-line-no">056</span><span id="line.56">        this.x = x;</span>
<span class="source-line-no">057</span><span id="line.57">        this.y = y;</span>
<span class="source-line-no">058</span><span id="line.58">    }</span>
<span class="source-line-no">059</span><span id="line.59">    public static Coord get(final int x, final int y)</span>
<span class="source-line-no">060</span><span id="line.60">    {</span>
<span class="source-line-no">061</span><span id="line.61">        if(x &gt;= -3 &amp;&amp; y &gt;= -3 &amp;&amp; x &lt; POOL.length - 3 &amp;&amp; y &lt; POOL[x + 3].length - 3)</span>
<span class="source-line-no">062</span><span id="line.62">            return POOL[x + 3][y + 3];</span>
<span class="source-line-no">063</span><span id="line.63">        else return new Coord(x, y);</span>
<span class="source-line-no">064</span><span id="line.64">    }</span>
<span class="source-line-no">065</span><span id="line.65"></span>
<span class="source-line-no">066</span><span id="line.66">        /**</span>
<span class="source-line-no">067</span><span id="line.67">     * Gets the angle in degrees to go between two Coords.</span>
<span class="source-line-no">068</span><span id="line.68">     * When only x is different and {@code to.x} is greater than {@code from.x}, this returns 0.</span>
<span class="source-line-no">069</span><span id="line.69">     * When only y is different and {@code to.y} is greater than {@code from.y}, this returns 90.</span>
<span class="source-line-no">070</span><span id="line.70">     * When only x is different and {@code to.x} is less than {@code from.x}, this returns 180.</span>
<span class="source-line-no">071</span><span id="line.71">     * When only y is different and {@code to.y} is less than {@code from.y}, this returns 270.</span>
<span class="source-line-no">072</span><span id="line.72">     * In cases between these, the angle is between those values; it cannot be 360 but it can be very close. This never</span>
<span class="source-line-no">073</span><span id="line.73">     * returns a negative angle. Keep in mind, "up" depends on how your code orients the y-axis, and SquidLib generally</span>
<span class="source-line-no">074</span><span id="line.74">     * defaults to positive y going toward the bottom of the screen, like how later lines in a paragraph are further</span>
<span class="source-line-no">075</span><span id="line.75">     * down on the page.</span>
<span class="source-line-no">076</span><span id="line.76">     * &lt;br&gt;</span>
<span class="source-line-no">077</span><span id="line.77">     * As a compatibility note, before SquidLib 3.0.0 stable, this used an odd rotation of the normal degrees where 0</span>
<span class="source-line-no">078</span><span id="line.78">     * degrees were used when {@code to.y} was greater than {@code from.y} and x was equal. Because that typically runs</span>
<span class="source-line-no">079</span><span id="line.79">     * counter to expectations from actual math, the behavior was changed. </span>
<span class="source-line-no">080</span><span id="line.80">         * @param from the starting Coord to measure from</span>
<span class="source-line-no">081</span><span id="line.81">         * @param to the ending Coord to measure to</span>
<span class="source-line-no">082</span><span id="line.82">         * @return The degree from {@code from} to {@code to}; 0 is up</span>
<span class="source-line-no">083</span><span id="line.83">         */</span>
<span class="source-line-no">084</span><span id="line.84">        public static double degrees(final Coord from, final Coord to) {</span>
<span class="source-line-no">085</span><span id="line.85">                return NumberTools.atan2Degrees360(to.y - from.y, to.x - from.x);</span>
<span class="source-line-no">086</span><span id="line.86">        }</span>
<span class="source-line-no">087</span><span id="line.87"></span>
<span class="source-line-no">088</span><span id="line.88">    /**</span>
<span class="source-line-no">089</span><span id="line.89">     * Provided for compatibility with earlier code that used the AWT Point API.</span>
<span class="source-line-no">090</span><span id="line.90">     * @return this Coord, without changes</span>
<span class="source-line-no">091</span><span id="line.91">     */</span>
<span class="source-line-no">092</span><span id="line.92">    public Coord getLocation()</span>
<span class="source-line-no">093</span><span id="line.93">    {</span>
<span class="source-line-no">094</span><span id="line.94">        return this;</span>
<span class="source-line-no">095</span><span id="line.95">    }</span>
<span class="source-line-no">096</span><span id="line.96"></span>
<span class="source-line-no">097</span><span id="line.97">    /**</span>
<span class="source-line-no">098</span><span id="line.98">     * Takes this Coord, adds x to its x and y to its y, and returns the Coord at that position.</span>
<span class="source-line-no">099</span><span id="line.99">     * @param x the amount of x distance to move</span>
<span class="source-line-no">100</span><span id="line.100">     * @param y the amount of y distance to move</span>
<span class="source-line-no">101</span><span id="line.101">     * @return a Coord (usually cached and not a new instance) that has been moved the specified distance</span>
<span class="source-line-no">102</span><span id="line.102">     */</span>
<span class="source-line-no">103</span><span id="line.103">    public Coord translate(final int x, final int y)</span>
<span class="source-line-no">104</span><span id="line.104">    {</span>
<span class="source-line-no">105</span><span id="line.105">        return get(this.x + x, this.y + y);</span>
<span class="source-line-no">106</span><span id="line.106">    }</span>
<span class="source-line-no">107</span><span id="line.107">    /**</span>
<span class="source-line-no">108</span><span id="line.108">     * Takes this Coord, adds x to its x and y to its y, limiting x from 0 to width and limiting y from 0 to height,</span>
<span class="source-line-no">109</span><span id="line.109">     * and returns the Coord at that position.</span>
<span class="source-line-no">110</span><span id="line.110">     * @param x the amount of x distance to move</span>
<span class="source-line-no">111</span><span id="line.111">     * @param y the amount of y distance to move</span>
<span class="source-line-no">112</span><span id="line.112">     * @param width one higher than the maximum x value this can use; typically the length of an array</span>
<span class="source-line-no">113</span><span id="line.113">     * @param height one higher than the maximum y value this can use; typically the length of an array</span>
<span class="source-line-no">114</span><span id="line.114">     * @return a Coord (usually cached and not a new instance) that has been moved the specified distance</span>
<span class="source-line-no">115</span><span id="line.115">     */</span>
<span class="source-line-no">116</span><span id="line.116">    public Coord translateCapped(final int x, final int y, final int width, final int height)</span>
<span class="source-line-no">117</span><span id="line.117">    {</span>
<span class="source-line-no">118</span><span id="line.118">        return get(Math.min(Math.max(0, this.x + x), width - 1), Math.min(Math.max(0, this.y + y), height - 1));</span>
<span class="source-line-no">119</span><span id="line.119">    }</span>
<span class="source-line-no">120</span><span id="line.120"></span>
<span class="source-line-no">121</span><span id="line.121">    /**</span>
<span class="source-line-no">122</span><span id="line.122">     * Separately combines the x and y positions of this Coord and other, producing a different Coord as their "sum."</span>
<span class="source-line-no">123</span><span id="line.123">     * @param other another Coord</span>
<span class="source-line-no">124</span><span id="line.124">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x + other.x; y = this.y + other.y}</span>
<span class="source-line-no">125</span><span id="line.125">     */</span>
<span class="source-line-no">126</span><span id="line.126">    public Coord add(final Coord other)</span>
<span class="source-line-no">127</span><span id="line.127">    {</span>
<span class="source-line-no">128</span><span id="line.128">        return get(x + other.x, y + other.y);</span>
<span class="source-line-no">129</span><span id="line.129">    }</span>
<span class="source-line-no">130</span><span id="line.130"></span>
<span class="source-line-no">131</span><span id="line.131">    /**</span>
<span class="source-line-no">132</span><span id="line.132">     * Separately adds the x and y positions of this Coord to operand, producing a different Coord as their</span>
<span class="source-line-no">133</span><span id="line.133">     * "sum."</span>
<span class="source-line-no">134</span><span id="line.134">     * @param operand a value to add each of x and y to</span>
<span class="source-line-no">135</span><span id="line.135">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x + operand; y = this.y + operand}</span>
<span class="source-line-no">136</span><span id="line.136">     */</span>
<span class="source-line-no">137</span><span id="line.137">    public Coord add(final int operand)</span>
<span class="source-line-no">138</span><span id="line.138">    {</span>
<span class="source-line-no">139</span><span id="line.139">        return get(x + operand, y + operand);</span>
<span class="source-line-no">140</span><span id="line.140">    }</span>
<span class="source-line-no">141</span><span id="line.141"></span>
<span class="source-line-no">142</span><span id="line.142">    /**</span>
<span class="source-line-no">143</span><span id="line.143">     * Separately adds the x and y positions of this Coord to operand, rounding to the nearest int for each of x</span>
<span class="source-line-no">144</span><span id="line.144">     * and y and producing a different Coord as their "sum."</span>
<span class="source-line-no">145</span><span id="line.145">     * @param operand a value to add each of x and y to</span>
<span class="source-line-no">146</span><span id="line.146">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x + operand; y = this.y +</span>
<span class="source-line-no">147</span><span id="line.147">     *          operand}, with both x and y rounded accordingly</span>
<span class="source-line-no">148</span><span id="line.148">     */</span>
<span class="source-line-no">149</span><span id="line.149">    public Coord add(final double operand)</span>
<span class="source-line-no">150</span><span id="line.150">    {</span>
<span class="source-line-no">151</span><span id="line.151">        return get((int)Math.round(x + operand), (int)Math.round(y + operand));</span>
<span class="source-line-no">152</span><span id="line.152">    }</span>
<span class="source-line-no">153</span><span id="line.153"></span>
<span class="source-line-no">154</span><span id="line.154">    /**</span>
<span class="source-line-no">155</span><span id="line.155">     * Separately subtracts the x and y positions of other from this Coord, producing a different Coord as their</span>
<span class="source-line-no">156</span><span id="line.156">     * "difference."</span>
<span class="source-line-no">157</span><span id="line.157">     * @param other another Coord</span>
<span class="source-line-no">158</span><span id="line.158">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x - other.x; y = this.y - other.y}</span>
<span class="source-line-no">159</span><span id="line.159">     */</span>
<span class="source-line-no">160</span><span id="line.160">    public Coord subtract(final Coord other)</span>
<span class="source-line-no">161</span><span id="line.161">    {</span>
<span class="source-line-no">162</span><span id="line.162">        return get(x - other.x, y - other.y);</span>
<span class="source-line-no">163</span><span id="line.163">    }</span>
<span class="source-line-no">164</span><span id="line.164"></span>
<span class="source-line-no">165</span><span id="line.165">    /**</span>
<span class="source-line-no">166</span><span id="line.166">     * Separately subtracts operand from the x and y positions of this Coord, producing a different Coord as their</span>
<span class="source-line-no">167</span><span id="line.167">     * "difference."</span>
<span class="source-line-no">168</span><span id="line.168">     * @param operand a value to subtract from each of x and y</span>
<span class="source-line-no">169</span><span id="line.169">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x - operand; y = this.y - operand}</span>
<span class="source-line-no">170</span><span id="line.170">     */</span>
<span class="source-line-no">171</span><span id="line.171">    public Coord subtract(final int operand)</span>
<span class="source-line-no">172</span><span id="line.172">    {</span>
<span class="source-line-no">173</span><span id="line.173">        return get(x - operand, y - operand);</span>
<span class="source-line-no">174</span><span id="line.174">    }</span>
<span class="source-line-no">175</span><span id="line.175"></span>
<span class="source-line-no">176</span><span id="line.176">    /**</span>
<span class="source-line-no">177</span><span id="line.177">     * Separately subtracts operand from the x and y positions of this Coord, rounding to the nearest int for each of x</span>
<span class="source-line-no">178</span><span id="line.178">     * and y and producing a different Coord as their "difference."</span>
<span class="source-line-no">179</span><span id="line.179">     * @param operand a value to subtract from each of x and y</span>
<span class="source-line-no">180</span><span id="line.180">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x - operand; y = this.y -</span>
<span class="source-line-no">181</span><span id="line.181">     *          operand}, with both x and y rounded accordingly</span>
<span class="source-line-no">182</span><span id="line.182">     */</span>
<span class="source-line-no">183</span><span id="line.183">    public Coord subtract(final double operand)</span>
<span class="source-line-no">184</span><span id="line.184">    {</span>
<span class="source-line-no">185</span><span id="line.185">        return get((int)Math.round(x - operand), (int)Math.round(y - operand));</span>
<span class="source-line-no">186</span><span id="line.186">    }</span>
<span class="source-line-no">187</span><span id="line.187">    /**</span>
<span class="source-line-no">188</span><span id="line.188">     * Separately multiplies the x and y positions of other from this Coord, producing a different Coord as their</span>
<span class="source-line-no">189</span><span id="line.189">     * "product."</span>
<span class="source-line-no">190</span><span id="line.190">     * @param other another Coord</span>
<span class="source-line-no">191</span><span id="line.191">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x * other.x; y = this.y * other.y}</span>
<span class="source-line-no">192</span><span id="line.192">     */</span>
<span class="source-line-no">193</span><span id="line.193">    public Coord multiply(final Coord other)</span>
<span class="source-line-no">194</span><span id="line.194">    {</span>
<span class="source-line-no">195</span><span id="line.195">        return get(x * other.x, y * other.y);</span>
<span class="source-line-no">196</span><span id="line.196">    }</span>
<span class="source-line-no">197</span><span id="line.197">    /**</span>
<span class="source-line-no">198</span><span id="line.198">     * Separately multiplies the x and y positions of this Coord by operand, producing a different Coord as their</span>
<span class="source-line-no">199</span><span id="line.199">     * "product."</span>
<span class="source-line-no">200</span><span id="line.200">     * @param operand a value to multiply each of x and y by</span>
<span class="source-line-no">201</span><span id="line.201">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x * operand; y = this.y * operand}</span>
<span class="source-line-no">202</span><span id="line.202">     */</span>
<span class="source-line-no">203</span><span id="line.203">    public Coord multiply(final int operand)</span>
<span class="source-line-no">204</span><span id="line.204">    {</span>
<span class="source-line-no">205</span><span id="line.205">        return get(x * operand, y * operand);</span>
<span class="source-line-no">206</span><span id="line.206">    }</span>
<span class="source-line-no">207</span><span id="line.207"></span>
<span class="source-line-no">208</span><span id="line.208">    /**</span>
<span class="source-line-no">209</span><span id="line.209">     * Separately multiplies the x and y positions of this Coord by operand, rounding to the nearest int for each of x</span>
<span class="source-line-no">210</span><span id="line.210">     * and y and producing a different Coord as their "product."</span>
<span class="source-line-no">211</span><span id="line.211">     * @param operand a value to multiply each of x and y by</span>
<span class="source-line-no">212</span><span id="line.212">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x * operand; y = this.y *</span>
<span class="source-line-no">213</span><span id="line.213">     *          operand}, with both x and y rounded accordingly</span>
<span class="source-line-no">214</span><span id="line.214">     */</span>
<span class="source-line-no">215</span><span id="line.215">    public Coord multiply(final double operand)</span>
<span class="source-line-no">216</span><span id="line.216">    {</span>
<span class="source-line-no">217</span><span id="line.217">        return get((int)Math.round(x * operand), (int)Math.round(y * operand));</span>
<span class="source-line-no">218</span><span id="line.218">    }</span>
<span class="source-line-no">219</span><span id="line.219"></span>
<span class="source-line-no">220</span><span id="line.220">    /**</span>
<span class="source-line-no">221</span><span id="line.221">     * Separately divides the x and y positions of this Coord by other, producing a different Coord as their</span>
<span class="source-line-no">222</span><span id="line.222">     * "quotient." If other has 0 for x or y, this will throw an exception, as dividing by 0 is expected to do.</span>
<span class="source-line-no">223</span><span id="line.223">     * @param other another Coord</span>
<span class="source-line-no">224</span><span id="line.224">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x / other.x; y = this.y / other.y}</span>
<span class="source-line-no">225</span><span id="line.225">     */</span>
<span class="source-line-no">226</span><span id="line.226">    public Coord divide(final Coord other)</span>
<span class="source-line-no">227</span><span id="line.227">    {</span>
<span class="source-line-no">228</span><span id="line.228">        return get(x / other.x, y / other.y);</span>
<span class="source-line-no">229</span><span id="line.229">    }</span>
<span class="source-line-no">230</span><span id="line.230">    /**</span>
<span class="source-line-no">231</span><span id="line.231">     * Separately divides the x and y positions of this Coord by operand, producing a different Coord as their</span>
<span class="source-line-no">232</span><span id="line.232">     * "quotient." If operand is 0, this will throw an exception, as dividing by 0 is expected to do.</span>
<span class="source-line-no">233</span><span id="line.233">     * @param operand a value to divide each of x and y by</span>
<span class="source-line-no">234</span><span id="line.234">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x / operand; y = this.y / operand}</span>
<span class="source-line-no">235</span><span id="line.235">     */</span>
<span class="source-line-no">236</span><span id="line.236">    public Coord divide(final int operand)</span>
<span class="source-line-no">237</span><span id="line.237">    {</span>
<span class="source-line-no">238</span><span id="line.238">        return get(x / operand, y / operand);</span>
<span class="source-line-no">239</span><span id="line.239">    }</span>
<span class="source-line-no">240</span><span id="line.240"></span>
<span class="source-line-no">241</span><span id="line.241">    /**</span>
<span class="source-line-no">242</span><span id="line.242">     * Separately divides the x and y positions of this Coord by operand, flooring to a lower int for each of x and</span>
<span class="source-line-no">243</span><span id="line.243">     * y and producing a different Coord as their "quotient." If operand is 0.0, expect strange results (infinity and</span>
<span class="source-line-no">244</span><span id="line.244">     * NaN are both possibilities).</span>
<span class="source-line-no">245</span><span id="line.245">     * @param operand a value to divide each of x and y by</span>
<span class="source-line-no">246</span><span id="line.246">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x / operand; y = this.y /</span>
<span class="source-line-no">247</span><span id="line.247">     *          operand}, with both x and y rounded accordingly</span>
<span class="source-line-no">248</span><span id="line.248">     */</span>
<span class="source-line-no">249</span><span id="line.249">    public Coord divide(final double operand)</span>
<span class="source-line-no">250</span><span id="line.250">    {</span>
<span class="source-line-no">251</span><span id="line.251">        return get((int)(x / operand), (int)(y / operand));</span>
<span class="source-line-no">252</span><span id="line.252">    }</span>
<span class="source-line-no">253</span><span id="line.253"></span>
<span class="source-line-no">254</span><span id="line.254">    /**</span>
<span class="source-line-no">255</span><span id="line.255">     * Separately divides the x and y positions of this Coord by operand, rounding to the nearest int for each of x and</span>
<span class="source-line-no">256</span><span id="line.256">     * y and producing a different Coord as their "quotient." If operand is 0.0, expect strange results (infinity and</span>
<span class="source-line-no">257</span><span id="line.257">     * NaN are both possibilities).</span>
<span class="source-line-no">258</span><span id="line.258">     * @param operand a value to divide each of x and y by</span>
<span class="source-line-no">259</span><span id="line.259">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x / operand; y = this.y /</span>
<span class="source-line-no">260</span><span id="line.260">     *          operand}, with both x and y rounded accordingly</span>
<span class="source-line-no">261</span><span id="line.261">     */</span>
<span class="source-line-no">262</span><span id="line.262">    public Coord divideRounding(final double operand)</span>
<span class="source-line-no">263</span><span id="line.263">    {</span>
<span class="source-line-no">264</span><span id="line.264">        return get((int)Math.round(x / operand), (int)Math.round(y / operand));</span>
<span class="source-line-no">265</span><span id="line.265">    }</span>
<span class="source-line-no">266</span><span id="line.266"></span>
<span class="source-line-no">267</span><span id="line.267">    /**</span>
<span class="source-line-no">268</span><span id="line.268">     * Separately averages the x and y positions of this Coord with other, producing a different Coord as their</span>
<span class="source-line-no">269</span><span id="line.269">     * "midpoint."</span>
<span class="source-line-no">270</span><span id="line.270">     * @param other another Coord</span>
<span class="source-line-no">271</span><span id="line.271">     * @return a Coord (usually cached and not a new instance) halfway between this and other, rounded nearest.</span>
<span class="source-line-no">272</span><span id="line.272">     */</span>
<span class="source-line-no">273</span><span id="line.273">    public Coord average(final Coord other)</span>
<span class="source-line-no">274</span><span id="line.274">    {</span>
<span class="source-line-no">275</span><span id="line.275">        return get(Math.round((x + other.x) * 0.5f), Math.round((y + other.y) * 0.5f));</span>
<span class="source-line-no">276</span><span id="line.276">    }</span>
<span class="source-line-no">277</span><span id="line.277">        /**</span>
<span class="source-line-no">278</span><span id="line.278">         * @param d</span>
<span class="source-line-no">279</span><span id="line.279">         *            A non-{@code null} direction.</span>
<span class="source-line-no">280</span><span id="line.280">         * @return The coordinate obtained by applying {@code d} on {@code this}.</span>
<span class="source-line-no">281</span><span id="line.281">         */</span>
<span class="source-line-no">282</span><span id="line.282">        public Coord translate(final Direction d) {</span>
<span class="source-line-no">283</span><span id="line.283">                return Coord.get(x + d.deltaX, y + d.deltaY);</span>
<span class="source-line-no">284</span><span id="line.284">        }</span>
<span class="source-line-no">285</span><span id="line.285"></span>
<span class="source-line-no">286</span><span id="line.286">        /**</span>
<span class="source-line-no">287</span><span id="line.287">         * @param i</span>
<span class="source-line-no">288</span><span id="line.288">         * @return {@code (x*i,y*i)}.</span>
<span class="source-line-no">289</span><span id="line.289">         */</span>
<span class="source-line-no">290</span><span id="line.290">        public Coord scale(final int i) {</span>
<span class="source-line-no">291</span><span id="line.291">                return Coord.get(x * i, y * i);</span>
<span class="source-line-no">292</span><span id="line.292">        }</span>
<span class="source-line-no">293</span><span id="line.293"></span>
<span class="source-line-no">294</span><span id="line.294">        /**</span>
<span class="source-line-no">295</span><span id="line.295">         * @param i</span>
<span class="source-line-no">296</span><span id="line.296">         * @return {@code (x*i,y*j)}.</span>
<span class="source-line-no">297</span><span id="line.297">         */</span>
<span class="source-line-no">298</span><span id="line.298">        public Coord scale(final int i, final int j) {</span>
<span class="source-line-no">299</span><span id="line.299">                return Coord.get(x * i, y * j);</span>
<span class="source-line-no">300</span><span id="line.300">        }</span>
<span class="source-line-no">301</span><span id="line.301"></span>
<span class="source-line-no">302</span><span id="line.302">    public double distance(final double x2, final double y2)</span>
<span class="source-line-no">303</span><span id="line.303">    {</span>
<span class="source-line-no">304</span><span id="line.304">        return Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y));</span>
<span class="source-line-no">305</span><span id="line.305">    }</span>
<span class="source-line-no">306</span><span id="line.306">    public double distance(final Coord co)</span>
<span class="source-line-no">307</span><span id="line.307">    {</span>
<span class="source-line-no">308</span><span id="line.308">        return Math.sqrt((co.x - x) * (co.x - x) + (co.y - y) * (co.y - y));</span>
<span class="source-line-no">309</span><span id="line.309">    }</span>
<span class="source-line-no">310</span><span id="line.310">    public double distanceSq(final double x2, final double y2)</span>
<span class="source-line-no">311</span><span id="line.311">    {</span>
<span class="source-line-no">312</span><span id="line.312">        return (x2 - x) * (x2 - x) + (y2 - y) * (y2 - y);</span>
<span class="source-line-no">313</span><span id="line.313">    }</span>
<span class="source-line-no">314</span><span id="line.314">    public double distanceSq(final Coord co) { return (co.x - x) * (co.x - x) + (co.y - y) * (co.y - y); }</span>
<span class="source-line-no">315</span><span id="line.315"></span>
<span class="source-line-no">316</span><span id="line.316">    /**</span>
<span class="source-line-no">317</span><span id="line.317">     * Gets a Coord based off this instance but with odd values for x and/or y decreased to the nearest even number.</span>
<span class="source-line-no">318</span><span id="line.318">     * May be useful for thin-wall maps as produced by {@link squidpony.squidgrid.mapping.ThinDungeonGenerator} and used</span>
<span class="source-line-no">319</span><span id="line.319">     * with {@link squidpony.squidgrid.Adjacency.ThinWallAdjacency}.</span>
<span class="source-line-no">320</span><span id="line.320">     * @return a Coord (probably from the pool) with even x and even y, changing (decrementing) only if they are odd</span>
<span class="source-line-no">321</span><span id="line.321">     */</span>
<span class="source-line-no">322</span><span id="line.322">    public Coord makeEven()</span>
<span class="source-line-no">323</span><span id="line.323">    {</span>
<span class="source-line-no">324</span><span id="line.324">        return get(x &amp; -2, y &amp; -2);</span>
<span class="source-line-no">325</span><span id="line.325">    }</span>
<span class="source-line-no">326</span><span id="line.326"></span>
<span class="source-line-no">327</span><span id="line.327">    /**</span>
<span class="source-line-no">328</span><span id="line.328">     * Gets a Coord based off this instance but with even values for x and/or y increased to the nearest odd number.</span>
<span class="source-line-no">329</span><span id="line.329">     * May be useful for thin-wall maps as produced by {@link squidpony.squidgrid.mapping.ThinDungeonGenerator} and used</span>
<span class="source-line-no">330</span><span id="line.330">     * with {@link squidpony.squidgrid.Adjacency.ThinWallAdjacency}.</span>
<span class="source-line-no">331</span><span id="line.331">     * @return a Coord (probably from the pool) with odd x and odd y, changing (incrementing) only if they are even</span>
<span class="source-line-no">332</span><span id="line.332">     */</span>
<span class="source-line-no">333</span><span id="line.333">    public Coord makeOdd() {</span>
<span class="source-line-no">334</span><span id="line.334">        return get(x | 1, y | 1);</span>
<span class="source-line-no">335</span><span id="line.335">    }</span>
<span class="source-line-no">336</span><span id="line.336"></span>
<span class="source-line-no">337</span><span id="line.337">        /**</span>
<span class="source-line-no">338</span><span id="line.338">         * @param c</span>
<span class="source-line-no">339</span><span id="line.339">         * @return Whether {@code this} is adjacent to {@code c}. Not that a cell is</span>
<span class="source-line-no">340</span><span id="line.340">         *         not adjacent to itself with this method.</span>
<span class="source-line-no">341</span><span id="line.341">         */</span>
<span class="source-line-no">342</span><span id="line.342">        public boolean isAdjacent(final Coord c) {</span>
<span class="source-line-no">343</span><span id="line.343">                switch (Math.abs(x - c.x)) {</span>
<span class="source-line-no">344</span><span id="line.344">                case 0:</span>
<span class="source-line-no">345</span><span id="line.345">                        return Math.abs(y - c.y) == 1;</span>
<span class="source-line-no">346</span><span id="line.346">                case 1:</span>
<span class="source-line-no">347</span><span id="line.347">                        return y == c.y || Math.abs(y - c.y) == 1;</span>
<span class="source-line-no">348</span><span id="line.348">                default:</span>
<span class="source-line-no">349</span><span id="line.349">                        return false;</span>
<span class="source-line-no">350</span><span id="line.350">                }</span>
<span class="source-line-no">351</span><span id="line.351">        }</span>
<span class="source-line-no">352</span><span id="line.352"></span>
<span class="source-line-no">353</span><span id="line.353">        /**</span>
<span class="source-line-no">354</span><span id="line.354">     * Gets the {@link Direction} needed to get to {@code target} from this; typically this is more useful when target</span>
<span class="source-line-no">355</span><span id="line.355">     * and this are adjacent (by {@link #isAdjacent(Coord)}) since that should make it possible to go to target.</span>
<span class="source-line-no">356</span><span id="line.356">     * &lt;br&gt;</span>
<span class="source-line-no">357</span><span id="line.357">     * Internally, this delegates to {@link Direction#toGoTo(Coord, Coord)}, and some code may prefer using the method</span>
<span class="source-line-no">358</span><span id="line.358">     * in Direction instead of this one. Earlier versions of this code only worked for adjacent Coords, which seemed</span>
<span class="source-line-no">359</span><span id="line.359">     * like an unnecessary limitation since Direction's version worked for any arguments.</span>
<span class="source-line-no">360</span><span id="line.360">         * @param target a non-null {@link Coord}</span>
<span class="source-line-no">361</span><span id="line.361">         * @return the direction to go from {@code this} to {@code target}</span>
<span class="source-line-no">362</span><span id="line.362">         */</span>
<span class="source-line-no">363</span><span id="line.363">        public Direction toGoTo(final Coord target) {</span>
<span class="source-line-no">364</span><span id="line.364">            return Direction.toGoTo(this, target);</span>
<span class="source-line-no">365</span><span id="line.365">        }</span>
<span class="source-line-no">366</span><span id="line.366"></span>
<span class="source-line-no">367</span><span id="line.367">    /**</span>
<span class="source-line-no">368</span><span id="line.368">     * Returns true if x is between 0 (inclusive) and width (exclusive) and y is between 0 (inclusive) and height</span>
<span class="source-line-no">369</span><span id="line.369">     * (exclusive), false otherwise.</span>
<span class="source-line-no">370</span><span id="line.370">     * @param width the upper limit on x to check, exclusive</span>
<span class="source-line-no">371</span><span id="line.371">     * @param height the upper limit on y to check, exclusive</span>
<span class="source-line-no">372</span><span id="line.372">     * @return true if this Coord is within the limits of width and height and has non-negative x and y</span>
<span class="source-line-no">373</span><span id="line.373">     */</span>
<span class="source-line-no">374</span><span id="line.374">    public boolean isWithin(final int width, final int height)</span>
<span class="source-line-no">375</span><span id="line.375">    {</span>
<span class="source-line-no">376</span><span id="line.376">        return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; width &amp;&amp; y &lt; height;</span>
<span class="source-line-no">377</span><span id="line.377">    }</span>
<span class="source-line-no">378</span><span id="line.378">    /**</span>
<span class="source-line-no">379</span><span id="line.379">     * Returns true if x is between minX (inclusive) and maxX (exclusive) and y is between minY (inclusive) and maxY</span>
<span class="source-line-no">380</span><span id="line.380">     * (exclusive), false otherwise.</span>
<span class="source-line-no">381</span><span id="line.381">     * @param minX the lower limit on x to check, inclusive</span>
<span class="source-line-no">382</span><span id="line.382">     * @param minY the lower limit on y to check, inclusive</span>
<span class="source-line-no">383</span><span id="line.383">     * @param maxX the upper limit on x to check, exclusive</span>
<span class="source-line-no">384</span><span id="line.384">     * @param maxY the upper limit on y to check, exclusive</span>
<span class="source-line-no">385</span><span id="line.385">     * @return true if this Coord is within the limits of the given parameters</span>
<span class="source-line-no">386</span><span id="line.386">     */</span>
<span class="source-line-no">387</span><span id="line.387">    public boolean isWithinRectangle(int minX, int minY, int maxX, int maxY)</span>
<span class="source-line-no">388</span><span id="line.388">    {</span>
<span class="source-line-no">389</span><span id="line.389">        return x &gt;= minX &amp;&amp; y &gt;= minY &amp;&amp; x &lt; maxX &amp;&amp; y &lt; maxY;</span>
<span class="source-line-no">390</span><span id="line.390">    }</span>
<span class="source-line-no">391</span><span id="line.391">    public int getX() {</span>
<span class="source-line-no">392</span><span id="line.392">        return x;</span>
<span class="source-line-no">393</span><span id="line.393">    }</span>
<span class="source-line-no">394</span><span id="line.394"></span>
<span class="source-line-no">395</span><span id="line.395">    public Coord setX(final int x) {</span>
<span class="source-line-no">396</span><span id="line.396">        return get(x, y);</span>
<span class="source-line-no">397</span><span id="line.397">    }</span>
<span class="source-line-no">398</span><span id="line.398"></span>
<span class="source-line-no">399</span><span id="line.399">    public int getY() {</span>
<span class="source-line-no">400</span><span id="line.400">        return y;</span>
<span class="source-line-no">401</span><span id="line.401">    }</span>
<span class="source-line-no">402</span><span id="line.402"></span>
<span class="source-line-no">403</span><span id="line.403">    public Coord setY(final int y) {</span>
<span class="source-line-no">404</span><span id="line.404">        return get(x, y);</span>
<span class="source-line-no">405</span><span id="line.405">    }</span>
<span class="source-line-no">406</span><span id="line.406"></span>
<span class="source-line-no">407</span><span id="line.407">    @Override</span>
<span class="source-line-no">408</span><span id="line.408">    public String toString()</span>
<span class="source-line-no">409</span><span id="line.409">    {</span>
<span class="source-line-no">410</span><span id="line.410">        return "(" + x + "," + y + ")";</span>
<span class="source-line-no">411</span><span id="line.411">    }</span>
<span class="source-line-no">412</span><span id="line.412"></span>
<span class="source-line-no">413</span><span id="line.413">    /**</span>
<span class="source-line-no">414</span><span id="line.414">     * Gets the hash code for this Coord; does not use the standard "auto-complete" style of hash that most IDEs will</span>
<span class="source-line-no">415</span><span id="line.415">     * generate, but instead uses a highly-specific technique based on the Rosenberg-Strong pairing function, a Gray</span>
<span class="source-line-no">416</span><span id="line.416">     * code, and two XLCG steps at the end. It manages to get extremely low collision rates under many circumstances,</span>
<span class="source-line-no">417</span><span id="line.417">     * and very frequently manages to avoid colliding on more than 25% of Coords (making the load factor of most</span>
<span class="source-line-no">418</span><span id="line.418">     * hash-based collections fine at a default of 0.75) while often having 0 collisions with some data sets.</span>
<span class="source-line-no">419</span><span id="line.419">     * It does much better when Coords are in the default pooled range of -3 or greater.</span>
<span class="source-line-no">420</span><span id="line.420">     * &lt;br&gt;</span>
<span class="source-line-no">421</span><span id="line.421">     * This gets slightly better collision rates than previous versions used by SquidLib, around 4% across a wide</span>
<span class="source-line-no">422</span><span id="line.422">     * variety of rectangular areas (most earlier hashes got about-5%-range collision rates, and using</span>
<span class="source-line-no">423</span><span id="line.423">     * {@link java.util.Objects#hash(Object...)} gives more than a 75% collision rate). The previous version, which is</span>
<span class="source-line-no">424</span><span id="line.424">     * still available as {@link #cantorHashCode(int, int)}, has slightly better results when used for seeding</span>
<span class="source-line-no">425</span><span id="line.425">     * procedural generation based on a Coord (a reasonable usage of this method), but both this hash code and the</span>
<span class="source-line-no">426</span><span id="line.426">     * Cantor-based one have excellent randomness in the upper bits of the hash (so if you use a hashCode() result as a</span>
<span class="source-line-no">427</span><span id="line.427">     * whole int, then it should be pretty good as a seed). The method before the Cantor-based one,</span>
<span class="source-line-no">428</span><span id="line.428">     * {@link #xoroHashCode(int, int)} was structured a little like xoroshiro ({@link XoRoRNG} uses the 64-bit version</span>
<span class="source-line-no">429</span><span id="line.429">     * of xoroshiro), and while it had pretty low collision rates (low 5% range), its hash codes changed bits in large</span>
<span class="source-line-no">430</span><span id="line.430">     * checkerboard patterns, leaving heavy square-shaped biases in generated results.</span>
<span class="source-line-no">431</span><span id="line.431">     * &lt;br&gt;</span>
<span class="source-line-no">432</span><span id="line.432">     * This changed at least 7 times in SquidLib's history. In general, you shouldn't rely on hashCodes to stay the</span>
<span class="source-line-no">433</span><span id="line.433">     * same across platforms and versions, whether for the JDK or this library. SquidLib (tries to) never depend on the</span>
<span class="source-line-no">434</span><span id="line.434">     * unpredictable ordering of some hash-based collections like HashSet and HashMap, instead using its own</span>
<span class="source-line-no">435</span><span id="line.435">     * {@link OrderedSet} and {@link OrderedMap}; if you use the ordered kinds, then the only things that matter about</span>
<span class="source-line-no">436</span><span id="line.436">     * this hash code are that it's fast (it's fast enough), it's cross-platform compatible (this version avoids using</span>
<span class="source-line-no">437</span><span id="line.437">     * long values, which are slow on GWT, and is carefully written to behave the same on GWT as desktop) and that it</span>
<span class="source-line-no">438</span><span id="line.438">     * doesn't collide often (which is now much more accurate than in earlier versions of this method).</span>
<span class="source-line-no">439</span><span id="line.439">     * @see #rosenbergStrongHashCode(int, int) A static method that gets the same result as this method without involving a Coord</span>
<span class="source-line-no">440</span><span id="line.440">     * @return an int that should, for most different Coord values, be significantly different from the other hash codes</span>
<span class="source-line-no">441</span><span id="line.441">     */</span>
<span class="source-line-no">442</span><span id="line.442">    @Override</span>
<span class="source-line-no">443</span><span id="line.443">    public int hashCode() {</span>
<span class="source-line-no">444</span><span id="line.444">        //// for Coord, since it can be as low as -3, and Rosenberg-Strong works only for positive integers</span>
<span class="source-line-no">445</span><span id="line.445">        final int x = this.x + 3;</span>
<span class="source-line-no">446</span><span id="line.446">        final int y = this.y + 3;</span>
<span class="source-line-no">447</span><span id="line.447">        //// Rosenberg-Strong pairing function; has excellent traits for keeping the hash gap-less while the</span>
<span class="source-line-no">448</span><span id="line.448">        //// inputs fit inside a square, and is still good for rectangles.</span>
<span class="source-line-no">449</span><span id="line.449">        final int n = (x &gt;= y ? x * (x + 2) - y : y * y + x);</span>
<span class="source-line-no">450</span><span id="line.450">        //// Gray code, XLCG, XLCG (ending on a XOR to stay within int range on GWT).</span>
<span class="source-line-no">451</span><span id="line.451">        //// The Gray code moves bits around just a little, but keeps the same power-of-two upper bound.</span>
<span class="source-line-no">452</span><span id="line.452">        //// the XLCGs together only really randomize the upper bits; they don't change the lower bit at all.</span>
<span class="source-line-no">453</span><span id="line.453">        //// (recall from RNG class that an XLCG is a XOR by a constant, then a multiply by a constant, where</span>
<span class="source-line-no">454</span><span id="line.454">        //// the XOR constant, mod 8, is 5, while the multiplier, mod 8, is 3; the order can be reversed too.)</span>
<span class="source-line-no">455</span><span id="line.455">        //// ending on a XOR helps mostly for GWT.</span>
<span class="source-line-no">456</span><span id="line.456">        return ((n ^ n &gt;&gt;&gt; 1) * 0x9E373 ^ 0xD1B54A35) * 0x125493 ^ 0x91E10DA5;</span>
<span class="source-line-no">457</span><span id="line.457">    }</span>
<span class="source-line-no">458</span><span id="line.458"></span>
<span class="source-line-no">459</span><span id="line.459">    /**</span>
<span class="source-line-no">460</span><span id="line.460">     * A static version of an earlier {@link #hashCode()} method of this class, taking x and y as parameters instead of</span>
<span class="source-line-no">461</span><span id="line.461">     * requiring a Coord object. Like the earlier hashCode() method, this involves the close-to-optimal mathematical</span>
<span class="source-line-no">462</span><span id="line.462">     * Cantor pairing function to distribute x and y without overlap until they get very large. Cantor's pairing</span>
<span class="source-line-no">463</span><span id="line.463">     * function can be written simply as {@code ((x + y) * (x + y + 1)) / 2 + y}; it produces sequential results for a</span>
<span class="source-line-no">464</span><span id="line.464">     * sequence of positive points traveling in diagonal stripes away from the origin. The finalization steps this</span>
<span class="source-line-no">465</span><span id="line.465">     * performs improve the randomness of the lower bits, but also worsen collision rates; most cases involving Coords</span>
<span class="source-line-no">466</span><span id="line.466">     * will see lower collision rates from {@link #rosenbergStrongHashCode(int, int)}, but more random results from this</span>
<span class="source-line-no">467</span><span id="line.467">     * method.</span>
<span class="source-line-no">468</span><span id="line.468">     * @param x the x coordinate of the "imaginary Coord" to hash</span>
<span class="source-line-no">469</span><span id="line.469">     * @param y the y coordinate of the "imaginary Coord" to hash</span>
<span class="source-line-no">470</span><span id="line.470">     * @return the equivalent to the hashCode() of an "imaginary Coord"</span>
<span class="source-line-no">471</span><span id="line.471">     */</span>
<span class="source-line-no">472</span><span id="line.472">    public static int cantorHashCode(int x, int y) {</span>
<span class="source-line-no">473</span><span id="line.473">        x ^= x &gt;&gt; 31;</span>
<span class="source-line-no">474</span><span id="line.474">        y ^= y &gt;&gt; 31;</span>
<span class="source-line-no">475</span><span id="line.475">        y += ((x + y) * (x + y + 1) &gt;&gt; 1);</span>
<span class="source-line-no">476</span><span id="line.476">        y ^= y &gt;&gt;&gt; 1 ^ y &gt;&gt;&gt; 6;</span>
<span class="source-line-no">477</span><span id="line.477">        return (y ^ (y &lt;&lt; 15 | y &gt;&gt;&gt; 17) ^ (y &lt;&lt; 23 | y &gt;&gt;&gt; 9)) * 0x125493 ^ 0xD1B54A35;</span>
<span class="source-line-no">478</span><span id="line.478">    }</span>
<span class="source-line-no">479</span><span id="line.479">    /**</span>
<span class="source-line-no">480</span><span id="line.480">     * A static version of the current {@link #hashCode()} method of this class, taking x and y as parameters instead of</span>
<span class="source-line-no">481</span><span id="line.481">     * requiring a Coord object. Like the current hashCode() method, this involves the close-to-optimal mathematical</span>
<span class="source-line-no">482</span><span id="line.482">     * Rosenberg-Strong pairing function to distribute x and y without overlap until they get very large. The</span>
<span class="source-line-no">483</span><span id="line.483">     * Rosenberg-Strong pairing function can be written simply as {@code ((x &gt;= y) ? x * (x + 2) - y : y * y + x)}; it</span>
<span class="source-line-no">484</span><span id="line.484">     * produces sequential results for a sequence of positive points traveling in square "shells" away from the origin.</span>
<span class="source-line-no">485</span><span id="line.485">     * &lt;a href="https://hbfs.wordpress.com/2018/08/07/moeud-deux/"&gt;the algorithm is discussed more here&lt;/a&gt;; the only</span>
<span class="source-line-no">486</span><span id="line.486">     * changes this makes are adding 3 to x and y (to account for the minimum of -3 in most cases for a Coord), and some</span>
<span class="source-line-no">487</span><span id="line.487">     * finalizing steps that help randomize the upper bits of the hash code (the lower bits are quite non-random because</span>
<span class="source-line-no">488</span><span id="line.488">     * they can't permit any gaps while optimizing collision rates).</span>
<span class="source-line-no">489</span><span id="line.489">     * @param x the x coordinate of the "imaginary Coord" to hash</span>
<span class="source-line-no">490</span><span id="line.490">     * @param y the y coordinate of the "imaginary Coord" to hash</span>
<span class="source-line-no">491</span><span id="line.491">     * @return the equivalent to the hashCode() of an "imaginary Coord"</span>
<span class="source-line-no">492</span><span id="line.492">     */</span>
<span class="source-line-no">493</span><span id="line.493">    public static int rosenbergStrongHashCode(int x, int y) {</span>
<span class="source-line-no">494</span><span id="line.494">        //// for Coord, since it can be as low as -3, and Rosenberg-Strong works only for positive integers</span>
<span class="source-line-no">495</span><span id="line.495">        x += 3;</span>
<span class="source-line-no">496</span><span id="line.496">        y += 3;</span>
<span class="source-line-no">497</span><span id="line.497">        //// Rosenberg-Strong pairing function; has excellent traits for keeping the hash gap-less while the</span>
<span class="source-line-no">498</span><span id="line.498">        //// inputs fit inside a square, and is still good for rectangles.</span>
<span class="source-line-no">499</span><span id="line.499">        final int n = (x &gt;= y ? x * (x + 2) - y : y * y + x);</span>
<span class="source-line-no">500</span><span id="line.500">        //// Gray code, XLCG, XLCG (ending on a XOR to stay within int range on GWT).</span>
<span class="source-line-no">501</span><span id="line.501">        //// The Gray code moves bits around just a little, but keeps the same power-of-two upper bound.</span>
<span class="source-line-no">502</span><span id="line.502">        //// the XLCGs together only really randomize the upper bits; they don't change the lower bit at all.</span>
<span class="source-line-no">503</span><span id="line.503">        //// (recall from RNG class that an XLCG is a XOR by a constant, then a multiply by a constant, where</span>
<span class="source-line-no">504</span><span id="line.504">        //// the XOR constant, mod 8, is 5, while the multiplier, mod 8, is 3; the order can be reversed too.)</span>
<span class="source-line-no">505</span><span id="line.505">        //// ending on a XOR helps mostly for GWT.</span>
<span class="source-line-no">506</span><span id="line.506">        return ((n ^ n &gt;&gt;&gt; 1) * 0x9E373 ^ 0xD1B54A35) * 0x125493 ^ 0x91E10DA5;</span>
<span class="source-line-no">507</span><span id="line.507">    }</span>
<span class="source-line-no">508</span><span id="line.508">    /**</span>
<span class="source-line-no">509</span><span id="line.509">     * An earlier hashCode() implementation used by this class, now standalone in case you want to replicate the results</span>
<span class="source-line-no">510</span><span id="line.510">     * of the older code. This uses only bitwise operations, which tend to be fairly fast on all platforms, and when</span>
<span class="source-line-no">511</span><span id="line.511">     * used in a collection it has comparable collision rates to the current hashCode() method (very, very low rates),</span>
<span class="source-line-no">512</span><span id="line.512">     * but if used for procedural generation it's simply terrible, with large blocks of nearby x,y points having</span>
<span class="source-line-no">513</span><span id="line.513">     * identical values for several bits and all changes happening in a repetitive checkerboard pattern. It is</span>
<span class="source-line-no">514</span><span id="line.514">     * structured very similarly to {@link XoRoRNG} and {@link Lathe32RNG} in particular, but using only bitwise math.</span>
<span class="source-line-no">515</span><span id="line.515">     * @param x the x coordinate of the "imaginary Coord" to hash</span>
<span class="source-line-no">516</span><span id="line.516">     * @param y the y coordinate of the "imaginary Coord" to hash</span>
<span class="source-line-no">517</span><span id="line.517">     * @return the equivalent to the hashCode() of an "imaginary Coord"</span>
<span class="source-line-no">518</span><span id="line.518">     */</span>
<span class="source-line-no">519</span><span id="line.519">    public static int xoroHashCode(final int x, final int y) {</span>
<span class="source-line-no">520</span><span id="line.520">        int r = x ^ y;</span>
<span class="source-line-no">521</span><span id="line.521">        r ^= (x &lt;&lt; 13 | x &gt;&gt;&gt; 19) ^ (r &lt;&lt; 5) ^ (r &lt;&lt; 28 | r &gt;&gt;&gt; 4);</span>
<span class="source-line-no">522</span><span id="line.522">        r = x ^ (r &lt;&lt; 11 | r &gt;&gt;&gt; 21);</span>
<span class="source-line-no">523</span><span id="line.523">        return r ^ (r &lt;&lt; 25 | r &gt;&gt;&gt; 7);</span>
<span class="source-line-no">524</span><span id="line.524">    }</span>
<span class="source-line-no">525</span><span id="line.525"></span>
<span class="source-line-no">526</span><span id="line.526">    /**</span>
<span class="source-line-no">527</span><span id="line.527">     * Something like hashCode(), but reversible with {@code Coord.decode()}. Works for Coords between roughly -256 and</span>
<span class="source-line-no">528</span><span id="line.528">     * 32000 in each of x and y, but will probably only decode to pooled Coords if x and y are both between -3 and 255</span>
<span class="source-line-no">529</span><span id="line.529">     * (inclusive for both).</span>
<span class="source-line-no">530</span><span id="line.530">     * @return an int as a unique code for this Coord</span>
<span class="source-line-no">531</span><span id="line.531">     */</span>
<span class="source-line-no">532</span><span id="line.532">    public int encode()</span>
<span class="source-line-no">533</span><span id="line.533">    {</span>
<span class="source-line-no">534</span><span id="line.534">        return ((x + 256) &lt;&lt; 16) ^ (y + 256);</span>
<span class="source-line-no">535</span><span id="line.535">    }</span>
<span class="source-line-no">536</span><span id="line.536"></span>
<span class="source-line-no">537</span><span id="line.537">    /**</span>
<span class="source-line-no">538</span><span id="line.538">     * An alternative to getting a Coord with Coord.get() only to encode() it as the next step. This doesn't create a</span>
<span class="source-line-no">539</span><span id="line.539">     * Coord in the middle step. Can be decoded with Coord.decode() to get the (x,y) Coord.</span>
<span class="source-line-no">540</span><span id="line.540">     * @param x the x position to encode</span>
<span class="source-line-no">541</span><span id="line.541">     * @param y the y position to encode</span>
<span class="source-line-no">542</span><span id="line.542">     * @return the coded int that a Coord at (x,y) would produce with encode()</span>
<span class="source-line-no">543</span><span id="line.543">     */</span>
<span class="source-line-no">544</span><span id="line.544">    public static int pureEncode(final int x, final int y)</span>
<span class="source-line-no">545</span><span id="line.545">    {</span>
<span class="source-line-no">546</span><span id="line.546">        return ((x + 256) &lt;&lt; 16) ^ (y + 256);</span>
<span class="source-line-no">547</span><span id="line.547">    }</span>
<span class="source-line-no">548</span><span id="line.548">    /**</span>
<span class="source-line-no">549</span><span id="line.549">     * This can take an int produced by {@code someCoord.encode()} and get the original Coord back out of it. It</span>
<span class="source-line-no">550</span><span id="line.550">     * works for all pooled Coords where the pool hasn't been expanded past about 32,000 in either dimension. It even</span>
<span class="source-line-no">551</span><span id="line.551">     * works for Coords with negative x or y as well, if they are no lower than -256 in either dimension. This will</span>
<span class="source-line-no">552</span><span id="line.552">     * almost certainly fail (producing a gibberish Coord that probably won't be pooled) on hashes produced by any other</span>
<span class="source-line-no">553</span><span id="line.553">     * class, including subclasses of Coord.</span>
<span class="source-line-no">554</span><span id="line.554">     * @param code an encoded int from a Coord, but not a subclass of Coord</span>
<span class="source-line-no">555</span><span id="line.555">     * @return the Coord that gave hash as its hashCode()</span>
<span class="source-line-no">556</span><span id="line.556">     */</span>
<span class="source-line-no">557</span><span id="line.557">    public static Coord decode(final int code)</span>
<span class="source-line-no">558</span><span id="line.558">    {</span>
<span class="source-line-no">559</span><span id="line.559">        return get((code &gt;&gt;&gt; 16) - 256, (code &amp; 0xFFFF) - 256);</span>
<span class="source-line-no">560</span><span id="line.560">    }</span>
<span class="source-line-no">561</span><span id="line.561"></span>
<span class="source-line-no">562</span><span id="line.562">    @Override</span>
<span class="source-line-no">563</span><span id="line.563">    public boolean equals(Object o) {</span>
<span class="source-line-no">564</span><span id="line.564">        if (o instanceof Coord) {</span>
<span class="source-line-no">565</span><span id="line.565">            Coord other = (Coord) o;</span>
<span class="source-line-no">566</span><span id="line.566">            return x == other.x &amp;&amp; y == other.y;</span>
<span class="source-line-no">567</span><span id="line.567">        } else {</span>
<span class="source-line-no">568</span><span id="line.568">            return false;</span>
<span class="source-line-no">569</span><span id="line.569">        }</span>
<span class="source-line-no">570</span><span id="line.570">    }</span>
<span class="source-line-no">571</span><span id="line.571">    private static Coord[][] POOL = new Coord[259][259];</span>
<span class="source-line-no">572</span><span id="line.572">    static {</span>
<span class="source-line-no">573</span><span id="line.573">        int width = POOL.length, height = POOL[0].length;</span>
<span class="source-line-no">574</span><span id="line.574">        for (int i = 0; i &lt; width; i++) {</span>
<span class="source-line-no">575</span><span id="line.575">            for (int j = 0; j &lt; height; j++) {</span>
<span class="source-line-no">576</span><span id="line.576">                POOL[i][j] = new Coord(i - 3, j - 3);</span>
<span class="source-line-no">577</span><span id="line.577">            }</span>
<span class="source-line-no">578</span><span id="line.578">        }</span>
<span class="source-line-no">579</span><span id="line.579">    }</span>
<span class="source-line-no">580</span><span id="line.580"></span>
<span class="source-line-no">581</span><span id="line.581">    /**</span>
<span class="source-line-no">582</span><span id="line.582">     * Gets the width of the pool used as a cache for Coords, not including negative Coords.</span>
<span class="source-line-no">583</span><span id="line.583">     * Unless expandPool() has been called, this should be 256.</span>
<span class="source-line-no">584</span><span id="line.584">     * Useful for finding the upper (exclusive) bound for x values that can be used efficiently in Coords.</span>
<span class="source-line-no">585</span><span id="line.585">     * Requesting a Coord with a x greater than or equal to this value will result in a new Coord being allocated and</span>
<span class="source-line-no">586</span><span id="line.586">     * not cached, which may cause problems with code that expects the normal reference equality of Coords to be upheld</span>
<span class="source-line-no">587</span><span id="line.587">     * and in extreme cases may require more time garbage collecting than is normally necessary.</span>
<span class="source-line-no">588</span><span id="line.588">     * @return the width of the Coord cache, disregarding negative Coords</span>
<span class="source-line-no">589</span><span id="line.589">     */</span>
<span class="source-line-no">590</span><span id="line.590">    public static int getCacheWidth()</span>
<span class="source-line-no">591</span><span id="line.591">    {</span>
<span class="source-line-no">592</span><span id="line.592">        return POOL.length - 3;</span>
<span class="source-line-no">593</span><span id="line.593">    }</span>
<span class="source-line-no">594</span><span id="line.594"></span>
<span class="source-line-no">595</span><span id="line.595">    /**</span>
<span class="source-line-no">596</span><span id="line.596">     * Gets the height of the pool used as a cache for Coords, not including negative Coords.</span>
<span class="source-line-no">597</span><span id="line.597">     * Unless expandPool() has been called, this should be 256.</span>
<span class="source-line-no">598</span><span id="line.598">     * Useful for finding the upper (exclusive) bound for y values that can be used efficiently in Coords.</span>
<span class="source-line-no">599</span><span id="line.599">     * Requesting a Coord with a y greater than or equal to this value will result in a new Coord being allocated and</span>
<span class="source-line-no">600</span><span id="line.600">     * not cached, which may cause problems with code that expects the normal reference equality of Coords to be upheld</span>
<span class="source-line-no">601</span><span id="line.601">     * and in extreme cases may require more time garbage collecting than is normally necessary.</span>
<span class="source-line-no">602</span><span id="line.602">     * @return the height of the Coord cache, disregarding negative Coords</span>
<span class="source-line-no">603</span><span id="line.603">     */</span>
<span class="source-line-no">604</span><span id="line.604">    public static int getCacheHeight()</span>
<span class="source-line-no">605</span><span id="line.605">    {</span>
<span class="source-line-no">606</span><span id="line.606">        return POOL[0].length - 3;</span>
<span class="source-line-no">607</span><span id="line.607">    }</span>
<span class="source-line-no">608</span><span id="line.608"></span>
<span class="source-line-no">609</span><span id="line.609">    /**</span>
<span class="source-line-no">610</span><span id="line.610">     * Enlarges the pool of cached Coords to the given width and height, and doesn't change</span>
<span class="source-line-no">611</span><span id="line.611">     * a dimension if it would be reduced in size.</span>
<span class="source-line-no">612</span><span id="line.612">     * Cached Coord values will be reused by Coord.get instead of re-allocated each time.</span>
<span class="source-line-no">613</span><span id="line.613">     * The default pool allows Coords with x and y each between -3 and 255, inclusive, to</span>
<span class="source-line-no">614</span><span id="line.614">     * be cached, and is considered to have width and height of 256 to begin with. Giving a</span>
<span class="source-line-no">615</span><span id="line.615">     * width greater than 256 will allow Coords with x greater than 255 to be cached;</span>
<span class="source-line-no">616</span><span id="line.616">     * likewise for height. If width or height is smaller than the current cache width or</span>
<span class="source-line-no">617</span><span id="line.617">     * height, that dimension will not change, but the other still may if it is valid. You</span>
<span class="source-line-no">618</span><span id="line.618">     * cannot shrink the pool size.</span>
<span class="source-line-no">619</span><span id="line.619">     * @param width the new width for the pool of cached Coords; will be ignored if smaller than the current width</span>
<span class="source-line-no">620</span><span id="line.620">     * @param height the new height for the pool of cached Coords; will be ignored if smaller than the current height</span>
<span class="source-line-no">621</span><span id="line.621">     */</span>
<span class="source-line-no">622</span><span id="line.622">    public static void expandPoolTo(final int width, final int height)</span>
<span class="source-line-no">623</span><span id="line.623">    {</span>
<span class="source-line-no">624</span><span id="line.624">        expandPool(Math.max(0, width + 3 - POOL.length), Math.max(0, height + 3 - POOL[0].length));</span>
<span class="source-line-no">625</span><span id="line.625">    }</span>
<span class="source-line-no">626</span><span id="line.626"></span>
<span class="source-line-no">627</span><span id="line.627">    /**</span>
<span class="source-line-no">628</span><span id="line.628">     * Enlarges the pool of cached Coords by the given amount of expansion for x and y.</span>
<span class="source-line-no">629</span><span id="line.629">     * Cached Coord values will be reused by Coord.get instead of re-allocated each time.</span>
<span class="source-line-no">630</span><span id="line.630">     * The default pool allows Coords with x and y each between -3 and 255, inclusive, to</span>
<span class="source-line-no">631</span><span id="line.631">     * be cached, and this can increase the size in the positive direction. If either</span>
<span class="source-line-no">632</span><span id="line.632">     * xIncrease or yIncrease is negative, this method returns immediately and does nothing</span>
<span class="source-line-no">633</span><span id="line.633">     * else; the same is true of both arguments are zero. You cannot shrink the pool size.</span>
<span class="source-line-no">634</span><span id="line.634">     * @param xIncrease the amount to increase cache's width by</span>
<span class="source-line-no">635</span><span id="line.635">     * @param yIncrease the amount to increase cache's height by</span>
<span class="source-line-no">636</span><span id="line.636">     */</span>
<span class="source-line-no">637</span><span id="line.637">    public static void expandPool(final int xIncrease, final int yIncrease)</span>
<span class="source-line-no">638</span><span id="line.638">    {</span>
<span class="source-line-no">639</span><span id="line.639">        if(xIncrease &lt; 0 || yIncrease &lt; 0 || (xIncrease | yIncrease) == 0 )</span>
<span class="source-line-no">640</span><span id="line.640">            return;</span>
<span class="source-line-no">641</span><span id="line.641">        int width = POOL.length, height = POOL[0].length;</span>
<span class="source-line-no">642</span><span id="line.642">        Coord[][] POOL2 = new Coord[width + xIncrease][height + yIncrease];</span>
<span class="source-line-no">643</span><span id="line.643">        for (int i = 0; i &lt; width; i++) {</span>
<span class="source-line-no">644</span><span id="line.644">            POOL2[i] = new Coord[height + yIncrease];</span>
<span class="source-line-no">645</span><span id="line.645">            System.arraycopy(POOL[i], 0, POOL2[i], 0, height);</span>
<span class="source-line-no">646</span><span id="line.646">            for (int j = 0; j &lt; height + yIncrease; j++) {</span>
<span class="source-line-no">647</span><span id="line.647">                if(POOL2[i][j] == null) POOL2[i][j] = new Coord(i - 3, j - 3);</span>
<span class="source-line-no">648</span><span id="line.648">            }</span>
<span class="source-line-no">649</span><span id="line.649">        }</span>
<span class="source-line-no">650</span><span id="line.650">        for (int i = width; i &lt; width + xIncrease; i++) {</span>
<span class="source-line-no">651</span><span id="line.651">            POOL2[i] = new Coord[height + yIncrease];</span>
<span class="source-line-no">652</span><span id="line.652">            for (int j = 0; j &lt; height + yIncrease; j++) {</span>
<span class="source-line-no">653</span><span id="line.653">                POOL2[i][j] = new Coord(i - 3, j - 3);</span>
<span class="source-line-no">654</span><span id="line.654">            }</span>
<span class="source-line-no">655</span><span id="line.655">        }</span>
<span class="source-line-no">656</span><span id="line.656">        POOL = POOL2;</span>
<span class="source-line-no">657</span><span id="line.657">    }</span>
<span class="source-line-no">658</span><span id="line.658"></span>
<span class="source-line-no">659</span><span id="line.659">        /**</span>
<span class="source-line-no">660</span><span id="line.660">         * Gets a (usually cached) Coord between this Coord and {@code end}, with the actual position relative to this based</span>
<span class="source-line-no">661</span><span id="line.661">         * on {@code amountTraveled}. If amountTraveled is 0, this simply returns a Coord equal to this; if amountTraveled</span>
<span class="source-line-no">662</span><span id="line.662">         * is 1, this returns a Coord equal to end, and values in between 0 and 1 give Coords between this and end.</span>
<span class="source-line-no">663</span><span id="line.663">         * @param end another Coord that acts as the "far" endpoint, where this is the "near" start point</span>
<span class="source-line-no">664</span><span id="line.664">         * @param amountTraveled a float between 0 and 1 inclusive, with lower meaning closer to this, higher meaning closer to end</span>
<span class="source-line-no">665</span><span id="line.665">         * @return a Coord that is between this and end as long as amountTraveled is between 0 and 1</span>
<span class="source-line-no">666</span><span id="line.666">         */</span>
<span class="source-line-no">667</span><span id="line.667">    public Coord interpolate(Coord end, float amountTraveled) {</span>
<span class="source-line-no">668</span><span id="line.668">        return Coord.get(x + Math.round((end.x - x) * amountTraveled),</span>
<span class="source-line-no">669</span><span id="line.669">                y + Math.round((end.y - y) * amountTraveled));</span>
<span class="source-line-no">670</span><span id="line.670">    }</span>
<span class="source-line-no">671</span><span id="line.671">}</span>




























































</pre>
</div>
</main>
</body>
</html>
