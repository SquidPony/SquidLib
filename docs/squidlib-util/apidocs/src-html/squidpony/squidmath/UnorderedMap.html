<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (16) -->
<title>Source code</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="source: package: squidpony.squidmath, class: UnorderedMap">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body class="source-page">
<main role="main">
<div class="source-container">
<pre><span class="source-line-no">001</span><span id="line.1">/*</span>
<span class="source-line-no">002</span><span id="line.2"> * Copyright (C) 2002-2015 Sebastiano Vigna</span>
<span class="source-line-no">003</span><span id="line.3"> *</span>
<span class="source-line-no">004</span><span id="line.4"> * Licensed under the Apache License, Version 2.0 (the "License");</span>
<span class="source-line-no">005</span><span id="line.5"> * you may not use this file except in compliance with the License.</span>
<span class="source-line-no">006</span><span id="line.6"> * You may obtain a copy of the License at</span>
<span class="source-line-no">007</span><span id="line.7"> *</span>
<span class="source-line-no">008</span><span id="line.8"> *     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="source-line-no">009</span><span id="line.9"> *</span>
<span class="source-line-no">010</span><span id="line.10"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="source-line-no">011</span><span id="line.11"> * distributed under the License is distributed on an "AS IS" BASIS,</span>
<span class="source-line-no">012</span><span id="line.12"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="source-line-no">013</span><span id="line.13"> * See the License for the specific language governing permissions and</span>
<span class="source-line-no">014</span><span id="line.14"> * limitations under the License. </span>
<span class="source-line-no">015</span><span id="line.15"> */</span>
<span class="source-line-no">016</span><span id="line.16">package squidpony.squidmath;</span>
<span class="source-line-no">017</span><span id="line.17"></span>
<span class="source-line-no">018</span><span id="line.18">import squidpony.annotation.GwtIncompatible;</span>
<span class="source-line-no">019</span><span id="line.19"></span>
<span class="source-line-no">020</span><span id="line.20">import java.io.Serializable;</span>
<span class="source-line-no">021</span><span id="line.21">import java.util.*;</span>
<span class="source-line-no">022</span><span id="line.22"></span>
<span class="source-line-no">023</span><span id="line.23">/**</span>
<span class="source-line-no">024</span><span id="line.24"> * A generic unordered hash map; generally prefer {@link HashMap} unless you need array keys. Originally from fastutil</span>
<span class="source-line-no">025</span><span id="line.25"> * as Object2ObjectOpenCustomHashMap but modified to support SquidLib's {@link squidpony.squidmath.CrossHash.IHasher}</span>
<span class="source-line-no">026</span><span id="line.26"> * interface for custom hashing instead of fastutil's Strategy interface.</span>
<span class="source-line-no">027</span><span id="line.27"> * &lt;br&gt;</span>
<span class="source-line-no">028</span><span id="line.28"> * Instances of this class use a hash table to represent a map. The table is filled up to a specified &lt;em&gt;load factor&lt;/em&gt;, and then doubled in size to accommodate new entries. If the table is</span>
<span class="source-line-no">029</span><span id="line.29"> * emptied below &lt;em&gt;one fourth&lt;/em&gt; of the load factor, it is halved in size. However, halving is not performed when deleting entries from an iterator, as it would interfere with the iteration</span>
<span class="source-line-no">030</span><span id="line.30"> * process.</span>
<span class="source-line-no">031</span><span id="line.31"> * &lt;br&gt;</span>
<span class="source-line-no">032</span><span id="line.32"> * Note that {@link #clear()} does not modify the hash table size. Rather, a family of {@linkplain #trim() trimming methods} lets you control the size of the table; this is particularly useful if</span>
<span class="source-line-no">033</span><span id="line.33"> * you reuse instances of this class.</span>
<span class="source-line-no">034</span><span id="line.34"> * &lt;br&gt;</span>
<span class="source-line-no">035</span><span id="line.35"> * You can pass a {@link CrossHash.IHasher} instance such as {@link CrossHash#generalHasher} as an extra parameter to</span>
<span class="source-line-no">036</span><span id="line.36"> * most of this class' constructors, which allows the OrderedMap to use arrays (usually primitive arrays) as keys. If</span>
<span class="source-line-no">037</span><span id="line.37"> * you expect only one type of array, you can use an instance like {@link CrossHash#intHasher} to hash int arrays, or</span>
<span class="source-line-no">038</span><span id="line.38"> * the aforementioned generalHasher to hash most kinds of arrays (it can't handle most multi-dimensional arrays well).</span>
<span class="source-line-no">039</span><span id="line.39"> * If you aren't using arrays as keys, you don't need to give an IHasher to the constructor and can ignore this feature</span>
<span class="source-line-no">040</span><span id="line.40"> * most of the time. However, the default IHasher this uses if none is specified performs a small but significant</span>
<span class="source-line-no">041</span><span id="line.41"> * "mixing" step to make the default generated hashCode() implementation many classes use into a higher-quality</span>
<span class="source-line-no">042</span><span id="line.42"> * random-like value. This isn't always optimal; if you plan to insert 1000 sequential Integer keys with some small</span>
<span class="source-line-no">043</span><span id="line.43"> * amount of random Integers after them, then the mixing actually increases the likelihood of a collision and takes time</span>
<span class="source-line-no">044</span><span id="line.44"> * to calculate. You could use a very simple IHasher in that case, relying on the fact that only Integers will be added:</span>
<span class="source-line-no">045</span><span id="line.45"> * &lt;pre&gt;</span>
<span class="source-line-no">046</span><span id="line.46"> * new CrossHash.IHasher() {</span>
<span class="source-line-no">047</span><span id="line.47"> *     public int hash(Object data) { return (int)data; }</span>
<span class="source-line-no">048</span><span id="line.48"> *     public boolean areEqual(Object left, Object right) { return Objects.equals(left, right); }</span>
<span class="source-line-no">049</span><span id="line.49"> * };</span>
<span class="source-line-no">050</span><span id="line.50"> * &lt;/pre&gt;</span>
<span class="source-line-no">051</span><span id="line.51"> * This is just one example of a case where a custom IHasher can be useful for performance reasons; there are also cases</span>
<span class="source-line-no">052</span><span id="line.52"> * where an IHasher is needed to enforce hashing by identity or by value, which affect program logic. Note that the</span>
<span class="source-line-no">053</span><span id="line.53"> * given IHasher is likely to be sub-optimal for many situations with Integer keys, and you may want to try a few</span>
<span class="source-line-no">054</span><span id="line.54"> * different approaches if you know OrderedMap is a bottleneck in your application. If the IHasher is a performance</span>
<span class="source-line-no">055</span><span id="line.55"> * problem, it will be at its worst if the OrderedMap needs to resize, and thus rehash, many times; this won't happen if</span>
<span class="source-line-no">056</span><span id="line.56"> * the capacity is set correctly when the OrderedMap is created (with the capacity equal to or greater than the maximum</span>
<span class="source-line-no">057</span><span id="line.57"> * number of entries that will be added).</span>
<span class="source-line-no">058</span><span id="line.58"> * &lt;br&gt;</span>
<span class="source-line-no">059</span><span id="line.59"> * Thank you, Sebastiano Vigna, for making FastUtil available to the public with such high quality.</span>
<span class="source-line-no">060</span><span id="line.60"> * &lt;br&gt;</span>
<span class="source-line-no">061</span><span id="line.61"> * See https://github.com/vigna/fastutil for the original library.</span>
<span class="source-line-no">062</span><span id="line.62"> * @author Sebastiano Vigna (responsible for all the hard parts)</span>
<span class="source-line-no">063</span><span id="line.63"> * @author Tommy Ettinger (mostly responsible for squashing several layers of parent classes into one monster class)</span>
<span class="source-line-no">064</span><span id="line.64"> */</span>
<span class="source-line-no">065</span><span id="line.65">public class UnorderedMap&lt;K, V&gt; implements Map&lt;K, V&gt;, Serializable, Cloneable {</span>
<span class="source-line-no">066</span><span id="line.66">    private static final long serialVersionUID = 0L;</span>
<span class="source-line-no">067</span><span id="line.67">    /**</span>
<span class="source-line-no">068</span><span id="line.68">     * The array of keys.</span>
<span class="source-line-no">069</span><span id="line.69">     */</span>
<span class="source-line-no">070</span><span id="line.70">    protected K[] key;</span>
<span class="source-line-no">071</span><span id="line.71">    /**</span>
<span class="source-line-no">072</span><span id="line.72">     * The array of values.</span>
<span class="source-line-no">073</span><span id="line.73">     */</span>
<span class="source-line-no">074</span><span id="line.74">    protected V[] value;</span>
<span class="source-line-no">075</span><span id="line.75">    /**</span>
<span class="source-line-no">076</span><span id="line.76">     * The mask for wrapping a position counter.</span>
<span class="source-line-no">077</span><span id="line.77">     */</span>
<span class="source-line-no">078</span><span id="line.78">    protected int mask;</span>
<span class="source-line-no">079</span><span id="line.79">    /**</span>
<span class="source-line-no">080</span><span id="line.80">     * Whether this set contains the key zero.</span>
<span class="source-line-no">081</span><span id="line.81">     */</span>
<span class="source-line-no">082</span><span id="line.82">    protected boolean containsNullKey;</span>
<span class="source-line-no">083</span><span id="line.83">    /**</span>
<span class="source-line-no">084</span><span id="line.84">     * The current table size.</span>
<span class="source-line-no">085</span><span id="line.85">     */</span>
<span class="source-line-no">086</span><span id="line.86">    protected int n;</span>
<span class="source-line-no">087</span><span id="line.87">    /**</span>
<span class="source-line-no">088</span><span id="line.88">     * Threshold after which we rehash. It must be the table size times {@link #f}.</span>
<span class="source-line-no">089</span><span id="line.89">     */</span>
<span class="source-line-no">090</span><span id="line.90">    protected int maxFill;</span>
<span class="source-line-no">091</span><span id="line.91">    /**</span>
<span class="source-line-no">092</span><span id="line.92">     * Number of entries in the set (including the key zero, if present).</span>
<span class="source-line-no">093</span><span id="line.93">     */</span>
<span class="source-line-no">094</span><span id="line.94">    protected int size;</span>
<span class="source-line-no">095</span><span id="line.95">    /**</span>
<span class="source-line-no">096</span><span id="line.96">     * The acceptable load factor.</span>
<span class="source-line-no">097</span><span id="line.97">     */</span>
<span class="source-line-no">098</span><span id="line.98">    public final float f;</span>
<span class="source-line-no">099</span><span id="line.99">    /**</span>
<span class="source-line-no">100</span><span id="line.100">     * Cached set of entries.</span>
<span class="source-line-no">101</span><span id="line.101">     */</span>
<span class="source-line-no">102</span><span id="line.102">    protected volatile MapEntrySet entries;</span>
<span class="source-line-no">103</span><span id="line.103">    /**</span>
<span class="source-line-no">104</span><span id="line.104">     * Cached set of keys.</span>
<span class="source-line-no">105</span><span id="line.105">     */</span>
<span class="source-line-no">106</span><span id="line.106">    protected volatile KeySet keys;</span>
<span class="source-line-no">107</span><span id="line.107">    /**</span>
<span class="source-line-no">108</span><span id="line.108">     * Cached collection of values.</span>
<span class="source-line-no">109</span><span id="line.109">     */</span>
<span class="source-line-no">110</span><span id="line.110">    protected volatile Collection&lt;V&gt; values;</span>
<span class="source-line-no">111</span><span id="line.111">    /**</span>
<span class="source-line-no">112</span><span id="line.112">     * Default return value.</span>
<span class="source-line-no">113</span><span id="line.113">     */</span>
<span class="source-line-no">114</span><span id="line.114">    protected V defRetValue;</span>
<span class="source-line-no">115</span><span id="line.115"></span>
<span class="source-line-no">116</span><span id="line.116">    /**</span>
<span class="source-line-no">117</span><span id="line.117">     * The initial default size of a hash table.</span>
<span class="source-line-no">118</span><span id="line.118">     */</span>
<span class="source-line-no">119</span><span id="line.119">    public static final int DEFAULT_INITIAL_SIZE = 16;</span>
<span class="source-line-no">120</span><span id="line.120">    /**</span>
<span class="source-line-no">121</span><span id="line.121">     * The default load factor of a hash table.</span>
<span class="source-line-no">122</span><span id="line.122">     */</span>
<span class="source-line-no">123</span><span id="line.123">    public static final float DEFAULT_LOAD_FACTOR = .375f; // .1875f; // .75f;</span>
<span class="source-line-no">124</span><span id="line.124">    /**</span>
<span class="source-line-no">125</span><span id="line.125">     * The load factor for a (usually small) table that is meant to be particularly fast.</span>
<span class="source-line-no">126</span><span id="line.126">     */</span>
<span class="source-line-no">127</span><span id="line.127">    public static final float FAST_LOAD_FACTOR = .5f;</span>
<span class="source-line-no">128</span><span id="line.128">    /**</span>
<span class="source-line-no">129</span><span id="line.129">     * The load factor for a (usually very small) table that is meant to be extremely fast.</span>
<span class="source-line-no">130</span><span id="line.130">     */</span>
<span class="source-line-no">131</span><span id="line.131">    public static final float VERY_FAST_LOAD_FACTOR = .25f;</span>
<span class="source-line-no">132</span><span id="line.132"></span>
<span class="source-line-no">133</span><span id="line.133">    protected final CrossHash.IHasher hasher;</span>
<span class="source-line-no">134</span><span id="line.134"></span>
<span class="source-line-no">135</span><span id="line.135">    public void defaultReturnValue(final V rv) {</span>
<span class="source-line-no">136</span><span id="line.136">        defRetValue = rv;</span>
<span class="source-line-no">137</span><span id="line.137">    }</span>
<span class="source-line-no">138</span><span id="line.138"></span>
<span class="source-line-no">139</span><span id="line.139">    public V defaultReturnValue() {</span>
<span class="source-line-no">140</span><span id="line.140">        return defRetValue;</span>
<span class="source-line-no">141</span><span id="line.141">    }</span>
<span class="source-line-no">142</span><span id="line.142"></span>
<span class="source-line-no">143</span><span id="line.143">    /**</span>
<span class="source-line-no">144</span><span id="line.144">     * Creates a new OrderedMap.</span>
<span class="source-line-no">145</span><span id="line.145">     * &lt;p&gt;</span>
<span class="source-line-no">146</span><span id="line.146">     * &lt;p&gt;The actual table size will be the least power of two greater than &lt;code&gt;expected&lt;/code&gt;/&lt;code&gt;f&lt;/code&gt;.</span>
<span class="source-line-no">147</span><span id="line.147">     *</span>
<span class="source-line-no">148</span><span id="line.148">     * @param expected the expected number of elements in the hash set.</span>
<span class="source-line-no">149</span><span id="line.149">     * @param f        the load factor.</span>
<span class="source-line-no">150</span><span id="line.150">     */</span>
<span class="source-line-no">151</span><span id="line.151"></span>
<span class="source-line-no">152</span><span id="line.152">    @SuppressWarnings("unchecked")</span>
<span class="source-line-no">153</span><span id="line.153">    public UnorderedMap(final int expected, final float f) {</span>
<span class="source-line-no">154</span><span id="line.154">        if (f &lt;= 0 || f &gt; 1)</span>
<span class="source-line-no">155</span><span id="line.155">            throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than or equal to 1");</span>
<span class="source-line-no">156</span><span id="line.156">        if (expected &lt; 0) throw new IllegalArgumentException("The expected number of elements must be nonnegative");</span>
<span class="source-line-no">157</span><span id="line.157">        this.f = f;</span>
<span class="source-line-no">158</span><span id="line.158">        n = arraySize(expected, f);</span>
<span class="source-line-no">159</span><span id="line.159">        mask = n - 1;</span>
<span class="source-line-no">160</span><span id="line.160">        maxFill = maxFill(n, f);</span>
<span class="source-line-no">161</span><span id="line.161">        key = (K[]) new Object[n + 1];</span>
<span class="source-line-no">162</span><span id="line.162">        value = (V[]) new Object[n + 1];</span>
<span class="source-line-no">163</span><span id="line.163">        hasher = CrossHash.mildHasher;</span>
<span class="source-line-no">164</span><span id="line.164">    }</span>
<span class="source-line-no">165</span><span id="line.165"></span>
<span class="source-line-no">166</span><span id="line.166">    /**</span>
<span class="source-line-no">167</span><span id="line.167">     * Creates a new OrderedMap with 0.75f as load factor.</span>
<span class="source-line-no">168</span><span id="line.168">     *</span>
<span class="source-line-no">169</span><span id="line.169">     * @param expected the expected number of elements in the OrderedMap.</span>
<span class="source-line-no">170</span><span id="line.170">     */</span>
<span class="source-line-no">171</span><span id="line.171">    public UnorderedMap(final int expected) {</span>
<span class="source-line-no">172</span><span id="line.172">        this(expected, DEFAULT_LOAD_FACTOR);</span>
<span class="source-line-no">173</span><span id="line.173">    }</span>
<span class="source-line-no">174</span><span id="line.174"></span>
<span class="source-line-no">175</span><span id="line.175">    /**</span>
<span class="source-line-no">176</span><span id="line.176">     * Creates a new OrderedMap with initial expected 16 entries and 0.75f as load factor.</span>
<span class="source-line-no">177</span><span id="line.177">     */</span>
<span class="source-line-no">178</span><span id="line.178">    public UnorderedMap() {</span>
<span class="source-line-no">179</span><span id="line.179">        this(DEFAULT_INITIAL_SIZE, DEFAULT_LOAD_FACTOR);</span>
<span class="source-line-no">180</span><span id="line.180">    }</span>
<span class="source-line-no">181</span><span id="line.181"></span>
<span class="source-line-no">182</span><span id="line.182">    /**</span>
<span class="source-line-no">183</span><span id="line.183">     * Creates a new OrderedMap copying a given one.</span>
<span class="source-line-no">184</span><span id="line.184">     *</span>
<span class="source-line-no">185</span><span id="line.185">     * @param m a {@link Map} to be copied into the new OrderedMap.</span>
<span class="source-line-no">186</span><span id="line.186">     * @param f the load factor.</span>
<span class="source-line-no">187</span><span id="line.187">     */</span>
<span class="source-line-no">188</span><span id="line.188">    public UnorderedMap(final Map&lt;? extends K, ? extends V&gt; m, final float f) {</span>
<span class="source-line-no">189</span><span id="line.189">        this(m.size(), f, (m instanceof UnorderedMap) ? ((UnorderedMap) m).hasher : CrossHash.mildHasher);</span>
<span class="source-line-no">190</span><span id="line.190">        putAll(m);</span>
<span class="source-line-no">191</span><span id="line.191">    }</span>
<span class="source-line-no">192</span><span id="line.192"></span>
<span class="source-line-no">193</span><span id="line.193">    /**</span>
<span class="source-line-no">194</span><span id="line.194">     * Creates a new OrderedMap with 0.75f as load factor copying a given one.</span>
<span class="source-line-no">195</span><span id="line.195">     *</span>
<span class="source-line-no">196</span><span id="line.196">     * @param m a {@link Map} to be copied into the new OrderedMap.</span>
<span class="source-line-no">197</span><span id="line.197">     */</span>
<span class="source-line-no">198</span><span id="line.198">    public UnorderedMap(final Map&lt;? extends K, ? extends V&gt; m) {</span>
<span class="source-line-no">199</span><span id="line.199">        this(m, (m instanceof UnorderedMap) ? ((UnorderedMap) m).f : DEFAULT_LOAD_FACTOR, (m instanceof UnorderedMap) ? ((UnorderedMap) m).hasher : CrossHash.mildHasher);</span>
<span class="source-line-no">200</span><span id="line.200">    }</span>
<span class="source-line-no">201</span><span id="line.201"></span>
<span class="source-line-no">202</span><span id="line.202">    /**</span>
<span class="source-line-no">203</span><span id="line.203">     * Creates a new OrderedMap using the elements of two parallel arrays.</span>
<span class="source-line-no">204</span><span id="line.204">     *</span>
<span class="source-line-no">205</span><span id="line.205">     * @param keyArray the array of keys of the new OrderedMap.</span>
<span class="source-line-no">206</span><span id="line.206">     * @param valueArray the array of corresponding values in the new OrderedMap.</span>
<span class="source-line-no">207</span><span id="line.207">     * @param f the load factor.</span>
<span class="source-line-no">208</span><span id="line.208">     * @throws IllegalArgumentException if &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; have different lengths.</span>
<span class="source-line-no">209</span><span id="line.209">     */</span>
<span class="source-line-no">210</span><span id="line.210">    public UnorderedMap(final K[] keyArray, final V[] valueArray, final float f) {</span>
<span class="source-line-no">211</span><span id="line.211">        this(keyArray.length, f);</span>
<span class="source-line-no">212</span><span id="line.212">        if (keyArray.length != valueArray.length)</span>
<span class="source-line-no">213</span><span id="line.213">            throw new IllegalArgumentException("The key array and the value array have different lengths (" + keyArray.length + " and " + valueArray.length + ")");</span>
<span class="source-line-no">214</span><span id="line.214">        for (int i = 0; i &lt; keyArray.length; i++)</span>
<span class="source-line-no">215</span><span id="line.215">            put(keyArray[i], valueArray[i]);</span>
<span class="source-line-no">216</span><span id="line.216">    }</span>
<span class="source-line-no">217</span><span id="line.217">    /**</span>
<span class="source-line-no">218</span><span id="line.218">     * Creates a new OrderedMap using the elements of two parallel arrays.</span>
<span class="source-line-no">219</span><span id="line.219">     *</span>
<span class="source-line-no">220</span><span id="line.220">     * @param keyColl the collection of keys of the new OrderedMap.</span>
<span class="source-line-no">221</span><span id="line.221">     * @param valueColl the collection of corresponding values in the new OrderedMap.</span>
<span class="source-line-no">222</span><span id="line.222">     * @throws IllegalArgumentException if &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; have different lengths.</span>
<span class="source-line-no">223</span><span id="line.223">     */</span>
<span class="source-line-no">224</span><span id="line.224">    public UnorderedMap(final Collection&lt;K&gt; keyColl, final Collection&lt;V&gt; valueColl) {</span>
<span class="source-line-no">225</span><span id="line.225">        this(keyColl, valueColl, DEFAULT_LOAD_FACTOR);</span>
<span class="source-line-no">226</span><span id="line.226">    }</span>
<span class="source-line-no">227</span><span id="line.227">        /**</span>
<span class="source-line-no">228</span><span id="line.228">         * Creates a new OrderedMap using the elements of two parallel arrays.</span>
<span class="source-line-no">229</span><span id="line.229">         *</span>
<span class="source-line-no">230</span><span id="line.230">         * @param keyColl the collection of keys of the new OrderedMap.</span>
<span class="source-line-no">231</span><span id="line.231">         * @param valueColl the collection of corresponding values in the new OrderedMap.</span>
<span class="source-line-no">232</span><span id="line.232">         * @param f the load factor.</span>
<span class="source-line-no">233</span><span id="line.233">         * @throws IllegalArgumentException if &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; have different lengths.</span>
<span class="source-line-no">234</span><span id="line.234">         */</span>
<span class="source-line-no">235</span><span id="line.235">    public UnorderedMap(final Collection&lt;K&gt; keyColl, final Collection&lt;V&gt; valueColl, final float f) {</span>
<span class="source-line-no">236</span><span id="line.236">        this(keyColl.size(), f);</span>
<span class="source-line-no">237</span><span id="line.237">        if (keyColl.size() != valueColl.size())</span>
<span class="source-line-no">238</span><span id="line.238">            throw new IllegalArgumentException("The key array and the value array have different lengths (" + keyColl.size() + " and " + valueColl.size() + ")");</span>
<span class="source-line-no">239</span><span id="line.239">        Iterator&lt;K&gt; ki = keyColl.iterator();</span>
<span class="source-line-no">240</span><span id="line.240">        Iterator&lt;V&gt; vi = valueColl.iterator();</span>
<span class="source-line-no">241</span><span id="line.241">        while (ki.hasNext() &amp;&amp; vi.hasNext())</span>
<span class="source-line-no">242</span><span id="line.242">        {</span>
<span class="source-line-no">243</span><span id="line.243">            put(ki.next(), vi.next());</span>
<span class="source-line-no">244</span><span id="line.244">        }</span>
<span class="source-line-no">245</span><span id="line.245">    }</span>
<span class="source-line-no">246</span><span id="line.246"></span>
<span class="source-line-no">247</span><span id="line.247">    /**</span>
<span class="source-line-no">248</span><span id="line.248">     * Creates a new OrderedMap with 0.75f as load factor using the elements of two parallel arrays.</span>
<span class="source-line-no">249</span><span id="line.249">     *</span>
<span class="source-line-no">250</span><span id="line.250">     * @param keyArray the array of keys of the new OrderedMap.</span>
<span class="source-line-no">251</span><span id="line.251">     * @param valueArray the array of corresponding values in the new OrderedMap.</span>
<span class="source-line-no">252</span><span id="line.252">     * @throws IllegalArgumentException if &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; have different lengths.</span>
<span class="source-line-no">253</span><span id="line.253">     */</span>
<span class="source-line-no">254</span><span id="line.254">    public UnorderedMap(final K[] keyArray, final V[] valueArray) {</span>
<span class="source-line-no">255</span><span id="line.255">        this(keyArray, valueArray, DEFAULT_LOAD_FACTOR);</span>
<span class="source-line-no">256</span><span id="line.256">    }</span>
<span class="source-line-no">257</span><span id="line.257"></span>
<span class="source-line-no">258</span><span id="line.258">    /**</span>
<span class="source-line-no">259</span><span id="line.259">     * Creates a new OrderedMap.</span>
<span class="source-line-no">260</span><span id="line.260">     * &lt;p&gt;</span>
<span class="source-line-no">261</span><span id="line.261">     * &lt;p&gt;The actual table size will be the least power of two greater than &lt;code&gt;expected&lt;/code&gt;/&lt;code&gt;f&lt;/code&gt;.</span>
<span class="source-line-no">262</span><span id="line.262">     *</span>
<span class="source-line-no">263</span><span id="line.263">     * @param expected the expected number of elements in the hash set.</span>
<span class="source-line-no">264</span><span id="line.264">     * @param f        the load factor.</span>
<span class="source-line-no">265</span><span id="line.265">     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations</span>
<span class="source-line-no">266</span><span id="line.266">     */</span>
<span class="source-line-no">267</span><span id="line.267"></span>
<span class="source-line-no">268</span><span id="line.268">    @SuppressWarnings("unchecked")</span>
<span class="source-line-no">269</span><span id="line.269">    public UnorderedMap(final int expected, final float f, CrossHash.IHasher hasher) {</span>
<span class="source-line-no">270</span><span id="line.270">        if (f &lt;= 0 || f &gt; 1)</span>
<span class="source-line-no">271</span><span id="line.271">            throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than or equal to 1");</span>
<span class="source-line-no">272</span><span id="line.272">        if (expected &lt; 0) throw new IllegalArgumentException("The expected number of elements must be nonnegative");</span>
<span class="source-line-no">273</span><span id="line.273">        this.f = f;</span>
<span class="source-line-no">274</span><span id="line.274">        n = arraySize(expected, f);</span>
<span class="source-line-no">275</span><span id="line.275">        mask = n - 1;</span>
<span class="source-line-no">276</span><span id="line.276">        maxFill = maxFill(n, f);</span>
<span class="source-line-no">277</span><span id="line.277">        key = (K[]) new Object[n + 1];</span>
<span class="source-line-no">278</span><span id="line.278">        value = (V[]) new Object[n + 1];</span>
<span class="source-line-no">279</span><span id="line.279">        this.hasher = (hasher == null) ? CrossHash.mildHasher : hasher;</span>
<span class="source-line-no">280</span><span id="line.280">    }</span>
<span class="source-line-no">281</span><span id="line.281">    /**</span>
<span class="source-line-no">282</span><span id="line.282">     * Creates a new OrderedMap with 0.75f as load factor.</span>
<span class="source-line-no">283</span><span id="line.283">     *</span>
<span class="source-line-no">284</span><span id="line.284">     * @param expected the expected number of elements in the OrderedMap.</span>
<span class="source-line-no">285</span><span id="line.285">     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations</span>
<span class="source-line-no">286</span><span id="line.286">     */</span>
<span class="source-line-no">287</span><span id="line.287">    public UnorderedMap(final int expected, CrossHash.IHasher hasher) {</span>
<span class="source-line-no">288</span><span id="line.288">        this(expected, DEFAULT_LOAD_FACTOR, hasher);</span>
<span class="source-line-no">289</span><span id="line.289">    }</span>
<span class="source-line-no">290</span><span id="line.290"></span>
<span class="source-line-no">291</span><span id="line.291">    /**</span>
<span class="source-line-no">292</span><span id="line.292">     * Creates a new OrderedMap with initial expected 16 entries and 0.75f as load factor.</span>
<span class="source-line-no">293</span><span id="line.293">     */</span>
<span class="source-line-no">294</span><span id="line.294">    public UnorderedMap(CrossHash.IHasher hasher) {</span>
<span class="source-line-no">295</span><span id="line.295">        this(DEFAULT_INITIAL_SIZE, DEFAULT_LOAD_FACTOR, hasher);</span>
<span class="source-line-no">296</span><span id="line.296">    }</span>
<span class="source-line-no">297</span><span id="line.297"></span>
<span class="source-line-no">298</span><span id="line.298">    /**</span>
<span class="source-line-no">299</span><span id="line.299">     * Creates a new OrderedMap copying a given one.</span>
<span class="source-line-no">300</span><span id="line.300">     *</span>
<span class="source-line-no">301</span><span id="line.301">     * @param m a {@link Map} to be copied into the new OrderedMap.</span>
<span class="source-line-no">302</span><span id="line.302">     * @param f the load factor.</span>
<span class="source-line-no">303</span><span id="line.303">     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations</span>
<span class="source-line-no">304</span><span id="line.304">     */</span>
<span class="source-line-no">305</span><span id="line.305">    public UnorderedMap(final Map&lt;? extends K, ? extends V&gt; m, final float f, CrossHash.IHasher hasher) {</span>
<span class="source-line-no">306</span><span id="line.306">        this(m.size(), f, hasher);</span>
<span class="source-line-no">307</span><span id="line.307">        putAll(m);</span>
<span class="source-line-no">308</span><span id="line.308">    }</span>
<span class="source-line-no">309</span><span id="line.309"></span>
<span class="source-line-no">310</span><span id="line.310">    /**</span>
<span class="source-line-no">311</span><span id="line.311">     * Creates a new OrderedMap with 0.75f as load factor copying a given one.</span>
<span class="source-line-no">312</span><span id="line.312">     * @param m a {@link Map} to be copied into the new OrderedMap.</span>
<span class="source-line-no">313</span><span id="line.313">     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations</span>
<span class="source-line-no">314</span><span id="line.314">     */</span>
<span class="source-line-no">315</span><span id="line.315">    public UnorderedMap(final Map&lt;? extends K, ? extends V&gt; m, CrossHash.IHasher hasher) {</span>
<span class="source-line-no">316</span><span id="line.316">        this(m, DEFAULT_LOAD_FACTOR, hasher);</span>
<span class="source-line-no">317</span><span id="line.317">    }</span>
<span class="source-line-no">318</span><span id="line.318"></span>
<span class="source-line-no">319</span><span id="line.319">    /**</span>
<span class="source-line-no">320</span><span id="line.320">     * Creates a new OrderedMap using the elements of two parallel arrays.</span>
<span class="source-line-no">321</span><span id="line.321">     *</span>
<span class="source-line-no">322</span><span id="line.322">     * @param keyArray the array of keys of the new OrderedMap.</span>
<span class="source-line-no">323</span><span id="line.323">     * @param valueArray the array of corresponding values in the new OrderedMap.</span>
<span class="source-line-no">324</span><span id="line.324">     * @param f the load factor.</span>
<span class="source-line-no">325</span><span id="line.325">     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations</span>
<span class="source-line-no">326</span><span id="line.326">     * @throws IllegalArgumentException if &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; have different lengths.</span>
<span class="source-line-no">327</span><span id="line.327">     */</span>
<span class="source-line-no">328</span><span id="line.328">    public UnorderedMap(final K[] keyArray, final V[] valueArray, final float f, CrossHash.IHasher hasher) {</span>
<span class="source-line-no">329</span><span id="line.329">        this(keyArray.length, f, hasher);</span>
<span class="source-line-no">330</span><span id="line.330">        if (keyArray.length != valueArray.length)</span>
<span class="source-line-no">331</span><span id="line.331">            throw new IllegalArgumentException("The key array and the value array have different lengths (" + keyArray.length + " and " + valueArray.length + ")");</span>
<span class="source-line-no">332</span><span id="line.332">        for (int i = 0; i &lt; keyArray.length; i++)</span>
<span class="source-line-no">333</span><span id="line.333">            put(keyArray[i], valueArray[i]);</span>
<span class="source-line-no">334</span><span id="line.334">    }</span>
<span class="source-line-no">335</span><span id="line.335">    /**</span>
<span class="source-line-no">336</span><span id="line.336">     * Creates a new OrderedMap with 0.75f as load factor using the elements of two parallel arrays.</span>
<span class="source-line-no">337</span><span id="line.337">     *</span>
<span class="source-line-no">338</span><span id="line.338">     * @param keyArray the array of keys of the new OrderedMap.</span>
<span class="source-line-no">339</span><span id="line.339">     * @param valueArray the array of corresponding values in the new OrderedMap.</span>
<span class="source-line-no">340</span><span id="line.340">     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations</span>
<span class="source-line-no">341</span><span id="line.341">     * @throws IllegalArgumentException if &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; have different lengths.</span>
<span class="source-line-no">342</span><span id="line.342">     */</span>
<span class="source-line-no">343</span><span id="line.343">    public UnorderedMap(final K[] keyArray, final V[] valueArray, CrossHash.IHasher hasher) {</span>
<span class="source-line-no">344</span><span id="line.344">        this(keyArray, valueArray, DEFAULT_LOAD_FACTOR, hasher);</span>
<span class="source-line-no">345</span><span id="line.345">    }</span>
<span class="source-line-no">346</span><span id="line.346"></span>
<span class="source-line-no">347</span><span id="line.347">    private int realSize() {</span>
<span class="source-line-no">348</span><span id="line.348">        return containsNullKey ? size - 1 : size;</span>
<span class="source-line-no">349</span><span id="line.349">    }</span>
<span class="source-line-no">350</span><span id="line.350">    private void ensureCapacity(final int capacity) {</span>
<span class="source-line-no">351</span><span id="line.351">        final int needed = arraySize(capacity, f);</span>
<span class="source-line-no">352</span><span id="line.352">        if (needed &gt; n)</span>
<span class="source-line-no">353</span><span id="line.353">            rehash(needed);</span>
<span class="source-line-no">354</span><span id="line.354">    }</span>
<span class="source-line-no">355</span><span id="line.355">    private void tryCapacity(final long capacity) {</span>
<span class="source-line-no">356</span><span id="line.356">        final int needed = (int) Math.min(</span>
<span class="source-line-no">357</span><span id="line.357">                1 &lt;&lt; 30,</span>
<span class="source-line-no">358</span><span id="line.358">                Math.max(2, HashCommon.nextPowerOfTwo((long) Math.ceil(capacity</span>
<span class="source-line-no">359</span><span id="line.359">                        / f))));</span>
<span class="source-line-no">360</span><span id="line.360">        if (needed &gt; n)</span>
<span class="source-line-no">361</span><span id="line.361">            rehash(needed);</span>
<span class="source-line-no">362</span><span id="line.362">    }</span>
<span class="source-line-no">363</span><span id="line.363">    private V removeEntry(final int pos) {</span>
<span class="source-line-no">364</span><span id="line.364">        final V oldValue = value[pos];</span>
<span class="source-line-no">365</span><span id="line.365">        value[pos] = null;</span>
<span class="source-line-no">366</span><span id="line.366">        size--;</span>
<span class="source-line-no">367</span><span id="line.367">        shiftKeys(pos);</span>
<span class="source-line-no">368</span><span id="line.368">        if (size &lt; maxFill / 4 &amp;&amp; n &gt; DEFAULT_INITIAL_SIZE)</span>
<span class="source-line-no">369</span><span id="line.369">            rehash(n / 2);</span>
<span class="source-line-no">370</span><span id="line.370">        return oldValue;</span>
<span class="source-line-no">371</span><span id="line.371">    }</span>
<span class="source-line-no">372</span><span id="line.372">    private V removeNullEntry() {</span>
<span class="source-line-no">373</span><span id="line.373">        containsNullKey = false;</span>
<span class="source-line-no">374</span><span id="line.374">        key[n] = null;</span>
<span class="source-line-no">375</span><span id="line.375">        final V oldValue = value[n];</span>
<span class="source-line-no">376</span><span id="line.376">        value[n] = null;</span>
<span class="source-line-no">377</span><span id="line.377">        size--;</span>
<span class="source-line-no">378</span><span id="line.378">        if (size &lt; maxFill / 4 &amp;&amp; n &gt; DEFAULT_INITIAL_SIZE)</span>
<span class="source-line-no">379</span><span id="line.379">            rehash(n / 2);</span>
<span class="source-line-no">380</span><span id="line.380">        return oldValue;</span>
<span class="source-line-no">381</span><span id="line.381">    }</span>
<span class="source-line-no">382</span><span id="line.382"></span>
<span class="source-line-no">383</span><span id="line.383">    /**</span>
<span class="source-line-no">384</span><span id="line.384">     * Puts the first key in keyArray with the first value in valueArray, then the second in each and so on.</span>
<span class="source-line-no">385</span><span id="line.385">     * The entries are all appended to the end of the iteration order, unless a key was already present. Then,</span>
<span class="source-line-no">386</span><span id="line.386">     * its value is changed at the existing position in the iteration order.</span>
<span class="source-line-no">387</span><span id="line.387">     * If the lengths of the two arrays are not equal, this puts a number of entries equal to the lesser length.</span>
<span class="source-line-no">388</span><span id="line.388">     * If either array is null, this returns without performing any changes.</span>
<span class="source-line-no">389</span><span id="line.389">     * @param keyArray an array of K keys that should usually have the same length as valueArray</span>
<span class="source-line-no">390</span><span id="line.390">     * @param valueArray an array of V values that should usually have the same length as keyArray</span>
<span class="source-line-no">391</span><span id="line.391">     */</span>
<span class="source-line-no">392</span><span id="line.392">    public void putAll(final K[] keyArray, final V[] valueArray)</span>
<span class="source-line-no">393</span><span id="line.393">    {</span>
<span class="source-line-no">394</span><span id="line.394">        if(keyArray == null || valueArray == null)</span>
<span class="source-line-no">395</span><span id="line.395">            return;</span>
<span class="source-line-no">396</span><span id="line.396">        for (int i = 0; i &lt; keyArray.length &amp;&amp; i &lt; valueArray.length; i++)</span>
<span class="source-line-no">397</span><span id="line.397">            put(keyArray[i], valueArray[i]);</span>
<span class="source-line-no">398</span><span id="line.398"></span>
<span class="source-line-no">399</span><span id="line.399">    }</span>
<span class="source-line-no">400</span><span id="line.400"></span>
<span class="source-line-no">401</span><span id="line.401">    /**</span>
<span class="source-line-no">402</span><span id="line.402">     * Puts all key-value pairs in the Map m into this OrderedMap.</span>
<span class="source-line-no">403</span><span id="line.403">     * The entries are all appended to the end of the iteration order, unless a key was already present. Then,</span>
<span class="source-line-no">404</span><span id="line.404">     * its value is changed at the existing position in the iteration order. This can take any kind of Map,</span>
<span class="source-line-no">405</span><span id="line.405">     * including unordered HashMap objects; if the Map does not have stable ordering, the order in which entries</span>
<span class="source-line-no">406</span><span id="line.406">     * will be appended is not stable either. For this reason, OrderedMap, LinkedHashMap, and TreeMap (or other</span>
<span class="source-line-no">407</span><span id="line.407">     * SortedMap implementations) will work best when order matters.</span>
<span class="source-line-no">408</span><span id="line.408">     * @param m a Map that should have the same or compatible K key and V value types; OrderedMap and TreeMap work best</span>
<span class="source-line-no">409</span><span id="line.409">     */</span>
<span class="source-line-no">410</span><span id="line.410">    public void putAll(Map&lt;? extends K, ? extends V&gt; m) {</span>
<span class="source-line-no">411</span><span id="line.411">        if (f &lt;= .5)</span>
<span class="source-line-no">412</span><span id="line.412">            ensureCapacity(m.size()); // The resulting map will be sized for</span>
<span class="source-line-no">413</span><span id="line.413">            // m.size() elements</span>
<span class="source-line-no">414</span><span id="line.414">        else</span>
<span class="source-line-no">415</span><span id="line.415">            tryCapacity(size() + m.size()); // The resulting map will be</span>
<span class="source-line-no">416</span><span id="line.416">        int n = m.size();</span>
<span class="source-line-no">417</span><span id="line.417">        final Iterator&lt;? extends Entry&lt;? extends K, ? extends V&gt;&gt; i = m</span>
<span class="source-line-no">418</span><span id="line.418">                .entrySet().iterator();</span>
<span class="source-line-no">419</span><span id="line.419">        Entry&lt;? extends K, ? extends V&gt; e;</span>
<span class="source-line-no">420</span><span id="line.420">        while (n-- != 0) {</span>
<span class="source-line-no">421</span><span id="line.421">            e = i.next();</span>
<span class="source-line-no">422</span><span id="line.422">            put(e.getKey(), e.getValue());</span>
<span class="source-line-no">423</span><span id="line.423">        }</span>
<span class="source-line-no">424</span><span id="line.424">    }</span>
<span class="source-line-no">425</span><span id="line.425">    private int insert(final K k, final V v) {</span>
<span class="source-line-no">426</span><span id="line.426">        int pos;</span>
<span class="source-line-no">427</span><span id="line.427">        if (k == null) {</span>
<span class="source-line-no">428</span><span id="line.428">            if (containsNullKey)</span>
<span class="source-line-no">429</span><span id="line.429">                return n;</span>
<span class="source-line-no">430</span><span id="line.430">            containsNullKey = true;</span>
<span class="source-line-no">431</span><span id="line.431">            pos = n;</span>
<span class="source-line-no">432</span><span id="line.432">        } else {</span>
<span class="source-line-no">433</span><span id="line.433">            K curr;</span>
<span class="source-line-no">434</span><span id="line.434">            final K[] key = this.key;</span>
<span class="source-line-no">435</span><span id="line.435">            // The starting point.</span>
<span class="source-line-no">436</span><span id="line.436">            if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) != null) {</span>
<span class="source-line-no">437</span><span id="line.437">                if (hasher.areEqual(curr, k))</span>
<span class="source-line-no">438</span><span id="line.438">                    return pos;</span>
<span class="source-line-no">439</span><span id="line.439">                while ((curr = key[pos = (pos + 1) &amp; mask]) != null)</span>
<span class="source-line-no">440</span><span id="line.440">                    if (hasher.areEqual(curr, k))</span>
<span class="source-line-no">441</span><span id="line.441">                        return pos;</span>
<span class="source-line-no">442</span><span id="line.442">            }</span>
<span class="source-line-no">443</span><span id="line.443">        }</span>
<span class="source-line-no">444</span><span id="line.444">        key[pos] = k;</span>
<span class="source-line-no">445</span><span id="line.445">        value[pos] = v;</span>
<span class="source-line-no">446</span><span id="line.446">        if (size++ &gt;= maxFill)</span>
<span class="source-line-no">447</span><span id="line.447">            rehash(arraySize(size + 1, f));</span>
<span class="source-line-no">448</span><span id="line.448">        return -1;</span>
<span class="source-line-no">449</span><span id="line.449">    }</span>
<span class="source-line-no">450</span><span id="line.450">    public V put(final K k, final V v) {</span>
<span class="source-line-no">451</span><span id="line.451">        final int pos = insert(k, v);</span>
<span class="source-line-no">452</span><span id="line.452">        if (pos &lt; 0)</span>
<span class="source-line-no">453</span><span id="line.453">            return defRetValue;</span>
<span class="source-line-no">454</span><span id="line.454">        final V oldValue = value[pos];</span>
<span class="source-line-no">455</span><span id="line.455">        value[pos] = v;</span>
<span class="source-line-no">456</span><span id="line.456">        return oldValue;</span>
<span class="source-line-no">457</span><span id="line.457">    }</span>
<span class="source-line-no">458</span><span id="line.458">    /**</span>
<span class="source-line-no">459</span><span id="line.459">     * Shifts left entries with the specified hash code, starting at the</span>
<span class="source-line-no">460</span><span id="line.460">     * specified position, and empties the resulting free entry.</span>
<span class="source-line-no">461</span><span id="line.461">     *</span>
<span class="source-line-no">462</span><span id="line.462">     * @param pos</span>
<span class="source-line-no">463</span><span id="line.463">     *            a starting position.</span>
<span class="source-line-no">464</span><span id="line.464">     */</span>
<span class="source-line-no">465</span><span id="line.465">    protected final void shiftKeys(int pos) {</span>
<span class="source-line-no">466</span><span id="line.466">        // Shift entries with the same hash.</span>
<span class="source-line-no">467</span><span id="line.467">        int last, slot;</span>
<span class="source-line-no">468</span><span id="line.468">        K curr;</span>
<span class="source-line-no">469</span><span id="line.469">        final K[] key = this.key;</span>
<span class="source-line-no">470</span><span id="line.470">        for (;;) {</span>
<span class="source-line-no">471</span><span id="line.471">            pos = ((last = pos) + 1) &amp; mask;</span>
<span class="source-line-no">472</span><span id="line.472">            for (;;) {</span>
<span class="source-line-no">473</span><span id="line.473">                if ((curr = key[pos]) == null) {</span>
<span class="source-line-no">474</span><span id="line.474">                    key[last] = null;</span>
<span class="source-line-no">475</span><span id="line.475">                    value[last] = null;</span>
<span class="source-line-no">476</span><span id="line.476">                    return;</span>
<span class="source-line-no">477</span><span id="line.477">                }</span>
<span class="source-line-no">478</span><span id="line.478">                slot = (hasher.hash(curr))</span>
<span class="source-line-no">479</span><span id="line.479">                        &amp; mask;</span>
<span class="source-line-no">480</span><span id="line.480">                if (last &lt;= pos ? last &gt;= slot || slot &gt; pos : last &gt;= slot</span>
<span class="source-line-no">481</span><span id="line.481">                        &amp;&amp; slot &gt; pos)</span>
<span class="source-line-no">482</span><span id="line.482">                    break;</span>
<span class="source-line-no">483</span><span id="line.483">                pos = (pos + 1) &amp; mask;</span>
<span class="source-line-no">484</span><span id="line.484">            }</span>
<span class="source-line-no">485</span><span id="line.485">            key[last] = curr;</span>
<span class="source-line-no">486</span><span id="line.486">            value[last] = value[pos];</span>
<span class="source-line-no">487</span><span id="line.487">        }</span>
<span class="source-line-no">488</span><span id="line.488">    }</span>
<span class="source-line-no">489</span><span id="line.489">    public V remove(final Object k) {</span>
<span class="source-line-no">490</span><span id="line.490">        if (k == null) {</span>
<span class="source-line-no">491</span><span id="line.491">            if (containsNullKey)</span>
<span class="source-line-no">492</span><span id="line.492">                return removeNullEntry();</span>
<span class="source-line-no">493</span><span id="line.493">            return defRetValue;</span>
<span class="source-line-no">494</span><span id="line.494">        }</span>
<span class="source-line-no">495</span><span id="line.495">        K curr;</span>
<span class="source-line-no">496</span><span id="line.496">        final K[] key = this.key;</span>
<span class="source-line-no">497</span><span id="line.497">        int pos;</span>
<span class="source-line-no">498</span><span id="line.498">        // The starting point.</span>
<span class="source-line-no">499</span><span id="line.499">        if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)</span>
<span class="source-line-no">500</span><span id="line.500">            return defRetValue;</span>
<span class="source-line-no">501</span><span id="line.501">        if (hasher.areEqual(k, curr))</span>
<span class="source-line-no">502</span><span id="line.502">            return removeEntry(pos);</span>
<span class="source-line-no">503</span><span id="line.503">        while (true) {</span>
<span class="source-line-no">504</span><span id="line.504">            if ((curr = key[pos = (pos + 1) &amp; mask]) == null)</span>
<span class="source-line-no">505</span><span id="line.505">                return defRetValue;</span>
<span class="source-line-no">506</span><span id="line.506">            if (hasher.areEqual(k, curr))</span>
<span class="source-line-no">507</span><span id="line.507">                return removeEntry(pos);</span>
<span class="source-line-no">508</span><span id="line.508">        }</span>
<span class="source-line-no">509</span><span id="line.509">    }</span>
<span class="source-line-no">510</span><span id="line.510">    private V setValue(final int pos, final V v) {</span>
<span class="source-line-no">511</span><span id="line.511">        final V oldValue = value[pos];</span>
<span class="source-line-no">512</span><span id="line.512">        value[pos] = v;</span>
<span class="source-line-no">513</span><span id="line.513">        return oldValue;</span>
<span class="source-line-no">514</span><span id="line.514">    }</span>
<span class="source-line-no">515</span><span id="line.515">    public V get(final Object k) {</span>
<span class="source-line-no">516</span><span id="line.516">        if (k == null)</span>
<span class="source-line-no">517</span><span id="line.517">            return containsNullKey ? value[n] : defRetValue;</span>
<span class="source-line-no">518</span><span id="line.518">        K curr;</span>
<span class="source-line-no">519</span><span id="line.519">        final K[] key = this.key;</span>
<span class="source-line-no">520</span><span id="line.520">        int pos;</span>
<span class="source-line-no">521</span><span id="line.521">        // The starting point.</span>
<span class="source-line-no">522</span><span id="line.522">        if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)</span>
<span class="source-line-no">523</span><span id="line.523">            return defRetValue;</span>
<span class="source-line-no">524</span><span id="line.524">        if (hasher.areEqual(k, curr))</span>
<span class="source-line-no">525</span><span id="line.525">            return value[pos];</span>
<span class="source-line-no">526</span><span id="line.526">        // There's always an unused entry.</span>
<span class="source-line-no">527</span><span id="line.527">        while (true) {</span>
<span class="source-line-no">528</span><span id="line.528">            if ((curr = key[pos = (pos + 1) &amp; mask]) == null)</span>
<span class="source-line-no">529</span><span id="line.529">                return defRetValue;</span>
<span class="source-line-no">530</span><span id="line.530">            if (hasher.areEqual(k, curr))</span>
<span class="source-line-no">531</span><span id="line.531">                return value[pos];</span>
<span class="source-line-no">532</span><span id="line.532">        }</span>
<span class="source-line-no">533</span><span id="line.533">    }</span>
<span class="source-line-no">534</span><span id="line.534"></span>
<span class="source-line-no">535</span><span id="line.535"></span>
<span class="source-line-no">536</span><span id="line.536">    public V getOrDefault(final Object k, final V defaultValue) {</span>
<span class="source-line-no">537</span><span id="line.537">        if (k == null)</span>
<span class="source-line-no">538</span><span id="line.538">            return containsNullKey ? value[n] : defaultValue;</span>
<span class="source-line-no">539</span><span id="line.539">        K curr;</span>
<span class="source-line-no">540</span><span id="line.540">        final K[] key = this.key;</span>
<span class="source-line-no">541</span><span id="line.541">        int pos;</span>
<span class="source-line-no">542</span><span id="line.542">        // The starting point.</span>
<span class="source-line-no">543</span><span id="line.543">        if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)</span>
<span class="source-line-no">544</span><span id="line.544">            return defaultValue;</span>
<span class="source-line-no">545</span><span id="line.545">        if (hasher.areEqual(k, curr))</span>
<span class="source-line-no">546</span><span id="line.546">            return value[pos];</span>
<span class="source-line-no">547</span><span id="line.547">        // There's always an unused entry.</span>
<span class="source-line-no">548</span><span id="line.548">        while (true) {</span>
<span class="source-line-no">549</span><span id="line.549">            if ((curr = key[pos = (pos + 1) &amp; mask]) == null)</span>
<span class="source-line-no">550</span><span id="line.550">                return defaultValue;</span>
<span class="source-line-no">551</span><span id="line.551">            if (hasher.areEqual(k, curr))</span>
<span class="source-line-no">552</span><span id="line.552">                return value[pos];</span>
<span class="source-line-no">553</span><span id="line.553">        }</span>
<span class="source-line-no">554</span><span id="line.554">    }</span>
<span class="source-line-no">555</span><span id="line.555"></span>
<span class="source-line-no">556</span><span id="line.556">    protected int positionOf(final Object k) {</span>
<span class="source-line-no">557</span><span id="line.557">        if (k == null)</span>
<span class="source-line-no">558</span><span id="line.558">        {</span>
<span class="source-line-no">559</span><span id="line.559">            if(containsNullKey)</span>
<span class="source-line-no">560</span><span id="line.560">                return n;</span>
<span class="source-line-no">561</span><span id="line.561">            else</span>
<span class="source-line-no">562</span><span id="line.562">                return -1;</span>
<span class="source-line-no">563</span><span id="line.563">        }</span>
<span class="source-line-no">564</span><span id="line.564">        K curr;</span>
<span class="source-line-no">565</span><span id="line.565">        final K[] key = this.key;</span>
<span class="source-line-no">566</span><span id="line.566">        int pos;</span>
<span class="source-line-no">567</span><span id="line.567">        // The starting point.</span>
<span class="source-line-no">568</span><span id="line.568">        if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)</span>
<span class="source-line-no">569</span><span id="line.569">            return -1;</span>
<span class="source-line-no">570</span><span id="line.570">        if (hasher.areEqual(k, curr))</span>
<span class="source-line-no">571</span><span id="line.571">            return pos;</span>
<span class="source-line-no">572</span><span id="line.572">        // There's always an unused entry.</span>
<span class="source-line-no">573</span><span id="line.573">        while (true) {</span>
<span class="source-line-no">574</span><span id="line.574">            if ((curr = key[pos = pos + 1 &amp; mask]) == null)</span>
<span class="source-line-no">575</span><span id="line.575">                return -1;</span>
<span class="source-line-no">576</span><span id="line.576">            if (hasher.areEqual(k, curr))</span>
<span class="source-line-no">577</span><span id="line.577">                return pos;</span>
<span class="source-line-no">578</span><span id="line.578">        }</span>
<span class="source-line-no">579</span><span id="line.579">    }</span>
<span class="source-line-no">580</span><span id="line.580"></span>
<span class="source-line-no">581</span><span id="line.581">    public boolean containsKey(final Object k) {</span>
<span class="source-line-no">582</span><span id="line.582">        if (k == null)</span>
<span class="source-line-no">583</span><span id="line.583">            return containsNullKey;</span>
<span class="source-line-no">584</span><span id="line.584">        K curr;</span>
<span class="source-line-no">585</span><span id="line.585">        final K[] key = this.key;</span>
<span class="source-line-no">586</span><span id="line.586">        int pos;</span>
<span class="source-line-no">587</span><span id="line.587">        // The starting point.</span>
<span class="source-line-no">588</span><span id="line.588">        if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)</span>
<span class="source-line-no">589</span><span id="line.589">            return false;</span>
<span class="source-line-no">590</span><span id="line.590">        if (hasher.areEqual(k, curr))</span>
<span class="source-line-no">591</span><span id="line.591">            return true;</span>
<span class="source-line-no">592</span><span id="line.592">        // There's always an unused entry.</span>
<span class="source-line-no">593</span><span id="line.593">        while (true) {</span>
<span class="source-line-no">594</span><span id="line.594">            if ((curr = key[pos = (pos + 1) &amp; mask]) == null)</span>
<span class="source-line-no">595</span><span id="line.595">                return false;</span>
<span class="source-line-no">596</span><span id="line.596">            if (hasher.areEqual(k, curr))</span>
<span class="source-line-no">597</span><span id="line.597">                return true;</span>
<span class="source-line-no">598</span><span id="line.598">        }</span>
<span class="source-line-no">599</span><span id="line.599">    }</span>
<span class="source-line-no">600</span><span id="line.600">    public boolean containsValue(final Object v) {</span>
<span class="source-line-no">601</span><span id="line.601">        final V[] value = this.value;</span>
<span class="source-line-no">602</span><span id="line.602">        final K[] key = this.key;</span>
<span class="source-line-no">603</span><span id="line.603">        if (containsNullKey</span>
<span class="source-line-no">604</span><span id="line.604">                &amp;&amp; (value[n] == null ? v == null : value[n].equals(v)))</span>
<span class="source-line-no">605</span><span id="line.605">            return true;</span>
<span class="source-line-no">606</span><span id="line.606">        for (int i = n; i-- != 0;)</span>
<span class="source-line-no">607</span><span id="line.607">            if (key[i] != null</span>
<span class="source-line-no">608</span><span id="line.608">                    &amp;&amp; (value[i] == null ? v == null : value[i].equals(v)))</span>
<span class="source-line-no">609</span><span id="line.609">                return true;</span>
<span class="source-line-no">610</span><span id="line.610">        return false;</span>
<span class="source-line-no">611</span><span id="line.611">    }</span>
<span class="source-line-no">612</span><span id="line.612">    /*</span>
<span class="source-line-no">613</span><span id="line.613">     * Removes all elements from this map.</span>
<span class="source-line-no">614</span><span id="line.614">     *</span>
<span class="source-line-no">615</span><span id="line.615">     * &lt;P&gt;To increase object reuse, this method does not change the table size.</span>
<span class="source-line-no">616</span><span id="line.616">     * If you want to reduce the table size, you must use {@link #trim()}.</span>
<span class="source-line-no">617</span><span id="line.617">     */</span>
<span class="source-line-no">618</span><span id="line.618">    public void clear() {</span>
<span class="source-line-no">619</span><span id="line.619">        if (size == 0)</span>
<span class="source-line-no">620</span><span id="line.620">            return;</span>
<span class="source-line-no">621</span><span id="line.621">        size = 0;</span>
<span class="source-line-no">622</span><span id="line.622">        containsNullKey = false;</span>
<span class="source-line-no">623</span><span id="line.623">        Arrays.fill(key, null);</span>
<span class="source-line-no">624</span><span id="line.624">        Arrays.fill(value, null);</span>
<span class="source-line-no">625</span><span id="line.625">    }</span>
<span class="source-line-no">626</span><span id="line.626"></span>
<span class="source-line-no">627</span><span id="line.627">    public int size() {</span>
<span class="source-line-no">628</span><span id="line.628">        return size;</span>
<span class="source-line-no">629</span><span id="line.629">    }</span>
<span class="source-line-no">630</span><span id="line.630"></span>
<span class="source-line-no">631</span><span id="line.631">    public boolean isEmpty() {</span>
<span class="source-line-no">632</span><span id="line.632">        return size == 0;</span>
<span class="source-line-no">633</span><span id="line.633">    }</span>
<span class="source-line-no">634</span><span id="line.634"></span>
<span class="source-line-no">635</span><span id="line.635">    /**</span>
<span class="source-line-no">636</span><span id="line.636">     * The entry class for a OrderedMap does not record key and value, but rather the position in the hash table of the corresponding entry. This is necessary so that calls to</span>
<span class="source-line-no">637</span><span id="line.637">     * {@link Entry#setValue(Object)} are reflected in the map</span>
<span class="source-line-no">638</span><span id="line.638">     */</span>
<span class="source-line-no">639</span><span id="line.639">    final class MapEntry implements Entry&lt;K, V&gt; {</span>
<span class="source-line-no">640</span><span id="line.640">        // The table index this entry refers to, or -1 if this entry has been</span>
<span class="source-line-no">641</span><span id="line.641">        // deleted.</span>
<span class="source-line-no">642</span><span id="line.642">        int index;</span>
<span class="source-line-no">643</span><span id="line.643">        MapEntry(final int index) {</span>
<span class="source-line-no">644</span><span id="line.644">            this.index = index;</span>
<span class="source-line-no">645</span><span id="line.645">        }</span>
<span class="source-line-no">646</span><span id="line.646">        MapEntry() {</span>
<span class="source-line-no">647</span><span id="line.647">        }</span>
<span class="source-line-no">648</span><span id="line.648">        public K getKey() {</span>
<span class="source-line-no">649</span><span id="line.649">            return key[index];</span>
<span class="source-line-no">650</span><span id="line.650">        }</span>
<span class="source-line-no">651</span><span id="line.651">        public V getValue() {</span>
<span class="source-line-no">652</span><span id="line.652">            return value[index];</span>
<span class="source-line-no">653</span><span id="line.653">        }</span>
<span class="source-line-no">654</span><span id="line.654">        public V setValue(final V v) {</span>
<span class="source-line-no">655</span><span id="line.655">            final V oldValue = value[index];</span>
<span class="source-line-no">656</span><span id="line.656">            value[index] = v;</span>
<span class="source-line-no">657</span><span id="line.657">            return oldValue;</span>
<span class="source-line-no">658</span><span id="line.658">        }</span>
<span class="source-line-no">659</span><span id="line.659">        @SuppressWarnings("unchecked")</span>
<span class="source-line-no">660</span><span id="line.660">        public boolean equals(final Object o) {</span>
<span class="source-line-no">661</span><span id="line.661">            if (!(o instanceof Map.Entry))</span>
<span class="source-line-no">662</span><span id="line.662">                return false;</span>
<span class="source-line-no">663</span><span id="line.663">            Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</span>
<span class="source-line-no">664</span><span id="line.664">            return (key[index] == null</span>
<span class="source-line-no">665</span><span id="line.665">                    ? e.getKey() == null</span>
<span class="source-line-no">666</span><span id="line.666">                    : hasher.areEqual(key[index], e.getKey()))</span>
<span class="source-line-no">667</span><span id="line.667">                    &amp;&amp; (value[index] == null</span>
<span class="source-line-no">668</span><span id="line.668">                    ? e.getValue() == null</span>
<span class="source-line-no">669</span><span id="line.669">                    : value[index].equals(e.getValue()));</span>
<span class="source-line-no">670</span><span id="line.670">        }</span>
<span class="source-line-no">671</span><span id="line.671">        public int hashCode() {</span>
<span class="source-line-no">672</span><span id="line.672">            return hasher.hash(key[index])</span>
<span class="source-line-no">673</span><span id="line.673">                    ^ (value[index] == null ? 0 : value[index].hashCode());</span>
<span class="source-line-no">674</span><span id="line.674">        }</span>
<span class="source-line-no">675</span><span id="line.675">        @Override</span>
<span class="source-line-no">676</span><span id="line.676">        public String toString() {</span>
<span class="source-line-no">677</span><span id="line.677">            return key[index] + "=&gt;" + value[index];</span>
<span class="source-line-no">678</span><span id="line.678">        }</span>
<span class="source-line-no">679</span><span id="line.679">    }</span>
<span class="source-line-no">680</span><span id="line.680">    </span>
<span class="source-line-no">681</span><span id="line.681">    /**</span>
<span class="source-line-no">682</span><span id="line.682">     * An iterator over a hash map.</span>
<span class="source-line-no">683</span><span id="line.683">     */</span>
<span class="source-line-no">684</span><span id="line.684">    private class MapIterator {</span>
<span class="source-line-no">685</span><span id="line.685">        /**</span>
<span class="source-line-no">686</span><span id="line.686">         * The index of the last entry returned, if positive or zero; initially, {@link #n}. If negative, the last</span>
<span class="source-line-no">687</span><span id="line.687">         * &lt;p&gt;</span>
<span class="source-line-no">688</span><span id="line.688">         * entry returned was that of the key of index {@code - pos - 1} from the {@link #wrapped} list.</span>
<span class="source-line-no">689</span><span id="line.689">         */</span>
<span class="source-line-no">690</span><span id="line.690">        int pos = n;</span>
<span class="source-line-no">691</span><span id="line.691">        /**</span>
<span class="source-line-no">692</span><span id="line.692">         * The index of the last entry that has been returned (more precisely, the value of {@link #pos} if {@link #pos} is positive,</span>
<span class="source-line-no">693</span><span id="line.693">         * &lt;p&gt;</span>
<span class="source-line-no">694</span><span id="line.694">         * or {@link Integer#MIN_VALUE} if {@link #pos} is negative). It is -1 if either</span>
<span class="source-line-no">695</span><span id="line.695">         * &lt;p&gt;</span>
<span class="source-line-no">696</span><span id="line.696">         * we did not return an entry yet, or the last returned entry has been removed.</span>
<span class="source-line-no">697</span><span id="line.697">         */</span>
<span class="source-line-no">698</span><span id="line.698">        int last = -1;</span>
<span class="source-line-no">699</span><span id="line.699">        /**</span>
<span class="source-line-no">700</span><span id="line.700">         * A downward counter measuring how many entries must still be returned.</span>
<span class="source-line-no">701</span><span id="line.701">         */</span>
<span class="source-line-no">702</span><span id="line.702">        int c = size;</span>
<span class="source-line-no">703</span><span id="line.703">        /**</span>
<span class="source-line-no">704</span><span id="line.704">         * A boolean telling us whether we should return the entry with the null key.</span>
<span class="source-line-no">705</span><span id="line.705">         */</span>
<span class="source-line-no">706</span><span id="line.706">        boolean mustReturnNullKey = UnorderedMap.this.containsNullKey;</span>
<span class="source-line-no">707</span><span id="line.707">        /**</span>
<span class="source-line-no">708</span><span id="line.708">         * A lazily allocated list containing keys of entries that have wrapped around the table because of removals.</span>
<span class="source-line-no">709</span><span id="line.709">         */</span>
<span class="source-line-no">710</span><span id="line.710">        ArrayList&lt;K&gt; wrapped;</span>
<span class="source-line-no">711</span><span id="line.711"></span>
<span class="source-line-no">712</span><span id="line.712">        public boolean hasNext() {</span>
<span class="source-line-no">713</span><span id="line.713">            return c != 0;</span>
<span class="source-line-no">714</span><span id="line.714">        }</span>
<span class="source-line-no">715</span><span id="line.715"></span>
<span class="source-line-no">716</span><span id="line.716">        public int nextEntry() {</span>
<span class="source-line-no">717</span><span id="line.717">            if (!hasNext()) throw new NoSuchElementException();</span>
<span class="source-line-no">718</span><span id="line.718">            c--;</span>
<span class="source-line-no">719</span><span id="line.719">            if (mustReturnNullKey) {</span>
<span class="source-line-no">720</span><span id="line.720">                mustReturnNullKey = false;</span>
<span class="source-line-no">721</span><span id="line.721">                return last = n;</span>
<span class="source-line-no">722</span><span id="line.722">            }</span>
<span class="source-line-no">723</span><span id="line.723">            final K[] key = UnorderedMap.this.key;</span>
<span class="source-line-no">724</span><span id="line.724">            for (; ; ) {</span>
<span class="source-line-no">725</span><span id="line.725">                if (--pos &lt; 0) {</span>
<span class="source-line-no">726</span><span id="line.726">                    // We are just enumerating elements from the wrapped list.</span>
<span class="source-line-no">727</span><span id="line.727">                    last = Integer.MIN_VALUE;</span>
<span class="source-line-no">728</span><span id="line.728">                    final K k = wrapped.get(-pos - 1);</span>
<span class="source-line-no">729</span><span id="line.729">                    int p = hasher.hash(k) &amp; mask;</span>
<span class="source-line-no">730</span><span id="line.730">                    while (!(hasher.areEqual(k, key[p]))) p = (p + 1) &amp; mask;</span>
<span class="source-line-no">731</span><span id="line.731">                    return p;</span>
<span class="source-line-no">732</span><span id="line.732">                }</span>
<span class="source-line-no">733</span><span id="line.733">                if (!((key[pos]) == null)) return last = pos;</span>
<span class="source-line-no">734</span><span id="line.734">            }</span>
<span class="source-line-no">735</span><span id="line.735">        }</span>
<span class="source-line-no">736</span><span id="line.736"></span>
<span class="source-line-no">737</span><span id="line.737">        /**</span>
<span class="source-line-no">738</span><span id="line.738">         * Shifts left entries with the specified hash code, starting at the specified position,</span>
<span class="source-line-no">739</span><span id="line.739">         * &lt;p&gt;</span>
<span class="source-line-no">740</span><span id="line.740">         * and empties the resulting free entry.</span>
<span class="source-line-no">741</span><span id="line.741">         *</span>
<span class="source-line-no">742</span><span id="line.742">         * @param pos a starting position.</span>
<span class="source-line-no">743</span><span id="line.743">         */</span>
<span class="source-line-no">744</span><span id="line.744">        private void shiftKeys(int pos) {</span>
<span class="source-line-no">745</span><span id="line.745">            // Shift entries with the same hash.</span>
<span class="source-line-no">746</span><span id="line.746">            int last, slot;</span>
<span class="source-line-no">747</span><span id="line.747">            K curr;</span>
<span class="source-line-no">748</span><span id="line.748">            final K[] key = UnorderedMap.this.key;</span>
<span class="source-line-no">749</span><span id="line.749">            for (; ; ) {</span>
<span class="source-line-no">750</span><span id="line.750">                pos = ((last = pos) + 1) &amp; mask;</span>
<span class="source-line-no">751</span><span id="line.751">                for (; ; ) {</span>
<span class="source-line-no">752</span><span id="line.752">                    if (((curr = key[pos]) == null)) {</span>
<span class="source-line-no">753</span><span id="line.753">                        key[last] = (null);</span>
<span class="source-line-no">754</span><span id="line.754">                        value[last] = null;</span>
<span class="source-line-no">755</span><span id="line.755">                        return;</span>
<span class="source-line-no">756</span><span id="line.756">                    }</span>
<span class="source-line-no">757</span><span id="line.757">                    slot = (hasher.hash(curr)) &amp; mask;</span>
<span class="source-line-no">758</span><span id="line.758">                    if (last &lt;= pos ? last &gt;= slot || slot &gt; pos : last &gt;= slot &amp;&amp; slot &gt; pos) break;</span>
<span class="source-line-no">759</span><span id="line.759">                    pos = (pos + 1) &amp; mask;</span>
<span class="source-line-no">760</span><span id="line.760">                }</span>
<span class="source-line-no">761</span><span id="line.761">                if (pos &lt; last) { // Wrapped entry.</span>
<span class="source-line-no">762</span><span id="line.762">                    if (wrapped == null) wrapped = new ArrayList&lt;&gt;(2);</span>
<span class="source-line-no">763</span><span id="line.763">                    wrapped.add(key[pos]);</span>
<span class="source-line-no">764</span><span id="line.764">                }</span>
<span class="source-line-no">765</span><span id="line.765">                key[last] = curr;</span>
<span class="source-line-no">766</span><span id="line.766">                value[last] = value[pos];</span>
<span class="source-line-no">767</span><span id="line.767">            }</span>
<span class="source-line-no">768</span><span id="line.768">        }</span>
<span class="source-line-no">769</span><span id="line.769"></span>
<span class="source-line-no">770</span><span id="line.770">        public void remove() {</span>
<span class="source-line-no">771</span><span id="line.771">            if (last == -1) throw new IllegalStateException();</span>
<span class="source-line-no">772</span><span id="line.772">            if (last == n) {</span>
<span class="source-line-no">773</span><span id="line.773">                containsNullKey = false;</span>
<span class="source-line-no">774</span><span id="line.774">                key[n] = null;</span>
<span class="source-line-no">775</span><span id="line.775">                value[n] = null;</span>
<span class="source-line-no">776</span><span id="line.776">            } else if (pos &gt;= 0) shiftKeys(last);</span>
<span class="source-line-no">777</span><span id="line.777">            else {</span>
<span class="source-line-no">778</span><span id="line.778">                // We're removing wrapped entries.</span>
<span class="source-line-no">779</span><span id="line.779">                UnorderedMap.this.remove(wrapped.set(-pos - 1, null));</span>
<span class="source-line-no">780</span><span id="line.780">                last = -1; // Note that we must not decrement size</span>
<span class="source-line-no">781</span><span id="line.781">                return;</span>
<span class="source-line-no">782</span><span id="line.782">            }</span>
<span class="source-line-no">783</span><span id="line.783">            size--;</span>
<span class="source-line-no">784</span><span id="line.784">            last = -1; // You can no longer remove this entry.</span>
<span class="source-line-no">785</span><span id="line.785">        }</span>
<span class="source-line-no">786</span><span id="line.786"></span>
<span class="source-line-no">787</span><span id="line.787">        public int skip(final int n) {</span>
<span class="source-line-no">788</span><span id="line.788">            int i = n;</span>
<span class="source-line-no">789</span><span id="line.789">            while (i-- != 0 &amp;&amp; hasNext()) nextEntry();</span>
<span class="source-line-no">790</span><span id="line.790">            return n - i - 1;</span>
<span class="source-line-no">791</span><span id="line.791">        }</span>
<span class="source-line-no">792</span><span id="line.792">    }</span>
<span class="source-line-no">793</span><span id="line.793"></span>
<span class="source-line-no">794</span><span id="line.794">    private class EntryIterator extends MapIterator implements Iterator&lt;Map.Entry&lt;K, V&gt;&gt; {</span>
<span class="source-line-no">795</span><span id="line.795">        private MapEntry entry;</span>
<span class="source-line-no">796</span><span id="line.796"></span>
<span class="source-line-no">797</span><span id="line.797">        public Map.Entry&lt;K, V&gt; next() {</span>
<span class="source-line-no">798</span><span id="line.798">            return entry = new MapEntry(nextEntry());</span>
<span class="source-line-no">799</span><span id="line.799">        }</span>
<span class="source-line-no">800</span><span id="line.800"></span>
<span class="source-line-no">801</span><span id="line.801">        @Override</span>
<span class="source-line-no">802</span><span id="line.802">        public void remove() {</span>
<span class="source-line-no">803</span><span id="line.803">            super.remove();</span>
<span class="source-line-no">804</span><span id="line.804">            entry.index = -1; // You cannot use a deleted entry.</span>
<span class="source-line-no">805</span><span id="line.805">        }</span>
<span class="source-line-no">806</span><span id="line.806">    }</span>
<span class="source-line-no">807</span><span id="line.807"></span>
<span class="source-line-no">808</span><span id="line.808">    private final class MapEntrySet extends AbstractSet&lt;Map.Entry&lt;K, V&gt;&gt; {</span>
<span class="source-line-no">809</span><span id="line.809">        public Iterator&lt;Map.Entry&lt;K, V&gt;&gt; iterator() {</span>
<span class="source-line-no">810</span><span id="line.810">            return new EntryIterator();</span>
<span class="source-line-no">811</span><span id="line.811">        }</span>
<span class="source-line-no">812</span><span id="line.812"></span>
<span class="source-line-no">813</span><span id="line.813">        @SuppressWarnings("unchecked")</span>
<span class="source-line-no">814</span><span id="line.814">        public boolean contains(final Object o) {</span>
<span class="source-line-no">815</span><span id="line.815">            if (!(o instanceof Map.Entry)) return false;</span>
<span class="source-line-no">816</span><span id="line.816">            final Map.Entry&lt;?, ?&gt; e = (Map.Entry&lt;?, ?&gt;) o;</span>
<span class="source-line-no">817</span><span id="line.817">            final K k = ((K) e.getKey());</span>
<span class="source-line-no">818</span><span id="line.818">            final V v = ((V) e.getValue());</span>
<span class="source-line-no">819</span><span id="line.819">            if (hasher.areEqual(k, null))</span>
<span class="source-line-no">820</span><span id="line.820">                return UnorderedMap.this.containsNullKey &amp;&amp; (value[n] == null ? v == null : value[n].equals(v));</span>
<span class="source-line-no">821</span><span id="line.821">            K curr;</span>
<span class="source-line-no">822</span><span id="line.822">            final K[] key = UnorderedMap.this.key;</span>
<span class="source-line-no">823</span><span id="line.823">            int pos;</span>
<span class="source-line-no">824</span><span id="line.824">            // The starting point.</span>
<span class="source-line-no">825</span><span id="line.825">            if (((curr = key[pos = hasher.hash(k) &amp; mask]) == null))</span>
<span class="source-line-no">826</span><span id="line.826">                return false;</span>
<span class="source-line-no">827</span><span id="line.827">            if (hasher.areEqual(k, curr)) return (value[pos] == null ? (v) == null : (value[pos]).equals(v));</span>
<span class="source-line-no">828</span><span id="line.828">            // There's always an unused entry.</span>
<span class="source-line-no">829</span><span id="line.829">            while (true) {</span>
<span class="source-line-no">830</span><span id="line.830">                if (((curr = key[pos = (pos + 1) &amp; mask]) == null)) return false;</span>
<span class="source-line-no">831</span><span id="line.831">                if (hasher.areEqual(k, curr))</span>
<span class="source-line-no">832</span><span id="line.832">                    return (value[pos] == null ? v == null : value[pos].equals(v));</span>
<span class="source-line-no">833</span><span id="line.833">            }</span>
<span class="source-line-no">834</span><span id="line.834">        }</span>
<span class="source-line-no">835</span><span id="line.835"></span>
<span class="source-line-no">836</span><span id="line.836">        @SuppressWarnings("unchecked")</span>
<span class="source-line-no">837</span><span id="line.837">        @Override</span>
<span class="source-line-no">838</span><span id="line.838">        public boolean remove(final Object o) {</span>
<span class="source-line-no">839</span><span id="line.839">            if (!(o instanceof Map.Entry)) return false;</span>
<span class="source-line-no">840</span><span id="line.840">            final Map.Entry&lt;?, ?&gt; e = (Map.Entry&lt;?, ?&gt;) o;</span>
<span class="source-line-no">841</span><span id="line.841">            final K k = ((K) e.getKey());</span>
<span class="source-line-no">842</span><span id="line.842">            final V v = ((V) e.getValue());</span>
<span class="source-line-no">843</span><span id="line.843">            if ((hasher.areEqual(k, null))) {</span>
<span class="source-line-no">844</span><span id="line.844">                if (containsNullKey &amp;&amp; ((value[n]) == null ? (v) == null : (value[n]).equals(v))) {</span>
<span class="source-line-no">845</span><span id="line.845">                    removeNullEntry();</span>
<span class="source-line-no">846</span><span id="line.846">                    return true;</span>
<span class="source-line-no">847</span><span id="line.847">                }</span>
<span class="source-line-no">848</span><span id="line.848">                return false;</span>
<span class="source-line-no">849</span><span id="line.849">            }</span>
<span class="source-line-no">850</span><span id="line.850">            K curr;</span>
<span class="source-line-no">851</span><span id="line.851">            final K[] key = UnorderedMap.this.key;</span>
<span class="source-line-no">852</span><span id="line.852">            int pos;</span>
<span class="source-line-no">853</span><span id="line.853">            // The starting point.</span>
<span class="source-line-no">854</span><span id="line.854">            if (((curr = key[pos = hasher.hash(k) &amp; mask]) == null))</span>
<span class="source-line-no">855</span><span id="line.855">                return false;</span>
<span class="source-line-no">856</span><span id="line.856">            if (hasher.areEqual(curr, k)) {</span>
<span class="source-line-no">857</span><span id="line.857">                if (((value[pos]) == null ? (v) == null : (value[pos]).equals(v))) {</span>
<span class="source-line-no">858</span><span id="line.858">                    removeEntry(pos);</span>
<span class="source-line-no">859</span><span id="line.859">                    return true;</span>
<span class="source-line-no">860</span><span id="line.860">                }</span>
<span class="source-line-no">861</span><span id="line.861">                return false;</span>
<span class="source-line-no">862</span><span id="line.862">            }</span>
<span class="source-line-no">863</span><span id="line.863">            while (true) {</span>
<span class="source-line-no">864</span><span id="line.864">                if (((curr = key[pos = (pos + 1) &amp; mask]) == null)) return false;</span>
<span class="source-line-no">865</span><span id="line.865">                if (hasher.areEqual(curr, k)) {</span>
<span class="source-line-no">866</span><span id="line.866">                    if (((value[pos]) == null ? (v) == null : (value[pos]).equals(v))) {</span>
<span class="source-line-no">867</span><span id="line.867">                        removeEntry(pos);</span>
<span class="source-line-no">868</span><span id="line.868">                        return true;</span>
<span class="source-line-no">869</span><span id="line.869">                    }</span>
<span class="source-line-no">870</span><span id="line.870">                }</span>
<span class="source-line-no">871</span><span id="line.871">            }</span>
<span class="source-line-no">872</span><span id="line.872">        }</span>
<span class="source-line-no">873</span><span id="line.873"></span>
<span class="source-line-no">874</span><span id="line.874">        public int size() {</span>
<span class="source-line-no">875</span><span id="line.875">            return size;</span>
<span class="source-line-no">876</span><span id="line.876">        }</span>
<span class="source-line-no">877</span><span id="line.877"></span>
<span class="source-line-no">878</span><span id="line.878">        public void clear() {</span>
<span class="source-line-no">879</span><span id="line.879">            UnorderedMap.this.clear();</span>
<span class="source-line-no">880</span><span id="line.880">        }</span>
<span class="source-line-no">881</span><span id="line.881">    }</span>
<span class="source-line-no">882</span><span id="line.882"></span>
<span class="source-line-no">883</span><span id="line.883">    @Override</span>
<span class="source-line-no">884</span><span id="line.884">    public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() {</span>
<span class="source-line-no">885</span><span id="line.885">        if (entries == null) entries = new MapEntrySet();</span>
<span class="source-line-no">886</span><span id="line.886">        return entries;</span>
<span class="source-line-no">887</span><span id="line.887">    }</span>
<span class="source-line-no">888</span><span id="line.888"></span>
<span class="source-line-no">889</span><span id="line.889"></span>
<span class="source-line-no">890</span><span id="line.890">    /**</span>
<span class="source-line-no">891</span><span id="line.891">     * An iterator on keys.</span>
<span class="source-line-no">892</span><span id="line.892">     *</span>
<span class="source-line-no">893</span><span id="line.893">     *</span>
<span class="source-line-no">894</span><span id="line.894">     *</span>
<span class="source-line-no">895</span><span id="line.895">     * &lt;P&gt;We simply override the {@link java.util.ListIterator#next()}/{@link java.util.ListIterator#previous()} methods</span>
<span class="source-line-no">896</span><span id="line.896">     * &lt;p&gt;</span>
<span class="source-line-no">897</span><span id="line.897">     * (and possibly their type-specific counterparts) so that they return keys</span>
<span class="source-line-no">898</span><span id="line.898">     * &lt;p&gt;</span>
<span class="source-line-no">899</span><span id="line.899">     * instead of entries.</span>
<span class="source-line-no">900</span><span id="line.900">     */</span>
<span class="source-line-no">901</span><span id="line.901">    private final class KeyIterator extends MapIterator implements Iterator&lt;K&gt; {</span>
<span class="source-line-no">902</span><span id="line.902">        public KeyIterator() {</span>
<span class="source-line-no">903</span><span id="line.903">            super();</span>
<span class="source-line-no">904</span><span id="line.904">        }</span>
<span class="source-line-no">905</span><span id="line.905"></span>
<span class="source-line-no">906</span><span id="line.906">        public K next() {</span>
<span class="source-line-no">907</span><span id="line.907">            return key[nextEntry()];</span>
<span class="source-line-no">908</span><span id="line.908">        }</span>
<span class="source-line-no">909</span><span id="line.909">    }</span>
<span class="source-line-no">910</span><span id="line.910"></span>
<span class="source-line-no">911</span><span id="line.911">    private final class KeySet extends AbstractSet&lt;K&gt; {</span>
<span class="source-line-no">912</span><span id="line.912">        public Iterator&lt;K&gt; iterator() {</span>
<span class="source-line-no">913</span><span id="line.913">            return new KeyIterator();</span>
<span class="source-line-no">914</span><span id="line.914">        }</span>
<span class="source-line-no">915</span><span id="line.915"></span>
<span class="source-line-no">916</span><span id="line.916">        public int size() {</span>
<span class="source-line-no">917</span><span id="line.917">            return size;</span>
<span class="source-line-no">918</span><span id="line.918">        }</span>
<span class="source-line-no">919</span><span id="line.919"></span>
<span class="source-line-no">920</span><span id="line.920">        public boolean contains(Object k) {</span>
<span class="source-line-no">921</span><span id="line.921">            return containsKey(k);</span>
<span class="source-line-no">922</span><span id="line.922">        }</span>
<span class="source-line-no">923</span><span id="line.923"></span>
<span class="source-line-no">924</span><span id="line.924">        public boolean rem(Object k) {</span>
<span class="source-line-no">925</span><span id="line.925">            final int oldSize = size;</span>
<span class="source-line-no">926</span><span id="line.926">            UnorderedMap.this.remove(k);</span>
<span class="source-line-no">927</span><span id="line.927">            return size != oldSize;</span>
<span class="source-line-no">928</span><span id="line.928">        }</span>
<span class="source-line-no">929</span><span id="line.929"></span>
<span class="source-line-no">930</span><span id="line.930">        public void clear() {</span>
<span class="source-line-no">931</span><span id="line.931">            UnorderedMap.this.clear();</span>
<span class="source-line-no">932</span><span id="line.932">        }</span>
<span class="source-line-no">933</span><span id="line.933">    }</span>
<span class="source-line-no">934</span><span id="line.934"></span>
<span class="source-line-no">935</span><span id="line.935">    public Set&lt;K&gt; keySet() {</span>
<span class="source-line-no">936</span><span id="line.936">        if (keys == null) keys = new KeySet();</span>
<span class="source-line-no">937</span><span id="line.937">        return keys;</span>
<span class="source-line-no">938</span><span id="line.938">    }</span>
<span class="source-line-no">939</span><span id="line.939"></span>
<span class="source-line-no">940</span><span id="line.940">    /**</span>
<span class="source-line-no">941</span><span id="line.941">     * An iterator on values.</span>
<span class="source-line-no">942</span><span id="line.942">     * &lt;br&gt;</span>
<span class="source-line-no">943</span><span id="line.943">     * We simply override the {@link java.util.Iterator#next()} method so that it returns values instead of entries.</span>
<span class="source-line-no">944</span><span id="line.944">     */</span>
<span class="source-line-no">945</span><span id="line.945">    private final class ValueIterator extends MapIterator implements Iterator&lt;V&gt; {</span>
<span class="source-line-no">946</span><span id="line.946">        public ValueIterator() {</span>
<span class="source-line-no">947</span><span id="line.947">            super();</span>
<span class="source-line-no">948</span><span id="line.948">        }</span>
<span class="source-line-no">949</span><span id="line.949"></span>
<span class="source-line-no">950</span><span id="line.950">        public V next() {</span>
<span class="source-line-no">951</span><span id="line.951">            return value[nextEntry()];</span>
<span class="source-line-no">952</span><span id="line.952">        }</span>
<span class="source-line-no">953</span><span id="line.953">    }</span>
<span class="source-line-no">954</span><span id="line.954"></span>
<span class="source-line-no">955</span><span id="line.955">    public final class ValueCollection extends AbstractCollection&lt;V&gt; implements Serializable</span>
<span class="source-line-no">956</span><span id="line.956">    {</span>
<span class="source-line-no">957</span><span id="line.957">        private static final long serialVersionUID = 0L;</span>
<span class="source-line-no">958</span><span id="line.958">        public ValueIterator iterator() {</span>
<span class="source-line-no">959</span><span id="line.959">            return new ValueIterator();</span>
<span class="source-line-no">960</span><span id="line.960">        }</span>
<span class="source-line-no">961</span><span id="line.961">        public int size() {</span>
<span class="source-line-no">962</span><span id="line.962">            return size;</span>
<span class="source-line-no">963</span><span id="line.963">        }</span>
<span class="source-line-no">964</span><span id="line.964">        public boolean contains(Object v) {</span>
<span class="source-line-no">965</span><span id="line.965">            return containsValue(v);</span>
<span class="source-line-no">966</span><span id="line.966">        }</span>
<span class="source-line-no">967</span><span id="line.967">        public void clear() {</span>
<span class="source-line-no">968</span><span id="line.968">            UnorderedMap.this.clear();</span>
<span class="source-line-no">969</span><span id="line.969">        }</span>
<span class="source-line-no">970</span><span id="line.970">    }</span>
<span class="source-line-no">971</span><span id="line.971">    public Collection&lt;V&gt; values() {</span>
<span class="source-line-no">972</span><span id="line.972">        if (values == null) values = new ValueCollection();</span>
<span class="source-line-no">973</span><span id="line.973">        return values;</span>
<span class="source-line-no">974</span><span id="line.974">    }</span>
<span class="source-line-no">975</span><span id="line.975"></span>
<span class="source-line-no">976</span><span id="line.976">    public ArrayList&lt;V&gt; valuesAsList()</span>
<span class="source-line-no">977</span><span id="line.977">    {</span>
<span class="source-line-no">978</span><span id="line.978">        ArrayList&lt;V&gt; ls = new ArrayList&lt;&gt;(size);</span>
<span class="source-line-no">979</span><span id="line.979">        ValueIterator vi = new ValueIterator();</span>
<span class="source-line-no">980</span><span id="line.980">        while (vi.hasNext())</span>
<span class="source-line-no">981</span><span id="line.981">            ls.add(vi.next());</span>
<span class="source-line-no">982</span><span id="line.982">        return ls;</span>
<span class="source-line-no">983</span><span id="line.983">    }</span>
<span class="source-line-no">984</span><span id="line.984"></span>
<span class="source-line-no">985</span><span id="line.985">    /**</span>
<span class="source-line-no">986</span><span id="line.986">     * Rehashes the map, making the table as small as possible.</span>
<span class="source-line-no">987</span><span id="line.987">     * &lt;p&gt;</span>
<span class="source-line-no">988</span><span id="line.988">     * &lt;P&gt;This method rehashes the table to the smallest size satisfying the load factor. It can be used when the set will not be changed anymore, so to optimize access speed and size.</span>
<span class="source-line-no">989</span><span id="line.989">     * &lt;p&gt;</span>
<span class="source-line-no">990</span><span id="line.990">     * &lt;P&gt;If the table size is already the minimum possible, this method does nothing.</span>
<span class="source-line-no">991</span><span id="line.991">     *</span>
<span class="source-line-no">992</span><span id="line.992">     * @return true if there was enough memory to trim the map.</span>
<span class="source-line-no">993</span><span id="line.993">     * @see #trim(int)</span>
<span class="source-line-no">994</span><span id="line.994">     */</span>
<span class="source-line-no">995</span><span id="line.995">    public boolean trim() {</span>
<span class="source-line-no">996</span><span id="line.996">        final int l = arraySize(size, f);</span>
<span class="source-line-no">997</span><span id="line.997">        if (l &gt;= n || size &gt; maxFill(l, f)) return true;</span>
<span class="source-line-no">998</span><span id="line.998">        try {</span>
<span class="source-line-no">999</span><span id="line.999">            rehash(l);</span>
<span class="source-line-no">1000</span><span id="line.1000">        } catch (Exception cantDoIt) {</span>
<span class="source-line-no">1001</span><span id="line.1001">            return false;</span>
<span class="source-line-no">1002</span><span id="line.1002">        }</span>
<span class="source-line-no">1003</span><span id="line.1003">        return true;</span>
<span class="source-line-no">1004</span><span id="line.1004">    }</span>
<span class="source-line-no">1005</span><span id="line.1005"></span>
<span class="source-line-no">1006</span><span id="line.1006">    /**</span>
<span class="source-line-no">1007</span><span id="line.1007">     * Rehashes this map if the table is too large.</span>
<span class="source-line-no">1008</span><span id="line.1008">     * &lt;p&gt;</span>
<span class="source-line-no">1009</span><span id="line.1009">     * &lt;P&gt;Let &lt;var&gt;N&lt;/var&gt; be the smallest table size that can hold &lt;code&gt;max(n,{@link #size()})&lt;/code&gt; entries, still satisfying the load factor. If the current table size is smaller than or equal to</span>
<span class="source-line-no">1010</span><span id="line.1010">     * &lt;var&gt;N&lt;/var&gt;, this method does nothing. Otherwise, it rehashes this map in a table of size &lt;var&gt;N&lt;/var&gt;.</span>
<span class="source-line-no">1011</span><span id="line.1011">     * &lt;p&gt;</span>
<span class="source-line-no">1012</span><span id="line.1012">     * &lt;P&gt;This method is useful when reusing maps. {@linkplain #clear() Clearing a map} leaves the table size untouched. If you are reusing a map many times, you can call this method with a typical</span>
<span class="source-line-no">1013</span><span id="line.1013">     * size to avoid keeping around a very large table just because of a few large transient maps.</span>
<span class="source-line-no">1014</span><span id="line.1014">     *</span>
<span class="source-line-no">1015</span><span id="line.1015">     * @param n the threshold for the trimming.</span>
<span class="source-line-no">1016</span><span id="line.1016">     * @return true if there was enough memory to trim the map.</span>
<span class="source-line-no">1017</span><span id="line.1017">     * @see #trim()</span>
<span class="source-line-no">1018</span><span id="line.1018">     */</span>
<span class="source-line-no">1019</span><span id="line.1019">    public boolean trim(final int n) {</span>
<span class="source-line-no">1020</span><span id="line.1020">        final int l = HashCommon.nextPowerOfTwo((int) Math.ceil(n / f));</span>
<span class="source-line-no">1021</span><span id="line.1021">        if (l &gt;= n || size &gt; maxFill(l, f)) return true;</span>
<span class="source-line-no">1022</span><span id="line.1022">        try {</span>
<span class="source-line-no">1023</span><span id="line.1023">            rehash(l);</span>
<span class="source-line-no">1024</span><span id="line.1024">        } catch (Exception cantDoIt) {</span>
<span class="source-line-no">1025</span><span id="line.1025">            return false;</span>
<span class="source-line-no">1026</span><span id="line.1026">        }</span>
<span class="source-line-no">1027</span><span id="line.1027">        return true;</span>
<span class="source-line-no">1028</span><span id="line.1028">    }</span>
<span class="source-line-no">1029</span><span id="line.1029"></span>
<span class="source-line-no">1030</span><span id="line.1030">    /**</span>
<span class="source-line-no">1031</span><span id="line.1031">     * Rehashes the map.</span>
<span class="source-line-no">1032</span><span id="line.1032">     *</span>
<span class="source-line-no">1033</span><span id="line.1033">     * &lt;P&gt;</span>
<span class="source-line-no">1034</span><span id="line.1034">     * This method implements the basic rehashing strategy, and may be overriden</span>
<span class="source-line-no">1035</span><span id="line.1035">     * by subclasses implementing different rehashing strategies (e.g.,</span>
<span class="source-line-no">1036</span><span id="line.1036">     * disk-based rehashing). However, you should not override this method</span>
<span class="source-line-no">1037</span><span id="line.1037">     * unless you understand the internal workings of this class.</span>
<span class="source-line-no">1038</span><span id="line.1038">     *</span>
<span class="source-line-no">1039</span><span id="line.1039">     * @param newN</span>
<span class="source-line-no">1040</span><span id="line.1040">     *            the new size</span>
<span class="source-line-no">1041</span><span id="line.1041">     */</span>
<span class="source-line-no">1042</span><span id="line.1042"></span>
<span class="source-line-no">1043</span><span id="line.1043">    @SuppressWarnings("unchecked")</span>
<span class="source-line-no">1044</span><span id="line.1044">    protected void rehash(final int newN) {</span>
<span class="source-line-no">1045</span><span id="line.1045">        final K[] key = this.key;</span>
<span class="source-line-no">1046</span><span id="line.1046">        final V[] value = this.value;</span>
<span class="source-line-no">1047</span><span id="line.1047">        final int mask = newN - 1; // Note that this is used by the hashing macro</span>
<span class="source-line-no">1048</span><span id="line.1048">        final K[] newKey = (K[]) new Object[newN + 1];</span>
<span class="source-line-no">1049</span><span id="line.1049">        final V[] newValue = (V[]) new Object[newN + 1];</span>
<span class="source-line-no">1050</span><span id="line.1050"></span>
<span class="source-line-no">1051</span><span id="line.1051">        int i = n, pos;</span>
<span class="source-line-no">1052</span><span id="line.1052">        for (int j = realSize(); j-- != 0; ) {</span>
<span class="source-line-no">1053</span><span id="line.1053">            while (((key[--i]) == null)) ;</span>
<span class="source-line-no">1054</span><span id="line.1054">            if (!((newKey[pos = hasher.hash(key[i]) &amp; mask]) == null))</span>
<span class="source-line-no">1055</span><span id="line.1055">                while (!((newKey[pos = (pos + 1) &amp; mask]) == null)) ;</span>
<span class="source-line-no">1056</span><span id="line.1056">            newKey[pos] = key[i];</span>
<span class="source-line-no">1057</span><span id="line.1057">            newValue[pos] = value[i];</span>
<span class="source-line-no">1058</span><span id="line.1058">        }</span>
<span class="source-line-no">1059</span><span id="line.1059">        newValue[newN] = value[n];</span>
<span class="source-line-no">1060</span><span id="line.1060">        n = newN;</span>
<span class="source-line-no">1061</span><span id="line.1061">        this.mask = mask;</span>
<span class="source-line-no">1062</span><span id="line.1062">        maxFill = maxFill(n, f);</span>
<span class="source-line-no">1063</span><span id="line.1063">        this.key = newKey;</span>
<span class="source-line-no">1064</span><span id="line.1064">        this.value = newValue;</span>
<span class="source-line-no">1065</span><span id="line.1065">    }</span>
<span class="source-line-no">1066</span><span id="line.1066">    /*</span>
<span class="source-line-no">1067</span><span id="line.1067">    @SuppressWarnings("unchecked")</span>
<span class="source-line-no">1068</span><span id="line.1068">    protected void rehash(final int newN) {</span>
<span class="source-line-no">1069</span><span id="line.1069">        final K key[] = this.key;</span>
<span class="source-line-no">1070</span><span id="line.1070">        final V value[] = this.value;</span>
<span class="source-line-no">1071</span><span id="line.1071">        final int mask = newN - 1; // Note that this is used by the hashing</span>
<span class="source-line-no">1072</span><span id="line.1072">        // macro</span>
<span class="source-line-no">1073</span><span id="line.1073">        final K newKey[] = (K[]) new Object[newN + 1];</span>
<span class="source-line-no">1074</span><span id="line.1074">        final V newValue[] = (V[]) new Object[newN + 1];</span>
<span class="source-line-no">1075</span><span id="line.1075">        int i = first, prev = -1, newPrev = -1, t, pos;</span>
<span class="source-line-no">1076</span><span id="line.1076">        final long link[] = this.link;</span>
<span class="source-line-no">1077</span><span id="line.1077">        final long newLink[] = new long[newN + 1];</span>
<span class="source-line-no">1078</span><span id="line.1078">        first = -1;</span>
<span class="source-line-no">1079</span><span id="line.1079">        for (int j = size; j-- != 0;) {</span>
<span class="source-line-no">1080</span><span id="line.1080">            if (((key[i]) == null))</span>
<span class="source-line-no">1081</span><span id="line.1081">                pos = newN;</span>
<span class="source-line-no">1082</span><span id="line.1082">            else {</span>
<span class="source-line-no">1083</span><span id="line.1083">                pos = (((key[i]).hashCode())) &amp; mask;</span>
<span class="source-line-no">1084</span><span id="line.1084">                while (!((newKey[pos]) == null))</span>
<span class="source-line-no">1085</span><span id="line.1085">                    pos = (pos + 1) &amp; mask;</span>
<span class="source-line-no">1086</span><span id="line.1086">            }</span>
<span class="source-line-no">1087</span><span id="line.1087">            newKey[pos] = key[i];</span>
<span class="source-line-no">1088</span><span id="line.1088">            newValue[pos] = value[i];</span>
<span class="source-line-no">1089</span><span id="line.1089">            if (prev != -1) {</span>
<span class="source-line-no">1090</span><span id="line.1090">                newLink[newPrev] ^= ((newLink[newPrev] ^ (pos &amp; 0xFFFFFFFFL)) &amp; 0xFFFFFFFFL);</span>
<span class="source-line-no">1091</span><span id="line.1091">                newLink[pos] ^= ((newLink[pos] ^ ((newPrev &amp; 0xFFFFFFFFL) &lt;&lt; 32)) &amp; 0xFFFFFFFF00000000L);</span>
<span class="source-line-no">1092</span><span id="line.1092">                newPrev = pos;</span>
<span class="source-line-no">1093</span><span id="line.1093">            } else {</span>
<span class="source-line-no">1094</span><span id="line.1094">                newPrev = first = pos;</span>
<span class="source-line-no">1095</span><span id="line.1095">                // Special case of SET(newLink[ pos ], -1, -1);</span>
<span class="source-line-no">1096</span><span id="line.1096">                newLink[pos] = -1L;</span>
<span class="source-line-no">1097</span><span id="line.1097">            }</span>
<span class="source-line-no">1098</span><span id="line.1098">            t = i;</span>
<span class="source-line-no">1099</span><span id="line.1099">            i = (int) link[i];</span>
<span class="source-line-no">1100</span><span id="line.1100">            prev = t;</span>
<span class="source-line-no">1101</span><span id="line.1101">        }</span>
<span class="source-line-no">1102</span><span id="line.1102">        this.link = newLink;</span>
<span class="source-line-no">1103</span><span id="line.1103">        this.last = newPrev;</span>
<span class="source-line-no">1104</span><span id="line.1104">        if (newPrev != -1)</span>
<span class="source-line-no">1105</span><span id="line.1105">            // Special case of SET_NEXT( newLink[ newPrev ], -1 );</span>
<span class="source-line-no">1106</span><span id="line.1106">            newLink[newPrev] |= -1 &amp; 0xFFFFFFFFL;</span>
<span class="source-line-no">1107</span><span id="line.1107">        n = newN;</span>
<span class="source-line-no">1108</span><span id="line.1108">        this.mask = mask;</span>
<span class="source-line-no">1109</span><span id="line.1109">        maxFill = maxFill(n, f);</span>
<span class="source-line-no">1110</span><span id="line.1110">        this.key = newKey;</span>
<span class="source-line-no">1111</span><span id="line.1111">        this.value = newValue;</span>
<span class="source-line-no">1112</span><span id="line.1112">    }</span>
<span class="source-line-no">1113</span><span id="line.1113">    */</span>
<span class="source-line-no">1114</span><span id="line.1114">    /**</span>
<span class="source-line-no">1115</span><span id="line.1115">     * Returns a deep copy of this map.</span>
<span class="source-line-no">1116</span><span id="line.1116">     *</span>
<span class="source-line-no">1117</span><span id="line.1117">     * &lt;P&gt;</span>
<span class="source-line-no">1118</span><span id="line.1118">     * This method performs a deep copy of this OrderedMap; the data stored in the</span>
<span class="source-line-no">1119</span><span id="line.1119">     * map, however, is not cloned. Note that this makes a difference only for</span>
<span class="source-line-no">1120</span><span id="line.1120">     * object keys.</span>
<span class="source-line-no">1121</span><span id="line.1121">     *</span>
<span class="source-line-no">1122</span><span id="line.1122">     * @return a deep copy of this map.</span>
<span class="source-line-no">1123</span><span id="line.1123">     */</span>
<span class="source-line-no">1124</span><span id="line.1124">    @SuppressWarnings("unchecked")</span>
<span class="source-line-no">1125</span><span id="line.1125">    @GwtIncompatible</span>
<span class="source-line-no">1126</span><span id="line.1126">    public UnorderedMap&lt;K, V&gt; clone() {</span>
<span class="source-line-no">1127</span><span id="line.1127">        UnorderedMap&lt;K, V&gt; c;</span>
<span class="source-line-no">1128</span><span id="line.1128">        try {</span>
<span class="source-line-no">1129</span><span id="line.1129">            c = new UnorderedMap&lt;&gt;(hasher);</span>
<span class="source-line-no">1130</span><span id="line.1130">            c.key = (K[]) new Object[n + 1];</span>
<span class="source-line-no">1131</span><span id="line.1131">            System.arraycopy(key, 0, c.key, 0, n + 1);</span>
<span class="source-line-no">1132</span><span id="line.1132">            c.value = (V[]) new Object[n + 1];</span>
<span class="source-line-no">1133</span><span id="line.1133">            System.arraycopy(value, 0, c.value, 0, n + 1);</span>
<span class="source-line-no">1134</span><span id="line.1134">            return c;</span>
<span class="source-line-no">1135</span><span id="line.1135">        } catch (Exception cantHappen) {</span>
<span class="source-line-no">1136</span><span id="line.1136">            throw new UnsupportedOperationException(cantHappen + (cantHappen.getMessage() != null ?</span>
<span class="source-line-no">1137</span><span id="line.1137">                    "; " + cantHappen.getMessage() : ""));</span>
<span class="source-line-no">1138</span><span id="line.1138">        }</span>
<span class="source-line-no">1139</span><span id="line.1139">    }</span>
<span class="source-line-no">1140</span><span id="line.1140">    /**</span>
<span class="source-line-no">1141</span><span id="line.1141">     * Returns a hash code for this map.</span>
<span class="source-line-no">1142</span><span id="line.1142">     *</span>
<span class="source-line-no">1143</span><span id="line.1143">     * This method overrides the generic method provided by the superclass.</span>
<span class="source-line-no">1144</span><span id="line.1144">     * Since &lt;code&gt;equals()&lt;/code&gt; is not overriden, it is important that the</span>
<span class="source-line-no">1145</span><span id="line.1145">     * value returned by this method is the same value as the one returned by</span>
<span class="source-line-no">1146</span><span id="line.1146">     * the overriden method.</span>
<span class="source-line-no">1147</span><span id="line.1147">     *</span>
<span class="source-line-no">1148</span><span id="line.1148">     * @return a hash code for this map.</span>
<span class="source-line-no">1149</span><span id="line.1149">     */</span>
<span class="source-line-no">1150</span><span id="line.1150">    public int hashCode() {</span>
<span class="source-line-no">1151</span><span id="line.1151">        int h = 0;</span>
<span class="source-line-no">1152</span><span id="line.1152">        for (int j = realSize(), i = 0, t = 0; j-- != 0;) {</span>
<span class="source-line-no">1153</span><span id="line.1153">            while (key[i] == null)</span>
<span class="source-line-no">1154</span><span id="line.1154">                i++;</span>
<span class="source-line-no">1155</span><span id="line.1155">            if (this != key[i])</span>
<span class="source-line-no">1156</span><span id="line.1156">                t = hasher.hash(key[i]);</span>
<span class="source-line-no">1157</span><span id="line.1157">            if (this != value[i])</span>
<span class="source-line-no">1158</span><span id="line.1158">                t ^= value[i] == null ? 0 : value[i].hashCode();</span>
<span class="source-line-no">1159</span><span id="line.1159">            h += t;</span>
<span class="source-line-no">1160</span><span id="line.1160">            i++;</span>
<span class="source-line-no">1161</span><span id="line.1161">        }</span>
<span class="source-line-no">1162</span><span id="line.1162">        // Zero / null keys have hash zero.</span>
<span class="source-line-no">1163</span><span id="line.1163">        if (containsNullKey)</span>
<span class="source-line-no">1164</span><span id="line.1164">            h += value[n] == null ? 0 : value[n].hashCode();</span>
<span class="source-line-no">1165</span><span id="line.1165">        return h;</span>
<span class="source-line-no">1166</span><span id="line.1166">    }</span>
<span class="source-line-no">1167</span><span id="line.1167"></span>
<span class="source-line-no">1168</span><span id="line.1168">    public long hash64()</span>
<span class="source-line-no">1169</span><span id="line.1169">    {</span>
<span class="source-line-no">1170</span><span id="line.1170">        return 31L * (31L * CrossHash.hash64(key) + CrossHash.hash64(value)) + size;</span>
<span class="source-line-no">1171</span><span id="line.1171">    }</span>
<span class="source-line-no">1172</span><span id="line.1172">    /**</span>
<span class="source-line-no">1173</span><span id="line.1173">     * Returns the maximum number of entries that can be filled before rehashing.</span>
<span class="source-line-no">1174</span><span id="line.1174">     *</span>
<span class="source-line-no">1175</span><span id="line.1175">     * @param n the size of the backing array.</span>
<span class="source-line-no">1176</span><span id="line.1176">     * @param f the load factor.</span>
<span class="source-line-no">1177</span><span id="line.1177">     * @return the maximum number of entries before rehashing.</span>
<span class="source-line-no">1178</span><span id="line.1178">     */</span>
<span class="source-line-no">1179</span><span id="line.1179">    public static int maxFill(final int n, final float f) {</span>
<span class="source-line-no">1180</span><span id="line.1180">        /* We must guarantee that there is always at least</span>
<span class="source-line-no">1181</span><span id="line.1181">                 * one free entry (even with pathological load factors). */</span>
<span class="source-line-no">1182</span><span id="line.1182">        return Math.min((int)(n * f + 0.99999994f), n - 1);</span>
<span class="source-line-no">1183</span><span id="line.1183">    }</span>
<span class="source-line-no">1184</span><span id="line.1184"></span>
<span class="source-line-no">1185</span><span id="line.1185">    /**</span>
<span class="source-line-no">1186</span><span id="line.1186">     * Returns the least power of two smaller than or equal to 2&lt;sup&gt;30&lt;/sup&gt; and larger than or equal to &lt;code&gt;Math.ceil( expected / f )&lt;/code&gt;.</span>
<span class="source-line-no">1187</span><span id="line.1187">     *re</span>
<span class="source-line-no">1188</span><span id="line.1188">     * @param expected the expected number of elements in a hash table.</span>
<span class="source-line-no">1189</span><span id="line.1189">     * @param f        the load factor.</span>
<span class="source-line-no">1190</span><span id="line.1190">     * @return the minimum possible size for a backing array.</span>
<span class="source-line-no">1191</span><span id="line.1191">     * @throws IllegalArgumentException if the necessary size is larger than 2&lt;sup&gt;30&lt;/sup&gt;.</span>
<span class="source-line-no">1192</span><span id="line.1192">     */</span>
<span class="source-line-no">1193</span><span id="line.1193">    public static int arraySize(final int expected, final float f) {</span>
<span class="source-line-no">1194</span><span id="line.1194">        final long s = Math.max(2, HashCommon.nextPowerOfTwo((long) Math.ceil(expected / f)));</span>
<span class="source-line-no">1195</span><span id="line.1195">        if (s &gt; (1 &lt;&lt; 30))</span>
<span class="source-line-no">1196</span><span id="line.1196">            throw new IllegalArgumentException("Too large (" + expected + " expected elements with load factor " + f + ")");</span>
<span class="source-line-no">1197</span><span id="line.1197">        return (int) s;</span>
<span class="source-line-no">1198</span><span id="line.1198">    }</span>
<span class="source-line-no">1199</span><span id="line.1199"></span>
<span class="source-line-no">1200</span><span id="line.1200">    /**</span>
<span class="source-line-no">1201</span><span id="line.1201">     * Unwraps an iterator into an array starting at a given offset for a given number of elements.</span>
<span class="source-line-no">1202</span><span id="line.1202">     * &lt;p&gt;</span>
<span class="source-line-no">1203</span><span id="line.1203">     * &lt;P&gt;This method iterates over the given type-specific iterator and stores the elements returned, up to a maximum of &lt;code&gt;length&lt;/code&gt;, in the given array starting at &lt;code&gt;offset&lt;/code&gt;. The</span>
<span class="source-line-no">1204</span><span id="line.1204">     * number of actually unwrapped elements is returned (it may be less than &lt;code&gt;max&lt;/code&gt; if the iterator emits less than &lt;code&gt;max&lt;/code&gt; elements).</span>
<span class="source-line-no">1205</span><span id="line.1205">     *</span>
<span class="source-line-no">1206</span><span id="line.1206">     * @param i      a type-specific iterator.</span>
<span class="source-line-no">1207</span><span id="line.1207">     * @param array  an array to contain the output of the iterator.</span>
<span class="source-line-no">1208</span><span id="line.1208">     * @param offset the first element of the array to be returned.</span>
<span class="source-line-no">1209</span><span id="line.1209">     * @param max    the maximum number of elements to unwrap.</span>
<span class="source-line-no">1210</span><span id="line.1210">     * @return the number of elements unwrapped.</span>
<span class="source-line-no">1211</span><span id="line.1211">     */</span>
<span class="source-line-no">1212</span><span id="line.1212">    private int unwrap(final ValueIterator i, final Object[] array, int offset, final int max) {</span>
<span class="source-line-no">1213</span><span id="line.1213">        if (max &lt; 0) throw new IllegalArgumentException("The maximum number of elements (" + max + ") is negative");</span>
<span class="source-line-no">1214</span><span id="line.1214">        if (offset &lt; 0 || offset + max &gt; array.length) throw new IllegalArgumentException();</span>
<span class="source-line-no">1215</span><span id="line.1215">        int j = max;</span>
<span class="source-line-no">1216</span><span id="line.1216">        while (j-- != 0 &amp;&amp; i.hasNext())</span>
<span class="source-line-no">1217</span><span id="line.1217">            array[offset++] = i.next();</span>
<span class="source-line-no">1218</span><span id="line.1218">        return max - j - 1;</span>
<span class="source-line-no">1219</span><span id="line.1219">    }</span>
<span class="source-line-no">1220</span><span id="line.1220"></span>
<span class="source-line-no">1221</span><span id="line.1221">    /**</span>
<span class="source-line-no">1222</span><span id="line.1222">     * Unwraps an iterator into an array.</span>
<span class="source-line-no">1223</span><span id="line.1223">     * &lt;p&gt;</span>
<span class="source-line-no">1224</span><span id="line.1224">     * &lt;P&gt;This method iterates over the given type-specific iterator and stores the elements returned in the given array. The iteration will stop when the iterator has no more elements or when the end</span>
<span class="source-line-no">1225</span><span id="line.1225">     * of the array has been reached.</span>
<span class="source-line-no">1226</span><span id="line.1226">     *</span>
<span class="source-line-no">1227</span><span id="line.1227">     * @param i     a type-specific iterator.</span>
<span class="source-line-no">1228</span><span id="line.1228">     * @param array an array to contain the output of the iterator.</span>
<span class="source-line-no">1229</span><span id="line.1229">     * @return the number of elements unwrapped.</span>
<span class="source-line-no">1230</span><span id="line.1230">     */</span>
<span class="source-line-no">1231</span><span id="line.1231">    private int unwrap(final ValueIterator i, final Object[] array) {</span>
<span class="source-line-no">1232</span><span id="line.1232">        return unwrap(i, array, 0, array.length);</span>
<span class="source-line-no">1233</span><span id="line.1233">    }</span>
<span class="source-line-no">1234</span><span id="line.1234"></span>
<span class="source-line-no">1235</span><span id="line.1235"></span>
<span class="source-line-no">1236</span><span id="line.1236">    /** Unwraps an iterator into an array starting at a given offset for a given number of elements.</span>
<span class="source-line-no">1237</span><span id="line.1237">     *</span>
<span class="source-line-no">1238</span><span id="line.1238">     * &lt;P&gt;This method iterates over the given type-specific iterator and stores the elements returned, up to a maximum of &lt;code&gt;length&lt;/code&gt;, in the given array starting at &lt;code&gt;offset&lt;/code&gt;. The</span>
<span class="source-line-no">1239</span><span id="line.1239">     * number of actually unwrapped elements is returned (it may be less than &lt;code&gt;max&lt;/code&gt; if the iterator emits less than &lt;code&gt;max&lt;/code&gt; elements).</span>
<span class="source-line-no">1240</span><span id="line.1240">     *</span>
<span class="source-line-no">1241</span><span id="line.1241">     * @param i a type-specific iterator.</span>
<span class="source-line-no">1242</span><span id="line.1242">     * @param array an array to contain the output of the iterator.</span>
<span class="source-line-no">1243</span><span id="line.1243">     * @param offset the first element of the array to be returned.</span>
<span class="source-line-no">1244</span><span id="line.1244">     * @param max the maximum number of elements to unwrap.</span>
<span class="source-line-no">1245</span><span id="line.1245">     * @return the number of elements unwrapped. */</span>
<span class="source-line-no">1246</span><span id="line.1246">    private static &lt;K&gt; int objectUnwrap(final Iterator&lt;? extends K&gt; i, final K[] array, int offset, final int max ) {</span>
<span class="source-line-no">1247</span><span id="line.1247">        if ( max &lt; 0 ) throw new IllegalArgumentException( "The maximum number of elements (" + max + ") is negative" );</span>
<span class="source-line-no">1248</span><span id="line.1248">        if ( offset &lt; 0 || offset + max &gt; array.length ) throw new IllegalArgumentException();</span>
<span class="source-line-no">1249</span><span id="line.1249">        int j = max;</span>
<span class="source-line-no">1250</span><span id="line.1250">        while ( j-- != 0 &amp;&amp; i.hasNext() )</span>
<span class="source-line-no">1251</span><span id="line.1251">            array[ offset++ ] = i.next();</span>
<span class="source-line-no">1252</span><span id="line.1252">        return max - j - 1;</span>
<span class="source-line-no">1253</span><span id="line.1253">    }</span>
<span class="source-line-no">1254</span><span id="line.1254"></span>
<span class="source-line-no">1255</span><span id="line.1255">    /** Unwraps an iterator into an array.</span>
<span class="source-line-no">1256</span><span id="line.1256">     *</span>
<span class="source-line-no">1257</span><span id="line.1257">     * &lt;P&gt;This method iterates over the given type-specific iterator and stores the elements returned in the given array. The iteration will stop when the iterator has no more elements or when the end</span>
<span class="source-line-no">1258</span><span id="line.1258">     * of the array has been reached.</span>
<span class="source-line-no">1259</span><span id="line.1259">     *</span>
<span class="source-line-no">1260</span><span id="line.1260">     * @param i a type-specific iterator.</span>
<span class="source-line-no">1261</span><span id="line.1261">     * @param array an array to contain the output of the iterator.</span>
<span class="source-line-no">1262</span><span id="line.1262">     * @return the number of elements unwrapped. */</span>
<span class="source-line-no">1263</span><span id="line.1263">    private static &lt;K&gt; int objectUnwrap(final Iterator&lt;? extends K&gt; i, final K[] array) {</span>
<span class="source-line-no">1264</span><span id="line.1264">        return objectUnwrap(i, array, 0, array.length );</span>
<span class="source-line-no">1265</span><span id="line.1265">    }</span>
<span class="source-line-no">1266</span><span id="line.1266"></span>
<span class="source-line-no">1267</span><span id="line.1267">    @Override</span>
<span class="source-line-no">1268</span><span id="line.1268">    public String toString() {</span>
<span class="source-line-no">1269</span><span id="line.1269">        final StringBuilder s = new StringBuilder();</span>
<span class="source-line-no">1270</span><span id="line.1270">        final Iterator&lt;Map.Entry&lt;K, V&gt;&gt; i = entrySet().iterator();</span>
<span class="source-line-no">1271</span><span id="line.1271">        int n = size();</span>
<span class="source-line-no">1272</span><span id="line.1272">        Map.Entry &lt;K,V&gt; e;</span>
<span class="source-line-no">1273</span><span id="line.1273">        boolean first = true;</span>
<span class="source-line-no">1274</span><span id="line.1274">        s.append("UnorderedMap {");</span>
<span class="source-line-no">1275</span><span id="line.1275">        while(n-- != 0) {</span>
<span class="source-line-no">1276</span><span id="line.1276">            if (first) first = false;</span>
<span class="source-line-no">1277</span><span id="line.1277">            else s.append(", ");</span>
<span class="source-line-no">1278</span><span id="line.1278">            e = i.next();</span>
<span class="source-line-no">1279</span><span id="line.1279">            if (this == e.getKey()) s.append("(this map)"); else</span>
<span class="source-line-no">1280</span><span id="line.1280">                s.append(String.valueOf(e.getKey()));</span>
<span class="source-line-no">1281</span><span id="line.1281">            s.append("=&gt;");</span>
<span class="source-line-no">1282</span><span id="line.1282">            if (this == e.getValue()) s.append("(this map)"); else</span>
<span class="source-line-no">1283</span><span id="line.1283">                s.append(String.valueOf(e.getValue()));</span>
<span class="source-line-no">1284</span><span id="line.1284">        }</span>
<span class="source-line-no">1285</span><span id="line.1285">        s.append("}");</span>
<span class="source-line-no">1286</span><span id="line.1286">        return s.toString();</span>
<span class="source-line-no">1287</span><span id="line.1287">    }</span>
<span class="source-line-no">1288</span><span id="line.1288">    @Override</span>
<span class="source-line-no">1289</span><span id="line.1289">    public boolean equals(Object o) {</span>
<span class="source-line-no">1290</span><span id="line.1290">        if (o == this)</span>
<span class="source-line-no">1291</span><span id="line.1291">            return true;</span>
<span class="source-line-no">1292</span><span id="line.1292">        if (!(o instanceof Map))</span>
<span class="source-line-no">1293</span><span id="line.1293">            return false;</span>
<span class="source-line-no">1294</span><span id="line.1294">        Map&lt;?, ?&gt; m = (Map&lt;?, ?&gt;) o;</span>
<span class="source-line-no">1295</span><span id="line.1295">        if (m.size() != size())</span>
<span class="source-line-no">1296</span><span id="line.1296">            return false;</span>
<span class="source-line-no">1297</span><span id="line.1297">        return entrySet().containsAll(m.entrySet());</span>
<span class="source-line-no">1298</span><span id="line.1298">    }</span>
<span class="source-line-no">1299</span><span id="line.1299"></span>
<span class="source-line-no">1300</span><span id="line.1300">    @GwtIncompatible</span>
<span class="source-line-no">1301</span><span id="line.1301">    private void writeObject(java.io.ObjectOutputStream s)</span>
<span class="source-line-no">1302</span><span id="line.1302">            throws java.io.IOException {</span>
<span class="source-line-no">1303</span><span id="line.1303">        final K[] key = this.key;</span>
<span class="source-line-no">1304</span><span id="line.1304">        final V[] value = this.value;</span>
<span class="source-line-no">1305</span><span id="line.1305">        final MapIterator i = new MapIterator();</span>
<span class="source-line-no">1306</span><span id="line.1306">        s.defaultWriteObject();</span>
<span class="source-line-no">1307</span><span id="line.1307">        for (int j = size, e; j-- != 0;) {</span>
<span class="source-line-no">1308</span><span id="line.1308">            e = i.nextEntry();</span>
<span class="source-line-no">1309</span><span id="line.1309">            s.writeObject(key[e]);</span>
<span class="source-line-no">1310</span><span id="line.1310">            s.writeObject(value[e]);</span>
<span class="source-line-no">1311</span><span id="line.1311">        }</span>
<span class="source-line-no">1312</span><span id="line.1312">    }</span>
<span class="source-line-no">1313</span><span id="line.1313">    @GwtIncompatible</span>
<span class="source-line-no">1314</span><span id="line.1314">    @SuppressWarnings("unchecked")</span>
<span class="source-line-no">1315</span><span id="line.1315">    private void readObject(java.io.ObjectInputStream s)</span>
<span class="source-line-no">1316</span><span id="line.1316">            throws java.io.IOException, ClassNotFoundException {</span>
<span class="source-line-no">1317</span><span id="line.1317">        s.defaultReadObject();</span>
<span class="source-line-no">1318</span><span id="line.1318">        n = arraySize(size, f);</span>
<span class="source-line-no">1319</span><span id="line.1319">        maxFill = maxFill(n, f);</span>
<span class="source-line-no">1320</span><span id="line.1320">        mask = n - 1;</span>
<span class="source-line-no">1321</span><span id="line.1321">        final K[] key = this.key = (K[]) new Object[n + 1];</span>
<span class="source-line-no">1322</span><span id="line.1322">        final V[] value = this.value = (V[]) new Object[n + 1];</span>
<span class="source-line-no">1323</span><span id="line.1323">        K k;</span>
<span class="source-line-no">1324</span><span id="line.1324">        V v;</span>
<span class="source-line-no">1325</span><span id="line.1325">        for (int i = size, pos; i-- != 0;) {</span>
<span class="source-line-no">1326</span><span id="line.1326">            k = (K) s.readObject();</span>
<span class="source-line-no">1327</span><span id="line.1327">            v = (V) s.readObject();</span>
<span class="source-line-no">1328</span><span id="line.1328">            if (k == null) {</span>
<span class="source-line-no">1329</span><span id="line.1329">                pos = n;</span>
<span class="source-line-no">1330</span><span id="line.1330">                containsNullKey = true;</span>
<span class="source-line-no">1331</span><span id="line.1331">            } else {</span>
<span class="source-line-no">1332</span><span id="line.1332">                pos = (hasher.hash(k))</span>
<span class="source-line-no">1333</span><span id="line.1333">                        &amp; mask;</span>
<span class="source-line-no">1334</span><span id="line.1334">                while (key[pos] != null)</span>
<span class="source-line-no">1335</span><span id="line.1335">                    pos = (pos + 1) &amp; mask;</span>
<span class="source-line-no">1336</span><span id="line.1336">            }</span>
<span class="source-line-no">1337</span><span id="line.1337"></span>
<span class="source-line-no">1338</span><span id="line.1338">            key[pos] = k;</span>
<span class="source-line-no">1339</span><span id="line.1339">            value[pos] = v;</span>
<span class="source-line-no">1340</span><span id="line.1340">        }</span>
<span class="source-line-no">1341</span><span id="line.1341">    }</span>
<span class="source-line-no">1342</span><span id="line.1342"></span>
<span class="source-line-no">1343</span><span id="line.1343">    public List&lt;V&gt; getMany(Collection&lt;K&gt; keys)</span>
<span class="source-line-no">1344</span><span id="line.1344">    {</span>
<span class="source-line-no">1345</span><span id="line.1345">        if(keys == null)</span>
<span class="source-line-no">1346</span><span id="line.1346">            return new ArrayList&lt;&gt;(1);</span>
<span class="source-line-no">1347</span><span id="line.1347">        ArrayList&lt;V&gt; vals = new ArrayList&lt;&gt;(keys.size());</span>
<span class="source-line-no">1348</span><span id="line.1348">        for(K k : keys)</span>
<span class="source-line-no">1349</span><span id="line.1349">        {</span>
<span class="source-line-no">1350</span><span id="line.1350">            vals.add(get(k));</span>
<span class="source-line-no">1351</span><span id="line.1351">        }</span>
<span class="source-line-no">1352</span><span id="line.1352">        return vals;</span>
<span class="source-line-no">1353</span><span id="line.1353">    }</span>
<span class="source-line-no">1354</span><span id="line.1354">    </span>
<span class="source-line-no">1355</span><span id="line.1355">    /**</span>
<span class="source-line-no">1356</span><span id="line.1356">     * If the specified key is not already associated with a value (or is mapped</span>
<span class="source-line-no">1357</span><span id="line.1357">     * to {@code null}) associates it with the given value and returns</span>
<span class="source-line-no">1358</span><span id="line.1358">     * {@code null}, else returns the current value.</span>
<span class="source-line-no">1359</span><span id="line.1359">     *</span>
<span class="source-line-no">1360</span><span id="line.1360">     * @param key   key with which the specified value is to be associated</span>
<span class="source-line-no">1361</span><span id="line.1361">     * @param value value to be associated with the specified key</span>
<span class="source-line-no">1362</span><span id="line.1362">     * @return the previous value associated with the specified key, or</span>
<span class="source-line-no">1363</span><span id="line.1363">     * {@code null} if there was no mapping for the key.</span>
<span class="source-line-no">1364</span><span id="line.1364">     * (A {@code null} return can also indicate that the map</span>
<span class="source-line-no">1365</span><span id="line.1365">     * previously associated {@code null} with the key.)</span>
<span class="source-line-no">1366</span><span id="line.1366">     */</span>
<span class="source-line-no">1367</span><span id="line.1367">    public V putIfAbsent(K key, V value) {</span>
<span class="source-line-no">1368</span><span id="line.1368">        V v = get(key);</span>
<span class="source-line-no">1369</span><span id="line.1369">        if(v == null)</span>
<span class="source-line-no">1370</span><span id="line.1370">            v = put(key, value);</span>
<span class="source-line-no">1371</span><span id="line.1371">        return v;</span>
<span class="source-line-no">1372</span><span id="line.1372">    }</span>
<span class="source-line-no">1373</span><span id="line.1373"></span>
<span class="source-line-no">1374</span><span id="line.1374">    /**</span>
<span class="source-line-no">1375</span><span id="line.1375">     * Removes the entry for the specified key only if it is currently</span>
<span class="source-line-no">1376</span><span id="line.1376">     * mapped to the specified value.</span>
<span class="source-line-no">1377</span><span id="line.1377">     *</span>
<span class="source-line-no">1378</span><span id="line.1378">     * @param key   key with which the specified value is associated</span>
<span class="source-line-no">1379</span><span id="line.1379">     * @param value value expected to be associated with the specified key</span>
<span class="source-line-no">1380</span><span id="line.1380">     * @return {@code true} if the value was removed</span>
<span class="source-line-no">1381</span><span id="line.1381">     */</span>
<span class="source-line-no">1382</span><span id="line.1382">    public boolean remove(Object key, Object value) {</span>
<span class="source-line-no">1383</span><span id="line.1383">        if (containsKey(key) &amp;&amp; Objects.equals(get(key), value)) {</span>
<span class="source-line-no">1384</span><span id="line.1384">            remove(key);</span>
<span class="source-line-no">1385</span><span id="line.1385">            return true;</span>
<span class="source-line-no">1386</span><span id="line.1386">        } else</span>
<span class="source-line-no">1387</span><span id="line.1387">            return false;</span>
<span class="source-line-no">1388</span><span id="line.1388">    }</span>
<span class="source-line-no">1389</span><span id="line.1389"></span>
<span class="source-line-no">1390</span><span id="line.1390">    /**</span>
<span class="source-line-no">1391</span><span id="line.1391">     * Replaces the entry for the specified key only if currently</span>
<span class="source-line-no">1392</span><span id="line.1392">     * mapped to the specified value. The position in the iteration</span>
<span class="source-line-no">1393</span><span id="line.1393">     * order is retained.</span>
<span class="source-line-no">1394</span><span id="line.1394">     *</span>
<span class="source-line-no">1395</span><span id="line.1395">     * @param key      key with which the specified value is associated</span>
<span class="source-line-no">1396</span><span id="line.1396">     * @param oldValue value expected to be associated with the specified key</span>
<span class="source-line-no">1397</span><span id="line.1397">     * @param newValue value to be associated with the specified key</span>
<span class="source-line-no">1398</span><span id="line.1398">     * @return {@code true} if the value was replaced</span>
<span class="source-line-no">1399</span><span id="line.1399">     */</span>
<span class="source-line-no">1400</span><span id="line.1400">    public boolean replace(K key, V oldValue, V newValue) {</span>
<span class="source-line-no">1401</span><span id="line.1401">        if (containsKey(key) &amp;&amp; Objects.equals(get(key), oldValue)) {</span>
<span class="source-line-no">1402</span><span id="line.1402">            put(key, newValue);</span>
<span class="source-line-no">1403</span><span id="line.1403">            return true;</span>
<span class="source-line-no">1404</span><span id="line.1404">        } else</span>
<span class="source-line-no">1405</span><span id="line.1405">            return false;</span>
<span class="source-line-no">1406</span><span id="line.1406">    }</span>
<span class="source-line-no">1407</span><span id="line.1407"></span>
<span class="source-line-no">1408</span><span id="line.1408">    /**</span>
<span class="source-line-no">1409</span><span id="line.1409">     * Replaces the entry for the specified key only if it is</span>
<span class="source-line-no">1410</span><span id="line.1410">     * currently mapped to some value. Preserves the existing key's</span>
<span class="source-line-no">1411</span><span id="line.1411">     * position in the iteration order.</span>
<span class="source-line-no">1412</span><span id="line.1412">     *</span>
<span class="source-line-no">1413</span><span id="line.1413">     * @param key   key with which the specified value is associated</span>
<span class="source-line-no">1414</span><span id="line.1414">     * @param value value to be associated with the specified key</span>
<span class="source-line-no">1415</span><span id="line.1415">     * @return the previous value associated with the specified key, or</span>
<span class="source-line-no">1416</span><span id="line.1416">     * {@code null} if there was no mapping for the key.</span>
<span class="source-line-no">1417</span><span id="line.1417">     * (A {@code null} return can also indicate that the map</span>
<span class="source-line-no">1418</span><span id="line.1418">     * previously associated {@code null} with the key.)</span>
<span class="source-line-no">1419</span><span id="line.1419">     */</span>
<span class="source-line-no">1420</span><span id="line.1420">    public V replace(K key, V value) {</span>
<span class="source-line-no">1421</span><span id="line.1421">        if (containsKey(key)) {</span>
<span class="source-line-no">1422</span><span id="line.1422">            return put(key, value);</span>
<span class="source-line-no">1423</span><span id="line.1423">        } else</span>
<span class="source-line-no">1424</span><span id="line.1424">            return null;</span>
<span class="source-line-no">1425</span><span id="line.1425">    }</span>
<span class="source-line-no">1426</span><span id="line.1426">    /**</span>
<span class="source-line-no">1427</span><span id="line.1427">     * Given alternating key and value arguments in pairs, puts each key-value pair into this OrderedMap as if by</span>
<span class="source-line-no">1428</span><span id="line.1428">     * calling {@link #put(Object, Object)} repeatedly for each pair. This mimics the parameter syntax used for</span>
<span class="source-line-no">1429</span><span id="line.1429">     * {@link #makeMap(Object, Object, Object...)}, and can be used to retain that style of insertion after an</span>
<span class="source-line-no">1430</span><span id="line.1430">     * OrderedMap has been instantiated.</span>
<span class="source-line-no">1431</span><span id="line.1431">     * @param k0 the first key to add</span>
<span class="source-line-no">1432</span><span id="line.1432">     * @param v0 the first value to add</span>
<span class="source-line-no">1433</span><span id="line.1433">     * @param rest an array or vararg of keys and values in pairs; should contain alternating K, V, K, V... elements</span>
<span class="source-line-no">1434</span><span id="line.1434">     * @return this, after adding all viable key-value pairs given</span>
<span class="source-line-no">1435</span><span id="line.1435">     */</span>
<span class="source-line-no">1436</span><span id="line.1436">    @SuppressWarnings("unchecked")</span>
<span class="source-line-no">1437</span><span id="line.1437">    public UnorderedMap&lt;K, V&gt; putPairs(K k0, V v0, Object... rest)</span>
<span class="source-line-no">1438</span><span id="line.1438">    {</span>
<span class="source-line-no">1439</span><span id="line.1439">        if(rest == null || rest.length == 0)</span>
<span class="source-line-no">1440</span><span id="line.1440">        {</span>
<span class="source-line-no">1441</span><span id="line.1441">            put(k0, v0);</span>
<span class="source-line-no">1442</span><span id="line.1442">            return this;</span>
<span class="source-line-no">1443</span><span id="line.1443">        }</span>
<span class="source-line-no">1444</span><span id="line.1444">        put(k0, v0);</span>
<span class="source-line-no">1445</span><span id="line.1445"></span>
<span class="source-line-no">1446</span><span id="line.1446">        for (int i = 0; i &lt; rest.length - 1; i+=2) {</span>
<span class="source-line-no">1447</span><span id="line.1447">            try {</span>
<span class="source-line-no">1448</span><span id="line.1448">                put((K) rest[i], (V) rest[i + 1]);</span>
<span class="source-line-no">1449</span><span id="line.1449">            }catch (ClassCastException ignored) {</span>
<span class="source-line-no">1450</span><span id="line.1450">            }</span>
<span class="source-line-no">1451</span><span id="line.1451">        }</span>
<span class="source-line-no">1452</span><span id="line.1452">        return this;</span>
<span class="source-line-no">1453</span><span id="line.1453">    }</span>
<span class="source-line-no">1454</span><span id="line.1454"></span>
<span class="source-line-no">1455</span><span id="line.1455">    /**</span>
<span class="source-line-no">1456</span><span id="line.1456">     * Makes an OrderedMap (OM) with the given load factor (which should be between 0.1 and 0.9), key and value types</span>
<span class="source-line-no">1457</span><span id="line.1457">     * inferred from the types of k0 and v0, and considers all remaining parameters key-value pairs, casting the Objects</span>
<span class="source-line-no">1458</span><span id="line.1458">     * at positions 0, 2, 4... etc. to K and the objects at positions 1, 3, 5... etc. to V. If rest has an odd-number</span>
<span class="source-line-no">1459</span><span id="line.1459">     * length, then it discards the last item. If any pair of items in rest cannot be cast to the correct type of K or</span>
<span class="source-line-no">1460</span><span id="line.1460">     * V, then this inserts nothing for that pair. This is similar to the makeOM method in the Maker class, but does not</span>
<span class="source-line-no">1461</span><span id="line.1461">     * allow setting the load factor (since that extra parameter can muddle how javac figures out which generic types</span>
<span class="source-line-no">1462</span><span id="line.1462">     * the map should use), nor does it log debug information if a cast fails. The result should be the same otherwise.</span>
<span class="source-line-no">1463</span><span id="line.1463">     * &lt;br&gt;</span>
<span class="source-line-no">1464</span><span id="line.1464">     * This is named makeMap to indicate that it expects key and value parameters, unlike a Set or List. This convention</span>
<span class="source-line-no">1465</span><span id="line.1465">     * may be extended to other data structures that also have static methods for instantiation.</span>
<span class="source-line-no">1466</span><span id="line.1466">     * @param k0 the first key; used to infer the types of other keys if generic parameters aren't specified.</span>
<span class="source-line-no">1467</span><span id="line.1467">     * @param v0 the first value; used to infer the types of other values if generic parameters aren't specified.</span>
<span class="source-line-no">1468</span><span id="line.1468">     * @param rest an array or vararg of keys and values in pairs; should contain alternating K, V, K, V... elements</span>
<span class="source-line-no">1469</span><span id="line.1469">     * @param &lt;K&gt; the type of keys in the returned OrderedMap; if not specified, will be inferred from k0</span>
<span class="source-line-no">1470</span><span id="line.1470">     * @param &lt;V&gt; the type of values in the returned OrderedMap; if not specified, will be inferred from v0</span>
<span class="source-line-no">1471</span><span id="line.1471">     * @return a freshly-made OrderedMap with K keys and V values, using k0, v0, and the contents of rest to fill it</span>
<span class="source-line-no">1472</span><span id="line.1472">     */</span>
<span class="source-line-no">1473</span><span id="line.1473">    @SuppressWarnings("unchecked")</span>
<span class="source-line-no">1474</span><span id="line.1474">    public static &lt;K, V&gt; UnorderedMap&lt;K, V&gt; makeMap(K k0, V v0, Object... rest)</span>
<span class="source-line-no">1475</span><span id="line.1475">    {</span>
<span class="source-line-no">1476</span><span id="line.1476">        if(rest == null || rest.length == 0)</span>
<span class="source-line-no">1477</span><span id="line.1477">        {</span>
<span class="source-line-no">1478</span><span id="line.1478">            UnorderedMap&lt;K, V&gt; om = new UnorderedMap&lt;&gt;(2);</span>
<span class="source-line-no">1479</span><span id="line.1479">            om.put(k0, v0);</span>
<span class="source-line-no">1480</span><span id="line.1480">            return om;</span>
<span class="source-line-no">1481</span><span id="line.1481">        }</span>
<span class="source-line-no">1482</span><span id="line.1482">        UnorderedMap&lt;K, V&gt; om = new UnorderedMap&lt;&gt;(1 + (rest.length &gt;&gt; 1));</span>
<span class="source-line-no">1483</span><span id="line.1483">        om.put(k0, v0);</span>
<span class="source-line-no">1484</span><span id="line.1484"></span>
<span class="source-line-no">1485</span><span id="line.1485">        for (int i = 0; i &lt; rest.length - 1; i+=2) {</span>
<span class="source-line-no">1486</span><span id="line.1486">            try {</span>
<span class="source-line-no">1487</span><span id="line.1487">                om.put((K) rest[i], (V) rest[i + 1]);</span>
<span class="source-line-no">1488</span><span id="line.1488">            }catch (ClassCastException ignored) {</span>
<span class="source-line-no">1489</span><span id="line.1489">            }</span>
<span class="source-line-no">1490</span><span id="line.1490">        }</span>
<span class="source-line-no">1491</span><span id="line.1491">        return om;</span>
<span class="source-line-no">1492</span><span id="line.1492">    }</span>
<span class="source-line-no">1493</span><span id="line.1493"></span>
<span class="source-line-no">1494</span><span id="line.1494">    /**</span>
<span class="source-line-no">1495</span><span id="line.1495">     * Makes an empty OrderedMap (OM); needs key and value types to be specified in order to work. For an empty</span>
<span class="source-line-no">1496</span><span id="line.1496">     * OrderedMap with String keys and Coord values, you could use {@code Maker.&lt;String, Coord&gt;makeOM()}. Using</span>
<span class="source-line-no">1497</span><span id="line.1497">     * the new keyword is probably just as easy in this case; this method is provided for completeness relative to</span>
<span class="source-line-no">1498</span><span id="line.1498">     * makeMap() with 2 or more parameters.</span>
<span class="source-line-no">1499</span><span id="line.1499">     * @param &lt;K&gt; the type of keys in the returned OrderedMap; cannot be inferred and must be specified</span>
<span class="source-line-no">1500</span><span id="line.1500">     * @param &lt;V&gt; the type of values in the returned OrderedMap; cannot be inferred and must be specified</span>
<span class="source-line-no">1501</span><span id="line.1501">     * @return an empty OrderedMap with the given key and value types.</span>
<span class="source-line-no">1502</span><span id="line.1502">     */</span>
<span class="source-line-no">1503</span><span id="line.1503">    public static &lt;K, V&gt; UnorderedMap&lt;K, V&gt; makeMap()</span>
<span class="source-line-no">1504</span><span id="line.1504">    {</span>
<span class="source-line-no">1505</span><span id="line.1505">        return new UnorderedMap&lt;&gt;();</span>
<span class="source-line-no">1506</span><span id="line.1506">    }</span>
<span class="source-line-no">1507</span><span id="line.1507"></span>
<span class="source-line-no">1508</span><span id="line.1508">}</span>




























































</pre>
</div>
</main>
</body>
</html>
