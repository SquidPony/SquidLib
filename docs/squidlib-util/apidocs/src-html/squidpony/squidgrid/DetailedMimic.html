<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>Source code</title>
<meta name="description" content="source: package: squidpony.squidgrid, class: DetailedMimic">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body class="source-page">
<main role="main">
<div class="source-container">
<pre><span class="source-line-no">001</span><span id="line.1">/*</span>
<span class="source-line-no">002</span><span id="line.2">The MIT License(MIT)</span>
<span class="source-line-no">003</span><span id="line.3">Copyright(c) mxgmn 2016.</span>
<span class="source-line-no">004</span><span id="line.4"></span>
<span class="source-line-no">005</span><span id="line.5">Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</span>
<span class="source-line-no">006</span><span id="line.6"></span>
<span class="source-line-no">007</span><span id="line.7">The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</span>
<span class="source-line-no">008</span><span id="line.8"></span>
<span class="source-line-no">009</span><span id="line.9">The software is provided "as is", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the software or the use or other dealings in the software.</span>
<span class="source-line-no">010</span><span id="line.10">*/</span>
<span class="source-line-no">011</span><span id="line.11">package squidpony.squidgrid;</span>
<span class="source-line-no">012</span><span id="line.12"></span>
<span class="source-line-no">013</span><span id="line.13">import squidpony.squidmath.*;</span>
<span class="source-line-no">014</span><span id="line.14"></span>
<span class="source-line-no">015</span><span id="line.15">import java.util.Arrays;</span>
<span class="source-line-no">016</span><span id="line.16"></span>
<span class="source-line-no">017</span><span id="line.17">/**</span>
<span class="source-line-no">018</span><span id="line.18"> * Similar to MimicFill, this class can be used to imitate the style of an existing piece of data, but this works on</span>
<span class="source-line-no">019</span><span id="line.19"> * more than just booleans; it can produce similar styles of texture (its original use in SynTex), of map, of item</span>
<span class="source-line-no">020</span><span id="line.20"> * placement, and so on by specifying a different technique for differentiating two int values.</span>
<span class="source-line-no">021</span><span id="line.21"> * &lt;br&gt;</span>
<span class="source-line-no">022</span><span id="line.22"> * Two options are now available; the process() method allows the slow analyze() step to be computed once,</span>
<span class="source-line-no">023</span><span id="line.23"> * before the rest of processing is potentially done many times, but the new neoProcess() method produces</span>
<span class="source-line-no">024</span><span id="line.24"> * comparable or better results and is drastically faster even without needing analysis. This means</span>
<span class="source-line-no">025</span><span id="line.25"> * neoProcess(), based on P.F. Harrison's algorithm in SynTex, is strongly recommended now.</span>
<span class="source-line-no">026</span><span id="line.26"> * &lt;br&gt;</span>
<span class="source-line-no">027</span><span id="line.27"> * Example results of neoProcess(), with a procedural dungeon first and the mimic versions after it:</span>
<span class="source-line-no">028</span><span id="line.28"> * https://gist.github.com/tommyettinger/405336fb0fc74838d806c021aabe77da (you may need to click Raw and zoom</span>
<span class="source-line-no">029</span><span id="line.29"> * out somewhat for it to render well).</span>
<span class="source-line-no">030</span><span id="line.30"> * &lt;br&gt;</span>
<span class="source-line-no">031</span><span id="line.31"> * Ported from https://github.com/mxgmn/SynTex by Tommy Ettinger on 6/9/2016.</span>
<span class="source-line-no">032</span><span id="line.32"> */</span>
<span class="source-line-no">033</span><span id="line.33">public class DetailedMimic {</span>
<span class="source-line-no">034</span><span id="line.34"></span>
<span class="source-line-no">035</span><span id="line.35">    /**</span>
<span class="source-line-no">036</span><span id="line.36">     * Constructor that uses an unseeded RNG and, without any instruction otherwise, assumes the ints this is asked to</span>
<span class="source-line-no">037</span><span id="line.37">     * compare are colors in RGBA8888 format. You can specify your own implementation of the AestheticDifference</span>
<span class="source-line-no">038</span><span id="line.38">     * interface (one function) and pass it to other constructors, as well.</span>
<span class="source-line-no">039</span><span id="line.39">     */</span>
<span class="source-line-no">040</span><span id="line.40">    public DetailedMimic()</span>
<span class="source-line-no">041</span><span id="line.41">    {</span>
<span class="source-line-no">042</span><span id="line.42">        this(AestheticDifference.rgba8888);</span>
<span class="source-line-no">043</span><span id="line.43">    }</span>
<span class="source-line-no">044</span><span id="line.44"></span>
<span class="source-line-no">045</span><span id="line.45">    /**</span>
<span class="source-line-no">046</span><span id="line.46">     * Constructor that uses an unseeded RNG (effectively a random seed) and the given AestheticDifference. An example</span>
<span class="source-line-no">047</span><span id="line.47">     * piece of code that implements an AestheticDifference is available in the docs for</span>
<span class="source-line-no">048</span><span id="line.48">     * {@link AestheticDifference#difference(int, int)}; it is also considered a functional interface if you use Java 8</span>
<span class="source-line-no">049</span><span id="line.49">     * or newer. You can also use the ready-made implementation {@link AestheticDifference#rgba8888} if you have int</span>
<span class="source-line-no">050</span><span id="line.50">     * data that represents RGBA8888 colors, which can be obtained from libGDX Colors or SColors in the display module.</span>
<span class="source-line-no">051</span><span id="line.51">     * @param diff an implementation of the AestheticDifference interface, such as {@link AestheticDifference#rgba8888};</span>
<span class="source-line-no">052</span><span id="line.52">     *             may be null, but that forces all calls to processing methods to treat discrete as true</span>
<span class="source-line-no">053</span><span id="line.53">     */</span>
<span class="source-line-no">054</span><span id="line.54">    public DetailedMimic(AestheticDifference diff)</span>
<span class="source-line-no">055</span><span id="line.55">    {</span>
<span class="source-line-no">056</span><span id="line.56">        this(diff, new GWTRNG());</span>
<span class="source-line-no">057</span><span id="line.57">    }</span>
<span class="source-line-no">058</span><span id="line.58"></span>
<span class="source-line-no">059</span><span id="line.59">    /**</span>
<span class="source-line-no">060</span><span id="line.60">     * Constructor that uses the given RNG and the given AestheticDifference. An example</span>
<span class="source-line-no">061</span><span id="line.61">     * piece of code that implements an AestheticDifference is available in the docs for</span>
<span class="source-line-no">062</span><span id="line.62">     * {@link AestheticDifference#difference(int, int)}; it is also considered a functional interface if you use Java 8</span>
<span class="source-line-no">063</span><span id="line.63">     * or newer. You can also use the ready-made implementation {@link AestheticDifference#rgba8888} if you have int</span>
<span class="source-line-no">064</span><span id="line.64">     * data that represents RGBA8888 colors, which can be obtained from libGDX Colors or SColors in the display module.</span>
<span class="source-line-no">065</span><span id="line.65">     * @param diff an implementation of the AestheticDifference interface, such as {@link AestheticDifference#rgba8888};</span>
<span class="source-line-no">066</span><span id="line.66">     *             may be null, but that forces all calls to processing methods to treat discrete as true</span>
<span class="source-line-no">067</span><span id="line.67">     * @param rng an IRNG, such as an RNG, to generate random factors; may be seeded to produce reliable output</span>
<span class="source-line-no">068</span><span id="line.68">     */</span>
<span class="source-line-no">069</span><span id="line.69">    public DetailedMimic(AestheticDifference diff, IRNG rng)</span>
<span class="source-line-no">070</span><span id="line.70">    {</span>
<span class="source-line-no">071</span><span id="line.71">        random = rng;</span>
<span class="source-line-no">072</span><span id="line.72">        difference = diff;</span>
<span class="source-line-no">073</span><span id="line.73">        analyzed = null;</span>
<span class="source-line-no">074</span><span id="line.74">    }</span>
<span class="source-line-no">075</span><span id="line.75"></span>
<span class="source-line-no">076</span><span id="line.76">    /**</span>
<span class="source-line-no">077</span><span id="line.77">     * DISCOURAGED; use {@link #neoProcess(int[], int, int, int, int, int, int, boolean)} instead, which doesn't need a</span>
<span class="source-line-no">078</span><span id="line.78">     * separate analysis step.</span>
<span class="source-line-no">079</span><span id="line.79">     * Analyzes a sample as a 1D int array and stores the needed info to call</span>
<span class="source-line-no">080</span><span id="line.80">     * {@link #process(int[], int, int, int, int, int, int, double, boolean)} any number of times later on without</span>
<span class="source-line-no">081</span><span id="line.81">     * recalculating some heavy-weight information.</span>
<span class="source-line-no">082</span><span id="line.82">     * @param sample a 1D array of ints that can be compared by the AestheticDifference this uses (or any ints if</span>
<span class="source-line-no">083</span><span id="line.83">     *               discrete is true)</span>
<span class="source-line-no">084</span><span id="line.84">     * @param width the width of the area in sample this should use (sample can be interpreted as different shapes)</span>
<span class="source-line-no">085</span><span id="line.85">     * @param height the height of the area in sample this should use (sample can be interpreted as different shapes)</span>
<span class="source-line-no">086</span><span id="line.86">     * @param detailLevel how much detail to try for; if 0 or less this does nothing, 2 works well in general</span>
<span class="source-line-no">087</span><span id="line.87">     * @param proximity how far away to consider cells as affecting another; 3 works well</span>
<span class="source-line-no">088</span><span id="line.88">     * @param discrete false if this can produce ints other than those in the input; true if it uses a fixed set</span>
<span class="source-line-no">089</span><span id="line.89">     */</span>
<span class="source-line-no">090</span><span id="line.90">    public void analyze(int[] sample, int width, int height, int detailLevel, int proximity, boolean discrete)</span>
<span class="source-line-no">091</span><span id="line.91">    {</span>
<span class="source-line-no">092</span><span id="line.92">        discrete |= (difference == null);</span>
<span class="source-line-no">093</span><span id="line.93">        if(detailLevel &gt; 0)</span>
<span class="source-line-no">094</span><span id="line.94">            analysis(sample, width, height, detailLevel, proximity, discrete);</span>
<span class="source-line-no">095</span><span id="line.95">    }</span>
<span class="source-line-no">096</span><span id="line.96">    /**</span>
<span class="source-line-no">097</span><span id="line.97">     * DISCOURAGED; use {@link #neoProcess(int[], int, int, int, int, int, int, boolean)} instead, which doesn't need a</span>
<span class="source-line-no">098</span><span id="line.98">     * separate analysis step.</span>
<span class="source-line-no">099</span><span id="line.99">     * Processes a sample as a 1D int array and returns a different 1D int array that mimics the input. If the last time</span>
<span class="source-line-no">100</span><span id="line.100">     * this was called used the same sample, sampleWidth, and sampleHeight parameters, or if</span>
<span class="source-line-no">101</span><span id="line.101">     * {@link #analyze(int[], int, int, int, int, boolean)} was called with its width equal to sampleWidth and its</span>
<span class="source-line-no">102</span><span id="line.102">     * height equal to sampleHeight, then this doesn't need to perform as many expensive calculations.</span>
<span class="source-line-no">103</span><span id="line.103">     * @param sample a 1D array of ints that can be compared by the AestheticDifference this uses (or any ints if</span>
<span class="source-line-no">104</span><span id="line.104">     *               discrete is true)</span>
<span class="source-line-no">105</span><span id="line.105">     * @param sampleWidth the width of the area in sample this should use (sample can be interpreted as different shapes)</span>
<span class="source-line-no">106</span><span id="line.106">     * @param sampleHeight the height of the area in sample this should use (sample can be interpreted as different shapes)</span>
<span class="source-line-no">107</span><span id="line.107">     * @param targetWidth the desired width of the output</span>
<span class="source-line-no">108</span><span id="line.108">     * @param targetHeight the desired height of the output</span>
<span class="source-line-no">109</span><span id="line.109">     * @param detailLevel how much detail to try for; if 0 or less this doesn't perform analysis and has somewhat lower</span>
<span class="source-line-no">110</span><span id="line.110">     *                    quality, but 2 works well in general</span>
<span class="source-line-no">111</span><span id="line.111">     * @param proximity how far away to consider cells as affecting another; 3 works well</span>
<span class="source-line-no">112</span><span id="line.112">     * @param temperature a level of unpredictability in the output relative to the input; must be greater than 0</span>
<span class="source-line-no">113</span><span id="line.113">     * @param discrete false if this can produce ints other than those in the input; true if it uses a fixed set</span>
<span class="source-line-no">114</span><span id="line.114">     * @return a new 1D int array that can be interpreted as having targetWidth and targetHeight, and mimics sample</span>
<span class="source-line-no">115</span><span id="line.115">     */</span>
<span class="source-line-no">116</span><span id="line.116">    public int[] process(int[] sample, int sampleWidth, int sampleHeight, int targetWidth, int targetHeight,</span>
<span class="source-line-no">117</span><span id="line.117">                         int detailLevel, int proximity, double temperature, boolean discrete)</span>
<span class="source-line-no">118</span><span id="line.118">    {</span>
<span class="source-line-no">119</span><span id="line.119">        discrete |= (difference == null);</span>
<span class="source-line-no">120</span><span id="line.120">        if(detailLevel &gt; 0)</span>
<span class="source-line-no">121</span><span id="line.121">        {</span>
<span class="source-line-no">122</span><span id="line.122">            if(analyzed == null || analyzed.length != sampleWidth || analyzed.length == 0 ||</span>
<span class="source-line-no">123</span><span id="line.123">                    analyzed[0].length != sampleHeight)</span>
<span class="source-line-no">124</span><span id="line.124">                analyze(sample, sampleWidth, sampleHeight, detailLevel, proximity, discrete);</span>
<span class="source-line-no">125</span><span id="line.125">            return coherentSynthesis(sample, sampleWidth, sampleHeight, analyzed, proximity,</span>
<span class="source-line-no">126</span><span id="line.126">                    targetWidth, targetHeight, temperature, discrete);</span>
<span class="source-line-no">127</span><span id="line.127">        }</span>
<span class="source-line-no">128</span><span id="line.128">        else {</span>
<span class="source-line-no">129</span><span id="line.129">            return fullSynthesis(sample, sampleWidth, sampleHeight, proximity,</span>
<span class="source-line-no">130</span><span id="line.130">                    targetWidth, targetHeight, temperature, discrete);</span>
<span class="source-line-no">131</span><span id="line.131">        }</span>
<span class="source-line-no">132</span><span id="line.132">    }</span>
<span class="source-line-no">133</span><span id="line.133"></span>
<span class="source-line-no">134</span><span id="line.134">    /**</span>
<span class="source-line-no">135</span><span id="line.135">     * Processes a 1D int array representing 2D storage of values that can be compared by this object's</span>
<span class="source-line-no">136</span><span id="line.136">     * AestheticDifference (or any values if that is null or discrete is true), and returns a 1D array representing data</span>
<span class="source-line-no">137</span><span id="line.137">     * with potentially different dimensions but similar appearance to sample.</span>
<span class="source-line-no">138</span><span id="line.138">     * @param sample a 1D array of ints that can be compared by the AestheticDifference this uses (or any ints if</span>
<span class="source-line-no">139</span><span id="line.139">     *               discrete is true)</span>
<span class="source-line-no">140</span><span id="line.140">     * @param sampleWidth the width of the area in sample this should use (sample can be interpreted as different shapes)</span>
<span class="source-line-no">141</span><span id="line.141">     * @param sampleHeight the height of the area in sample this should use (sample can be interpreted as different shapes)</span>
<span class="source-line-no">142</span><span id="line.142">     * @param targetWidth the desired width of the output</span>
<span class="source-line-no">143</span><span id="line.143">     * @param targetHeight the desired height of the output</span>
<span class="source-line-no">144</span><span id="line.144">     * @param detailLevel how much detail to try for; here this will always be treated as at least 1</span>
<span class="source-line-no">145</span><span id="line.145">     * @param proximity how far away to consider cells as affecting another; 3 works well</span>
<span class="source-line-no">146</span><span id="line.146">     * @param discrete false if this can produce ints other than those in the input; true if it uses a fixed set</span>
<span class="source-line-no">147</span><span id="line.147">     * @return a new 1D int array that can be interpreted as having targetWidth and targetHeight, and mimics sample</span>
<span class="source-line-no">148</span><span id="line.148">     */</span>
<span class="source-line-no">149</span><span id="line.149">    public int[] neoProcess(int[] sample, int sampleWidth, int sampleHeight, int targetWidth, int targetHeight,</span>
<span class="source-line-no">150</span><span id="line.150">                         int detailLevel, int proximity, boolean discrete)</span>
<span class="source-line-no">151</span><span id="line.151">    {</span>
<span class="source-line-no">152</span><span id="line.152">            return reSynthesis(sample, sampleWidth, sampleHeight, proximity, 20,</span>
<span class="source-line-no">153</span><span id="line.153">                    Math.max(1, detailLevel), discrete || (difference == null), targetWidth, targetHeight);</span>
<span class="source-line-no">154</span><span id="line.154">    }</span>
<span class="source-line-no">155</span><span id="line.155"></span>
<span class="source-line-no">156</span><span id="line.156">    public IRNG random;</span>
<span class="source-line-no">157</span><span id="line.157">    public AestheticDifference difference;</span>
<span class="source-line-no">158</span><span id="line.158">    private int[][] analyzed;</span>
<span class="source-line-no">159</span><span id="line.159"></span>
<span class="source-line-no">160</span><span id="line.160">    private void analysis(int[] bitmap, int width, int height, int K, int N, boolean indexed)</span>
<span class="source-line-no">161</span><span id="line.161">    {</span>
<span class="source-line-no">162</span><span id="line.162">        int area = width * height;</span>
<span class="source-line-no">163</span><span id="line.163">        analyzed = new int[area][];</span>
<span class="source-line-no">164</span><span id="line.164">        OrderedSet&lt;Integer&gt; points = new OrderedSet&lt;&gt;(area);</span>
<span class="source-line-no">165</span><span id="line.165">        for (int i = 0; i &lt; area; i++) points.add(i);</span>
<span class="source-line-no">166</span><span id="line.166"></span>
<span class="source-line-no">167</span><span id="line.167">        double[] similarities = new double[area * area];</span>
<span class="source-line-no">168</span><span id="line.168">        for (int i = 0; i &lt; area; i++) for (int j = 0; j &lt; area; j++)</span>
<span class="source-line-no">169</span><span id="line.169">            similarities[i * area + j] = similarities[j * area + i] != 0 ? similarities[j * area + i] :</span>
<span class="source-line-no">170</span><span id="line.170">                    similarity(i, bitmap, width, height, j, bitmap, width, height, N, null, indexed);</span>
<span class="source-line-no">171</span><span id="line.171"></span>
<span class="source-line-no">172</span><span id="line.172">        for (int i = 0; i &lt; area; i++)</span>
<span class="source-line-no">173</span><span id="line.173">        {</span>
<span class="source-line-no">174</span><span id="line.174">            analyzed[i] = new int[K];</span>
<span class="source-line-no">175</span><span id="line.175">            OrderedSet&lt;Integer&gt; copy = new OrderedSet&lt;&gt;(points);</span>
<span class="source-line-no">176</span><span id="line.176"></span>
<span class="source-line-no">177</span><span id="line.177">            analyzed[i][0] = i;</span>
<span class="source-line-no">178</span><span id="line.178">            copy.remove(i);</span>
<span class="source-line-no">179</span><span id="line.179"></span>
<span class="source-line-no">180</span><span id="line.180">            for (int k = 1; k &lt; K; k++)</span>
<span class="source-line-no">181</span><span id="line.181">            {</span>
<span class="source-line-no">182</span><span id="line.182">                double max = -10000;</span>
<span class="source-line-no">183</span><span id="line.183">                int argmax = -1;</span>
<span class="source-line-no">184</span><span id="line.184"></span>
<span class="source-line-no">185</span><span id="line.185">                for(Integer p : copy)</span>
<span class="source-line-no">186</span><span id="line.186">                {</span>
<span class="source-line-no">187</span><span id="line.187">                    double s = similarities[i * area + p];</span>
<span class="source-line-no">188</span><span id="line.188">                    if (s &gt; max)</span>
<span class="source-line-no">189</span><span id="line.189">                    {</span>
<span class="source-line-no">190</span><span id="line.190">                        max = s;</span>
<span class="source-line-no">191</span><span id="line.191">                        argmax = p;</span>
<span class="source-line-no">192</span><span id="line.192">                    }</span>
<span class="source-line-no">193</span><span id="line.193">                }</span>
<span class="source-line-no">194</span><span id="line.194"></span>
<span class="source-line-no">195</span><span id="line.195">                analyzed[i][k] = argmax;</span>
<span class="source-line-no">196</span><span id="line.196">                copy.remove(argmax);</span>
<span class="source-line-no">197</span><span id="line.197">            }</span>
<span class="source-line-no">198</span><span id="line.198">        }</span>
<span class="source-line-no">199</span><span id="line.199">    }</span>
<span class="source-line-no">200</span><span id="line.200"></span>
<span class="source-line-no">201</span><span id="line.201">    private int[] coherentSynthesis(int[] sample, int SW, int SH, int[][] sets, int N, int OW, int OH, double t, boolean indexed)</span>
<span class="source-line-no">202</span><span id="line.202">    {</span>
<span class="source-line-no">203</span><span id="line.203">        int[] result = new int[OW * OH];</span>
<span class="source-line-no">204</span><span id="line.204">        Integer[] origins = new Integer[OW * OH];</span>
<span class="source-line-no">205</span><span id="line.205">        GreasedRegion mask = new GreasedRegion(SW, SH);</span>
<span class="source-line-no">206</span><span id="line.206"></span>
<span class="source-line-no">207</span><span id="line.207">        for (int i = 0; i &lt; OW * OH; i++)</span>
<span class="source-line-no">208</span><span id="line.208">        {</span>
<span class="source-line-no">209</span><span id="line.209">            int x = i % OW, y = i / OW;</span>
<span class="source-line-no">210</span><span id="line.210">            IntDoubleOrderedMap candidates = new IntDoubleOrderedMap();</span>
<span class="source-line-no">211</span><span id="line.211">            mask.clear();</span>
<span class="source-line-no">212</span><span id="line.212"></span>
<span class="source-line-no">213</span><span id="line.213">            for (int dy = -1; dy &lt;= 1; dy++){</span>
<span class="source-line-no">214</span><span id="line.214">                for (int dx = -1; dx &lt;= 1; dx++)</span>
<span class="source-line-no">215</span><span id="line.215">                {</span>
<span class="source-line-no">216</span><span id="line.216">                    int sx = (x + dx + OW) % OW, sy = (y + dy + OH) % OH;</span>
<span class="source-line-no">217</span><span id="line.217">                    Integer origin = origins[sy * OW + sx];</span>
<span class="source-line-no">218</span><span id="line.218">                    if ((dx != 0 || dy != 0) &amp;&amp; origin != null)</span>
<span class="source-line-no">219</span><span id="line.219">                    {</span>
<span class="source-line-no">220</span><span id="line.220">                        for (int pi = 0, p; pi &lt; sets[origin].length; pi++)</span>
<span class="source-line-no">221</span><span id="line.221">                        {</span>
<span class="source-line-no">222</span><span id="line.222">                            p = sets[origin][pi];</span>
<span class="source-line-no">223</span><span id="line.223">                            int ox = (p % SW - dx + SW) % SW, oy = (p / SW - dy + SH) % SH;</span>
<span class="source-line-no">224</span><span id="line.224">                            double s = similarity(oy * SW + ox, sample, SW, SH, i, result, OW, OH, N, origins, indexed);</span>
<span class="source-line-no">225</span><span id="line.225"></span>
<span class="source-line-no">226</span><span id="line.226">                            if (!mask.contains(ox, oy)) candidates.put(ox + oy * SW, Math.pow(100, s / t));</span>
<span class="source-line-no">227</span><span id="line.227">                            mask.insert(ox, oy);</span>
<span class="source-line-no">228</span><span id="line.228">                        }</span>
<span class="source-line-no">229</span><span id="line.229">                    }</span>
<span class="source-line-no">230</span><span id="line.230">                }</span>
<span class="source-line-no">231</span><span id="line.231">            }</span>
<span class="source-line-no">232</span><span id="line.232"></span>
<span class="source-line-no">233</span><span id="line.233">            int shifted = candidates.isEmpty() ? random.nextInt(SW) + random.nextInt(SH) * SW : weightedRandom(candidates, random.nextDouble());</span>
<span class="source-line-no">234</span><span id="line.234">            origins[i] = shifted;</span>
<span class="source-line-no">235</span><span id="line.235">            result[i] = sample[shifted];</span>
<span class="source-line-no">236</span><span id="line.236">        }</span>
<span class="source-line-no">237</span><span id="line.237"></span>
<span class="source-line-no">238</span><span id="line.238">        return result;</span>
<span class="source-line-no">239</span><span id="line.239">    }</span>
<span class="source-line-no">240</span><span id="line.240"></span>
<span class="source-line-no">241</span><span id="line.241">    private int[] fullSynthesis(int[] sample, int SW, int SH, int N, int OW, int OH, double t, boolean indexed)</span>
<span class="source-line-no">242</span><span id="line.242">    {</span>
<span class="source-line-no">243</span><span id="line.243">        int[] result = new int[OW * OH];</span>
<span class="source-line-no">244</span><span id="line.244">        Integer[] origins = new Integer[OW * OH];</span>
<span class="source-line-no">245</span><span id="line.245"></span>
<span class="source-line-no">246</span><span id="line.246">        if (!indexed) for (int y = 0; y &lt; OH; y++) {</span>
<span class="source-line-no">247</span><span id="line.247">            for (int x = 0; x &lt; OW; x++){</span>
<span class="source-line-no">248</span><span id="line.248">                if (y + N &gt;= OH)</span>
<span class="source-line-no">249</span><span id="line.249">                {</span>
<span class="source-line-no">250</span><span id="line.250">                    result[x + y * OW] = sample[random.nextInt(SW * SH)];</span>
<span class="source-line-no">251</span><span id="line.251">                    origins[x + y * OW] = -1;</span>
<span class="source-line-no">252</span><span id="line.252">                }</span>
<span class="source-line-no">253</span><span id="line.253">            }</span>
<span class="source-line-no">254</span><span id="line.254">        }</span>
<span class="source-line-no">255</span><span id="line.255"></span>
<span class="source-line-no">256</span><span id="line.256">        for (int i = 0; i &lt; OW * OH; i++)</span>
<span class="source-line-no">257</span><span id="line.257">        {</span>
<span class="source-line-no">258</span><span id="line.258">            double[] candidates = new double[SW * SH];</span>
<span class="source-line-no">259</span><span id="line.259">            double max = -10000;</span>
<span class="source-line-no">260</span><span id="line.260">            int argmax = -1;</span>
<span class="source-line-no">261</span><span id="line.261"></span>
<span class="source-line-no">262</span><span id="line.262">            for (int j = 0; j &lt; SW * SH; j++)</span>
<span class="source-line-no">263</span><span id="line.263">            {</span>
<span class="source-line-no">264</span><span id="line.264">                double s = similarity(j, sample, SW, SH, i, result, OW, OH, N, origins, indexed);</span>
<span class="source-line-no">265</span><span id="line.265">                if (s &gt; max)</span>
<span class="source-line-no">266</span><span id="line.266">                {</span>
<span class="source-line-no">267</span><span id="line.267">                    max = s;</span>
<span class="source-line-no">268</span><span id="line.268">                    argmax = j;</span>
<span class="source-line-no">269</span><span id="line.269">                }</span>
<span class="source-line-no">270</span><span id="line.270"></span>
<span class="source-line-no">271</span><span id="line.271">                if (indexed) candidates[j] = Math.pow(100.0, s / t);</span>
<span class="source-line-no">272</span><span id="line.272">            }</span>
<span class="source-line-no">273</span><span id="line.273"></span>
<span class="source-line-no">274</span><span id="line.274">            if (indexed) argmax = weightedRandom(candidates, random.nextDouble());</span>
<span class="source-line-no">275</span><span id="line.275">            result[i] = sample[argmax];</span>
<span class="source-line-no">276</span><span id="line.276">            origins[i] = -1;</span>
<span class="source-line-no">277</span><span id="line.277">        }</span>
<span class="source-line-no">278</span><span id="line.278"></span>
<span class="source-line-no">279</span><span id="line.279">        return result;</span>
<span class="source-line-no">280</span><span id="line.280">    }</span>
<span class="source-line-no">281</span><span id="line.281"></span>
<span class="source-line-no">282</span><span id="line.282"></span>
<span class="source-line-no">283</span><span id="line.283">    private int[] reSynthesis(int[] sample, int SW, int SH, int N, int M, int polish, boolean indexed, int OW, int OH)</span>
<span class="source-line-no">284</span><span id="line.284">    {</span>
<span class="source-line-no">285</span><span id="line.285">        IntVLA colors = new IntVLA();</span>
<span class="source-line-no">286</span><span id="line.286">        int[] indexedSample = new int[Math.min(SW * SH, sample.length)];</span>
<span class="source-line-no">287</span><span id="line.287">        for (int j = 0; j &lt; indexedSample.length; j++)</span>
<span class="source-line-no">288</span><span id="line.288">        {</span>
<span class="source-line-no">289</span><span id="line.289">            int color = sample[j];</span>
<span class="source-line-no">290</span><span id="line.290"></span>
<span class="source-line-no">291</span><span id="line.291">            int i = 0;</span>
<span class="source-line-no">292</span><span id="line.292">            for (int cn = 0; cn &lt; colors.size; cn++)</span>
<span class="source-line-no">293</span><span id="line.293">            {</span>
<span class="source-line-no">294</span><span id="line.294">                if(colors.get(cn) == color) break;</span>
<span class="source-line-no">295</span><span id="line.295">                i++;</span>
<span class="source-line-no">296</span><span id="line.296">            }</span>
<span class="source-line-no">297</span><span id="line.297"></span>
<span class="source-line-no">298</span><span id="line.298">            if (i == colors.size) colors.add(color);</span>
<span class="source-line-no">299</span><span id="line.299">            indexedSample[j] = i;</span>
<span class="source-line-no">300</span><span id="line.300">        }</span>
<span class="source-line-no">301</span><span id="line.301"></span>
<span class="source-line-no">302</span><span id="line.302">        int colorsNumber = colors.size;</span>
<span class="source-line-no">303</span><span id="line.303"></span>
<span class="source-line-no">304</span><span id="line.304">        double[][] colorMetric = null;</span>
<span class="source-line-no">305</span><span id="line.305">        if (!indexed &amp;&amp; colorsNumber &lt;= 1024)</span>
<span class="source-line-no">306</span><span id="line.306">        {</span>
<span class="source-line-no">307</span><span id="line.307">            colorMetric = new double[colorsNumber][colorsNumber];</span>
<span class="source-line-no">308</span><span id="line.308">            for (int x = 0; x &lt; colorsNumber; x++)</span>
<span class="source-line-no">309</span><span id="line.309">            {</span>
<span class="source-line-no">310</span><span id="line.310">                for (int y = 0; y &lt; colorsNumber; y++)</span>
<span class="source-line-no">311</span><span id="line.311">                {</span>
<span class="source-line-no">312</span><span id="line.312">                    int cx = colors.get(x), cy = colors.get(y);</span>
<span class="source-line-no">313</span><span id="line.313">                    colorMetric[x][y] = difference.difference(cx, cy);</span>
<span class="source-line-no">314</span><span id="line.314">                }</span>
<span class="source-line-no">315</span><span id="line.315">            }</span>
<span class="source-line-no">316</span><span id="line.316">        }</span>
<span class="source-line-no">317</span><span id="line.317"></span>
<span class="source-line-no">318</span><span id="line.318">        int[] origins = new int[OW * OH];</span>
<span class="source-line-no">319</span><span id="line.319">        Arrays.fill(origins, -1);</span>
<span class="source-line-no">320</span><span id="line.320"></span>
<span class="source-line-no">321</span><span id="line.321">        int[] shuffle = new int[OW * OH];</span>
<span class="source-line-no">322</span><span id="line.322">        for (int i = 0; i &lt; shuffle.length; i++)</span>
<span class="source-line-no">323</span><span id="line.323">        {</span>
<span class="source-line-no">324</span><span id="line.324">            int j = random.nextInt(i + 1);</span>
<span class="source-line-no">325</span><span id="line.325">            if (j != i) shuffle[i] = shuffle[j];</span>
<span class="source-line-no">326</span><span id="line.326">            shuffle[j] = i;</span>
<span class="source-line-no">327</span><span id="line.327">        }</span>
<span class="source-line-no">328</span><span id="line.328"></span>
<span class="source-line-no">329</span><span id="line.329">        for (int round = 0; round &lt;= polish; round++) for (int counter = 0; counter &lt; shuffle.length; counter++)</span>
<span class="source-line-no">330</span><span id="line.330">        {</span>
<span class="source-line-no">331</span><span id="line.331">            int f = shuffle[counter];</span>
<span class="source-line-no">332</span><span id="line.332">            int fx = f % OW, fy = f / OW;</span>
<span class="source-line-no">333</span><span id="line.333">            int neighborsNumber = round &gt; 0 ? 8 : Math.min(8, counter);</span>
<span class="source-line-no">334</span><span id="line.334">            int neighborsFound = 0;</span>
<span class="source-line-no">335</span><span id="line.335"></span>
<span class="source-line-no">336</span><span id="line.336">            int[] candidates = new int[neighborsNumber + M];</span>
<span class="source-line-no">337</span><span id="line.337"></span>
<span class="source-line-no">338</span><span id="line.338">            if (neighborsNumber &gt; 0)</span>
<span class="source-line-no">339</span><span id="line.339">            {</span>
<span class="source-line-no">340</span><span id="line.340">                int[] neighbors = new int[neighborsNumber];</span>
<span class="source-line-no">341</span><span id="line.341">                int[] x = new int[4], y = new int[4];</span>
<span class="source-line-no">342</span><span id="line.342"></span>
<span class="source-line-no">343</span><span id="line.343">                for (int radius = 1; neighborsFound &lt; neighborsNumber; radius++)</span>
<span class="source-line-no">344</span><span id="line.344">                {</span>
<span class="source-line-no">345</span><span id="line.345">                    x[0] = fx - radius;</span>
<span class="source-line-no">346</span><span id="line.346">                    y[0] = fy - radius;</span>
<span class="source-line-no">347</span><span id="line.347">                    x[1] = fx - radius;</span>
<span class="source-line-no">348</span><span id="line.348">                    y[1] = fy + radius;</span>
<span class="source-line-no">349</span><span id="line.349">                    x[2] = fx + radius;</span>
<span class="source-line-no">350</span><span id="line.350">                    y[2] = fy + radius;</span>
<span class="source-line-no">351</span><span id="line.351">                    x[3] = fx + radius;</span>
<span class="source-line-no">352</span><span id="line.352">                    y[3] = fy - radius;</span>
<span class="source-line-no">353</span><span id="line.353"></span>
<span class="source-line-no">354</span><span id="line.354">                    for (int k = 0; k &lt; 2 * radius; k++)</span>
<span class="source-line-no">355</span><span id="line.355">                    {</span>
<span class="source-line-no">356</span><span id="line.356">                        for (int d = 0; d &lt; 4; d++)</span>
<span class="source-line-no">357</span><span id="line.357">                        {</span>
<span class="source-line-no">358</span><span id="line.358">                            x[d] = (x[d] + 10 * OW) % OW;</span>
<span class="source-line-no">359</span><span id="line.359">                            y[d] = (y[d] + 10 * OH) % OH;</span>
<span class="source-line-no">360</span><span id="line.360"></span>
<span class="source-line-no">361</span><span id="line.361">                            if (neighborsFound &gt;= neighborsNumber) continue;</span>
<span class="source-line-no">362</span><span id="line.362">                            int point = x[d] + y[d] * OW;</span>
<span class="source-line-no">363</span><span id="line.363">                            if (origins[point] != -1)</span>
<span class="source-line-no">364</span><span id="line.364">                            {</span>
<span class="source-line-no">365</span><span id="line.365">                                neighbors[neighborsFound] = point;</span>
<span class="source-line-no">366</span><span id="line.366">                                neighborsFound++;</span>
<span class="source-line-no">367</span><span id="line.367">                            }</span>
<span class="source-line-no">368</span><span id="line.368">                        }</span>
<span class="source-line-no">369</span><span id="line.369"></span>
<span class="source-line-no">370</span><span id="line.370">                        y[0]++;</span>
<span class="source-line-no">371</span><span id="line.371">                        x[1]++;</span>
<span class="source-line-no">372</span><span id="line.372">                        y[2]--;</span>
<span class="source-line-no">373</span><span id="line.373">                        x[3]--;</span>
<span class="source-line-no">374</span><span id="line.374">                    }</span>
<span class="source-line-no">375</span><span id="line.375">                }</span>
<span class="source-line-no">376</span><span id="line.376"></span>
<span class="source-line-no">377</span><span id="line.377"></span>
<span class="source-line-no">378</span><span id="line.378">                for (int n = 0; n &lt; neighborsNumber; n++)</span>
<span class="source-line-no">379</span><span id="line.379">                {</span>
<span class="source-line-no">380</span><span id="line.380">                    int cx = (origins[neighbors[n]] + (f - neighbors[n]) % OW + 100 * SW) % SW;</span>
<span class="source-line-no">381</span><span id="line.381">                    int cy = (origins[neighbors[n]] / SW + f / OW - neighbors[n] / OW + 100 * SH) % SH;</span>
<span class="source-line-no">382</span><span id="line.382">                    candidates[n] = cx + cy * SW;</span>
<span class="source-line-no">383</span><span id="line.383">                }</span>
<span class="source-line-no">384</span><span id="line.384">            }</span>
<span class="source-line-no">385</span><span id="line.385"></span>
<span class="source-line-no">386</span><span id="line.386">            for (int m = 0; m &lt; M; m++) candidates[neighborsNumber + m] = random.nextInt(SW * SH);</span>
<span class="source-line-no">387</span><span id="line.387"></span>
<span class="source-line-no">388</span><span id="line.388">            double max = -1E+10;</span>
<span class="source-line-no">389</span><span id="line.389">            int argmax = -1;</span>
<span class="source-line-no">390</span><span id="line.390"></span>
<span class="source-line-no">391</span><span id="line.391">            for (int c = 0; c &lt; candidates.length; c++)</span>
<span class="source-line-no">392</span><span id="line.392">            {</span>
<span class="source-line-no">393</span><span id="line.393">                double sum = random.nextDouble(0.000001);</span>
<span class="source-line-no">394</span><span id="line.394">                int ix = candidates[c] % SW, iy = candidates[c] / SW, jx = f % OW, jy = f / OW;</span>
<span class="source-line-no">395</span><span id="line.395">                int SX, SY, FX, FY, S, F;</span>
<span class="source-line-no">396</span><span id="line.396">                int origin;</span>
<span class="source-line-no">397</span><span id="line.397"></span>
<span class="source-line-no">398</span><span id="line.398">                for (int dy = -N; dy &lt;= N; dy++)</span>
<span class="source-line-no">399</span><span id="line.399">                {</span>
<span class="source-line-no">400</span><span id="line.400">                    for (int dx = -N; dx &lt;= N; dx++)</span>
<span class="source-line-no">401</span><span id="line.401">                    {</span>
<span class="source-line-no">402</span><span id="line.402">                        if (dx != 0 || dy != 0)</span>
<span class="source-line-no">403</span><span id="line.403">                        {</span>
<span class="source-line-no">404</span><span id="line.404">                            SX = ix + dx;</span>
<span class="source-line-no">405</span><span id="line.405">                            if (SX &lt; 0) SX += SW;</span>
<span class="source-line-no">406</span><span id="line.406">                            else if (SX &gt;= SW) SX -= SW;</span>
<span class="source-line-no">407</span><span id="line.407"></span>
<span class="source-line-no">408</span><span id="line.408">                            SY = iy + dy;</span>
<span class="source-line-no">409</span><span id="line.409">                            if (SY &lt; 0) SY += SH;</span>
<span class="source-line-no">410</span><span id="line.410">                            else if (SY &gt;= SH) SY -= SH;</span>
<span class="source-line-no">411</span><span id="line.411"></span>
<span class="source-line-no">412</span><span id="line.412">                            FX = jx + dx;</span>
<span class="source-line-no">413</span><span id="line.413">                            if (FX &lt; 0) FX += OW;</span>
<span class="source-line-no">414</span><span id="line.414">                            else if (FX &gt;= OW) FX -= OW;</span>
<span class="source-line-no">415</span><span id="line.415"></span>
<span class="source-line-no">416</span><span id="line.416">                            FY = jy + dy;</span>
<span class="source-line-no">417</span><span id="line.417">                            if (FY &lt; 0) FY += OH;</span>
<span class="source-line-no">418</span><span id="line.418">                            else if (FY &gt;= OH) FY -= OH;</span>
<span class="source-line-no">419</span><span id="line.419"></span>
<span class="source-line-no">420</span><span id="line.420">                            S = SX + SY * SW;</span>
<span class="source-line-no">421</span><span id="line.421">                            F = FX + FY * OW;</span>
<span class="source-line-no">422</span><span id="line.422"></span>
<span class="source-line-no">423</span><span id="line.423">                            origin = origins[F];</span>
<span class="source-line-no">424</span><span id="line.424">                            if (origin != -1)</span>
<span class="source-line-no">425</span><span id="line.425">                            {</span>
<span class="source-line-no">426</span><span id="line.426">                                if (indexed) sum += sample[origin] == sample[S] ? 1 : -1;</span>
<span class="source-line-no">427</span><span id="line.427">                                else if (colorMetric != null) sum += colorMetric[indexedSample[origin]][indexedSample[S]];</span>
<span class="source-line-no">428</span><span id="line.428">                                else sum += difference.difference(sample[origin], sample[S]);</span>
<span class="source-line-no">429</span><span id="line.429">                            }</span>
<span class="source-line-no">430</span><span id="line.430">                        }</span>
<span class="source-line-no">431</span><span id="line.431">                    }</span>
<span class="source-line-no">432</span><span id="line.432">                }</span>
<span class="source-line-no">433</span><span id="line.433"></span>
<span class="source-line-no">434</span><span id="line.434">                if (sum &gt;= max)</span>
<span class="source-line-no">435</span><span id="line.435">                {</span>
<span class="source-line-no">436</span><span id="line.436">                    max = sum;</span>
<span class="source-line-no">437</span><span id="line.437">                    argmax = candidates[c];</span>
<span class="source-line-no">438</span><span id="line.438">                }</span>
<span class="source-line-no">439</span><span id="line.439">            }</span>
<span class="source-line-no">440</span><span id="line.440"></span>
<span class="source-line-no">441</span><span id="line.441">            origins[f] = argmax;</span>
<span class="source-line-no">442</span><span id="line.442">        }</span>
<span class="source-line-no">443</span><span id="line.443"></span>
<span class="source-line-no">444</span><span id="line.444">        int[] result = new int[OW * OH];</span>
<span class="source-line-no">445</span><span id="line.445">        for (int i = 0; i &lt; result.length; i++) result[i] = sample[origins[i]];</span>
<span class="source-line-no">446</span><span id="line.446">        return result;</span>
<span class="source-line-no">447</span><span id="line.447">    }</span>
<span class="source-line-no">448</span><span id="line.448"></span>
<span class="source-line-no">449</span><span id="line.449">    private double similarity(int i1, int[] b1, int w1, int h1, int i2, int[] b2, int w2, int h2, int N, Integer[] origins, boolean indexed)</span>
<span class="source-line-no">450</span><span id="line.450">    {</span>
<span class="source-line-no">451</span><span id="line.451">        double sum = 0;</span>
<span class="source-line-no">452</span><span id="line.452">        int x1 = i1 % w1, y1 = i1 / w1, x2 = i2 % w2, y2 = i2 / w2;</span>
<span class="source-line-no">453</span><span id="line.453"></span>
<span class="source-line-no">454</span><span id="line.454">        for (int dy = -N; dy &lt;= 0; dy++) for (int dx = -N; (dy &lt; 0 &amp;&amp; dx &lt;= N) || (dy == 0 &amp;&amp; dx &lt; 0); dx++)</span>
<span class="source-line-no">455</span><span id="line.455">        {</span>
<span class="source-line-no">456</span><span id="line.456">            int sx1 = (x1 + dx + w1) % w1, sy1 = (y1 + dy + h1) % h1;</span>
<span class="source-line-no">457</span><span id="line.457">            int sx2 = (x2 + dx + w2) % w2, sy2 = (y2 + dy + h2) % h2;</span>
<span class="source-line-no">458</span><span id="line.458"></span>
<span class="source-line-no">459</span><span id="line.459">            int c1 = b1[sx1 + sy1 * w1];</span>
<span class="source-line-no">460</span><span id="line.460">            int c2 = b2[sx2 + sy2 * w2];</span>
<span class="source-line-no">461</span><span id="line.461"></span>
<span class="source-line-no">462</span><span id="line.462">            if (origins == null || origins[sy2 * w2 + sx2] != null)</span>
<span class="source-line-no">463</span><span id="line.463">            {</span>
<span class="source-line-no">464</span><span id="line.464">                if (indexed)</span>
<span class="source-line-no">465</span><span id="line.465">                    sum += c1 == c2 ? 1 : -1;</span>
<span class="source-line-no">466</span><span id="line.466">                else</span>
<span class="source-line-no">467</span><span id="line.467">                    sum -= difference.difference(c1, c2);</span>
<span class="source-line-no">468</span><span id="line.468">                    /*</span>
<span class="source-line-no">469</span><span id="line.469">                    Color C1 = Color.FromArgb(c1), C2 = Color.FromArgb(c2);</span>
<span class="source-line-no">470</span><span id="line.470">                    sum -= (double)((C1.R - C2.R) * (C1.R - C2.R) + (C1.G - C2.G) * (C1.G - C2.G) + (C1.B - C2.B) * (C1.B - C2.B)) / 65536.0;</span>
<span class="source-line-no">471</span><span id="line.471">                    */</span>
<span class="source-line-no">472</span><span id="line.472">            }</span>
<span class="source-line-no">473</span><span id="line.473">        }</span>
<span class="source-line-no">474</span><span id="line.474"></span>
<span class="source-line-no">475</span><span id="line.475">        return sum;</span>
<span class="source-line-no">476</span><span id="line.476">    }</span>
<span class="source-line-no">477</span><span id="line.477"></span>
<span class="source-line-no">478</span><span id="line.478">    static int weightedRandom(double[] array, double r)</span>
<span class="source-line-no">479</span><span id="line.479">    {</span>
<span class="source-line-no">480</span><span id="line.480">        double sum = 0;</span>
<span class="source-line-no">481</span><span id="line.481">        for (int j = 0; j &lt; array.length; j++)</span>
<span class="source-line-no">482</span><span id="line.482">            sum += Math.max(1.0, array[j]);</span>
<span class="source-line-no">483</span><span id="line.483"></span>
<span class="source-line-no">484</span><span id="line.484">        for (int j = 0; j &lt; array.length; j++)</span>
<span class="source-line-no">485</span><span id="line.485">            array[j] /= sum;</span>
<span class="source-line-no">486</span><span id="line.486"></span>
<span class="source-line-no">487</span><span id="line.487">        int i = 0;</span>
<span class="source-line-no">488</span><span id="line.488">        double x = 0;</span>
<span class="source-line-no">489</span><span id="line.489"></span>
<span class="source-line-no">490</span><span id="line.490">        while (i &lt; array.length)</span>
<span class="source-line-no">491</span><span id="line.491">        {</span>
<span class="source-line-no">492</span><span id="line.492">            x += array[i];</span>
<span class="source-line-no">493</span><span id="line.493">            if (r &lt;= x) return i;</span>
<span class="source-line-no">494</span><span id="line.494">            i++;</span>
<span class="source-line-no">495</span><span id="line.495">        }</span>
<span class="source-line-no">496</span><span id="line.496"></span>
<span class="source-line-no">497</span><span id="line.497">        return 0;</span>
<span class="source-line-no">498</span><span id="line.498">    }</span>
<span class="source-line-no">499</span><span id="line.499"></span>
<span class="source-line-no">500</span><span id="line.500">    static int weightedRandom(IntDoubleOrderedMap dic, double r) {</span>
<span class="source-line-no">501</span><span id="line.501">//        int[] ints = dic.keySet().toIntArray();</span>
<span class="source-line-no">502</span><span id="line.502">//        double[] doubles =  dic.values().toDoubleArray();</span>
<span class="source-line-no">503</span><span id="line.503">        double sum = 0;</span>
<span class="source-line-no">504</span><span id="line.504">        final int sz = dic.size();</span>
<span class="source-line-no">505</span><span id="line.505">        for (int j = 0; j &lt; sz; j++)</span>
<span class="source-line-no">506</span><span id="line.506">            sum += Math.max(1.0, dic.getAt(j));</span>
<span class="source-line-no">507</span><span id="line.507"></span>
<span class="source-line-no">508</span><span id="line.508">        int i = 0;</span>
<span class="source-line-no">509</span><span id="line.509">        double x = 0;</span>
<span class="source-line-no">510</span><span id="line.510"></span>
<span class="source-line-no">511</span><span id="line.511">        while (i &lt; sz)</span>
<span class="source-line-no">512</span><span id="line.512">        {</span>
<span class="source-line-no">513</span><span id="line.513">            x += dic.getAt(i) / sz;</span>
<span class="source-line-no">514</span><span id="line.514">            if (r &lt;= x) return dic.keyAt(i);</span>
<span class="source-line-no">515</span><span id="line.515">            i++;</span>
<span class="source-line-no">516</span><span id="line.516">        }</span>
<span class="source-line-no">517</span><span id="line.517">        return dic.firstKey();</span>
<span class="source-line-no">518</span><span id="line.518">    }</span>
<span class="source-line-no">519</span><span id="line.519"></span>
<span class="source-line-no">520</span><span id="line.520">    /**</span>
<span class="source-line-no">521</span><span id="line.521">     * Utility method to produce 1D int arrays this can process when discrete is true or difference is null.</span>
<span class="source-line-no">522</span><span id="line.522">     * @param map a 2D char array</span>
<span class="source-line-no">523</span><span id="line.523">     * @return an int array that can be used as a sample</span>
<span class="source-line-no">524</span><span id="line.524">     */</span>
<span class="source-line-no">525</span><span id="line.525">    public static int[] convertCharToInt(char[][] map)</span>
<span class="source-line-no">526</span><span id="line.526">    {</span>
<span class="source-line-no">527</span><span id="line.527">        int w = map.length, h = map[0].length;</span>
<span class="source-line-no">528</span><span id="line.528">        int[] result = new int[w * h];</span>
<span class="source-line-no">529</span><span id="line.529">        for (int x = 0; x &lt; w; x++) {</span>
<span class="source-line-no">530</span><span id="line.530">            for (int y = 0; y &lt; h; y++) {</span>
<span class="source-line-no">531</span><span id="line.531">                result[x * h + y] = map[x][y];</span>
<span class="source-line-no">532</span><span id="line.532">            }</span>
<span class="source-line-no">533</span><span id="line.533">        }</span>
<span class="source-line-no">534</span><span id="line.534">        return result;</span>
<span class="source-line-no">535</span><span id="line.535">    }</span>
<span class="source-line-no">536</span><span id="line.536"></span>
<span class="source-line-no">537</span><span id="line.537">    /**</span>
<span class="source-line-no">538</span><span id="line.538">     * Utility method that takes a 1D int array that represents chars (such as a sample produced by</span>
<span class="source-line-no">539</span><span id="line.539">     * {@link #convertCharToInt(char[][])} or, more likely, the result of processing such a sample with this class) and</span>
<span class="source-line-no">540</span><span id="line.540">     * returns a 2D char array with the requested width and height (which should match the targetWidth and targetHeight</span>
<span class="source-line-no">541</span><span id="line.541">     * given during processing).</span>
<span class="source-line-no">542</span><span id="line.542">     * @param arr a 1D int array that represents char values</span>
<span class="source-line-no">543</span><span id="line.543">     * @param w the width that arr can be interpreted as; should probably match the targetWidth given in processing</span>
<span class="source-line-no">544</span><span id="line.544">     * @param h the height that arr can be interpreted as; should probably match the targetHeight given in processing</span>
<span class="source-line-no">545</span><span id="line.545">     * @return a 2D char array with the given width and height, probably filled with the data from arr</span>
<span class="source-line-no">546</span><span id="line.546">     */</span>
<span class="source-line-no">547</span><span id="line.547">    public static char[][] convertIntToChar(int[] arr, int w, int h)</span>
<span class="source-line-no">548</span><span id="line.548">    {</span>
<span class="source-line-no">549</span><span id="line.549">        char[][] result = new char[w][h];</span>
<span class="source-line-no">550</span><span id="line.550">        if(arr == null)</span>
<span class="source-line-no">551</span><span id="line.551">            return result;</span>
<span class="source-line-no">552</span><span id="line.552">        for (int x = 0; x &lt; w; x++) {</span>
<span class="source-line-no">553</span><span id="line.553">            for (int y = 0; y &lt; h; y++) {</span>
<span class="source-line-no">554</span><span id="line.554">                if(x * h + y &gt;= arr.length)</span>
<span class="source-line-no">555</span><span id="line.555">                    return result;</span>
<span class="source-line-no">556</span><span id="line.556">                result[x][y] = (char) arr[x * h + y];</span>
<span class="source-line-no">557</span><span id="line.557">            }</span>
<span class="source-line-no">558</span><span id="line.558">        }</span>
<span class="source-line-no">559</span><span id="line.559">        return result;</span>
<span class="source-line-no">560</span><span id="line.560">    }</span>
<span class="source-line-no">561</span><span id="line.561">}</span>




























































</pre>
</div>
</main>
</body>
</html>
