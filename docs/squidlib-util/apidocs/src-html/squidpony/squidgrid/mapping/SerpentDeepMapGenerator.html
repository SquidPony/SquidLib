<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (16) -->
<title>Source code</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="source: package: squidpony.squidgrid.mapping, class: SerpentDeepMapGenerator">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
</head>
<body class="source-page">
<main role="main">
<div class="source-container">
<pre><span class="source-line-no">001</span><span id="line.1">package squidpony.squidgrid.mapping;</span>
<span class="source-line-no">002</span><span id="line.2"></span>
<span class="source-line-no">003</span><span id="line.3">import squidpony.Maker;</span>
<span class="source-line-no">004</span><span id="line.4">import squidpony.squidmath.*;</span>
<span class="source-line-no">005</span><span id="line.5"></span>
<span class="source-line-no">006</span><span id="line.6">import java.util.ArrayList;</span>
<span class="source-line-no">007</span><span id="line.7">import java.util.List;</span>
<span class="source-line-no">008</span><span id="line.8"></span>
<span class="source-line-no">009</span><span id="line.9">/**</span>
<span class="source-line-no">010</span><span id="line.10"> * Generate dungeons based on a random, winding, looping path through 3D space, requiring a character to move up and</span>
<span class="source-line-no">011</span><span id="line.11"> * down as well as north/south/east/west to get through the dungeon. Uses techniques from MixedGenerator.</span>
<span class="source-line-no">012</span><span id="line.12"> * Uses a Moore Curve, which is related to Hilbert Curves but loops back to its starting point, and stretches and</span>
<span class="source-line-no">013</span><span id="line.13"> * distorts the grid to make sure a visual correlation isn't obvious.</span>
<span class="source-line-no">014</span><span id="line.14"> * &lt;br&gt;</span>
<span class="source-line-no">015</span><span id="line.15"> * The name comes from a vivid dream I had about gigantic, multi-colored snakes that completely occupied a roguelike</span>
<span class="source-line-no">016</span><span id="line.16"> * dungeon. Shortly after, I made the connection to the Australian mythology I'd heard about the Rainbow Serpent, which</span>
<span class="source-line-no">017</span><span id="line.17"> * in some stories dug water-holes and was similarly gigantic.</span>
<span class="source-line-no">018</span><span id="line.18"> * Created by Tommy Ettinger on 10/24/2015.</span>
<span class="source-line-no">019</span><span id="line.19"> */</span>
<span class="source-line-no">020</span><span id="line.20">public class SerpentDeepMapGenerator {</span>
<span class="source-line-no">021</span><span id="line.21">    private MixedGenerator[] mix;</span>
<span class="source-line-no">022</span><span id="line.22">    private int[] columns, rows;</span>
<span class="source-line-no">023</span><span id="line.23">    private int width, height, depth;</span>
<span class="source-line-no">024</span><span id="line.24">    private ArrayList&lt;OrderedSet&lt;Coord&gt;&gt; linksUp,linksDown;</span>
<span class="source-line-no">025</span><span id="line.25">    private IRNG random;</span>
<span class="source-line-no">026</span><span id="line.26"></span>
<span class="source-line-no">027</span><span id="line.27">    /**</span>
<span class="source-line-no">028</span><span id="line.28">     * This prepares a map generator that will generate a map with the given width, height and depth, using the given</span>
<span class="source-line-no">029</span><span id="line.29">     * IRNG. The intended purpose is to carve a long path that loops through the whole dungeon's 3D space, while</span>
<span class="source-line-no">030</span><span id="line.30">     * hopefully maximizing the amount of rooms the player encounters. You call the different carver-adding methods to</span>
<span class="source-line-no">031</span><span id="line.31">     * affect what the dungeon will look like, putCaveCarvers(), putBoxRoomCarvers(), and putRoundRoomCarvers(),</span>
<span class="source-line-no">032</span><span id="line.32">     * defaulting to only caves if none are called. You call generate() after adding carvers, which returns a char[][][]</span>
<span class="source-line-no">033</span><span id="line.33">     * for a map.</span>
<span class="source-line-no">034</span><span id="line.34">     * @param width the width of the final map in cells</span>
<span class="source-line-no">035</span><span id="line.35">     * @param height the height of the final map in cells</span>
<span class="source-line-no">036</span><span id="line.36">     * @param depth the number of levels deep to create</span>
<span class="source-line-no">037</span><span id="line.37">     * @param rng an IRNG object to use for random choices; this make a lot of random choices.</span>
<span class="source-line-no">038</span><span id="line.38">     * @see MixedGenerator</span>
<span class="source-line-no">039</span><span id="line.39">     */</span>
<span class="source-line-no">040</span><span id="line.40">    public SerpentDeepMapGenerator(int width, int height, int depth, IRNG rng) {</span>
<span class="source-line-no">041</span><span id="line.41">        this(width, height, depth, rng, 0.3);</span>
<span class="source-line-no">042</span><span id="line.42">    }</span>
<span class="source-line-no">043</span><span id="line.43">    /**</span>
<span class="source-line-no">044</span><span id="line.44">     * This prepares a map generator that will generate a map with the given width, height and depth, using the given</span>
<span class="source-line-no">045</span><span id="line.45">     * IRNG, and will branch out to other nearby rooms that (probably) do not have staircases between layers.</span>
<span class="source-line-no">046</span><span id="line.46">     * The intended purpose is to carve a long path that loops through the whole dungeon's 3D space, while</span>
<span class="source-line-no">047</span><span id="line.47">     * hopefully maximizing the amount of rooms the player encounters. You call the different carver-adding methods to</span>
<span class="source-line-no">048</span><span id="line.48">     * affect what the dungeon will look like, putCaveCarvers(), putBoxRoomCarvers(), and putRoundRoomCarvers(),</span>
<span class="source-line-no">049</span><span id="line.49">     * defaulting to only caves if none are called. You call generate() after adding carvers, which returns a char[][][]</span>
<span class="source-line-no">050</span><span id="line.50">     * for a map.</span>
<span class="source-line-no">051</span><span id="line.51">     * @param width the width of the final map in cells</span>
<span class="source-line-no">052</span><span id="line.52">     * @param height the height of the final map in cells</span>
<span class="source-line-no">053</span><span id="line.53">     * @param depth the number of levels deep to create</span>
<span class="source-line-no">054</span><span id="line.54">     * @param rng an IRNG object to use for random choices; this make a lot of random choices.</span>
<span class="source-line-no">055</span><span id="line.55">     * @param branchingChance the odds from 0.0 to 1.0 that a branch will be created near each necessary room.</span>
<span class="source-line-no">056</span><span id="line.56">     * @see MixedGenerator</span>
<span class="source-line-no">057</span><span id="line.57">     */</span>
<span class="source-line-no">058</span><span id="line.58">    public SerpentDeepMapGenerator(int width, int height, int depth, IRNG rng, double branchingChance)</span>
<span class="source-line-no">059</span><span id="line.59">    {</span>
<span class="source-line-no">060</span><span id="line.60">        if(width &lt;= 2 || height &lt;= 2)</span>
<span class="source-line-no">061</span><span id="line.61">            throw new IllegalArgumentException("width and height must be greater than 2");</span>
<span class="source-line-no">062</span><span id="line.62">        if(depth &lt; 1)</span>
<span class="source-line-no">063</span><span id="line.63">            throw new IllegalArgumentException("depth must be at least 1");</span>
<span class="source-line-no">064</span><span id="line.64">        CoordPacker.init();</span>
<span class="source-line-no">065</span><span id="line.65">        random = rng;</span>
<span class="source-line-no">066</span><span id="line.66">        this.width = width;</span>
<span class="source-line-no">067</span><span id="line.67">        this.height = height;</span>
<span class="source-line-no">068</span><span id="line.68">        this.depth = depth;</span>
<span class="source-line-no">069</span><span id="line.69">        int numLayers = (int)Math.ceil(depth / 4.0);</span>
<span class="source-line-no">070</span><span id="line.70">        long alterations = random.nextLong();</span>
<span class="source-line-no">071</span><span id="line.71">        long columnAlterations = alterations &amp; 0xFFFFFFFFL;</span>
<span class="source-line-no">072</span><span id="line.72">        float columnBase = (width - 2) / (Long.bitCount(columnAlterations) + 16.0f);</span>
<span class="source-line-no">073</span><span id="line.73">        long rowAlterations = alterations &gt;&gt;&gt; 32;</span>
<span class="source-line-no">074</span><span id="line.74">        float rowBase = (height - 2) / (Long.bitCount(rowAlterations) + 16.0f);</span>
<span class="source-line-no">075</span><span id="line.75"></span>
<span class="source-line-no">076</span><span id="line.76">        columns = new int[16];</span>
<span class="source-line-no">077</span><span id="line.77">        rows = new int[16];</span>
<span class="source-line-no">078</span><span id="line.78">        linksUp = new ArrayList&lt;&gt;(depth);</span>
<span class="source-line-no">079</span><span id="line.79">        linksDown = new ArrayList&lt;&gt;(depth);</span>
<span class="source-line-no">080</span><span id="line.80">        for (int i = 0; i &lt; depth; i++) {</span>
<span class="source-line-no">081</span><span id="line.81">            linksUp.add(new OrderedSet&lt;Coord&gt;(80));</span>
<span class="source-line-no">082</span><span id="line.82">            linksDown.add(new OrderedSet&lt;Coord&gt;(80));</span>
<span class="source-line-no">083</span><span id="line.83">        }</span>
<span class="source-line-no">084</span><span id="line.84">        float csum = 0, rsum = 0;</span>
<span class="source-line-no">085</span><span id="line.85">        long b = 3;</span>
<span class="source-line-no">086</span><span id="line.86">        for (int i = 0; i &lt; 16; i++, b &lt;&lt;= 2) {</span>
<span class="source-line-no">087</span><span id="line.87">            columns[i] = (int)((csum += columnBase * (1 + Long.bitCount(columnAlterations &amp; b))));</span>
<span class="source-line-no">088</span><span id="line.88">            rows[i] = (int)((rsum += rowBase * (1 + Long.bitCount(rowAlterations &amp; b))));</span>
<span class="source-line-no">089</span><span id="line.89">        }</span>
<span class="source-line-no">090</span><span id="line.90"></span>
<span class="source-line-no">091</span><span id="line.91">        List&lt;OrderedMap&lt;Coord, List&lt;Coord&gt;&gt;&gt; connections = new ArrayList&lt;&gt;(depth);</span>
<span class="source-line-no">092</span><span id="line.92">        for (int i = 0; i &lt; depth; i++) {</span>
<span class="source-line-no">093</span><span id="line.93">            connections.add(new OrderedMap&lt;Coord, List&lt;Coord&gt;&gt;(80));</span>
<span class="source-line-no">094</span><span id="line.94">        }</span>
<span class="source-line-no">095</span><span id="line.95">        int m = random.nextInt(0x800 * numLayers);</span>
<span class="source-line-no">096</span><span id="line.96">        int x = CoordPacker.getXMoore3D(m, numLayers), y = CoordPacker.getYMoore3D(m, numLayers),</span>
<span class="source-line-no">097</span><span id="line.97">                z = (int)Math.floor(CoordPacker.getZMoore3D(m, numLayers) * depth / (8f * numLayers)),</span>
<span class="source-line-no">098</span><span id="line.98">                sx = x, sy = y, sz = z, tz = z;</span>
<span class="source-line-no">099</span><span id="line.99">        int r = random.between(12, 33);</span>
<span class="source-line-no">100</span><span id="line.100">        m += r;</span>
<span class="source-line-no">101</span><span id="line.101">        for (int i = 0; i &lt; 0x800 * numLayers; r = random.between(12, 33), i += r, m = (m + r) % (0x800 * numLayers)) {</span>
<span class="source-line-no">102</span><span id="line.102">            int tx = x, ty = y;</span>
<span class="source-line-no">103</span><span id="line.103">            do {</span>
<span class="source-line-no">104</span><span id="line.104">                List&lt;Coord&gt; cl = new ArrayList&lt;&gt;(4);</span>
<span class="source-line-no">105</span><span id="line.105"></span>
<span class="source-line-no">106</span><span id="line.106">                for (int j = 0;</span>
<span class="source-line-no">107</span><span id="line.107">                     j &lt; 2;</span>
<span class="source-line-no">108</span><span id="line.108">                     j++) {</span>
<span class="source-line-no">109</span><span id="line.109">                    int x2 = random.between(Math.max(0, tx - 2), tx);</span>
<span class="source-line-no">110</span><span id="line.110">                    int x3 = random.between(tx + 1, Math.min(tx + 3, 15));</span>
<span class="source-line-no">111</span><span id="line.111">                    int y2 = random.between(Math.max(0, ty - 2), ty);</span>
<span class="source-line-no">112</span><span id="line.112">                    int y3 = random.between(ty + 1, Math.min(ty + 3, 15));</span>
<span class="source-line-no">113</span><span id="line.113">                    if (x3 &lt; 16 &amp;&amp; random.nextBoolean())</span>
<span class="source-line-no">114</span><span id="line.114">                        x2 = x3;</span>
<span class="source-line-no">115</span><span id="line.115">                    if (y3 &lt; 16 &amp;&amp; random.nextBoolean())</span>
<span class="source-line-no">116</span><span id="line.116">                        y2 = y3;</span>
<span class="source-line-no">117</span><span id="line.117">                    cl.add(Coord.get(columns[x2], rows[y2]));</span>
<span class="source-line-no">118</span><span id="line.118">                    if (random.nextDouble() &gt;= branchingChance)</span>
<span class="source-line-no">119</span><span id="line.119">                        break;</span>
<span class="source-line-no">120</span><span id="line.120">                }</span>
<span class="source-line-no">121</span><span id="line.121"></span>
<span class="source-line-no">122</span><span id="line.122">                List&lt;Coord&gt; connect = connections.get(tz).get(Coord.get(columns[tx], rows[ty]));</span>
<span class="source-line-no">123</span><span id="line.123">                if(connect != null)</span>
<span class="source-line-no">124</span><span id="line.124">                    connections.get(tz).get(Coord.get(columns[tx], rows[ty])).addAll(cl);</span>
<span class="source-line-no">125</span><span id="line.125">                else</span>
<span class="source-line-no">126</span><span id="line.126">                    connections.get(tz).put(Coord.get(columns[tx], rows[ty]), new ArrayList&lt;&gt;(cl));</span>
<span class="source-line-no">127</span><span id="line.127"></span>
<span class="source-line-no">128</span><span id="line.128">                x = CoordPacker.getXMoore3D(m, numLayers);</span>
<span class="source-line-no">129</span><span id="line.129">                y = CoordPacker.getYMoore3D(m, numLayers);</span>
<span class="source-line-no">130</span><span id="line.130">                z = (int)Math.floor(CoordPacker.getZMoore3D(m, numLayers) * depth / (8f * numLayers));</span>
<span class="source-line-no">131</span><span id="line.131">                if(z != tz)</span>
<span class="source-line-no">132</span><span id="line.132">                    cl.clear();</span>
<span class="source-line-no">133</span><span id="line.133">                cl.add(Coord.get(columns[x], rows[y]));</span>
<span class="source-line-no">134</span><span id="line.134"></span>
<span class="source-line-no">135</span><span id="line.135">                if (tz == z) {</span>
<span class="source-line-no">136</span><span id="line.136">                    List&lt;Coord&gt; conn = connections.get(z).get(Coord.get(columns[tx], rows[ty]));</span>
<span class="source-line-no">137</span><span id="line.137">                    if(conn != null)</span>
<span class="source-line-no">138</span><span id="line.138">                        connections.get(z).get(Coord.get(columns[tx], rows[ty])).addAll(cl);</span>
<span class="source-line-no">139</span><span id="line.139">                    else</span>
<span class="source-line-no">140</span><span id="line.140">                        connections.get(z).put(Coord.get(columns[tx], rows[ty]), new ArrayList&lt;&gt;(cl));</span>
<span class="source-line-no">141</span><span id="line.141">                    break;</span>
<span class="source-line-no">142</span><span id="line.142">                }</span>
<span class="source-line-no">143</span><span id="line.143">                else {</span>
<span class="source-line-no">144</span><span id="line.144">                    if (z &gt; tz) {</span>
<span class="source-line-no">145</span><span id="line.145">                        linksDown.get(tz).add(Coord.get(tx, ty));</span>
<span class="source-line-no">146</span><span id="line.146">                        tz++;</span>
<span class="source-line-no">147</span><span id="line.147">                        linksUp.get(tz).add(Coord.get(tx, ty));</span>
<span class="source-line-no">148</span><span id="line.148">                    }</span>
<span class="source-line-no">149</span><span id="line.149">                    else</span>
<span class="source-line-no">150</span><span id="line.150">                    {</span>
<span class="source-line-no">151</span><span id="line.151">                        linksUp.get(tz).add(Coord.get(tx, ty));</span>
<span class="source-line-no">152</span><span id="line.152">                        tz--;</span>
<span class="source-line-no">153</span><span id="line.153">                        linksDown.get(tz).add(Coord.get(tx, ty));</span>
<span class="source-line-no">154</span><span id="line.154">                    }</span>
<span class="source-line-no">155</span><span id="line.155">                }</span>
<span class="source-line-no">156</span><span id="line.156">            }while (true);</span>
<span class="source-line-no">157</span><span id="line.157">        }</span>
<span class="source-line-no">158</span><span id="line.158"></span>
<span class="source-line-no">159</span><span id="line.159">        do {</span>
<span class="source-line-no">160</span><span id="line.160">            List&lt;Coord&gt; cl = new ArrayList&lt;&gt;(4);</span>
<span class="source-line-no">161</span><span id="line.161"></span>
<span class="source-line-no">162</span><span id="line.162">            for (int j = 0;</span>
<span class="source-line-no">163</span><span id="line.163">                 j &lt; 2;</span>
<span class="source-line-no">164</span><span id="line.164">                 j++) {</span>
<span class="source-line-no">165</span><span id="line.165">                int x2 = random.between(Math.max(0, x - 2), x);</span>
<span class="source-line-no">166</span><span id="line.166">                int x3 = random.between(x + 1, Math.min(x + 3, 15));</span>
<span class="source-line-no">167</span><span id="line.167">                int y2 = random.between(Math.max(0, y - 2), y);</span>
<span class="source-line-no">168</span><span id="line.168">                int y3 = random.between(y + 1, Math.min(y + 3, 15));</span>
<span class="source-line-no">169</span><span id="line.169">                if (x3 &lt; 16 &amp;&amp; random.nextBoolean())</span>
<span class="source-line-no">170</span><span id="line.170">                    x2 = x3;</span>
<span class="source-line-no">171</span><span id="line.171">                if (y3 &lt; 16 &amp;&amp; random.nextBoolean())</span>
<span class="source-line-no">172</span><span id="line.172">                    y2 = y3;</span>
<span class="source-line-no">173</span><span id="line.173">                cl.add(Coord.get(columns[x2], rows[y2]));</span>
<span class="source-line-no">174</span><span id="line.174">                if (Math.min(random.nextDouble(), random.nextDouble()) &gt;= branchingChance)</span>
<span class="source-line-no">175</span><span id="line.175">                    break;</span>
<span class="source-line-no">176</span><span id="line.176">            }</span>
<span class="source-line-no">177</span><span id="line.177"></span>
<span class="source-line-no">178</span><span id="line.178">            List&lt;Coord&gt; connect = connections.get(tz).get(Coord.get(columns[x], rows[y]));</span>
<span class="source-line-no">179</span><span id="line.179">            if(connect != null)</span>
<span class="source-line-no">180</span><span id="line.180">                connections.get(tz).get(Coord.get(columns[x], rows[y])).addAll(cl);</span>
<span class="source-line-no">181</span><span id="line.181">            else</span>
<span class="source-line-no">182</span><span id="line.182">                connections.get(tz).put(Coord.get(columns[x], rows[y]), new ArrayList&lt;&gt;(cl));</span>
<span class="source-line-no">183</span><span id="line.183"></span>
<span class="source-line-no">184</span><span id="line.184">            if(sz != tz)</span>
<span class="source-line-no">185</span><span id="line.185">                cl.clear();</span>
<span class="source-line-no">186</span><span id="line.186">            cl.add(Coord.get(columns[x], rows[y]));</span>
<span class="source-line-no">187</span><span id="line.187"></span>
<span class="source-line-no">188</span><span id="line.188">            if (tz == sz) {</span>
<span class="source-line-no">189</span><span id="line.189">                connections.get(sz).get(Coord.get(columns[x], rows[y])).add(</span>
<span class="source-line-no">190</span><span id="line.190">                        Coord.get(columns[sx], rows[sy]));</span>
<span class="source-line-no">191</span><span id="line.191">                break;</span>
<span class="source-line-no">192</span><span id="line.192">            }</span>
<span class="source-line-no">193</span><span id="line.193">            else {</span>
<span class="source-line-no">194</span><span id="line.194">                if (sz &gt; tz) {</span>
<span class="source-line-no">195</span><span id="line.195">                    linksDown.get(tz).add(Coord.get(x, y));</span>
<span class="source-line-no">196</span><span id="line.196">                    tz++;</span>
<span class="source-line-no">197</span><span id="line.197">                    linksUp.get(tz).add(Coord.get(x, y));</span>
<span class="source-line-no">198</span><span id="line.198">                }</span>
<span class="source-line-no">199</span><span id="line.199">                else</span>
<span class="source-line-no">200</span><span id="line.200">                {</span>
<span class="source-line-no">201</span><span id="line.201">                    linksUp.get(tz).add(Coord.get(x, y));</span>
<span class="source-line-no">202</span><span id="line.202">                    tz--;</span>
<span class="source-line-no">203</span><span id="line.203">                    linksDown.get(tz).add(Coord.get(x, y));</span>
<span class="source-line-no">204</span><span id="line.204">                }</span>
<span class="source-line-no">205</span><span id="line.205">            }</span>
<span class="source-line-no">206</span><span id="line.206">        }while (true);</span>
<span class="source-line-no">207</span><span id="line.207"></span>
<span class="source-line-no">208</span><span id="line.208">        mix = new MixedGenerator[depth];</span>
<span class="source-line-no">209</span><span id="line.209">        for (int i = 0; i &lt; depth; i++) {</span>
<span class="source-line-no">210</span><span id="line.210">            mix[i] = new MixedGenerator(width, height, random, connections.get(i), 0.35f);</span>
<span class="source-line-no">211</span><span id="line.211">        }</span>
<span class="source-line-no">212</span><span id="line.212">    }</span>
<span class="source-line-no">213</span><span id="line.213">    /**</span>
<span class="source-line-no">214</span><span id="line.214">     * Changes the number of "carvers" that will create caves from one room to the next. If count is 0 or less, no caves</span>
<span class="source-line-no">215</span><span id="line.215">     * will be made. If count is at least 1, caves are possible, and higher numbers relative to the other carvers make</span>
<span class="source-line-no">216</span><span id="line.216">     * caves more likely. Carvers are shuffled when used, then repeat if exhausted during generation. Since typically</span>
<span class="source-line-no">217</span><span id="line.217">     * about 30-40 rooms are carved, large totals for carver count aren't really needed; aiming for a total of 10</span>
<span class="source-line-no">218</span><span id="line.218">     * between the count of putCaveCarvers(), putBoxRoomCarvers(), and putRoundRoomCarvers() is reasonable.</span>
<span class="source-line-no">219</span><span id="line.219">     * @see MixedGenerator</span>
<span class="source-line-no">220</span><span id="line.220">     * @param count the number of carvers making caves between rooms; only matters in relation to other carvers</span>
<span class="source-line-no">221</span><span id="line.221">     */</span>
<span class="source-line-no">222</span><span id="line.222">    public void putCaveCarvers(int count)</span>
<span class="source-line-no">223</span><span id="line.223">    {</span>
<span class="source-line-no">224</span><span id="line.224">        for (int i = 0; i &lt; depth; i++) {</span>
<span class="source-line-no">225</span><span id="line.225">            mix[i].putCaveCarvers(count);</span>
<span class="source-line-no">226</span><span id="line.226">        }</span>
<span class="source-line-no">227</span><span id="line.227">    }</span>
<span class="source-line-no">228</span><span id="line.228">    /**</span>
<span class="source-line-no">229</span><span id="line.229">     * Changes the number of "carvers" that will create right-angle corridors from one room to the next, create rooms</span>
<span class="source-line-no">230</span><span id="line.230">     * with a random size in a box shape at the start and end, and a small room at the corner if there is one. If count</span>
<span class="source-line-no">231</span><span id="line.231">     * is 0 or less, no box-shaped rooms will be made. If count is at least 1, box-shaped rooms are possible, and higher</span>
<span class="source-line-no">232</span><span id="line.232">     * numbers relative to the other carvers make box-shaped rooms more likely. Carvers are shuffled when used, then</span>
<span class="source-line-no">233</span><span id="line.233">     * repeat if exhausted during generation. Since typically about 30-40 rooms are carved, large totals for carver</span>
<span class="source-line-no">234</span><span id="line.234">     * count aren't really needed; aiming for a total of 10 between the count of putCaveCarvers(), putBoxRoomCarvers(),</span>
<span class="source-line-no">235</span><span id="line.235">     * and putRoundRoomCarvers() is reasonable.</span>
<span class="source-line-no">236</span><span id="line.236">     * @see MixedGenerator</span>
<span class="source-line-no">237</span><span id="line.237">     * @param count the number of carvers making box-shaped rooms and corridors between them; only matters in relation</span>
<span class="source-line-no">238</span><span id="line.238">     *              to other carvers</span>
<span class="source-line-no">239</span><span id="line.239">     */</span>
<span class="source-line-no">240</span><span id="line.240">    public void putBoxRoomCarvers(int count)</span>
<span class="source-line-no">241</span><span id="line.241">    {</span>
<span class="source-line-no">242</span><span id="line.242">        for (int i = 0; i &lt; depth; i++) {</span>
<span class="source-line-no">243</span><span id="line.243">            mix[i].putBoxRoomCarvers(count);</span>
<span class="source-line-no">244</span><span id="line.244">        }</span>
<span class="source-line-no">245</span><span id="line.245">    }</span>
<span class="source-line-no">246</span><span id="line.246">    /**</span>
<span class="source-line-no">247</span><span id="line.247">     * Changes the number of "carvers" that will create right-angle corridors from one room to the next, create rooms</span>
<span class="source-line-no">248</span><span id="line.248">     * with a random size in a box shape at the start and end, and a small room at the corner if there is one. This also</span>
<span class="source-line-no">249</span><span id="line.249">     * ensures walls will be placed around the room, only allowing corridors and small cave openings to pass. If count</span>
<span class="source-line-no">250</span><span id="line.250">     * is 0 or less, no box-shaped rooms will be made. If count is at least 1, box-shaped rooms are possible, and higher</span>
<span class="source-line-no">251</span><span id="line.251">     * numbers relative to the other carvers make box-shaped rooms more likely. Carvers are shuffled when used, then</span>
<span class="source-line-no">252</span><span id="line.252">     * repeat if exhausted during generation. Since typically about 30-40 rooms are carved, large totals for carver</span>
<span class="source-line-no">253</span><span id="line.253">     * count aren't really needed; aiming for a total of 10 between the count of putCaveCarvers(), putBoxRoomCarvers(),</span>
<span class="source-line-no">254</span><span id="line.254">     * and putRoundRoomCarvers() is reasonable.</span>
<span class="source-line-no">255</span><span id="line.255">     * @see MixedGenerator</span>
<span class="source-line-no">256</span><span id="line.256">     * @param count the number of carvers making box-shaped rooms and corridors between them; only matters in relation</span>
<span class="source-line-no">257</span><span id="line.257">     *              to other carvers</span>
<span class="source-line-no">258</span><span id="line.258">     */</span>
<span class="source-line-no">259</span><span id="line.259">    public void putWalledBoxRoomCarvers(int count)</span>
<span class="source-line-no">260</span><span id="line.260">    {</span>
<span class="source-line-no">261</span><span id="line.261">        for (int i = 0; i &lt; depth; i++) {</span>
<span class="source-line-no">262</span><span id="line.262">            mix[i].putWalledBoxRoomCarvers(count);</span>
<span class="source-line-no">263</span><span id="line.263">        }</span>
<span class="source-line-no">264</span><span id="line.264">    }</span>
<span class="source-line-no">265</span><span id="line.265">    /**</span>
<span class="source-line-no">266</span><span id="line.266">     * Changes the number of "carvers" that will create right-angle corridors from one room to the next, create rooms</span>
<span class="source-line-no">267</span><span id="line.267">     * with a random size in a circle shape at the start and end, and a small circular room at the corner if there is</span>
<span class="source-line-no">268</span><span id="line.268">     * one. If count is 0 or less, no circular rooms will be made. If count is at least 1, circular rooms are possible,</span>
<span class="source-line-no">269</span><span id="line.269">     * and higher numbers relative to the other carvers make circular rooms more likely. Carvers are shuffled when used,</span>
<span class="source-line-no">270</span><span id="line.270">     * then repeat if exhausted during generation. Since typically about 30-40 rooms are carved, large totals for carver</span>
<span class="source-line-no">271</span><span id="line.271">     * count aren't really needed; aiming for a total of 10 between the count of putCaveCarvers(), putBoxRoomCarvers(),</span>
<span class="source-line-no">272</span><span id="line.272">     * and putRoundRoomCarvers() is reasonable.</span>
<span class="source-line-no">273</span><span id="line.273">     * @see MixedGenerator</span>
<span class="source-line-no">274</span><span id="line.274">     * @param count the number of carvers making circular rooms and corridors between them; only matters in relation</span>
<span class="source-line-no">275</span><span id="line.275">     *              to other carvers</span>
<span class="source-line-no">276</span><span id="line.276">     */</span>
<span class="source-line-no">277</span><span id="line.277">    public void putRoundRoomCarvers(int count)</span>
<span class="source-line-no">278</span><span id="line.278">    {</span>
<span class="source-line-no">279</span><span id="line.279">        for (int i = 0; i &lt; depth; i++) {</span>
<span class="source-line-no">280</span><span id="line.280">            mix[i].putRoundRoomCarvers(count);</span>
<span class="source-line-no">281</span><span id="line.281">        }</span>
<span class="source-line-no">282</span><span id="line.282">    }</span>
<span class="source-line-no">283</span><span id="line.283"></span>
<span class="source-line-no">284</span><span id="line.284">    /**</span>
<span class="source-line-no">285</span><span id="line.285">     * Changes the number of "carvers" that will create right-angle corridors from one room to the next, create rooms</span>
<span class="source-line-no">286</span><span id="line.286">     * with a random size in a circle shape at the start and end, and a small circular room at the corner if there is</span>
<span class="source-line-no">287</span><span id="line.287">     * one. This also ensures walls will be placed around the room, only allowing corridors and small cave openings to</span>
<span class="source-line-no">288</span><span id="line.288">     * pass. If count is 0 or less, no circular rooms will be made. If count is at least 1, circular rooms are possible,</span>
<span class="source-line-no">289</span><span id="line.289">     * and higher numbers relative to the other carvers make circular rooms more likely. Carvers are shuffled when used,</span>
<span class="source-line-no">290</span><span id="line.290">     * then repeat if exhausted during generation. Since typically about 30-40 rooms are carved, large totals for carver</span>
<span class="source-line-no">291</span><span id="line.291">     * count aren't really needed; aiming for a total of 10 between the count of putCaveCarvers(), putBoxRoomCarvers(),</span>
<span class="source-line-no">292</span><span id="line.292">     * and putRoundRoomCarvers() is reasonable.</span>
<span class="source-line-no">293</span><span id="line.293">     * @see MixedGenerator</span>
<span class="source-line-no">294</span><span id="line.294">     * @param count the number of carvers making circular rooms and corridors between them; only matters in relation</span>
<span class="source-line-no">295</span><span id="line.295">     *              to other carvers</span>
<span class="source-line-no">296</span><span id="line.296">     */</span>
<span class="source-line-no">297</span><span id="line.297">    public void putWalledRoundRoomCarvers(int count)</span>
<span class="source-line-no">298</span><span id="line.298">    {</span>
<span class="source-line-no">299</span><span id="line.299">        for (int i = 0; i &lt; depth; i++) {</span>
<span class="source-line-no">300</span><span id="line.300">            mix[i].putWalledRoundRoomCarvers(count);</span>
<span class="source-line-no">301</span><span id="line.301">        }</span>
<span class="source-line-no">302</span><span id="line.302">    }</span>
<span class="source-line-no">303</span><span id="line.303"></span>
<span class="source-line-no">304</span><span id="line.304">    /**</span>
<span class="source-line-no">305</span><span id="line.305">     * This generates a new map by stretching a 32x32x(multiple of 8) grid of potential rooms to fit the width, height,</span>
<span class="source-line-no">306</span><span id="line.306">     * and depth passed to the constructor, randomly expanding columns and rows before contracting the whole to fit</span>
<span class="source-line-no">307</span><span id="line.307">     * perfectly. This uses the Moore Curve, a space-filling curve that loops around on itself, to guarantee that the</span>
<span class="source-line-no">308</span><span id="line.308">     * rooms will always have a long path through the dungeon, going up and down as well as north/south/east/west, that,</span>
<span class="source-line-no">309</span><span id="line.309">     * if followed completely, will take you back to your starting room. Some small branches are possible, and large</span>
<span class="source-line-no">310</span><span id="line.310">     * rooms may merge with other rooms nearby. This uses MixedGenerator.</span>
<span class="source-line-no">311</span><span id="line.311">     * @see MixedGenerator</span>
<span class="source-line-no">312</span><span id="line.312">     * @return a char[][][] where the outermost array is layers, then inside that are x and y in order (z x y)</span>
<span class="source-line-no">313</span><span id="line.313">     */</span>
<span class="source-line-no">314</span><span id="line.314">    public char[][][] generate()</span>
<span class="source-line-no">315</span><span id="line.315">    {</span>
<span class="source-line-no">316</span><span id="line.316">        char[][][] dungeon = new char[depth][][];</span>
<span class="source-line-no">317</span><span id="line.317">        short[][] floors = new short[depth][];</span>
<span class="source-line-no">318</span><span id="line.318">        int dlimit = (height + width) / 3;</span>
<span class="source-line-no">319</span><span id="line.319">        for (int i = 0; i &lt; depth; i++) {</span>
<span class="source-line-no">320</span><span id="line.320">            dungeon[i] = mix[i].generate();</span>
<span class="source-line-no">321</span><span id="line.321">            floors[i] = CoordPacker.pack(dungeon[i], '.');</span>
<span class="source-line-no">322</span><span id="line.322">        }</span>
<span class="source-line-no">323</span><span id="line.323">        //using actual dungeon space per layer, not row/column 3D grid space</span>
<span class="source-line-no">324</span><span id="line.324">        ArrayList&lt;OrderedSet&lt;Coord&gt;&gt; ups = new ArrayList&lt;&gt;(depth),</span>
<span class="source-line-no">325</span><span id="line.325">                downs = new ArrayList&lt;&gt;(depth);</span>
<span class="source-line-no">326</span><span id="line.326">        for (int i = 0; i &lt; depth; i++) {</span>
<span class="source-line-no">327</span><span id="line.327">            ups.add(new OrderedSet&lt;Coord&gt;(40));</span>
<span class="source-line-no">328</span><span id="line.328">            downs.add(new OrderedSet&lt;Coord&gt;(40));</span>
<span class="source-line-no">329</span><span id="line.329">            OrderedSet&lt;Coord&gt; above = new OrderedSet&lt;&gt;(32);</span>
<span class="source-line-no">330</span><span id="line.330">            if (i &gt; 0) {</span>
<span class="source-line-no">331</span><span id="line.331">                if(linksDown.get(i - 1).isEmpty())</span>
<span class="source-line-no">332</span><span id="line.332">                    continue;</span>
<span class="source-line-no">333</span><span id="line.333">                above.clear();</span>
<span class="source-line-no">334</span><span id="line.334">                above.addAll(linksDown.get(i - 1));</span>
<span class="source-line-no">335</span><span id="line.335">                Coord higher = above.randomItem(random);</span>
<span class="source-line-no">336</span><span id="line.336">                while(above.size() &gt; 0)</span>
<span class="source-line-no">337</span><span id="line.337">                {</span>
<span class="source-line-no">338</span><span id="line.338">                    short[] nearAbove = CoordPacker.flood(floors[i - 1],</span>
<span class="source-line-no">339</span><span id="line.339">                            CoordPacker.packOne(columns[higher.x], rows[higher.y]),</span>
<span class="source-line-no">340</span><span id="line.340">                            dlimit);</span>
<span class="source-line-no">341</span><span id="line.341">                    short[] near = CoordPacker.intersectPacked(nearAbove, CoordPacker.flood(floors[i],</span>
<span class="source-line-no">342</span><span id="line.342">                            CoordPacker.packOne(columns[higher.x], rows[higher.y]),</span>
<span class="source-line-no">343</span><span id="line.343">                            dlimit));</span>
<span class="source-line-no">344</span><span id="line.344">                    Coord subLink = CoordPacker.singleRandom(near, random);</span>
<span class="source-line-no">345</span><span id="line.345">                    ups.get(i).add(subLink);</span>
<span class="source-line-no">346</span><span id="line.346">                    downs.get(i-1).add(subLink);</span>
<span class="source-line-no">347</span><span id="line.347">                    for(Coord abv : linksDown.get(i-1))</span>
<span class="source-line-no">348</span><span id="line.348">                    {</span>
<span class="source-line-no">349</span><span id="line.349">                        if(CoordPacker.queryPacked(nearAbove, columns[abv.x], rows[abv.y])) //scannedAbove[columns[abv.x]][rows[abv.y]] &lt;= dlimit</span>
<span class="source-line-no">350</span><span id="line.350">                            above.remove(abv);</span>
<span class="source-line-no">351</span><span id="line.351">                    }</span>
<span class="source-line-no">352</span><span id="line.352">                    if(above.isEmpty())</span>
<span class="source-line-no">353</span><span id="line.353">                        break;</span>
<span class="source-line-no">354</span><span id="line.354">                    higher = above.randomItem(random);//random.getRandomElement(above.toArray(new Coord[above.size()]));</span>
<span class="source-line-no">355</span><span id="line.355">                }</span>
<span class="source-line-no">356</span><span id="line.356">            }</span>
<span class="source-line-no">357</span><span id="line.357">        }</span>
<span class="source-line-no">358</span><span id="line.358"></span>
<span class="source-line-no">359</span><span id="line.359">        for (int i = 0; i &lt; depth; i++) {</span>
<span class="source-line-no">360</span><span id="line.360">            OrderedMap&lt;Coord, Integer&gt; used = new OrderedMap&lt;&gt;(128);</span>
<span class="source-line-no">361</span><span id="line.361">            for(Coord up : ups.get(i))</span>
<span class="source-line-no">362</span><span id="line.362">            {</span>
<span class="source-line-no">363</span><span id="line.363">                Integer count = used.get(up);</span>
<span class="source-line-no">364</span><span id="line.364">                if(count != null &amp;&amp; count &gt; 1)</span>
<span class="source-line-no">365</span><span id="line.365">                    continue;</span>
<span class="source-line-no">366</span><span id="line.366">                dungeon[i][up.x][up.y] = '&lt;';</span>
<span class="source-line-no">367</span><span id="line.367"></span>
<span class="source-line-no">368</span><span id="line.368">                used.put(up, (count == null) ? 1 : count + 1);</span>
<span class="source-line-no">369</span><span id="line.369">            }</span>
<span class="source-line-no">370</span><span id="line.370">            used.clear();</span>
<span class="source-line-no">371</span><span id="line.371">            for(Coord down : downs.get(i))</span>
<span class="source-line-no">372</span><span id="line.372">            {</span>
<span class="source-line-no">373</span><span id="line.373">                Integer count = used.get(down);</span>
<span class="source-line-no">374</span><span id="line.374">                if(count != null &amp;&amp; count &gt; 1)</span>
<span class="source-line-no">375</span><span id="line.375">                    continue;</span>
<span class="source-line-no">376</span><span id="line.376">                dungeon[i][down.x][down.y] = '&gt;';</span>
<span class="source-line-no">377</span><span id="line.377"></span>
<span class="source-line-no">378</span><span id="line.378">                used.put(down, (count == null) ? 1 : count + 1);</span>
<span class="source-line-no">379</span><span id="line.379">            }</span>
<span class="source-line-no">380</span><span id="line.380">        }</span>
<span class="source-line-no">381</span><span id="line.381">        return dungeon;</span>
<span class="source-line-no">382</span><span id="line.382">    }</span>
<span class="source-line-no">383</span><span id="line.383"></span>
<span class="source-line-no">384</span><span id="line.384">    /**</span>
<span class="source-line-no">385</span><span id="line.385">     * Gets an array (length equals depth) of 2D int arrays representing the environments for levels.</span>
<span class="source-line-no">386</span><span id="line.386">     * @return an array of 2D int arrays, where each 2D array is a level's environment</span>
<span class="source-line-no">387</span><span id="line.387">     */</span>
<span class="source-line-no">388</span><span id="line.388">    public int[][][] getEnvironments()</span>
<span class="source-line-no">389</span><span id="line.389">    {</span>
<span class="source-line-no">390</span><span id="line.390">        int[][][] env = new int[depth][][];</span>
<span class="source-line-no">391</span><span id="line.391">        for (int i = 0; i &lt; depth; i++) {</span>
<span class="source-line-no">392</span><span id="line.392">            env[i] = mix[i].getEnvironment();</span>
<span class="source-line-no">393</span><span id="line.393">        }</span>
<span class="source-line-no">394</span><span id="line.394">        return env;</span>
<span class="source-line-no">395</span><span id="line.395">    }</span>
<span class="source-line-no">396</span><span id="line.396"></span>
<span class="source-line-no">397</span><span id="line.397">    /**</span>
<span class="source-line-no">398</span><span id="line.398">     * Gets a 2D int array representing the environment for the requested level.</span>
<span class="source-line-no">399</span><span id="line.399">     * @param level the level to get from the generated dungeon; will be clamped between 0 and depth - 1</span>
<span class="source-line-no">400</span><span id="line.400">     * @return a 2D int array representing the requested level's environment</span>
<span class="source-line-no">401</span><span id="line.401">     */</span>
<span class="source-line-no">402</span><span id="line.402">    public int[][] getEnvironment(int level)</span>
<span class="source-line-no">403</span><span id="line.403">    {</span>
<span class="source-line-no">404</span><span id="line.404">        return mix[Math.max(0, Math.min(depth - 1, level))].getEnvironment();</span>
<span class="source-line-no">405</span><span id="line.405">    }</span>
<span class="source-line-no">406</span><span id="line.406">}</span>




























































</pre>
</div>
</main>
</body>
</html>
